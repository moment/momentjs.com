/*!
 * QUnit 1.17.1
 * http://qunitjs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-01-20T19:39Z
 */

(function( window ) {

var QUnit,
	config,
	onErrorFnPrev,
	loggingCallbacks = {},
	fileName = ( sourceFromStacktrace( 0 ) || "" ).replace( /(:\d+)+\)?/, "" ).replace( /.+\//, "" ),
	toString = Object.prototype.toString,
	hasOwn = Object.prototype.hasOwnProperty,
	// Keep a local reference to Date (GH-283)
	Date = window.Date,
	now = Date.now || function() {
		return new Date().getTime();
	},
	globalStartCalled = false,
	runStarted = false,
	setTimeout = window.setTimeout,
	clearTimeout = window.clearTimeout,
	defined = {
		document: window.document !== undefined,
		setTimeout: window.setTimeout !== undefined,
		sessionStorage: (function() {
			var x = "qunit-test-string";
			try {
				sessionStorage.setItem( x, x );
				sessionStorage.removeItem( x );
				return true;
			} catch ( e ) {
				return false;
			}
		}())
	},
	/**
	 * Provides a normalized error string, correcting an issue
	 * with IE 7 (and prior) where Error.prototype.toString is
	 * not properly implemented
	 *
	 * Based on http://es5.github.com/#x15.11.4.4
	 *
	 * @param {String|Error} error
	 * @return {String} error message
	 */
	errorString = function( error ) {
		var name, message,
			errorString = error.toString();
		if ( errorString.substring( 0, 7 ) === "[object" ) {
			name = error.name ? error.name.toString() : "Error";
			message = error.message ? error.message.toString() : "";
			if ( name && message ) {
				return name + ": " + message;
			} else if ( name ) {
				return name;
			} else if ( message ) {
				return message;
			} else {
				return "Error";
			}
		} else {
			return errorString;
		}
	},
	/**
	 * Makes a clone of an object using only Array or Object as base,
	 * and copies over the own enumerable properties.
	 *
	 * @param {Object} obj
	 * @return {Object} New object with only the own properties (recursively).
	 */
	objectValues = function( obj ) {
		var key, val,
			vals = QUnit.is( "array", obj ) ? [] : {};
		for ( key in obj ) {
			if ( hasOwn.call( obj, key ) ) {
				val = obj[ key ];
				vals[ key ] = val === Object( val ) ? objectValues( val ) : val;
			}
		}
		return vals;
	};

QUnit = {};

/**
 * Config object: Maintain internal state
 * Later exposed as QUnit.config
 * `config` initialized at top of scope
 */
config = {
	// The queue of tests to run
	queue: [],

	// block until document ready
	blocking: true,

	// by default, run previously failed tests first
	// very useful in combination with "Hide passed tests" checked
	reorder: true,

	// by default, modify document.title when suite is done
	altertitle: true,

	// by default, scroll to top of the page when suite is done
	scrolltop: true,

	// when enabled, all tests must call expect()
	requireExpects: false,

	// add checkboxes that are persisted in the query-string
	// when enabled, the id is set to `true` as a `QUnit.config` property
	urlConfig: [
		{
			id: "hidepassed",
			label: "Hide passed tests",
			tooltip: "Only show tests and assertions that fail. Stored as query-strings."
		},
		{
			id: "noglobals",
			label: "Check for Globals",
			tooltip: "Enabling this will test if any test introduces new properties on the " +
				"`window` object. Stored as query-strings."
		},
		{
			id: "notrycatch",
			label: "No try-catch",
			tooltip: "Enabling this will run tests outside of a try-catch block. Makes debugging " +
				"exceptions in IE reasonable. Stored as query-strings."
		}
	],

	// Set of all modules.
	modules: [],

	// The first unnamed module
	currentModule: {
		name: "",
		tests: []
	},

	callbacks: {}
};

// Push a loose unnamed module to the modules collection
config.modules.push( config.currentModule );

// Initialize more QUnit.config and QUnit.urlParams
(function() {
	var i, current,
		location = window.location || { search: "", protocol: "file:" },
		params = location.search.slice( 1 ).split( "&" ),
		length = params.length,
		urlParams = {};

	if ( params[ 0 ] ) {
		for ( i = 0; i < length; i++ ) {
			current = params[ i ].split( "=" );
			current[ 0 ] = decodeURIComponent( current[ 0 ] );

			// allow just a key to turn on a flag, e.g., test.html?noglobals
			current[ 1 ] = current[ 1 ] ? decodeURIComponent( current[ 1 ] ) : true;
			if ( urlParams[ current[ 0 ] ] ) {
				urlParams[ current[ 0 ] ] = [].concat( urlParams[ current[ 0 ] ], current[ 1 ] );
			} else {
				urlParams[ current[ 0 ] ] = current[ 1 ];
			}
		}
	}

	if ( urlParams.filter === true ) {
		delete urlParams.filter;
	}

	QUnit.urlParams = urlParams;

	// String search anywhere in moduleName+testName
	config.filter = urlParams.filter;

	config.testId = [];
	if ( urlParams.testId ) {

		// Ensure that urlParams.testId is an array
		urlParams.testId = [].concat( urlParams.testId );
		for ( i = 0; i < urlParams.testId.length; i++ ) {
			config.testId.push( urlParams.testId[ i ] );
		}
	}

	// Figure out if we're running the tests from a server or not
	QUnit.isLocal = location.protocol === "file:";
}());

// Root QUnit object.
// `QUnit` initialized at top of scope
extend( QUnit, {

	// call on start of module test to prepend name to all tests
	module: function( name, testEnvironment ) {
		var currentModule = {
			name: name,
			testEnvironment: testEnvironment,
			tests: []
		};

		// DEPRECATED: handles setup/teardown functions,
		// beforeEach and afterEach should be used instead
		if ( testEnvironment && testEnvironment.setup ) {
			testEnvironment.beforeEach = testEnvironment.setup;
			delete testEnvironment.setup;
		}
		if ( testEnvironment && testEnvironment.teardown ) {
			testEnvironment.afterEach = testEnvironment.teardown;
			delete testEnvironment.teardown;
		}

		config.modules.push( currentModule );
		config.currentModule = currentModule;
	},

	// DEPRECATED: QUnit.asyncTest() will be removed in QUnit 2.0.
	asyncTest: function( testName, expected, callback ) {
		if ( arguments.length === 2 ) {
			callback = expected;
			expected = null;
		}

		QUnit.test( testName, expected, callback, true );
	},

	test: function( testName, expected, callback, async ) {
		var test;

		if ( arguments.length === 2 ) {
			callback = expected;
			expected = null;
		}

		test = new Test({
			testName: testName,
			expected: expected,
			async: async,
			callback: callback
		});

		test.queue();
	},

	skip: function( testName ) {
		var test = new Test({
			testName: testName,
			skip: true
		});

		test.queue();
	},

	// DEPRECATED: The functionality of QUnit.start() will be altered in QUnit 2.0.
	// In QUnit 2.0, invoking it will ONLY affect the `QUnit.config.autostart` blocking behavior.
	start: function( count ) {
		var globalStartAlreadyCalled = globalStartCalled;

		if ( !config.current ) {
			globalStartCalled = true;

			if ( runStarted ) {
				throw new Error( "Called start() outside of a test context while already started" );
			} else if ( globalStartAlreadyCalled || count > 1 ) {
				throw new Error( "Called start() outside of a test context too many times" );
			} else if ( config.autostart ) {
				throw new Error( "Called start() outside of a test context when " +
					"QUnit.config.autostart was true" );
			} else if ( !config.pageLoaded ) {

				// The page isn't completely loaded yet, so bail out and let `QUnit.load` handle it
				config.autostart = true;
				return;
			}
		} else {

			// If a test is running, adjust its semaphore
			config.current.semaphore -= count || 1;

			// Don't start until equal number of stop-calls
			if ( config.current.semaphore > 0 ) {
				return;
			}

			// throw an Error if start is called more often than stop
			if ( config.current.semaphore < 0 ) {
				config.current.semaphore = 0;

				QUnit.pushFailure(
					"Called start() while already started (test's semaphore was 0 already)",
					sourceFromStacktrace( 2 )
				);
				return;
			}
		}

		resumeProcessing();
	},

	// DEPRECATED: QUnit.stop() will be removed in QUnit 2.0.
	stop: function( count ) {

		// If there isn't a test running, don't allow QUnit.stop() to be called
		if ( !config.current ) {
			throw new Error( "Called stop() outside of a test context" );
		}

		// If a test is running, adjust its semaphore
		config.current.semaphore += count || 1;

		pauseProcessing();
	},

	config: config,

	// Safe object type checking
	is: function( type, obj ) {
		return QUnit.objectType( obj ) === type;
	},

	objectType: function( obj ) {
		if ( typeof obj === "undefined" ) {
			return "undefined";
		}

		// Consider: typeof null === object
		if ( obj === null ) {
			return "null";
		}

		var match = toString.call( obj ).match( /^\[object\s(.*)\]$/ ),
			type = match && match[ 1 ] || "";

		switch ( type ) {
			case "Number":
				if ( isNaN( obj ) ) {
					return "nan";
				}
				return "number";
			case "String":
			case "Boolean":
			case "Array":
			case "Date":
			case "RegExp":
			case "Function":
				return type.toLowerCase();
		}
		if ( typeof obj === "object" ) {
			return "object";
		}
		return undefined;
	},

	extend: extend,

	load: function() {
		config.pageLoaded = true;

		// Initialize the configuration options
		extend( config, {
			stats: { all: 0, bad: 0 },
			moduleStats: { all: 0, bad: 0 },
			started: 0,
			updateRate: 1000,
			autostart: true,
			filter: ""
		}, true );

		config.blocking = false;

		if ( config.autostart ) {
			resumeProcessing();
		}
	}
});

// Register logging callbacks
(function() {
	var i, l, key,
		callbacks = [ "begin", "done", "log", "testStart", "testDone",
			"moduleStart", "moduleDone" ];

	function registerLoggingCallback( key ) {
		var loggingCallback = function( callback ) {
			if ( QUnit.objectType( callback ) !== "function" ) {
				throw new Error(
					"QUnit logging methods require a callback function as their first parameters."
				);
			}

			config.callbacks[ key ].push( callback );
		};

		// DEPRECATED: This will be removed on QUnit 2.0.0+
		// Stores the registered functions allowing restoring
		// at verifyLoggingCallbacks() if modified
		loggingCallbacks[ key ] = loggingCallback;

		return loggingCallback;
	}

	for ( i = 0, l = callbacks.length; i < l; i++ ) {
		key = callbacks[ i ];

		// Initialize key collection of logging callback
		if ( QUnit.objectType( config.callbacks[ key ] ) === "undefined" ) {
			config.callbacks[ key ] = [];
		}

		QUnit[ key ] = registerLoggingCallback( key );
	}
})();

// `onErrorFnPrev` initialized at top of scope
// Preserve other handlers
onErrorFnPrev = window.onerror;

// Cover uncaught exceptions
// Returning true will suppress the default browser handler,
// returning false will let it run.
window.onerror = function( error, filePath, linerNr ) {
	var ret = false;
	if ( onErrorFnPrev ) {
		ret = onErrorFnPrev( error, filePath, linerNr );
	}

	// Treat return value as window.onerror itself does,
	// Only do our handling if not suppressed.
	if ( ret !== true ) {
		if ( QUnit.config.current ) {
			if ( QUnit.config.current.ignoreGlobalErrors ) {
				return true;
			}
			QUnit.pushFailure( error, filePath + ":" + linerNr );
		} else {
			QUnit.test( "global failure", extend(function() {
				QUnit.pushFailure( error, filePath + ":" + linerNr );
			}, { validTest: true } ) );
		}
		return false;
	}

	return ret;
};

function done() {
	var runtime, passed;

	config.autorun = true;

	// Log the last module results
	if ( config.previousModule ) {
		runLoggingCallbacks( "moduleDone", {
			name: config.previousModule.name,
			tests: config.previousModule.tests,
			failed: config.moduleStats.bad,
			passed: config.moduleStats.all - config.moduleStats.bad,
			total: config.moduleStats.all,
			runtime: now() - config.moduleStats.started
		});
	}
	delete config.previousModule;

	runtime = now() - config.started;
	passed = config.stats.all - config.stats.bad;

	runLoggingCallbacks( "done", {
		failed: config.stats.bad,
		passed: passed,
		total: config.stats.all,
		runtime: runtime
	});
}

// Doesn't support IE6 to IE9
// See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack
function extractStacktrace( e, offset ) {
	offset = offset === undefined ? 4 : offset;

	var stack, include, i;

	if ( e.stacktrace ) {

		// Opera 12.x
		return e.stacktrace.split( "\n" )[ offset + 3 ];
	} else if ( e.stack ) {

		// Firefox, Chrome, Safari 6+, IE10+, PhantomJS and Node
		stack = e.stack.split( "\n" );
		if ( /^error$/i.test( stack[ 0 ] ) ) {
			stack.shift();
		}
		if ( fileName ) {
			include = [];
			for ( i = offset; i < stack.length; i++ ) {
				if ( stack[ i ].indexOf( fileName ) !== -1 ) {
					break;
				}
				include.push( stack[ i ] );
			}
			if ( include.length ) {
				return include.join( "\n" );
			}
		}
		return stack[ offset ];
	} else if ( e.sourceURL ) {

		// Safari < 6
		// exclude useless self-reference for generated Error objects
		if ( /qunit.js$/.test( e.sourceURL ) ) {
			return;
		}

		// for actual exceptions, this is useful
		return e.sourceURL + ":" + e.line;
	}
}

function sourceFromStacktrace( offset ) {
	var e = new Error();
	if ( !e.stack ) {
		try {
			throw e;
		} catch ( err ) {
			// This should already be true in most browsers
			e = err;
		}
	}
	return extractStacktrace( e, offset );
}

function synchronize( callback, last ) {
	if ( QUnit.objectType( callback ) === "array" ) {
		while ( callback.length ) {
			synchronize( callback.shift() );
		}
		return;
	}
	config.queue.push( callback );

	if ( config.autorun && !config.blocking ) {
		process( last );
	}
}

function process( last ) {
	function next() {
		process( last );
	}
	var start = now();
	config.depth = ( config.depth || 0 ) + 1;

	while ( config.queue.length && !config.blocking ) {
		if ( !defined.setTimeout || config.updateRate <= 0 ||
				( ( now() - start ) < config.updateRate ) ) {
			if ( config.current ) {

				// Reset async tracking for each phase of the Test lifecycle
				config.current.usedAsync = false;
			}
			config.queue.shift()();
		} else {
			setTimeout( next, 13 );
			break;
		}
	}
	config.depth--;
	if ( last && !config.blocking && !config.queue.length && config.depth === 0 ) {
		done();
	}
}

function begin() {
	var i, l,
		modulesLog = [];

	// If the test run hasn't officially begun yet
	if ( !config.started ) {

		// Record the time of the test run's beginning
		config.started = now();

		verifyLoggingCallbacks();

		// Delete the loose unnamed module if unused.
		if ( config.modules[ 0 ].name === "" && config.modules[ 0 ].tests.length === 0 ) {
			config.modules.shift();
		}

		// Avoid unnecessary information by not logging modules' test environments
		for ( i = 0, l = config.modules.length; i < l; i++ ) {
			modulesLog.push({
				name: config.modules[ i ].name,
				tests: config.modules[ i ].tests
			});
		}

		// The test run is officially beginning now
		runLoggingCallbacks( "begin", {
			totalTests: Test.count,
			modules: modulesLog
		});
	}

	config.blocking = false;
	process( true );
}

function resumeProcessing() {
	runStarted = true;

	// A slight delay to allow this iteration of the event loop to finish (more assertions, etc.)
	if ( defined.setTimeout ) {
		setTimeout(function() {
			if ( config.current && config.current.semaphore > 0 ) {
				return;
			}
			if ( config.timeout ) {
				clearTimeout( config.timeout );
			}

			begin();
		}, 13 );
	} else {
		begin();
	}
}

function pauseProcessing() {
	config.blocking = true;

	if ( config.testTimeout && defined.setTimeout ) {
		clearTimeout( config.timeout );
		config.timeout = setTimeout(function() {
			if ( config.current ) {
				config.current.semaphore = 0;
				QUnit.pushFailure( "Test timed out", sourceFromStacktrace( 2 ) );
			} else {
				throw new Error( "Test timed out" );
			}
			resumeProcessing();
		}, config.testTimeout );
	}
}

function saveGlobal() {
	config.pollution = [];

	if ( config.noglobals ) {
		for ( var key in window ) {
			if ( hasOwn.call( window, key ) ) {
				// in Opera sometimes DOM element ids show up here, ignore them
				if ( /^qunit-test-output/.test( key ) ) {
					continue;
				}
				config.pollution.push( key );
			}
		}
	}
}

function checkPollution() {
	var newGlobals,
		deletedGlobals,
		old = config.pollution;

	saveGlobal();

	newGlobals = diff( config.pollution, old );
	if ( newGlobals.length > 0 ) {
		QUnit.pushFailure( "Introduced global variable(s): " + newGlobals.join( ", " ) );
	}

	deletedGlobals = diff( old, config.pollution );
	if ( deletedGlobals.length > 0 ) {
		QUnit.pushFailure( "Deleted global variable(s): " + deletedGlobals.join( ", " ) );
	}
}

// returns a new Array with the elements that are in a but not in b
function diff( a, b ) {
	var i, j,
		result = a.slice();

	for ( i = 0; i < result.length; i++ ) {
		for ( j = 0; j < b.length; j++ ) {
			if ( result[ i ] === b[ j ] ) {
				result.splice( i, 1 );
				i--;
				break;
			}
		}
	}
	return result;
}

function extend( a, b, undefOnly ) {
	for ( var prop in b ) {
		if ( hasOwn.call( b, prop ) ) {

			// Avoid "Member not found" error in IE8 caused by messing with window.constructor
			if ( !( prop === "constructor" && a === window ) ) {
				if ( b[ prop ] === undefined ) {
					delete a[ prop ];
				} else if ( !( undefOnly && typeof a[ prop ] !== "undefined" ) ) {
					a[ prop ] = b[ prop ];
				}
			}
		}
	}

	return a;
}

function runLoggingCallbacks( key, args ) {
	var i, l, callbacks;

	callbacks = config.callbacks[ key ];
	for ( i = 0, l = callbacks.length; i < l; i++ ) {
		callbacks[ i ]( args );
	}
}

// DEPRECATED: This will be removed on 2.0.0+
// This function verifies if the loggingCallbacks were modified by the user
// If so, it will restore it, assign the given callback and print a console warning
function verifyLoggingCallbacks() {
	var loggingCallback, userCallback;

	for ( loggingCallback in loggingCallbacks ) {
		if ( QUnit[ loggingCallback ] !== loggingCallbacks[ loggingCallback ] ) {

			userCallback = QUnit[ loggingCallback ];

			// Restore the callback function
			QUnit[ loggingCallback ] = loggingCallbacks[ loggingCallback ];

			// Assign the deprecated given callback
			QUnit[ loggingCallback ]( userCallback );

			if ( window.console && window.console.warn ) {
				window.console.warn(
					"QUnit." + loggingCallback + " was replaced with a new value.\n" +
					"Please, check out the documentation on how to apply logging callbacks.\n" +
					"Reference: http://api.qunitjs.com/category/callbacks/"
				);
			}
		}
	}
}

// from jquery.js
function inArray( elem, array ) {
	if ( array.indexOf ) {
		return array.indexOf( elem );
	}

	for ( var i = 0, length = array.length; i < length; i++ ) {
		if ( array[ i ] === elem ) {
			return i;
		}
	}

	return -1;
}

function Test( settings ) {
	var i, l;

	++Test.count;

	extend( this, settings );
	this.assertions = [];
	this.semaphore = 0;
	this.usedAsync = false;
	this.module = config.currentModule;
	this.stack = sourceFromStacktrace( 3 );

	// Register unique strings
	for ( i = 0, l = this.module.tests; i < l.length; i++ ) {
		if ( this.module.tests[ i ].name === this.testName ) {
			this.testName += " ";
		}
	}

	this.testId = generateHash( this.module.name, this.testName );

	this.module.tests.push({
		name: this.testName,
		testId: this.testId
	});

	if ( settings.skip ) {

		// Skipped tests will fully ignore any sent callback
		this.callback = function() {};
		this.async = false;
		this.expected = 0;
	} else {
		this.assert = new Assert( this );
	}
}

Test.count = 0;

Test.prototype = {
	before: function() {
		if (

			// Emit moduleStart when we're switching from one module to another
			this.module !== config.previousModule ||

				// They could be equal (both undefined) but if the previousModule property doesn't
				// yet exist it means this is the first test in a suite that isn't wrapped in a
				// module, in which case we'll just emit a moduleStart event for 'undefined'.
				// Without this, reporters can get testStart before moduleStart  which is a problem.
				!hasOwn.call( config, "previousModule" )
		) {
			if ( hasOwn.call( config, "previousModule" ) ) {
				runLoggingCallbacks( "moduleDone", {
					name: config.previousModule.name,
					tests: config.previousModule.tests,
					failed: config.moduleStats.bad,
					passed: config.moduleStats.all - config.moduleStats.bad,
					total: config.moduleStats.all,
					runtime: now() - config.moduleStats.started
				});
			}
			config.previousModule = this.module;
			config.moduleStats = { all: 0, bad: 0, started: now() };
			runLoggingCallbacks( "moduleStart", {
				name: this.module.name,
				tests: this.module.tests
			});
		}

		config.current = this;

		this.testEnvironment = extend( {}, this.module.testEnvironment );
		delete this.testEnvironment.beforeEach;
		delete this.testEnvironment.afterEach;

		this.started = now();
		runLoggingCallbacks( "testStart", {
			name: this.testName,
			module: this.module.name,
			testId: this.testId
		});

		if ( !config.pollution ) {
			saveGlobal();
		}
	},

	run: function() {
		var promise;

		config.current = this;

		if ( this.async ) {
			QUnit.stop();
		}

		this.callbackStarted = now();

		if ( config.notrycatch ) {
			promise = this.callback.call( this.testEnvironment, this.assert );
			this.resolvePromise( promise );
			return;
		}

		try {
			promise = this.callback.call( this.testEnvironment, this.assert );
			this.resolvePromise( promise );
		} catch ( e ) {
			this.pushFailure( "Died on test #" + ( this.assertions.length + 1 ) + " " +
				this.stack + ": " + ( e.message || e ), extractStacktrace( e, 0 ) );

			// else next test will carry the responsibility
			saveGlobal();

			// Restart the tests if they're blocking
			if ( config.blocking ) {
				QUnit.start();
			}
		}
	},

	after: function() {
		checkPollution();
	},

	queueHook: function( hook, hookName ) {
		var promise,
			test = this;
		return function runHook() {
			config.current = test;
			if ( config.notrycatch ) {
				promise = hook.call( test.testEnvironment, test.assert );
				test.resolvePromise( promise, hookName );
				return;
			}
			try {
				promise = hook.call( test.testEnvironment, test.assert );
				test.resolvePromise( promise, hookName );
			} catch ( error ) {
				test.pushFailure( hookName + " failed on " + test.testName + ": " +
					( error.message || error ), extractStacktrace( error, 0 ) );
			}
		};
	},

	// Currently only used for module level hooks, can be used to add global level ones
	hooks: function( handler ) {
		var hooks = [];

		// Hooks are ignored on skipped tests
		if ( this.skip ) {
			return hooks;
		}

		if ( this.module.testEnvironment &&
				QUnit.objectType( this.module.testEnvironment[ handler ] ) === "function" ) {
			hooks.push( this.queueHook( this.module.testEnvironment[ handler ], handler ) );
		}

		return hooks;
	},

	finish: function() {
		config.current = this;
		if ( config.requireExpects && this.expected === null ) {
			this.pushFailure( "Expected number of assertions to be defined, but expect() was " +
				"not called.", this.stack );
		} else if ( this.expected !== null && this.expected !== this.assertions.length ) {
			this.pushFailure( "Expected " + this.expected + " assertions, but " +
				this.assertions.length + " were run", this.stack );
		} else if ( this.expected === null && !this.assertions.length ) {
			this.pushFailure( "Expected at least one assertion, but none were run - call " +
				"expect(0) to accept zero assertions.", this.stack );
		}

		var i,
			bad = 0;

		this.runtime = now() - this.started;
		config.stats.all += this.assertions.length;
		config.moduleStats.all += this.assertions.length;

		for ( i = 0; i < this.assertions.length; i++ ) {
			if ( !this.assertions[ i ].result ) {
				bad++;
				config.stats.bad++;
				config.moduleStats.bad++;
			}
		}

		runLoggingCallbacks( "testDone", {
			name: this.testName,
			module: this.module.name,
			skipped: !!this.skip,
			failed: bad,
			passed: this.assertions.length - bad,
			total: this.assertions.length,
			runtime: this.runtime,

			// HTML Reporter use
			assertions: this.assertions,
			testId: this.testId,

			// DEPRECATED: this property will be removed in 2.0.0, use runtime instead
			duration: this.runtime
		});

		// QUnit.reset() is deprecated and will be replaced for a new
		// fixture reset function on QUnit 2.0/2.1.
		// It's still called here for backwards compatibility handling
		QUnit.reset();

		config.current = undefined;
	},

	queue: function() {
		var bad,
			test = this;

		if ( !this.valid() ) {
			return;
		}

		function run() {

			// each of these can by async
			synchronize([
				function() {
					test.before();
				},

				test.hooks( "beforeEach" ),

				function() {
					test.run();
				},

				test.hooks( "afterEach" ).reverse(),

				function() {
					test.after();
				},
				function() {
					test.finish();
				}
			]);
		}

		// `bad` initialized at top of scope
		// defer when previous test run passed, if storage is available
		bad = QUnit.config.reorder && defined.sessionStorage &&
				+sessionStorage.getItem( "qunit-test-" + this.module.name + "-" + this.testName );

		if ( bad ) {
			run();
		} else {
			synchronize( run, true );
		}
	},

	push: function( result, actual, expected, message ) {
		var source,
			details = {
				module: this.module.name,
				name: this.testName,
				result: result,
				message: message,
				actual: actual,
				expected: expected,
				testId: this.testId,
				runtime: now() - this.started
			};

		if ( !result ) {
			source = sourceFromStacktrace();

			if ( source ) {
				details.source = source;
			}
		}

		runLoggingCallbacks( "log", details );

		this.assertions.push({
			result: !!result,
			message: message
		});
	},

	pushFailure: function( message, source, actual ) {
		if ( !this instanceof Test ) {
			throw new Error( "pushFailure() assertion outside test context, was " +
				sourceFromStacktrace( 2 ) );
		}

		var details = {
				module: this.module.name,
				name: this.testName,
				result: false,
				message: message || "error",
				actual: actual || null,
				testId: this.testId,
				runtime: now() - this.started
			};

		if ( source ) {
			details.source = source;
		}

		runLoggingCallbacks( "log", details );

		this.assertions.push({
			result: false,
			message: message
		});
	},

	resolvePromise: function( promise, phase ) {
		var then, message,
			test = this;
		if ( promise != null ) {
			then = promise.then;
			if ( QUnit.objectType( then ) === "function" ) {
				QUnit.stop();
				then.call(
					promise,
					QUnit.start,
					function( error ) {
						message = "Promise rejected " +
							( !phase ? "during" : phase.replace( /Each$/, "" ) ) +
							" " + test.testName + ": " + ( error.message || error );
						test.pushFailure( message, extractStacktrace( error, 0 ) );

						// else next test will carry the responsibility
						saveGlobal();

						// Unblock
						QUnit.start();
					}
				);
			}
		}
	},

	valid: function() {
		var include,
			filter = config.filter,
			module = QUnit.urlParams.module && QUnit.urlParams.module.toLowerCase(),
			fullName = ( this.module.name + ": " + this.testName ).toLowerCase();

		// Internally-generated tests are always valid
		if ( this.callback && this.callback.validTest ) {
			return true;
		}

		if ( config.testId.length > 0 && inArray( this.testId, config.testId ) < 0 ) {
			return false;
		}

		if ( module && ( !this.module.name || this.module.name.toLowerCase() !== module ) ) {
			return false;
		}

		if ( !filter ) {
			return true;
		}

		include = filter.charAt( 0 ) !== "!";
		if ( !include ) {
			filter = filter.toLowerCase().slice( 1 );
		}

		// If the filter matches, we need to honour include
		if ( fullName.indexOf( filter ) !== -1 ) {
			return include;
		}

		// Otherwise, do the opposite
		return !include;
	}

};

// Resets the test setup. Useful for tests that modify the DOM.
/*
DEPRECATED: Use multiple tests instead of resetting inside a test.
Use testStart or testDone for custom cleanup.
This method will throw an error in 2.0, and will be removed in 2.1
*/
QUnit.reset = function() {

	// Return on non-browser environments
	// This is necessary to not break on node tests
	if ( typeof window === "undefined" ) {
		return;
	}

	var fixture = defined.document && document.getElementById &&
			document.getElementById( "qunit-fixture" );

	if ( fixture ) {
		fixture.innerHTML = config.fixture;
	}
};

QUnit.pushFailure = function() {
	if ( !QUnit.config.current ) {
		throw new Error( "pushFailure() assertion outside test context, in " +
			sourceFromStacktrace( 2 ) );
	}

	// Gets current test obj
	var currentTest = QUnit.config.current;

	return currentTest.pushFailure.apply( currentTest, arguments );
};

// Based on Java's String.hashCode, a simple but not
// rigorously collision resistant hashing function
function generateHash( module, testName ) {
	var hex,
		i = 0,
		hash = 0,
		str = module + "\x1C" + testName,
		len = str.length;

	for ( ; i < len; i++ ) {
		hash  = ( ( hash << 5 ) - hash ) + str.charCodeAt( i );
		hash |= 0;
	}

	// Convert the possibly negative integer hash code into an 8 character hex string, which isn't
	// strictly necessary but increases user understanding that the id is a SHA-like hash
	hex = ( 0x100000000 + hash ).toString( 16 );
	if ( hex.length < 8 ) {
		hex = "0000000" + hex;
	}

	return hex.slice( -8 );
}

function Assert( testContext ) {
	this.test = testContext;
}

// Assert helpers
QUnit.assert = Assert.prototype = {

	// Specify the number of expected assertions to guarantee that failed test
	// (no assertions are run at all) don't slip through.
	expect: function( asserts ) {
		if ( arguments.length === 1 ) {
			this.test.expected = asserts;
		} else {
			return this.test.expected;
		}
	},

	// Increment this Test's semaphore counter, then return a single-use function that
	// decrements that counter a maximum of once.
	async: function() {
		var test = this.test,
			popped = false;

		test.semaphore += 1;
		test.usedAsync = true;
		pauseProcessing();

		return function done() {
			if ( !popped ) {
				test.semaphore -= 1;
				popped = true;
				resumeProcessing();
			} else {
				test.pushFailure( "Called the callback returned from `assert.async` more than once",
					sourceFromStacktrace( 2 ) );
			}
		};
	},

	// Exports test.push() to the user API
	push: function( /* result, actual, expected, message */ ) {
		var assert = this,
			currentTest = ( assert instanceof Assert && assert.test ) || QUnit.config.current;

		// Backwards compatibility fix.
		// Allows the direct use of global exported assertions and QUnit.assert.*
		// Although, it's use is not recommended as it can leak assertions
		// to other tests from async tests, because we only get a reference to the current test,
		// not exactly the test where assertion were intended to be called.
		if ( !currentTest ) {
			throw new Error( "assertion outside test context, in " + sourceFromStacktrace( 2 ) );
		}

		if ( currentTest.usedAsync === true && currentTest.semaphore === 0 ) {
			currentTest.pushFailure( "Assertion after the final `assert.async` was resolved",
				sourceFromStacktrace( 2 ) );

			// Allow this assertion to continue running anyway...
		}

		if ( !( assert instanceof Assert ) ) {
			assert = currentTest.assert;
		}
		return assert.test.push.apply( assert.test, arguments );
	},

	/**
	 * Asserts rough true-ish result.
	 * @name ok
	 * @function
	 * @example ok( "asdfasdf".length > 5, "There must be at least 5 chars" );
	 */
	ok: function( result, message ) {
		message = message || ( result ? "okay" : "failed, expected argument to be truthy, was: " +
			QUnit.dump.parse( result ) );
		this.push( !!result, result, true, message );
	},

	/**
	 * Assert that the first two arguments are equal, with an optional message.
	 * Prints out both actual and expected values.
	 * @name equal
	 * @function
	 * @example equal( format( "{0} bytes.", 2), "2 bytes.", "replaces {0} with next argument" );
	 */
	equal: function( actual, expected, message ) {
		/*jshint eqeqeq:false */
		this.push( expected == actual, actual, expected, message );
	},

	/**
	 * @name notEqual
	 * @function
	 */
	notEqual: function( actual, expected, message ) {
		/*jshint eqeqeq:false */
		this.push( expected != actual, actual, expected, message );
	},

	/**
	 * @name propEqual
	 * @function
	 */
	propEqual: function( actual, expected, message ) {
		actual = objectValues( actual );
		expected = objectValues( expected );
		this.push( QUnit.equiv( actual, expected ), actual, expected, message );
	},

	/**
	 * @name notPropEqual
	 * @function
	 */
	notPropEqual: function( actual, expected, message ) {
		actual = objectValues( actual );
		expected = objectValues( expected );
		this.push( !QUnit.equiv( actual, expected ), actual, expected, message );
	},

	/**
	 * @name deepEqual
	 * @function
	 */
	deepEqual: function( actual, expected, message ) {
		this.push( QUnit.equiv( actual, expected ), actual, expected, message );
	},

	/**
	 * @name notDeepEqual
	 * @function
	 */
	notDeepEqual: function( actual, expected, message ) {
		this.push( !QUnit.equiv( actual, expected ), actual, expected, message );
	},

	/**
	 * @name strictEqual
	 * @function
	 */
	strictEqual: function( actual, expected, message ) {
		this.push( expected === actual, actual, expected, message );
	},

	/**
	 * @name notStrictEqual
	 * @function
	 */
	notStrictEqual: function( actual, expected, message ) {
		this.push( expected !== actual, actual, expected, message );
	},

	"throws": function( block, expected, message ) {
		var actual, expectedType,
			expectedOutput = expected,
			ok = false;

		// 'expected' is optional unless doing string comparison
		if ( message == null && typeof expected === "string" ) {
			message = expected;
			expected = null;
		}

		this.test.ignoreGlobalErrors = true;
		try {
			block.call( this.test.testEnvironment );
		} catch (e) {
			actual = e;
		}
		this.test.ignoreGlobalErrors = false;

		if ( actual ) {
			expectedType = QUnit.objectType( expected );

			// we don't want to validate thrown error
			if ( !expected ) {
				ok = true;
				expectedOutput = null;

			// expected is a regexp
			} else if ( expectedType === "regexp" ) {
				ok = expected.test( errorString( actual ) );

			// expected is a string
			} else if ( expectedType === "string" ) {
				ok = expected === errorString( actual );

			// expected is a constructor, maybe an Error constructor
			} else if ( expectedType === "function" && actual instanceof expected ) {
				ok = true;

			// expected is an Error object
			} else if ( expectedType === "object" ) {
				ok = actual instanceof expected.constructor &&
					actual.name === expected.name &&
					actual.message === expected.message;

			// expected is a validation function which returns true if validation passed
			} else if ( expectedType === "function" && expected.call( {}, actual ) === true ) {
				expectedOutput = null;
				ok = true;
			}

			this.push( ok, actual, expectedOutput, message );
		} else {
			this.test.pushFailure( message, null, "No exception was thrown." );
		}
	}
};

// Provide an alternative to assert.throws(), for enviroments that consider throws a reserved word
// Known to us are: Closure Compiler, Narwhal
(function() {
	/*jshint sub:true */
	Assert.prototype.raises = Assert.prototype[ "throws" ];
}());

// Test for equality any JavaScript type.
// Author: Philippe Rath√© <prathe@gmail.com>
QUnit.equiv = (function() {

	// Call the o related callback with the given arguments.
	function bindCallbacks( o, callbacks, args ) {
		var prop = QUnit.objectType( o );
		if ( prop ) {
			if ( QUnit.objectType( callbacks[ prop ] ) === "function" ) {
				return callbacks[ prop ].apply( callbacks, args );
			} else {
				return callbacks[ prop ]; // or undefined
			}
		}
	}

	// the real equiv function
	var innerEquiv,

		// stack to decide between skip/abort functions
		callers = [],

		// stack to avoiding loops from circular referencing
		parents = [],
		parentsB = [],

		getProto = Object.getPrototypeOf || function( obj ) {
			/* jshint camelcase: false, proto: true */
			return obj.__proto__;
		},
		callbacks = (function() {

			// for string, boolean, number and null
			function useStrictEquality( b, a ) {

				/*jshint eqeqeq:false */
				if ( b instanceof a.constructor || a instanceof b.constructor ) {

					// to catch short annotation VS 'new' annotation of a
					// declaration
					// e.g. var i = 1;
					// var j = new Number(1);
					return a == b;
				} else {
					return a === b;
				}
			}

			return {
				"string": useStrictEquality,
				"boolean": useStrictEquality,
				"number": useStrictEquality,
				"null": useStrictEquality,
				"undefined": useStrictEquality,

				"nan": function( b ) {
					return isNaN( b );
				},

				"date": function( b, a ) {
					return QUnit.objectType( b ) === "date" && a.valueOf() === b.valueOf();
				},

				"regexp": function( b, a ) {
					return QUnit.objectType( b ) === "regexp" &&

						// the regex itself
						a.source === b.source &&

						// and its modifiers
						a.global === b.global &&

						// (gmi) ...
						a.ignoreCase === b.ignoreCase &&
						a.multiline === b.multiline &&
						a.sticky === b.sticky;
				},

				// - skip when the property is a method of an instance (OOP)
				// - abort otherwise,
				// initial === would have catch identical references anyway
				"function": function() {
					var caller = callers[ callers.length - 1 ];
					return caller !== Object && typeof caller !== "undefined";
				},

				"array": function( b, a ) {
					var i, j, len, loop, aCircular, bCircular;

					// b could be an object literal here
					if ( QUnit.objectType( b ) !== "array" ) {
						return false;
					}

					len = a.length;
					if ( len !== b.length ) {
						// safe and faster
						return false;
					}

					// track reference to avoid circular references
					parents.push( a );
					parentsB.push( b );
					for ( i = 0; i < len; i++ ) {
						loop = false;
						for ( j = 0; j < parents.length; j++ ) {
							aCircular = parents[ j ] === a[ i ];
							bCircular = parentsB[ j ] === b[ i ];
							if ( aCircular || bCircular ) {
								if ( a[ i ] === b[ i ] || aCircular && bCircular ) {
									loop = true;
								} else {
									parents.pop();
									parentsB.pop();
									return false;
								}
							}
						}
						if ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {
							parents.pop();
							parentsB.pop();
							return false;
						}
					}
					parents.pop();
					parentsB.pop();
					return true;
				},

				"object": function( b, a ) {

					/*jshint forin:false */
					var i, j, loop, aCircular, bCircular,
						// Default to true
						eq = true,
						aProperties = [],
						bProperties = [];

					// comparing constructors is more strict than using
					// instanceof
					if ( a.constructor !== b.constructor ) {

						// Allow objects with no prototype to be equivalent to
						// objects with Object as their constructor.
						if ( !( ( getProto( a ) === null && getProto( b ) === Object.prototype ) ||
							( getProto( b ) === null && getProto( a ) === Object.prototype ) ) ) {
							return false;
						}
					}

					// stack constructor before traversing properties
					callers.push( a.constructor );

					// track reference to avoid circular references
					parents.push( a );
					parentsB.push( b );

					// be strict: don't ensure hasOwnProperty and go deep
					for ( i in a ) {
						loop = false;
						for ( j = 0; j < parents.length; j++ ) {
							aCircular = parents[ j ] === a[ i ];
							bCircular = parentsB[ j ] === b[ i ];
							if ( aCircular || bCircular ) {
								if ( a[ i ] === b[ i ] || aCircular && bCircular ) {
									loop = true;
								} else {
									eq = false;
									break;
								}
							}
						}
						aProperties.push( i );
						if ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {
							eq = false;
							break;
						}
					}

					parents.pop();
					parentsB.pop();
					callers.pop(); // unstack, we are done

					for ( i in b ) {
						bProperties.push( i ); // collect b's properties
					}

					// Ensures identical properties name
					return eq && innerEquiv( aProperties.sort(), bProperties.sort() );
				}
			};
		}());

	innerEquiv = function() { // can take multiple arguments
		var args = [].slice.apply( arguments );
		if ( args.length < 2 ) {
			return true; // end transition
		}

		return ( (function( a, b ) {
			if ( a === b ) {
				return true; // catch the most you can
			} else if ( a === null || b === null || typeof a === "undefined" ||
					typeof b === "undefined" ||
					QUnit.objectType( a ) !== QUnit.objectType( b ) ) {

				// don't lose time with error prone cases
				return false;
			} else {
				return bindCallbacks( a, callbacks, [ b, a ] );
			}

			// apply transition with (1..n) arguments
		}( args[ 0 ], args[ 1 ] ) ) &&
			innerEquiv.apply( this, args.splice( 1, args.length - 1 ) ) );
	};

	return innerEquiv;
}());

// Based on jsDump by Ariel Flesler
// http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html
QUnit.dump = (function() {
	function quote( str ) {
		return "\"" + str.toString().replace( /"/g, "\\\"" ) + "\"";
	}
	function literal( o ) {
		return o + "";
	}
	function join( pre, arr, post ) {
		var s = dump.separator(),
			base = dump.indent(),
			inner = dump.indent( 1 );
		if ( arr.join ) {
			arr = arr.join( "," + s + inner );
		}
		if ( !arr ) {
			return pre + post;
		}
		return [ pre, inner + arr, base + post ].join( s );
	}
	function array( arr, stack ) {
		var i = arr.length,
			ret = new Array( i );

		if ( dump.maxDepth && dump.depth > dump.maxDepth ) {
			return "[object Array]";
		}

		this.up();
		while ( i-- ) {
			ret[ i ] = this.parse( arr[ i ], undefined, stack );
		}
		this.down();
		return join( "[", ret, "]" );
	}

	var reName = /^function (\w+)/,
		dump = {

			// objType is used mostly internally, you can fix a (custom) type in advance
			parse: function( obj, objType, stack ) {
				stack = stack || [];
				var res, parser, parserType,
					inStack = inArray( obj, stack );

				if ( inStack !== -1 ) {
					return "recursion(" + ( inStack - stack.length ) + ")";
				}

				objType = objType || this.typeOf( obj  );
				parser = this.parsers[ objType ];
				parserType = typeof parser;

				if ( parserType === "function" ) {
					stack.push( obj );
					res = parser.call( this, obj, stack );
					stack.pop();
					return res;
				}
				return ( parserType === "string" ) ? parser : this.parsers.error;
			},
			typeOf: function( obj ) {
				var type;
				if ( obj === null ) {
					type = "null";
				} else if ( typeof obj === "undefined" ) {
					type = "undefined";
				} else if ( QUnit.is( "regexp", obj ) ) {
					type = "regexp";
				} else if ( QUnit.is( "date", obj ) ) {
					type = "date";
				} else if ( QUnit.is( "function", obj ) ) {
					type = "function";
				} else if ( obj.setInterval !== undefined &&
						obj.document !== undefined &&
						obj.nodeType === undefined ) {
					type = "window";
				} else if ( obj.nodeType === 9 ) {
					type = "document";
				} else if ( obj.nodeType ) {
					type = "node";
				} else if (

					// native arrays
					toString.call( obj ) === "[object Array]" ||

					// NodeList objects
					( typeof obj.length === "number" && obj.item !== undefined &&
					( obj.length ? obj.item( 0 ) === obj[ 0 ] : ( obj.item( 0 ) === null &&
					obj[ 0 ] === undefined ) ) )
				) {
					type = "array";
				} else if ( obj.constructor === Error.prototype.constructor ) {
					type = "error";
				} else {
					type = typeof obj;
				}
				return type;
			},
			separator: function() {
				return this.multiline ? this.HTML ? "<br />" : "\n" : this.HTML ? "&#160;" : " ";
			},
			// extra can be a number, shortcut for increasing-calling-decreasing
			indent: function( extra ) {
				if ( !this.multiline ) {
					return "";
				}
				var chr = this.indentChar;
				if ( this.HTML ) {
					chr = chr.replace( /\t/g, "   " ).replace( / /g, "&#160;" );
				}
				return new Array( this.depth + ( extra || 0 ) ).join( chr );
			},
			up: function( a ) {
				this.depth += a || 1;
			},
			down: function( a ) {
				this.depth -= a || 1;
			},
			setParser: function( name, parser ) {
				this.parsers[ name ] = parser;
			},
			// The next 3 are exposed so you can use them
			quote: quote,
			literal: literal,
			join: join,
			//
			depth: 1,
			maxDepth: 5,

			// This is the list of parsers, to modify them, use dump.setParser
			parsers: {
				window: "[Window]",
				document: "[Document]",
				error: function( error ) {
					return "Error(\"" + error.message + "\")";
				},
				unknown: "[Unknown]",
				"null": "null",
				"undefined": "undefined",
				"function": function( fn ) {
					var ret = "function",

						// functions never have name in IE
						name = "name" in fn ? fn.name : ( reName.exec( fn ) || [] )[ 1 ];

					if ( name ) {
						ret += " " + name;
					}
					ret += "( ";

					ret = [ ret, dump.parse( fn, "functionArgs" ), "){" ].join( "" );
					return join( ret, dump.parse( fn, "functionCode" ), "}" );
				},
				array: array,
				nodelist: array,
				"arguments": array,
				object: function( map, stack ) {
					var keys, key, val, i, nonEnumerableProperties,
						ret = [];

					if ( dump.maxDepth && dump.depth > dump.maxDepth ) {
						return "[object Object]";
					}

					dump.up();
					keys = [];
					for ( key in map ) {
						keys.push( key );
					}

					// Some properties are not always enumerable on Error objects.
					nonEnumerableProperties = [ "message", "name" ];
					for ( i in nonEnumerableProperties ) {
						key = nonEnumerableProperties[ i ];
						if ( key in map && !( key in keys ) ) {
							keys.push( key );
						}
					}
					keys.sort();
					for ( i = 0; i < keys.length; i++ ) {
						key = keys[ i ];
						val = map[ key ];
						ret.push( dump.parse( key, "key" ) + ": " +
							dump.parse( val, undefined, stack ) );
					}
					dump.down();
					return join( "{", ret, "}" );
				},
				node: function( node ) {
					var len, i, val,
						open = dump.HTML ? "&lt;" : "<",
						close = dump.HTML ? "&gt;" : ">",
						tag = node.nodeName.toLowerCase(),
						ret = open + tag,
						attrs = node.attributes;

					if ( attrs ) {
						for ( i = 0, len = attrs.length; i < len; i++ ) {
							val = attrs[ i ].nodeValue;

							// IE6 includes all attributes in .attributes, even ones not explicitly
							// set. Those have values like undefined, null, 0, false, "" or
							// "inherit".
							if ( val && val !== "inherit" ) {
								ret += " " + attrs[ i ].nodeName + "=" +
									dump.parse( val, "attribute" );
							}
						}
					}
					ret += close;

					// Show content of TextNode or CDATASection
					if ( node.nodeType === 3 || node.nodeType === 4 ) {
						ret += node.nodeValue;
					}

					return ret + open + "/" + tag + close;
				},

				// function calls it internally, it's the arguments part of the function
				functionArgs: function( fn ) {
					var args,
						l = fn.length;

					if ( !l ) {
						return "";
					}

					args = new Array( l );
					while ( l-- ) {

						// 97 is 'a'
						args[ l ] = String.fromCharCode( 97 + l );
					}
					return " " + args.join( ", " ) + " ";
				},
				// object calls it internally, the key part of an item in a map
				key: quote,
				// function calls it internally, it's the content of the function
				functionCode: "[code]",
				// node calls it internally, it's an html attribute value
				attribute: quote,
				string: quote,
				date: quote,
				regexp: literal,
				number: literal,
				"boolean": literal
			},
			// if true, entities are escaped ( <, >, \t, space and \n )
			HTML: false,
			// indentation unit
			indentChar: "  ",
			// if true, items in a collection, are separated by a \n, else just a space.
			multiline: true
		};

	return dump;
}());

// back compat
QUnit.jsDump = QUnit.dump;

// For browser, export only select globals
if ( typeof window !== "undefined" ) {

	// Deprecated
	// Extend assert methods to QUnit and Global scope through Backwards compatibility
	(function() {
		var i,
			assertions = Assert.prototype;

		function applyCurrent( current ) {
			return function() {
				var assert = new Assert( QUnit.config.current );
				current.apply( assert, arguments );
			};
		}

		for ( i in assertions ) {
			QUnit[ i ] = applyCurrent( assertions[ i ] );
		}
	})();

	(function() {
		var i, l,
			keys = [
				"test",
				"module",
				"expect",
				"asyncTest",
				"start",
				"stop",
				"ok",
				"equal",
				"notEqual",
				"propEqual",
				"notPropEqual",
				"deepEqual",
				"notDeepEqual",
				"strictEqual",
				"notStrictEqual",
				"throws"
			];

		for ( i = 0, l = keys.length; i < l; i++ ) {
			window[ keys[ i ] ] = QUnit[ keys[ i ] ];
		}
	})();

	window.QUnit = QUnit;
}

// For nodejs
if ( typeof module !== "undefined" && module && module.exports ) {
	module.exports = QUnit;

	// For consistency with CommonJS environments' exports
	module.exports.QUnit = QUnit;
}

// For CommonJS with exports, but without module.exports, like Rhino
if ( typeof exports !== "undefined" && exports ) {
	exports.QUnit = QUnit;
}

// Get a reference to the global object, like window in browsers
}( (function() {
	return this;
})() ));

/*istanbul ignore next */
// jscs:disable maximumLineLength
/*
 * Javascript Diff Algorithm
 *  By John Resig (http://ejohn.org/)
 *  Modified by Chu Alan "sprite"
 *
 * Released under the MIT license.
 *
 * More Info:
 *  http://ejohn.org/projects/javascript-diff-algorithm/
 *
 * Usage: QUnit.diff(expected, actual)
 *
 * QUnit.diff( "the quick brown fox jumped over", "the quick fox jumps over" ) == "the  quick <del>brown </del> fox <del>jumped </del><ins>jumps </ins> over"
 */
QUnit.diff = (function() {
	var hasOwn = Object.prototype.hasOwnProperty;

	/*jshint eqeqeq:false, eqnull:true */
	function diff( o, n ) {
		var i,
			ns = {},
			os = {};

		for ( i = 0; i < n.length; i++ ) {
			if ( !hasOwn.call( ns, n[ i ] ) ) {
				ns[ n[ i ] ] = {
					rows: [],
					o: null
				};
			}
			ns[ n[ i ] ].rows.push( i );
		}

		for ( i = 0; i < o.length; i++ ) {
			if ( !hasOwn.call( os, o[ i ] ) ) {
				os[ o[ i ] ] = {
					rows: [],
					n: null
				};
			}
			os[ o[ i ] ].rows.push( i );
		}

		for ( i in ns ) {
			if ( hasOwn.call( ns, i ) ) {
				if ( ns[ i ].rows.length === 1 && hasOwn.call( os, i ) && os[ i ].rows.length === 1 ) {
					n[ ns[ i ].rows[ 0 ] ] = {
						text: n[ ns[ i ].rows[ 0 ] ],
						row: os[ i ].rows[ 0 ]
					};
					o[ os[ i ].rows[ 0 ] ] = {
						text: o[ os[ i ].rows[ 0 ] ],
						row: ns[ i ].rows[ 0 ]
					};
				}
			}
		}

		for ( i = 0; i < n.length - 1; i++ ) {
			if ( n[ i ].text != null && n[ i + 1 ].text == null && n[ i ].row + 1 < o.length && o[ n[ i ].row + 1 ].text == null &&
				n[ i + 1 ] == o[ n[ i ].row + 1 ] ) {

				n[ i + 1 ] = {
					text: n[ i + 1 ],
					row: n[ i ].row + 1
				};
				o[ n[ i ].row + 1 ] = {
					text: o[ n[ i ].row + 1 ],
					row: i + 1
				};
			}
		}

		for ( i = n.length - 1; i > 0; i-- ) {
			if ( n[ i ].text != null && n[ i - 1 ].text == null && n[ i ].row > 0 && o[ n[ i ].row - 1 ].text == null &&
				n[ i - 1 ] == o[ n[ i ].row - 1 ] ) {

				n[ i - 1 ] = {
					text: n[ i - 1 ],
					row: n[ i ].row - 1
				};
				o[ n[ i ].row - 1 ] = {
					text: o[ n[ i ].row - 1 ],
					row: i - 1
				};
			}
		}

		return {
			o: o,
			n: n
		};
	}

	return function( o, n ) {
		o = o.replace( /\s+$/, "" );
		n = n.replace( /\s+$/, "" );

		var i, pre,
			str = "",
			out = diff( o === "" ? [] : o.split( /\s+/ ), n === "" ? [] : n.split( /\s+/ ) ),
			oSpace = o.match( /\s+/g ),
			nSpace = n.match( /\s+/g );

		if ( oSpace == null ) {
			oSpace = [ " " ];
		} else {
			oSpace.push( " " );
		}

		if ( nSpace == null ) {
			nSpace = [ " " ];
		} else {
			nSpace.push( " " );
		}

		if ( out.n.length === 0 ) {
			for ( i = 0; i < out.o.length; i++ ) {
				str += "<del>" + out.o[ i ] + oSpace[ i ] + "</del>";
			}
		} else {
			if ( out.n[ 0 ].text == null ) {
				for ( n = 0; n < out.o.length && out.o[ n ].text == null; n++ ) {
					str += "<del>" + out.o[ n ] + oSpace[ n ] + "</del>";
				}
			}

			for ( i = 0; i < out.n.length; i++ ) {
				if ( out.n[ i ].text == null ) {
					str += "<ins>" + out.n[ i ] + nSpace[ i ] + "</ins>";
				} else {

					// `pre` initialized at top of scope
					pre = "";

					for ( n = out.n[ i ].row + 1; n < out.o.length && out.o[ n ].text == null; n++ ) {
						pre += "<del>" + out.o[ n ] + oSpace[ n ] + "</del>";
					}
					str += " " + out.n[ i ].text + nSpace[ i ] + pre;
				}
			}
		}

		return str;
	};
}());
// jscs:enable

(function() {

// Deprecated QUnit.init - Ref #530
// Re-initialize the configuration options
QUnit.init = function() {
	var tests, banner, result, qunit,
		config = QUnit.config;

	config.stats = { all: 0, bad: 0 };
	config.moduleStats = { all: 0, bad: 0 };
	config.started = 0;
	config.updateRate = 1000;
	config.blocking = false;
	config.autostart = true;
	config.autorun = false;
	config.filter = "";
	config.queue = [];

	// Return on non-browser environments
	// This is necessary to not break on node tests
	if ( typeof window === "undefined" ) {
		return;
	}

	qunit = id( "qunit" );
	if ( qunit ) {
		qunit.innerHTML =
			"<h1 id='qunit-header'>" + escapeText( document.title ) + "</h1>" +
			"<h2 id='qunit-banner'></h2>" +
			"<div id='qunit-testrunner-toolbar'></div>" +
			"<h2 id='qunit-userAgent'></h2>" +
			"<ol id='qunit-tests'></ol>";
	}

	tests = id( "qunit-tests" );
	banner = id( "qunit-banner" );
	result = id( "qunit-testresult" );

	if ( tests ) {
		tests.innerHTML = "";
	}

	if ( banner ) {
		banner.className = "";
	}

	if ( result ) {
		result.parentNode.removeChild( result );
	}

	if ( tests ) {
		result = document.createElement( "p" );
		result.id = "qunit-testresult";
		result.className = "result";
		tests.parentNode.insertBefore( result, tests );
		result.innerHTML = "Running...<br />&#160;";
	}
};

// Don't load the HTML Reporter on non-Browser environments
if ( typeof window === "undefined" ) {
	return;
}

var config = QUnit.config,
	hasOwn = Object.prototype.hasOwnProperty,
	defined = {
		document: window.document !== undefined,
		sessionStorage: (function() {
			var x = "qunit-test-string";
			try {
				sessionStorage.setItem( x, x );
				sessionStorage.removeItem( x );
				return true;
			} catch ( e ) {
				return false;
			}
		}())
	},
	modulesList = [];

/**
* Escape text for attribute or text content.
*/
function escapeText( s ) {
	if ( !s ) {
		return "";
	}
	s = s + "";

	// Both single quotes and double quotes (for attributes)
	return s.replace( /['"<>&]/g, function( s ) {
		switch ( s ) {
		case "'":
			return "&#039;";
		case "\"":
			return "&quot;";
		case "<":
			return "&lt;";
		case ">":
			return "&gt;";
		case "&":
			return "&amp;";
		}
	});
}

/**
 * @param {HTMLElement} elem
 * @param {string} type
 * @param {Function} fn
 */
function addEvent( elem, type, fn ) {
	if ( elem.addEventListener ) {

		// Standards-based browsers
		elem.addEventListener( type, fn, false );
	} else if ( elem.attachEvent ) {

		// support: IE <9
		elem.attachEvent( "on" + type, fn );
	}
}

/**
 * @param {Array|NodeList} elems
 * @param {string} type
 * @param {Function} fn
 */
function addEvents( elems, type, fn ) {
	var i = elems.length;
	while ( i-- ) {
		addEvent( elems[ i ], type, fn );
	}
}

function hasClass( elem, name ) {
	return ( " " + elem.className + " " ).indexOf( " " + name + " " ) >= 0;
}

function addClass( elem, name ) {
	if ( !hasClass( elem, name ) ) {
		elem.className += ( elem.className ? " " : "" ) + name;
	}
}

function toggleClass( elem, name ) {
	if ( hasClass( elem, name ) ) {
		removeClass( elem, name );
	} else {
		addClass( elem, name );
	}
}

function removeClass( elem, name ) {
	var set = " " + elem.className + " ";

	// Class name may appear multiple times
	while ( set.indexOf( " " + name + " " ) >= 0 ) {
		set = set.replace( " " + name + " ", " " );
	}

	// trim for prettiness
	elem.className = typeof set.trim === "function" ? set.trim() : set.replace( /^\s+|\s+$/g, "" );
}

function id( name ) {
	return defined.document && document.getElementById && document.getElementById( name );
}

function getUrlConfigHtml() {
	var i, j, val,
		escaped, escapedTooltip,
		selection = false,
		len = config.urlConfig.length,
		urlConfigHtml = "";

	for ( i = 0; i < len; i++ ) {
		val = config.urlConfig[ i ];
		if ( typeof val === "string" ) {
			val = {
				id: val,
				label: val
			};
		}

		escaped = escapeText( val.id );
		escapedTooltip = escapeText( val.tooltip );

		if ( config[ val.id ] === undefined ) {
			config[ val.id ] = QUnit.urlParams[ val.id ];
		}

		if ( !val.value || typeof val.value === "string" ) {
			urlConfigHtml += "<input id='qunit-urlconfig-" + escaped +
				"' name='" + escaped + "' type='checkbox'" +
				( val.value ? " value='" + escapeText( val.value ) + "'" : "" ) +
				( config[ val.id ] ? " checked='checked'" : "" ) +
				" title='" + escapedTooltip + "' /><label for='qunit-urlconfig-" + escaped +
				"' title='" + escapedTooltip + "'>" + val.label + "</label>";
		} else {
			urlConfigHtml += "<label for='qunit-urlconfig-" + escaped +
				"' title='" + escapedTooltip + "'>" + val.label +
				": </label><select id='qunit-urlconfig-" + escaped +
				"' name='" + escaped + "' title='" + escapedTooltip + "'><option></option>";

			if ( QUnit.is( "array", val.value ) ) {
				for ( j = 0; j < val.value.length; j++ ) {
					escaped = escapeText( val.value[ j ] );
					urlConfigHtml += "<option value='" + escaped + "'" +
						( config[ val.id ] === val.value[ j ] ?
							( selection = true ) && " selected='selected'" : "" ) +
						">" + escaped + "</option>";
				}
			} else {
				for ( j in val.value ) {
					if ( hasOwn.call( val.value, j ) ) {
						urlConfigHtml += "<option value='" + escapeText( j ) + "'" +
							( config[ val.id ] === j ?
								( selection = true ) && " selected='selected'" : "" ) +
							">" + escapeText( val.value[ j ] ) + "</option>";
					}
				}
			}
			if ( config[ val.id ] && !selection ) {
				escaped = escapeText( config[ val.id ] );
				urlConfigHtml += "<option value='" + escaped +
					"' selected='selected' disabled='disabled'>" + escaped + "</option>";
			}
			urlConfigHtml += "</select>";
		}
	}

	return urlConfigHtml;
}

// Handle "click" events on toolbar checkboxes and "change" for select menus.
// Updates the URL with the new state of `config.urlConfig` values.
function toolbarChanged() {
	var updatedUrl, value,
		field = this,
		params = {};

	// Detect if field is a select menu or a checkbox
	if ( "selectedIndex" in field ) {
		value = field.options[ field.selectedIndex ].value || undefined;
	} else {
		value = field.checked ? ( field.defaultValue || true ) : undefined;
	}

	params[ field.name ] = value;
	updatedUrl = setUrl( params );

	if ( "hidepassed" === field.name && "replaceState" in window.history ) {
		config[ field.name ] = value || false;
		if ( value ) {
			addClass( id( "qunit-tests" ), "hidepass" );
		} else {
			removeClass( id( "qunit-tests" ), "hidepass" );
		}

		// It is not necessary to refresh the whole page
		window.history.replaceState( null, "", updatedUrl );
	} else {
		window.location = updatedUrl;
	}
}

function setUrl( params ) {
	var key,
		querystring = "?";

	params = QUnit.extend( QUnit.extend( {}, QUnit.urlParams ), params );

	for ( key in params ) {
		if ( hasOwn.call( params, key ) ) {
			if ( params[ key ] === undefined ) {
				continue;
			}
			querystring += encodeURIComponent( key );
			if ( params[ key ] !== true ) {
				querystring += "=" + encodeURIComponent( params[ key ] );
			}
			querystring += "&";
		}
	}
	return location.protocol + "//" + location.host +
		location.pathname + querystring.slice( 0, -1 );
}

function applyUrlParams() {
	var selectBox = id( "qunit-modulefilter" ),
		selection = decodeURIComponent( selectBox.options[ selectBox.selectedIndex ].value ),
		filter = id( "qunit-filter-input" ).value;

	window.location = setUrl({
		module: ( selection === "" ) ? undefined : selection,
		filter: ( filter === "" ) ? undefined : filter,

		// Remove testId filter
		testId: undefined
	});
}

function toolbarUrlConfigContainer() {
	var urlConfigContainer = document.createElement( "span" );

	urlConfigContainer.innerHTML = getUrlConfigHtml();
	addClass( urlConfigContainer, "qunit-url-config" );

	// For oldIE support:
	// * Add handlers to the individual elements instead of the container
	// * Use "click" instead of "change" for checkboxes
	addEvents( urlConfigContainer.getElementsByTagName( "input" ), "click", toolbarChanged );
	addEvents( urlConfigContainer.getElementsByTagName( "select" ), "change", toolbarChanged );

	return urlConfigContainer;
}

function toolbarLooseFilter() {
	var filter = document.createElement( "form" ),
		label = document.createElement( "label" ),
		input = document.createElement( "input" ),
		button = document.createElement( "button" );

	addClass( filter, "qunit-filter" );

	label.innerHTML = "Filter: ";

	input.type = "text";
	input.value = config.filter || "";
	input.name = "filter";
	input.id = "qunit-filter-input";

	button.innerHTML = "Go";

	label.appendChild( input );

	filter.appendChild( label );
	filter.appendChild( button );
	addEvent( filter, "submit", function( ev ) {
		applyUrlParams();

		if ( ev && ev.preventDefault ) {
			ev.preventDefault();
		}

		return false;
	});

	return filter;
}

function toolbarModuleFilterHtml() {
	var i,
		moduleFilterHtml = "";

	if ( !modulesList.length ) {
		return false;
	}

	modulesList.sort(function( a, b ) {
		return a.localeCompare( b );
	});

	moduleFilterHtml += "<label for='qunit-modulefilter'>Module: </label>" +
		"<select id='qunit-modulefilter' name='modulefilter'><option value='' " +
		( QUnit.urlParams.module === undefined ? "selected='selected'" : "" ) +
		">< All Modules ></option>";

	for ( i = 0; i < modulesList.length; i++ ) {
		moduleFilterHtml += "<option value='" +
			escapeText( encodeURIComponent( modulesList[ i ] ) ) + "' " +
			( QUnit.urlParams.module === modulesList[ i ] ? "selected='selected'" : "" ) +
			">" + escapeText( modulesList[ i ] ) + "</option>";
	}
	moduleFilterHtml += "</select>";

	return moduleFilterHtml;
}

function toolbarModuleFilter() {
	var toolbar = id( "qunit-testrunner-toolbar" ),
		moduleFilter = document.createElement( "span" ),
		moduleFilterHtml = toolbarModuleFilterHtml();

	if ( !toolbar || !moduleFilterHtml ) {
		return false;
	}

	moduleFilter.setAttribute( "id", "qunit-modulefilter-container" );
	moduleFilter.innerHTML = moduleFilterHtml;

	addEvent( moduleFilter.lastChild, "change", applyUrlParams );

	toolbar.appendChild( moduleFilter );
}

function appendToolbar() {
	var toolbar = id( "qunit-testrunner-toolbar" );

	if ( toolbar ) {
		toolbar.appendChild( toolbarUrlConfigContainer() );
		toolbar.appendChild( toolbarLooseFilter() );
	}
}

function appendHeader() {
	var header = id( "qunit-header" );

	if ( header ) {
		header.innerHTML = "<a href='" +
			setUrl({ filter: undefined, module: undefined, testId: undefined }) +
			"'>" + header.innerHTML + "</a> ";
	}
}

function appendBanner() {
	var banner = id( "qunit-banner" );

	if ( banner ) {
		banner.className = "";
	}
}

function appendTestResults() {
	var tests = id( "qunit-tests" ),
		result = id( "qunit-testresult" );

	if ( result ) {
		result.parentNode.removeChild( result );
	}

	if ( tests ) {
		tests.innerHTML = "";
		result = document.createElement( "p" );
		result.id = "qunit-testresult";
		result.className = "result";
		tests.parentNode.insertBefore( result, tests );
		result.innerHTML = "Running...<br />&#160;";
	}
}

function storeFixture() {
	var fixture = id( "qunit-fixture" );
	if ( fixture ) {
		config.fixture = fixture.innerHTML;
	}
}

function appendUserAgent() {
	var userAgent = id( "qunit-userAgent" );
	if ( userAgent ) {
		userAgent.innerHTML = "";
		userAgent.appendChild( document.createTextNode( navigator.userAgent ) );
	}
}

function appendTestsList( modules ) {
	var i, l, x, z, test, moduleObj;

	for ( i = 0, l = modules.length; i < l; i++ ) {
		moduleObj = modules[ i ];

		if ( moduleObj.name ) {
			modulesList.push( moduleObj.name );
		}

		for ( x = 0, z = moduleObj.tests.length; x < z; x++ ) {
			test = moduleObj.tests[ x ];

			appendTest( test.name, test.testId, moduleObj.name );
		}
	}
}

function appendTest( name, testId, moduleName ) {
	var title, rerunTrigger, testBlock, assertList,
		tests = id( "qunit-tests" );

	if ( !tests ) {
		return;
	}

	title = document.createElement( "strong" );
	title.innerHTML = getNameHtml( name, moduleName );

	rerunTrigger = document.createElement( "a" );
	rerunTrigger.innerHTML = "Rerun";
	rerunTrigger.href = setUrl({ testId: testId });

	testBlock = document.createElement( "li" );
	testBlock.appendChild( title );
	testBlock.appendChild( rerunTrigger );
	testBlock.id = "qunit-test-output-" + testId;

	assertList = document.createElement( "ol" );
	assertList.className = "qunit-assert-list";

	testBlock.appendChild( assertList );

	tests.appendChild( testBlock );
}

// HTML Reporter initialization and load
QUnit.begin(function( details ) {
	var qunit = id( "qunit" );

	// Fixture is the only one necessary to run without the #qunit element
	storeFixture();

	if ( qunit ) {
		qunit.innerHTML =
			"<h1 id='qunit-header'>" + escapeText( document.title ) + "</h1>" +
			"<h2 id='qunit-banner'></h2>" +
			"<div id='qunit-testrunner-toolbar'></div>" +
			"<h2 id='qunit-userAgent'></h2>" +
			"<ol id='qunit-tests'></ol>";
	}

	appendHeader();
	appendBanner();
	appendTestResults();
	appendUserAgent();
	appendToolbar();
	appendTestsList( details.modules );
	toolbarModuleFilter();

	if ( qunit && config.hidepassed ) {
		addClass( qunit.lastChild, "hidepass" );
	}
});

QUnit.done(function( details ) {
	var i, key,
		banner = id( "qunit-banner" ),
		tests = id( "qunit-tests" ),
		html = [
			"Tests completed in ",
			details.runtime,
			" milliseconds.<br />",
			"<span class='passed'>",
			details.passed,
			"</span> assertions of <span class='total'>",
			details.total,
			"</span> passed, <span class='failed'>",
			details.failed,
			"</span> failed."
		].join( "" );

	if ( banner ) {
		banner.className = details.failed ? "qunit-fail" : "qunit-pass";
	}

	if ( tests ) {
		id( "qunit-testresult" ).innerHTML = html;
	}

	if ( config.altertitle && defined.document && document.title ) {

		// show ‚úñ for good, ‚úî for bad suite result in title
		// use escape sequences in case file gets loaded with non-utf-8-charset
		document.title = [
			( details.failed ? "\u2716" : "\u2714" ),
			document.title.replace( /^[\u2714\u2716] /i, "" )
		].join( " " );
	}

	// clear own sessionStorage items if all tests passed
	if ( config.reorder && defined.sessionStorage && details.failed === 0 ) {
		for ( i = 0; i < sessionStorage.length; i++ ) {
			key = sessionStorage.key( i++ );
			if ( key.indexOf( "qunit-test-" ) === 0 ) {
				sessionStorage.removeItem( key );
			}
		}
	}

	// scroll back to top to show results
	if ( config.scrolltop && window.scrollTo ) {
		window.scrollTo( 0, 0 );
	}
});

function getNameHtml( name, module ) {
	var nameHtml = "";

	if ( module ) {
		nameHtml = "<span class='module-name'>" + escapeText( module ) + "</span>: ";
	}

	nameHtml += "<span class='test-name'>" + escapeText( name ) + "</span>";

	return nameHtml;
}

QUnit.testStart(function( details ) {
	var running, testBlock;

	testBlock = id( "qunit-test-output-" + details.testId );
	if ( testBlock ) {
		testBlock.className = "running";
	} else {

		// Report later registered tests
		appendTest( details.name, details.testId, details.module );
	}

	running = id( "qunit-testresult" );
	if ( running ) {
		running.innerHTML = "Running: <br />" + getNameHtml( details.name, details.module );
	}

});

QUnit.log(function( details ) {
	var assertList, assertLi,
		message, expected, actual,
		testItem = id( "qunit-test-output-" + details.testId );

	if ( !testItem ) {
		return;
	}

	message = escapeText( details.message ) || ( details.result ? "okay" : "failed" );
	message = "<span class='test-message'>" + message + "</span>";
	message += "<span class='runtime'>@ " + details.runtime + " ms</span>";

	// pushFailure doesn't provide details.expected
	// when it calls, it's implicit to also not show expected and diff stuff
	// Also, we need to check details.expected existence, as it can exist and be undefined
	if ( !details.result && hasOwn.call( details, "expected" ) ) {
		expected = escapeText( QUnit.dump.parse( details.expected ) );
		actual = escapeText( QUnit.dump.parse( details.actual ) );
		message += "<table><tr class='test-expected'><th>Expected: </th><td><pre>" +
			expected +
			"</pre></td></tr>";

		if ( actual !== expected ) {
			message += "<tr class='test-actual'><th>Result: </th><td><pre>" +
				actual + "</pre></td></tr>" +
				"<tr class='test-diff'><th>Diff: </th><td><pre>" +
				QUnit.diff( expected, actual ) + "</pre></td></tr>";
		}

		if ( details.source ) {
			message += "<tr class='test-source'><th>Source: </th><td><pre>" +
				escapeText( details.source ) + "</pre></td></tr>";
		}

		message += "</table>";

	// this occours when pushFailure is set and we have an extracted stack trace
	} else if ( !details.result && details.source ) {
		message += "<table>" +
			"<tr class='test-source'><th>Source: </th><td><pre>" +
			escapeText( details.source ) + "</pre></td></tr>" +
			"</table>";
	}

	assertList = testItem.getElementsByTagName( "ol" )[ 0 ];

	assertLi = document.createElement( "li" );
	assertLi.className = details.result ? "pass" : "fail";
	assertLi.innerHTML = message;
	assertList.appendChild( assertLi );
});

QUnit.testDone(function( details ) {
	var testTitle, time, testItem, assertList,
		good, bad, testCounts, skipped,
		tests = id( "qunit-tests" );

	if ( !tests ) {
		return;
	}

	testItem = id( "qunit-test-output-" + details.testId );

	assertList = testItem.getElementsByTagName( "ol" )[ 0 ];

	good = details.passed;
	bad = details.failed;

	// store result when possible
	if ( config.reorder && defined.sessionStorage ) {
		if ( bad ) {
			sessionStorage.setItem( "qunit-test-" + details.module + "-" + details.name, bad );
		} else {
			sessionStorage.removeItem( "qunit-test-" + details.module + "-" + details.name );
		}
	}

	if ( bad === 0 ) {
		addClass( assertList, "qunit-collapsed" );
	}

	// testItem.firstChild is the test name
	testTitle = testItem.firstChild;

	testCounts = bad ?
		"<b class='failed'>" + bad + "</b>, " + "<b class='passed'>" + good + "</b>, " :
		"";

	testTitle.innerHTML += " <b class='counts'>(" + testCounts +
		details.assertions.length + ")</b>";

	if ( details.skipped ) {
		testItem.className = "skipped";
		skipped = document.createElement( "em" );
		skipped.className = "qunit-skipped-label";
		skipped.innerHTML = "skipped";
		testItem.insertBefore( skipped, testTitle );
	} else {
		addEvent( testTitle, "click", function() {
			toggleClass( assertList, "qunit-collapsed" );
		});

		testItem.className = bad ? "fail" : "pass";

		time = document.createElement( "span" );
		time.className = "runtime";
		time.innerHTML = details.runtime + " ms";
		testItem.insertBefore( time, assertList );
	}
});

if ( !defined.document || document.readyState === "complete" ) {
	config.pageLoaded = true;
	config.autorun = true;
}

if ( defined.document ) {
	addEvent( window, "load", QUnit.load );
}

})();

QUnit.config.autostart = false;

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, function () { 'use strict';

    var hookCallback;

    function utils_hooks__hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function create_utc__createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    function valid__isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            m._isValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }
        }
        return m._isValid;
    }

    function valid__createInvalid (flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    var momentProperties = utils_hooks__hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (typeof from._isAMomentObject !== 'undefined') {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (typeof from._i !== 'undefined') {
            to._i = from._i;
        }
        if (typeof from._f !== 'undefined') {
            to._f = from._f;
        }
        if (typeof from._l !== 'undefined') {
            to._l = from._l;
        }
        if (typeof from._strict !== 'undefined') {
            to._strict = from._strict;
        }
        if (typeof from._tzm !== 'undefined') {
            to._tzm = from._tzm;
        }
        if (typeof from._isUTC !== 'undefined') {
            to._isUTC = from._isUTC;
        }
        if (typeof from._offset !== 'undefined') {
            to._offset = from._offset;
        }
        if (typeof from._pf !== 'undefined') {
            to._pf = getParsingFlags(from);
        }
        if (typeof from._locale !== 'undefined') {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (typeof val !== 'undefined') {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(+config._d);
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            utils_hooks__hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }

        return value;
    }

    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function Locale() {
    }

    var locales = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && typeof module !== 'undefined' &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we
                // want to undo that for lazy loaded locales
                locale_locales__getSetGlobalLocale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function locale_locales__getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (typeof values === 'undefined') {
                data = locale_locales__getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, values) {
        if (values !== null) {
            values.abbr = name;
            if (!locales[name]) {
                locales[name] = new Locale();
            }
            locales[name].set(values);

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    // returns locale data
    function locale_locales__getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                get_set__set(this, unit, value);
                utils_hooks__hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get_set__get(this, unit);
            }
        };
    }

    function get_set__get (mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }

    function get_set__set (mom, unit, value) {
        return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }

    // MOMENTS

    function getSet (units, value) {
        var unit;
        if (typeof units === 'object') {
            for (unit in units) {
                this.set(unit, units[unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                return this[units](value);
            }
        }
        return this;
    }

    function zeroFill(number, targetLength, forceSign) {
        var output = '' + Math.abs(number),
            sign = number >= 0;

        while (output.length < targetLength) {
            output = '0' + output;
        }
        return (sign ? (forceSign ? '+' : '') : '-') + output;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '';
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;

    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = typeof regex === 'function' ? regex : function (isStrict) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (typeof callback === 'number') {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  matchWord);
    addRegexToken('MMMM', matchWord);

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m) {
        return this._months[m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m) {
        return this._monthsShort[m.month()];
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            utils_hooks__hooks.updateOffset(this, true);
            return this;
        } else {
            return get_set__get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true,
            msgWithStack = msg + '\n' + (new Error()).stack;

        return extend(function () {
            if (firstTime) {
                warn(msgWithStack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    utils_hooks__hooks.suppressDeprecationWarnings = false;

    var from_string__isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
        ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
        ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d{2}/],
        ['YYYY-DDD', /\d{4}-\d{3}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
        ['HH:mm', /(T| )\d\d:\d\d/],
        ['HH', /(T| )\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = from_string__isoRegex.exec(string);

        if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    // match[5] should be 'T' or undefined
                    config._f = isoDates[i][0] + (match[6] || ' ');
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(matchOffset)) {
                config._f += 'Z';
            }
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    utils_hooks__hooks.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'https://github.com/moment/moment/issues/1407 for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    function createDate (y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate (y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYY', 'YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YY', function (input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    utils_hooks__hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', false);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = local__createLocal(mom).add(daysToDayOfWeek, 'd');
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = createUTCDate(year, 0, 1).getUTCDay();
        var daysToAdd;
        var dayOfYear;

        d = d === 0 ? 7 : d;
        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

        return {
            year      : dayOfYear > 0 ? year      : year - 1,
            dayOfYear : dayOfYear > 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()];
        }
        return [now.getFullYear(), now.getMonth(), now.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
            week = defaults(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);

        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }

    utils_hooks__hooks.ISO_8601 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === utils_hooks__hooks.ISO_8601) {
            configFromISO(config);
            return;
        }

        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (getParsingFlags(config).bigHour === true &&
                config._a[HOUR] <= 12 &&
                config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!valid__isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = [i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond];

        configFromArray(config);
    }

    function createFromConfig (config) {
        var input = config._i,
            format = config._f,
            res;

        config._locale = config._locale || locale_locales__getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return valid__createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else if (isDate(input)) {
            config._d = input;
        } else {
            configFromInput(config);
        }

        res = new Moment(checkOverflow(config));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
            config._d = new Date();
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (typeof(input) === 'object') {
            configFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function local__createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
         'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
         function () {
             var other = local__createLocal.apply(null, arguments);
             return other < this ? this : other;
         }
     );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
        function () {
            var other = local__createLocal.apply(null, arguments);
            return other > this ? this : other;
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = locale_locales__getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchOffset);
    addRegexToken('ZZ', matchOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(string) {
        var matches = ((string || '').match(matchOffset) || []);
        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(+res._d + diff);
            utils_hooks__hooks.updateOffset(res, false);
            return res;
        } else {
            return local__createLocal(input).local();
        }
        return model._isUTC ? local__createLocal(input).zone(model._offset || 0) : local__createLocal(input).local();
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    utils_hooks__hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime) {
        var offset = this._offset || 0,
            localAdjust;
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(input);
            }
            if (Math.abs(input) < 16) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    utils_hooks__hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm) {
            this.utcOffset(this._tzm);
        } else if (typeof this._i === 'string') {
            this.utcOffset(offsetFromString(this._i));
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!input) {
            input = 0;
        }
        else {
            input = local__createLocal(input).utcOffset();
        }

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (this._a) {
            var other = this._isUTC ? create_utc__createUTC(this._a) : local__createLocal(this._a);
            return this.isValid() && compareArrays(this._a, other.toArray()) > 0;
        }

        return false;
    }

    function isLocal () {
        return !this._isUTC;
    }

    function isUtcOffset () {
        return this._isUTC;
    }

    function isUtc () {
        return this._isUTC && this._offset === 0;
    }

    var aspNetRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    var create__isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;

    function create__createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])        * sign,
                h  : toInt(match[HOUR])        * sign,
                m  : toInt(match[MINUTE])      * sign,
                s  : toInt(match[SECOND])      * sign,
                ms : toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = create__isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                d : parseIso(match[4], sign),
                h : parseIso(match[5], sign),
                m : parseIso(match[6], sign),
                s : parseIso(match[7], sign),
                w : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    create__createDuration.fn = Duration.prototype;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = create__createDuration(val, period);
            add_subtract__addSubtract(this, dur, direction);
            return this;
        };
    }

    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
        }
        if (months) {
            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            utils_hooks__hooks.updateOffset(mom, days || months);
        }
    }

    var add_subtract__add      = createAdder(1, 'add');
    var add_subtract__subtract = createAdder(-1, 'subtract');

    function moment_calendar__calendar (time) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || local__createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            diff = this.diff(sod, 'days', true),
            format = diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
        return this.format(this.localeData().calendar(format, this, local__createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this > +input;
        } else {
            inputMs = isMoment(input) ? +input : +local__createLocal(input);
            return inputMs < +this.clone().startOf(units);
        }
    }

    function isBefore (input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this < +input;
        } else {
            inputMs = isMoment(input) ? +input : +local__createLocal(input);
            return +this.clone().endOf(units) < inputMs;
        }
    }

    function isBetween (from, to, units) {
        return this.isAfter(from, units) && this.isBefore(to, units);
    }

    function isSame (input, units) {
        var inputMs;
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this === +input;
        } else {
            inputMs = +local__createLocal(input);
            return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
        }
    }

    function absFloor (number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    function diff (input, units, asFloat) {
        var that = cloneWithOffset(input, this),
            zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4,
            delta, output;

        units = normalizeUnits(units);

        if (units === 'year' || units === 'month' || units === 'quarter') {
            output = monthDiff(this, that);
            if (units === 'quarter') {
                output = output / 3;
            } else if (units === 'year') {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === 'second' ? delta / 1e3 : // 1000
                units === 'minute' ? delta / 6e4 : // 1000 * 60
                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                delta;
        }
        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        return -(wholeMonthDiff + adjust);
    }

    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function moment_format__toISOString () {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
            if ('function' === typeof Date.prototype.toISOString) {
                // native implementation is ~50x faster, use it when we can
                return this.toDate().toISOString();
            } else {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        } else {
            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
    }

    function moment_format__format (inputString) {
        var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    }

    function fromNow (withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    }

    function toNow (withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix);
    }

    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = locale_locales__getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    function startOf (units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf (units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }
        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function to_type__valueOf () {
        return +this._d - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(+this / 1000);
    }

    function toDate () {
        return this._offset ? new Date(+this) : this._d;
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function moment_valid__isValid () {
        return valid__isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // HELPERS

    function weeksInYear(year, dow, doy) {
        return weekOfYear(local__createLocal([year, 11, 31 + dow - doy]), dow, doy).week;
    }

    // MOMENTS

    function getSetWeekYear (input) {
        var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
        return input == null ? year : this.add((input - year), 'y');
    }

    function getSetISOWeekYear (input) {
        var year = weekOfYear(this, 1, 4).year;
        return input == null ? year : this.add((input - year), 'y');
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    addFormatToken('Q', 0, 0, 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   matchWord);
    addRegexToken('ddd',  matchWord);
    addRegexToken('dddd', matchWord);

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config) {
        var weekday = config._locale.weekdaysParse(input);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input === 'string') {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            }
            else {
                input = locale.weekdaysParse(input);
                if (typeof input !== 'number') {
                    return null;
                }
            }
        }
        return input;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m) {
        return this._weekdays[m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return this._weekdaysShort[m.day()];
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return this._weekdaysMin[m.day()];
    }

    function localeWeekdaysParse (weekdayName) {
        var i, mom, regex;

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            if (!this._weekdaysParse[i]) {
                mom = local__createLocal([2000, 1]).day(i);
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.
        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, function () {
        return this.hours() % 12 || 12;
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    function millisecond__milliseconds (token) {
        addFormatToken(0, [token, 3], 0, 'millisecond');
    }

    millisecond__milliseconds('SSS');
    millisecond__milliseconds('SSSS');

    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);
    addRegexToken('SSSS', matchUnsigned);
    addParseToken(['S', 'SS', 'SSS', 'SSSS'], function (input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    });

    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var momentPrototype__proto = Moment.prototype;

    momentPrototype__proto.add          = add_subtract__add;
    momentPrototype__proto.calendar     = moment_calendar__calendar;
    momentPrototype__proto.clone        = clone;
    momentPrototype__proto.diff         = diff;
    momentPrototype__proto.endOf        = endOf;
    momentPrototype__proto.format       = moment_format__format;
    momentPrototype__proto.from         = from;
    momentPrototype__proto.fromNow      = fromNow;
    momentPrototype__proto.to           = to;
    momentPrototype__proto.toNow        = toNow;
    momentPrototype__proto.get          = getSet;
    momentPrototype__proto.invalidAt    = invalidAt;
    momentPrototype__proto.isAfter      = isAfter;
    momentPrototype__proto.isBefore     = isBefore;
    momentPrototype__proto.isBetween    = isBetween;
    momentPrototype__proto.isSame       = isSame;
    momentPrototype__proto.isValid      = moment_valid__isValid;
    momentPrototype__proto.lang         = lang;
    momentPrototype__proto.locale       = locale;
    momentPrototype__proto.localeData   = localeData;
    momentPrototype__proto.max          = prototypeMax;
    momentPrototype__proto.min          = prototypeMin;
    momentPrototype__proto.parsingFlags = parsingFlags;
    momentPrototype__proto.set          = getSet;
    momentPrototype__proto.startOf      = startOf;
    momentPrototype__proto.subtract     = add_subtract__subtract;
    momentPrototype__proto.toArray      = toArray;
    momentPrototype__proto.toDate       = toDate;
    momentPrototype__proto.toISOString  = moment_format__toISOString;
    momentPrototype__proto.toJSON       = moment_format__toISOString;
    momentPrototype__proto.toString     = toString;
    momentPrototype__proto.unix         = unix;
    momentPrototype__proto.valueOf      = to_type__valueOf;

    // Year
    momentPrototype__proto.year       = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;

    // Week Year
    momentPrototype__proto.weekYear    = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

    // Quarter
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

    // Month
    momentPrototype__proto.month       = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;

    // Week
    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
    momentPrototype__proto.weeksInYear    = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

    // Day
    momentPrototype__proto.date       = getSetDayOfMonth;
    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear  = getSetDayOfYear;

    // Hour
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

    // Minute
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

    // Second
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

    // Millisecond
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

    // Offset
    momentPrototype__proto.utcOffset            = getSetOffset;
    momentPrototype__proto.utc                  = setOffsetToUTC;
    momentPrototype__proto.local                = setOffsetToLocal;
    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST                = isDaylightSavingTime;
    momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;
    momentPrototype__proto.isLocal              = isLocal;
    momentPrototype__proto.isUtcOffset          = isUtcOffset;
    momentPrototype__proto.isUtc                = isUtc;
    momentPrototype__proto.isUTC                = isUtc;

    // Timezone
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;

    // Deprecations
    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);

    var momentPrototype = momentPrototype__proto;

    function moment_moment__createUnix (input) {
        return local__createLocal(input * 1000);
    }

    function moment_moment__createInZone () {
        return local__createLocal.apply(null, arguments).parseZone();
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function locale_calendar__calendar (key, mom, now) {
        var output = this._calendar[key];
        return typeof output === 'function' ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY LT',
        LLLL : 'dddd, MMMM D, YYYY LT'
    };

    function longDateFormat (key) {
        var output = this._longDateFormat[key];
        if (!output && this._longDateFormat[key.toUpperCase()]) {
            output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                return val.slice(1);
            });
            this._longDateFormat[key] = output;
        }
        return output;
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    function preParsePostFormat (string) {
        return string;
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (typeof output === 'function') ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
    }

    function locale_set__set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (typeof prop === 'function') {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _ordinalParseLenient.
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
    }

    var prototype__proto = Locale.prototype;

    prototype__proto._calendar       = defaultCalendar;
    prototype__proto.calendar        = locale_calendar__calendar;
    prototype__proto._longDateFormat = defaultLongDateFormat;
    prototype__proto.longDateFormat  = longDateFormat;
    prototype__proto._invalidDate    = defaultInvalidDate;
    prototype__proto.invalidDate     = invalidDate;
    prototype__proto._ordinal        = defaultOrdinal;
    prototype__proto.ordinal         = ordinal;
    prototype__proto._ordinalParse   = defaultOrdinalParse;
    prototype__proto.preparse        = preParsePostFormat;
    prototype__proto.postformat      = preParsePostFormat;
    prototype__proto._relativeTime   = defaultRelativeTime;
    prototype__proto.relativeTime    = relative__relativeTime;
    prototype__proto.pastFuture      = pastFuture;
    prototype__proto.set             = locale_set__set;

    // Month
    prototype__proto.months       =        localeMonths;
    prototype__proto._months      = defaultLocaleMonths;
    prototype__proto.monthsShort  =        localeMonthsShort;
    prototype__proto._monthsShort = defaultLocaleMonthsShort;
    prototype__proto.monthsParse  =        localeMonthsParse;

    // Week
    prototype__proto.week = localeWeek;
    prototype__proto._week = defaultLocaleWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

    // Day of Week
    prototype__proto.weekdays       =        localeWeekdays;
    prototype__proto._weekdays      = defaultLocaleWeekdays;
    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
    prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;
    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
    prototype__proto.weekdaysParse  =        localeWeekdaysParse;

    // Hours
    prototype__proto.isPM = localeIsPM;
    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
    prototype__proto.meridiem = localeMeridiem;

    function lists__get (format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function list (format, index, field, count, setter) {
        if (typeof format === 'number') {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return lists__get(format, index, field, setter);
        }

        var i;
        var out = [];
        for (i = 0; i < count; i++) {
            out[i] = lists__get(format, i, field, setter);
        }
        return out;
    }

    function lists__listMonths (format, index) {
        return list(format, index, 'months', 12, 'month');
    }

    function lists__listMonthsShort (format, index) {
        return list(format, index, 'monthsShort', 12, 'month');
    }

    function lists__listWeekdays (format, index) {
        return list(format, index, 'weekdays', 7, 'day');
    }

    function lists__listWeekdaysShort (format, index) {
        return list(format, index, 'weekdaysShort', 7, 'day');
    }

    function lists__listWeekdaysMin (format, index) {
        return list(format, index, 'weekdaysMin', 7, 'day');
    }

    locale_locales__getSetGlobalLocale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports
    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

    var mathAbs = Math.abs;

    function duration_abs__abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function duration_add_subtract__addSubtract (duration, input, value, direction) {
        var other = create__createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function duration_add_subtract__add (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function duration_add_subtract__subtract (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years = 0;

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // Accurately convert days to years, assume start from year 0.
        years = absFloor(daysToYears(days));
        days -= absFloor(yearsToDays(years));

        // 30 days to a month
        // TODO (iskren): Use anchor date (like 1st Jan) to compute this.
        months += absFloor(days / 30);
        days   %= 30;

        // 12 months -> 1 year
        years  += absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToYears (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        return days * 400 / 146097;
    }

    function yearsToDays (years) {
        // years * 365 + absFloor(years / 4) -
        //     absFloor(years / 100) + absFloor(years / 400);
        return years * 146097 / 400;
    }

    function as (units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days   = this._days   + milliseconds / 864e5;
            months = this._months + daysToYears(days) * 12;
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(yearsToDays(this._months / 12));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function duration_as__valueOf () {
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asYears        = makeAs('y');

    function duration_get__get (units) {
        units = normalizeUnits(units);
        return this[units + 's']();
    }

    function makeGetter(name) {
        return function () {
            return this._data[name];
        };
    }

    var duration_get__milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var duration_get__months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        s: 45,  // seconds to minute
        m: 45,  // minutes to hour
        h: 22,  // hours to day
        d: 26,  // days to month
        M: 11   // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds < thresholds.s && ['s', seconds]  ||
                minutes === 1          && ['m']           ||
                minutes < thresholds.m && ['mm', minutes] ||
                hours   === 1          && ['h']           ||
                hours   < thresholds.h && ['hh', hours]   ||
                days    === 1          && ['d']           ||
                days    < thresholds.d && ['dd', days]    ||
                months  === 1          && ['M']           ||
                months  < thresholds.M && ['MM', months]  ||
                years   === 1          && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set a threshold for relative time strings
    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
    }

    function humanize (withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var iso_string__abs = Math.abs;

    function iso_string__toISOString() {
        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = iso_string__abs(this.years());
        var M = iso_string__abs(this.months());
        var D = iso_string__abs(this.days());
        var h = iso_string__abs(this.hours());
        var m = iso_string__abs(this.minutes());
        var s = iso_string__abs(this.seconds() + this.milliseconds() / 1000);
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        return (total < 0 ? '-' : '') +
            'P' +
            (Y ? Y + 'Y' : '') +
            (M ? M + 'M' : '') +
            (D ? D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? h + 'H' : '') +
            (m ? m + 'M' : '') +
            (s ? s + 'S' : '');
    }

    var duration_prototype__proto = Duration.prototype;

    duration_prototype__proto.abs            = duration_abs__abs;
    duration_prototype__proto.add            = duration_add_subtract__add;
    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
    duration_prototype__proto.as             = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds      = asSeconds;
    duration_prototype__proto.asMinutes      = asMinutes;
    duration_prototype__proto.asHours        = asHours;
    duration_prototype__proto.asDays         = asDays;
    duration_prototype__proto.asWeeks        = asWeeks;
    duration_prototype__proto.asMonths       = asMonths;
    duration_prototype__proto.asYears        = asYears;
    duration_prototype__proto.valueOf        = duration_as__valueOf;
    duration_prototype__proto._bubble        = bubble;
    duration_prototype__proto.get            = duration_get__get;
    duration_prototype__proto.milliseconds   = duration_get__milliseconds;
    duration_prototype__proto.seconds        = seconds;
    duration_prototype__proto.minutes        = minutes;
    duration_prototype__proto.hours          = hours;
    duration_prototype__proto.days           = days;
    duration_prototype__proto.weeks          = weeks;
    duration_prototype__proto.months         = duration_get__months;
    duration_prototype__proto.years          = years;
    duration_prototype__proto.humanize       = humanize;
    duration_prototype__proto.toISOString    = iso_string__toISOString;
    duration_prototype__proto.toString       = iso_string__toISOString;
    duration_prototype__proto.toJSON         = iso_string__toISOString;
    duration_prototype__proto.locale         = locale;
    duration_prototype__proto.localeData     = localeData;

    // Deprecations
    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
    duration_prototype__proto.lang = lang;

    // Side effect imports

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports

    ;

    //! moment.js
    //! version : 2.10.3
    //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
    //! license : MIT
    //! momentjs.com

    utils_hooks__hooks.version = '2.10.3';

    setHookCallback(local__createLocal);

    utils_hooks__hooks.fn                    = momentPrototype;
    utils_hooks__hooks.min                   = min;
    utils_hooks__hooks.max                   = max;
    utils_hooks__hooks.utc                   = create_utc__createUTC;
    utils_hooks__hooks.unix                  = moment_moment__createUnix;
    utils_hooks__hooks.months                = lists__listMonths;
    utils_hooks__hooks.isDate                = isDate;
    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid               = valid__createInvalid;
    utils_hooks__hooks.duration              = create__createDuration;
    utils_hooks__hooks.isMoment              = isMoment;
    utils_hooks__hooks.weekdays              = lists__listWeekdays;
    utils_hooks__hooks.parseZone             = moment_moment__createInZone;
    utils_hooks__hooks.localeData            = locale_locales__getLocale;
    utils_hooks__hooks.isDuration            = isDuration;
    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale          = defineLocale;
    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;

    var _moment__default = utils_hooks__hooks;

    //! moment.js locale configuration
    //! locale : afrikaans (af)
    //! author : Werner Mollentze : https://github.com/wernerm

    var af = _moment__default.defineLocale('af', {
        months : 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
        weekdays : 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
        weekdaysShort : 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
        weekdaysMin : 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
        meridiemParse: /vm|nm/i,
        isPM : function (input) {
            return /^nm$/i.test(input);
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower ? 'vm' : 'VM';
            } else {
                return isLower ? 'nm' : 'NM';
            }
        },
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd, D MMMM YYYY LT'
        },
        calendar : {
            sameDay : '[Vandag om] LT',
            nextDay : '[M√¥re om] LT',
            nextWeek : 'dddd [om] LT',
            lastDay : '[Gister om] LT',
            lastWeek : '[Laas] dddd [om] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'oor %s',
            past : '%s gelede',
            s : '\'n paar sekondes',
            m : '\'n minuut',
            mm : '%d minute',
            h : '\'n uur',
            hh : '%d ure',
            d : '\'n dag',
            dd : '%d dae',
            M : '\'n maand',
            MM : '%d maande',
            y : '\'n jaar',
            yy : '%d jaar'
        },
        ordinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris R√∂ling : https://github.com/jjupiter
        },
        week : {
            dow : 1, // Maandag is die eerste dag van die week.
            doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
        }
    });

    //! moment.js locale configuration
    //! locale : Moroccan Arabic (ar-ma)
    //! author : ElFadili Yassine : https://github.com/ElFadiliY
    //! author : Abdel Said : https://github.com/abdelsaid

    var ar_ma = _moment__default.defineLocale('ar-ma', {
        months : 'ŸäŸÜÿßŸäÿ±_ŸÅÿ®ÿ±ÿßŸäÿ±_ŸÖÿßÿ±ÿ≥_ÿ£ÿ®ÿ±ŸäŸÑ_ŸÖÿßŸä_ŸäŸàŸÜŸäŸà_ŸäŸàŸÑŸäŸàÿ≤_ÿ∫ÿ¥ÿ™_ÿ¥ÿ™ŸÜÿ®ÿ±_ÿ£ŸÉÿ™Ÿàÿ®ÿ±_ŸÜŸàŸÜÿ®ÿ±_ÿØÿ¨ŸÜÿ®ÿ±'.split('_'),
        monthsShort : 'ŸäŸÜÿßŸäÿ±_ŸÅÿ®ÿ±ÿßŸäÿ±_ŸÖÿßÿ±ÿ≥_ÿ£ÿ®ÿ±ŸäŸÑ_ŸÖÿßŸä_ŸäŸàŸÜŸäŸà_ŸäŸàŸÑŸäŸàÿ≤_ÿ∫ÿ¥ÿ™_ÿ¥ÿ™ŸÜÿ®ÿ±_ÿ£ŸÉÿ™Ÿàÿ®ÿ±_ŸÜŸàŸÜÿ®ÿ±_ÿØÿ¨ŸÜÿ®ÿ±'.split('_'),
        weekdays : 'ÿßŸÑÿ£ÿ≠ÿØ_ÿßŸÑÿ•ÿ™ŸÜŸäŸÜ_ÿßŸÑÿ´ŸÑÿßÿ´ÿßÿ°_ÿßŸÑÿ£ÿ±ÿ®ÿπÿßÿ°_ÿßŸÑÿÆŸÖŸäÿ≥_ÿßŸÑÿ¨ŸÖÿπÿ©_ÿßŸÑÿ≥ÿ®ÿ™'.split('_'),
        weekdaysShort : 'ÿßÿ≠ÿØ_ÿßÿ™ŸÜŸäŸÜ_ÿ´ŸÑÿßÿ´ÿßÿ°_ÿßÿ±ÿ®ÿπÿßÿ°_ÿÆŸÖŸäÿ≥_ÿ¨ŸÖÿπÿ©_ÿ≥ÿ®ÿ™'.split('_'),
        weekdaysMin : 'ÿ≠_ŸÜ_ÿ´_ÿ±_ÿÆ_ÿ¨_ÿ≥'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd D MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[ÿßŸÑŸäŸàŸÖ ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT',
            nextDay: '[ÿ∫ÿØÿß ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT',
            nextWeek: 'dddd [ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT',
            lastDay: '[ÿ£ŸÖÿ≥ ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT',
            lastWeek: 'dddd [ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'ŸÅŸä %s',
            past : 'ŸÖŸÜÿ∞ %s',
            s : 'ÿ´ŸàÿßŸÜ',
            m : 'ÿØŸÇŸäŸÇÿ©',
            mm : '%d ÿØŸÇÿßÿ¶ŸÇ',
            h : 'ÿ≥ÿßÿπÿ©',
            hh : '%d ÿ≥ÿßÿπÿßÿ™',
            d : 'ŸäŸàŸÖ',
            dd : '%d ÿ£ŸäÿßŸÖ',
            M : 'ÿ¥Ÿáÿ±',
            MM : '%d ÿ£ÿ¥Ÿáÿ±',
            y : 'ÿ≥ŸÜÿ©',
            yy : '%d ÿ≥ŸÜŸàÿßÿ™'
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Arabic Saudi Arabia (ar-sa)
    //! author : Suhail Alkowaileet : https://github.com/xsoh

    var ar_sa__symbolMap = {
        '1': 'Ÿ°',
        '2': 'Ÿ¢',
        '3': 'Ÿ£',
        '4': 'Ÿ§',
        '5': 'Ÿ•',
        '6': 'Ÿ¶',
        '7': 'Ÿß',
        '8': 'Ÿ®',
        '9': 'Ÿ©',
        '0': 'Ÿ†'
    }, ar_sa__numberMap = {
        'Ÿ°': '1',
        'Ÿ¢': '2',
        'Ÿ£': '3',
        'Ÿ§': '4',
        'Ÿ•': '5',
        'Ÿ¶': '6',
        'Ÿß': '7',
        'Ÿ®': '8',
        'Ÿ©': '9',
        'Ÿ†': '0'
    };

    var ar_sa = _moment__default.defineLocale('ar-sa', {
        months : 'ŸäŸÜÿßŸäÿ±_ŸÅÿ®ÿ±ÿßŸäÿ±_ŸÖÿßÿ±ÿ≥_ÿ£ÿ®ÿ±ŸäŸÑ_ŸÖÿßŸäŸà_ŸäŸàŸÜŸäŸà_ŸäŸàŸÑŸäŸà_ÿ£ÿ∫ÿ≥ÿ∑ÿ≥_ÿ≥ÿ®ÿ™ŸÖÿ®ÿ±_ÿ£ŸÉÿ™Ÿàÿ®ÿ±_ŸÜŸàŸÅŸÖÿ®ÿ±_ÿØŸäÿ≥ŸÖÿ®ÿ±'.split('_'),
        monthsShort : 'ŸäŸÜÿßŸäÿ±_ŸÅÿ®ÿ±ÿßŸäÿ±_ŸÖÿßÿ±ÿ≥_ÿ£ÿ®ÿ±ŸäŸÑ_ŸÖÿßŸäŸà_ŸäŸàŸÜŸäŸà_ŸäŸàŸÑŸäŸà_ÿ£ÿ∫ÿ≥ÿ∑ÿ≥_ÿ≥ÿ®ÿ™ŸÖÿ®ÿ±_ÿ£ŸÉÿ™Ÿàÿ®ÿ±_ŸÜŸàŸÅŸÖÿ®ÿ±_ÿØŸäÿ≥ŸÖÿ®ÿ±'.split('_'),
        weekdays : 'ÿßŸÑÿ£ÿ≠ÿØ_ÿßŸÑÿ•ÿ´ŸÜŸäŸÜ_ÿßŸÑÿ´ŸÑÿßÿ´ÿßÿ°_ÿßŸÑÿ£ÿ±ÿ®ÿπÿßÿ°_ÿßŸÑÿÆŸÖŸäÿ≥_ÿßŸÑÿ¨ŸÖÿπÿ©_ÿßŸÑÿ≥ÿ®ÿ™'.split('_'),
        weekdaysShort : 'ÿ£ÿ≠ÿØ_ÿ•ÿ´ŸÜŸäŸÜ_ÿ´ŸÑÿßÿ´ÿßÿ°_ÿ£ÿ±ÿ®ÿπÿßÿ°_ÿÆŸÖŸäÿ≥_ÿ¨ŸÖÿπÿ©_ÿ≥ÿ®ÿ™'.split('_'),
        weekdaysMin : 'ÿ≠_ŸÜ_ÿ´_ÿ±_ÿÆ_ÿ¨_ÿ≥'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd D MMMM YYYY LT'
        },
        meridiemParse: /ÿµ|ŸÖ/,
        isPM : function (input) {
            return 'ŸÖ' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ÿµ';
            } else {
                return 'ŸÖ';
            }
        },
        calendar : {
            sameDay: '[ÿßŸÑŸäŸàŸÖ ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT',
            nextDay: '[ÿ∫ÿØÿß ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT',
            nextWeek: 'dddd [ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT',
            lastDay: '[ÿ£ŸÖÿ≥ ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT',
            lastWeek: 'dddd [ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'ŸÅŸä %s',
            past : 'ŸÖŸÜÿ∞ %s',
            s : 'ÿ´ŸàÿßŸÜ',
            m : 'ÿØŸÇŸäŸÇÿ©',
            mm : '%d ÿØŸÇÿßÿ¶ŸÇ',
            h : 'ÿ≥ÿßÿπÿ©',
            hh : '%d ÿ≥ÿßÿπÿßÿ™',
            d : 'ŸäŸàŸÖ',
            dd : '%d ÿ£ŸäÿßŸÖ',
            M : 'ÿ¥Ÿáÿ±',
            MM : '%d ÿ£ÿ¥Ÿáÿ±',
            y : 'ÿ≥ŸÜÿ©',
            yy : '%d ÿ≥ŸÜŸàÿßÿ™'
        },
        preparse: function (string) {
            return string.replace(/[Ÿ°Ÿ¢Ÿ£Ÿ§Ÿ•Ÿ¶ŸßŸ®Ÿ©Ÿ†]/g, function (match) {
                return ar_sa__numberMap[match];
            }).replace(/ÿå/g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return ar_sa__symbolMap[match];
            }).replace(/,/g, 'ÿå');
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale  : Tunisian Arabic (ar-tn)

    var ar_tn = _moment__default.defineLocale('ar-tn', {
        months: 'ÿ¨ÿßŸÜŸÅŸä_ŸÅŸäŸÅÿ±Ÿä_ŸÖÿßÿ±ÿ≥_ÿ£ŸÅÿ±ŸäŸÑ_ŸÖÿßŸä_ÿ¨ŸàÿßŸÜ_ÿ¨ŸàŸäŸÑŸäÿ©_ÿ£Ÿàÿ™_ÿ≥ÿ®ÿ™ŸÖÿ®ÿ±_ÿ£ŸÉÿ™Ÿàÿ®ÿ±_ŸÜŸàŸÅŸÖÿ®ÿ±_ÿØŸäÿ≥ŸÖÿ®ÿ±'.split('_'),
        monthsShort: 'ÿ¨ÿßŸÜŸÅŸä_ŸÅŸäŸÅÿ±Ÿä_ŸÖÿßÿ±ÿ≥_ÿ£ŸÅÿ±ŸäŸÑ_ŸÖÿßŸä_ÿ¨ŸàÿßŸÜ_ÿ¨ŸàŸäŸÑŸäÿ©_ÿ£Ÿàÿ™_ÿ≥ÿ®ÿ™ŸÖÿ®ÿ±_ÿ£ŸÉÿ™Ÿàÿ®ÿ±_ŸÜŸàŸÅŸÖÿ®ÿ±_ÿØŸäÿ≥ŸÖÿ®ÿ±'.split('_'),
        weekdays: 'ÿßŸÑÿ£ÿ≠ÿØ_ÿßŸÑÿ•ÿ´ŸÜŸäŸÜ_ÿßŸÑÿ´ŸÑÿßÿ´ÿßÿ°_ÿßŸÑÿ£ÿ±ÿ®ÿπÿßÿ°_ÿßŸÑÿÆŸÖŸäÿ≥_ÿßŸÑÿ¨ŸÖÿπÿ©_ÿßŸÑÿ≥ÿ®ÿ™'.split('_'),
        weekdaysShort: 'ÿ£ÿ≠ÿØ_ÿ•ÿ´ŸÜŸäŸÜ_ÿ´ŸÑÿßÿ´ÿßÿ°_ÿ£ÿ±ÿ®ÿπÿßÿ°_ÿÆŸÖŸäÿ≥_ÿ¨ŸÖÿπÿ©_ÿ≥ÿ®ÿ™'.split('_'),
        weekdaysMin: 'ÿ≠_ŸÜ_ÿ´_ÿ±_ÿÆ_ÿ¨_ÿ≥'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'LT:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY LT',
            LLLL: 'dddd D MMMM YYYY LT'
        },
        calendar: {
            sameDay: '[ÿßŸÑŸäŸàŸÖ ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT',
            nextDay: '[ÿ∫ÿØÿß ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT',
            nextWeek: 'dddd [ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT',
            lastDay: '[ÿ£ŸÖÿ≥ ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT',
            lastWeek: 'dddd [ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'ŸÅŸä %s',
            past: 'ŸÖŸÜÿ∞ %s',
            s: 'ÿ´ŸàÿßŸÜ',
            m: 'ÿØŸÇŸäŸÇÿ©',
            mm: '%d ÿØŸÇÿßÿ¶ŸÇ',
            h: 'ÿ≥ÿßÿπÿ©',
            hh: '%d ÿ≥ÿßÿπÿßÿ™',
            d: 'ŸäŸàŸÖ',
            dd: '%d ÿ£ŸäÿßŸÖ',
            M: 'ÿ¥Ÿáÿ±',
            MM: '%d ÿ£ÿ¥Ÿáÿ±',
            y: 'ÿ≥ŸÜÿ©',
            yy: '%d ÿ≥ŸÜŸàÿßÿ™'
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! Locale: Arabic (ar)
    //! Author: Abdel Said: https://github.com/abdelsaid
    //! Changes in months, weekdays: Ahmed Elkhatib
    //! Native plural forms: forabi https://github.com/forabi

    var ar__symbolMap = {
        '1': 'Ÿ°',
        '2': 'Ÿ¢',
        '3': 'Ÿ£',
        '4': 'Ÿ§',
        '5': 'Ÿ•',
        '6': 'Ÿ¶',
        '7': 'Ÿß',
        '8': 'Ÿ®',
        '9': 'Ÿ©',
        '0': 'Ÿ†'
    }, ar__numberMap = {
        'Ÿ°': '1',
        'Ÿ¢': '2',
        'Ÿ£': '3',
        'Ÿ§': '4',
        'Ÿ•': '5',
        'Ÿ¶': '6',
        'Ÿß': '7',
        'Ÿ®': '8',
        'Ÿ©': '9',
        'Ÿ†': '0'
    }, pluralForm = function (n) {
        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    }, plurals = {
        s : ['ÿ£ŸÇŸÑ ŸÖŸÜ ÿ´ÿßŸÜŸäÿ©', 'ÿ´ÿßŸÜŸäÿ© Ÿàÿßÿ≠ÿØÿ©', ['ÿ´ÿßŸÜŸäÿ™ÿßŸÜ', 'ÿ´ÿßŸÜŸäÿ™ŸäŸÜ'], '%d ÿ´ŸàÿßŸÜ', '%d ÿ´ÿßŸÜŸäÿ©', '%d ÿ´ÿßŸÜŸäÿ©'],
        m : ['ÿ£ŸÇŸÑ ŸÖŸÜ ÿØŸÇŸäŸÇÿ©', 'ÿØŸÇŸäŸÇÿ© Ÿàÿßÿ≠ÿØÿ©', ['ÿØŸÇŸäŸÇÿ™ÿßŸÜ', 'ÿØŸÇŸäŸÇÿ™ŸäŸÜ'], '%d ÿØŸÇÿßÿ¶ŸÇ', '%d ÿØŸÇŸäŸÇÿ©', '%d ÿØŸÇŸäŸÇÿ©'],
        h : ['ÿ£ŸÇŸÑ ŸÖŸÜ ÿ≥ÿßÿπÿ©', 'ÿ≥ÿßÿπÿ© Ÿàÿßÿ≠ÿØÿ©', ['ÿ≥ÿßÿπÿ™ÿßŸÜ', 'ÿ≥ÿßÿπÿ™ŸäŸÜ'], '%d ÿ≥ÿßÿπÿßÿ™', '%d ÿ≥ÿßÿπÿ©', '%d ÿ≥ÿßÿπÿ©'],
        d : ['ÿ£ŸÇŸÑ ŸÖŸÜ ŸäŸàŸÖ', 'ŸäŸàŸÖ Ÿàÿßÿ≠ÿØ', ['ŸäŸàŸÖÿßŸÜ', 'ŸäŸàŸÖŸäŸÜ'], '%d ÿ£ŸäÿßŸÖ', '%d ŸäŸàŸÖŸãÿß', '%d ŸäŸàŸÖ'],
        M : ['ÿ£ŸÇŸÑ ŸÖŸÜ ÿ¥Ÿáÿ±', 'ÿ¥Ÿáÿ± Ÿàÿßÿ≠ÿØ', ['ÿ¥Ÿáÿ±ÿßŸÜ', 'ÿ¥Ÿáÿ±ŸäŸÜ'], '%d ÿ£ÿ¥Ÿáÿ±', '%d ÿ¥Ÿáÿ±ÿß', '%d ÿ¥Ÿáÿ±'],
        y : ['ÿ£ŸÇŸÑ ŸÖŸÜ ÿπÿßŸÖ', 'ÿπÿßŸÖ Ÿàÿßÿ≠ÿØ', ['ÿπÿßŸÖÿßŸÜ', 'ÿπÿßŸÖŸäŸÜ'], '%d ÿ£ÿπŸàÿßŸÖ', '%d ÿπÿßŸÖŸãÿß', '%d ÿπÿßŸÖ']
    }, pluralize = function (u) {
        return function (number, withoutSuffix, string, isFuture) {
            var f = pluralForm(number),
                str = plurals[u][pluralForm(number)];
            if (f === 2) {
                str = str[withoutSuffix ? 0 : 1];
            }
            return str.replace(/%d/i, number);
        };
    }, ar__months = [
        'ŸÉÿßŸÜŸàŸÜ ÿßŸÑÿ´ÿßŸÜŸä ŸäŸÜÿßŸäÿ±',
        'ÿ¥ÿ®ÿßÿ∑ ŸÅÿ®ÿ±ÿßŸäÿ±',
        'ÿ¢ÿ∞ÿßÿ± ŸÖÿßÿ±ÿ≥',
        'ŸÜŸäÿ≥ÿßŸÜ ÿ£ÿ®ÿ±ŸäŸÑ',
        'ÿ£Ÿäÿßÿ± ŸÖÿßŸäŸà',
        'ÿ≠ÿ≤Ÿäÿ±ÿßŸÜ ŸäŸàŸÜŸäŸà',
        'ÿ™ŸÖŸàÿ≤ ŸäŸàŸÑŸäŸà',
        'ÿ¢ÿ® ÿ£ÿ∫ÿ≥ÿ∑ÿ≥',
        'ÿ£ŸäŸÑŸàŸÑ ÿ≥ÿ®ÿ™ŸÖÿ®ÿ±',
        'ÿ™ÿ¥ÿ±ŸäŸÜ ÿßŸÑÿ£ŸàŸÑ ÿ£ŸÉÿ™Ÿàÿ®ÿ±',
        'ÿ™ÿ¥ÿ±ŸäŸÜ ÿßŸÑÿ´ÿßŸÜŸä ŸÜŸàŸÅŸÖÿ®ÿ±',
        'ŸÉÿßŸÜŸàŸÜ ÿßŸÑÿ£ŸàŸÑ ÿØŸäÿ≥ŸÖÿ®ÿ±'
    ];

    var ar = _moment__default.defineLocale('ar', {
        months : ar__months,
        monthsShort : ar__months,
        weekdays : 'ÿßŸÑÿ£ÿ≠ÿØ_ÿßŸÑÿ•ÿ´ŸÜŸäŸÜ_ÿßŸÑÿ´ŸÑÿßÿ´ÿßÿ°_ÿßŸÑÿ£ÿ±ÿ®ÿπÿßÿ°_ÿßŸÑÿÆŸÖŸäÿ≥_ÿßŸÑÿ¨ŸÖÿπÿ©_ÿßŸÑÿ≥ÿ®ÿ™'.split('_'),
        weekdaysShort : 'ÿ£ÿ≠ÿØ_ÿ•ÿ´ŸÜŸäŸÜ_ÿ´ŸÑÿßÿ´ÿßÿ°_ÿ£ÿ±ÿ®ÿπÿßÿ°_ÿÆŸÖŸäÿ≥_ÿ¨ŸÖÿπÿ©_ÿ≥ÿ®ÿ™'.split('_'),
        weekdaysMin : 'ÿ≠_ŸÜ_ÿ´_ÿ±_ÿÆ_ÿ¨_ÿ≥'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'D/\u200FM/\u200FYYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd D MMMM YYYY LT'
        },
        meridiemParse: /ÿµ|ŸÖ/,
        isPM : function (input) {
            return 'ŸÖ' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ÿµ';
            } else {
                return 'ŸÖ';
            }
        },
        calendar : {
            sameDay: '[ÿßŸÑŸäŸàŸÖ ÿπŸÜÿØ ÿßŸÑÿ≥ÿßÿπÿ©] LT',
            nextDay: '[ÿ∫ÿØŸãÿß ÿπŸÜÿØ ÿßŸÑÿ≥ÿßÿπÿ©] LT',
            nextWeek: 'dddd [ÿπŸÜÿØ ÿßŸÑÿ≥ÿßÿπÿ©] LT',
            lastDay: '[ÿ£ŸÖÿ≥ ÿπŸÜÿØ ÿßŸÑÿ≥ÿßÿπÿ©] LT',
            lastWeek: 'dddd [ÿπŸÜÿØ ÿßŸÑÿ≥ÿßÿπÿ©] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'ÿ®ÿπÿØ %s',
            past : 'ŸÖŸÜÿ∞ %s',
            s : pluralize('s'),
            m : pluralize('m'),
            mm : pluralize('m'),
            h : pluralize('h'),
            hh : pluralize('h'),
            d : pluralize('d'),
            dd : pluralize('d'),
            M : pluralize('M'),
            MM : pluralize('M'),
            y : pluralize('y'),
            yy : pluralize('y')
        },
        preparse: function (string) {
            return string.replace(/\u200f/g, '').replace(/[Ÿ°Ÿ¢Ÿ£Ÿ§Ÿ•Ÿ¶ŸßŸ®Ÿ©Ÿ†]/g, function (match) {
                return ar__numberMap[match];
            }).replace(/ÿå/g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return ar__symbolMap[match];
            }).replace(/,/g, 'ÿå');
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : azerbaijani (az)
    //! author : topchiyev : https://github.com/topchiyev

    var az__suffixes = {
        1: '-inci',
        5: '-inci',
        8: '-inci',
        70: '-inci',
        80: '-inci',
        2: '-nci',
        7: '-nci',
        20: '-nci',
        50: '-nci',
        3: '-√ºnc√º',
        4: '-√ºnc√º',
        100: '-√ºnc√º',
        6: '-ncƒ±',
        9: '-uncu',
        10: '-uncu',
        30: '-uncu',
        60: '-ƒ±ncƒ±',
        90: '-ƒ±ncƒ±'
    };

    var az = _moment__default.defineLocale('az', {
        months : 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
        monthsShort : 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
        weekdays : 'Bazar_Bazar ert…ôsi_√á…ôr≈ü…ônb…ô ax≈üamƒ±_√á…ôr≈ü…ônb…ô_C√ºm…ô ax≈üamƒ±_C√ºm…ô_≈û…ônb…ô'.split('_'),
        weekdaysShort : 'Baz_BzE_√áAx_√á…ôr_CAx_C√ºm_≈û…ôn'.split('_'),
        weekdaysMin : 'Bz_BE_√áA_√á…ô_CA_C√º_≈û…ô'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd, D MMMM YYYY LT'
        },
        calendar : {
            sameDay : '[bug√ºn saat] LT',
            nextDay : '[sabah saat] LT',
            nextWeek : '[g…ôl…ôn h…ôft…ô] dddd [saat] LT',
            lastDay : '[d√ºn…ôn] LT',
            lastWeek : '[ke√ß…ôn h…ôft…ô] dddd [saat] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s sonra',
            past : '%s …ôvv…ôl',
            s : 'birne√ß…ô saniyy…ô',
            m : 'bir d…ôqiq…ô',
            mm : '%d d…ôqiq…ô',
            h : 'bir saat',
            hh : '%d saat',
            d : 'bir g√ºn',
            dd : '%d g√ºn',
            M : 'bir ay',
            MM : '%d ay',
            y : 'bir il',
            yy : '%d il'
        },
        meridiemParse: /gec…ô|s…ôh…ôr|g√ºnd√ºz|ax≈üam/,
        isPM : function (input) {
            return /^(g√ºnd√ºz|ax≈üam)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'gec…ô';
            } else if (hour < 12) {
                return 's…ôh…ôr';
            } else if (hour < 17) {
                return 'g√ºnd√ºz';
            } else {
                return 'ax≈üam';
            }
        },
        ordinalParse: /\d{1,2}-(ƒ±ncƒ±|inci|nci|√ºnc√º|ncƒ±|uncu)/,
        ordinal : function (number) {
            if (number === 0) {  // special case for zero
                return number + '-ƒ±ncƒ±';
            }
            var a = number % 10,
                b = number % 100 - a,
                c = number >= 100 ? 100 : null;
            return number + (az__suffixes[a] || az__suffixes[b] || az__suffixes[c]);
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : belarusian (be)
    //! author : Dmitry Demidov : https://github.com/demidov91
    //! author: Praleska: http://praleska.pro/
    //! Author : Menelion Elens√∫le : https://github.com/Oire

    function be__plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
    }
    function be__relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'mm': withoutSuffix ? '—Ö–≤—ñ–ª—ñ–Ω–∞_—Ö–≤—ñ–ª—ñ–Ω—ã_—Ö–≤—ñ–ª—ñ–Ω' : '—Ö–≤—ñ–ª—ñ–Ω—É_—Ö–≤—ñ–ª—ñ–Ω—ã_—Ö–≤—ñ–ª—ñ–Ω',
            'hh': withoutSuffix ? '–≥–∞–¥–∑—ñ–Ω–∞_–≥–∞–¥–∑—ñ–Ω—ã_–≥–∞–¥–∑—ñ–Ω' : '–≥–∞–¥–∑—ñ–Ω—É_–≥–∞–¥–∑—ñ–Ω—ã_–≥–∞–¥–∑—ñ–Ω',
            'dd': '–¥–∑–µ–Ω—å_–¥–Ω—ñ_–¥–∑—ë–Ω',
            'MM': '–º–µ—Å—è—Ü_–º–µ—Å—è—Ü—ã_–º–µ—Å—è—Ü–∞—û',
            'yy': '–≥–æ–¥_–≥–∞–¥—ã_–≥–∞–¥–æ—û'
        };
        if (key === 'm') {
            return withoutSuffix ? '—Ö–≤—ñ–ª—ñ–Ω–∞' : '—Ö–≤—ñ–ª—ñ–Ω—É';
        }
        else if (key === 'h') {
            return withoutSuffix ? '–≥–∞–¥–∑—ñ–Ω–∞' : '–≥–∞–¥–∑—ñ–Ω—É';
        }
        else {
            return number + ' ' + be__plural(format[key], +number);
        }
    }
    function be__monthsCaseReplace(m, format) {
        var months = {
            'nominative': '—Å—Ç—É–¥–∑–µ–Ω—å_–ª—é—Ç—ã_—Å–∞–∫–∞–≤—ñ–∫_–∫—Ä–∞—Å–∞–≤—ñ–∫_—Ç—Ä–∞–≤–µ–Ω—å_—á—ç—Ä–≤–µ–Ω—å_–ª—ñ–ø–µ–Ω—å_–∂–Ω—ñ–≤–µ–Ω—å_–≤–µ—Ä–∞—Å–µ–Ω—å_–∫–∞—Å—Ç—Ä—ã—á–Ω—ñ–∫_–ª—ñ—Å—Ç–∞–ø–∞–¥_—Å–Ω–µ–∂–∞–Ω—å'.split('_'),
            'accusative': '—Å—Ç—É–¥–∑–µ–Ω—è_–ª—é—Ç–∞–≥–∞_—Å–∞–∫–∞–≤—ñ–∫–∞_–∫—Ä–∞—Å–∞–≤—ñ–∫–∞_—Ç—Ä–∞—û–Ω—è_—á—ç—Ä–≤–µ–Ω—è_–ª—ñ–ø–µ–Ω—è_–∂–Ω—ñ—û–Ω—è_–≤–µ—Ä–∞—Å–Ω—è_–∫–∞—Å—Ç—Ä—ã—á–Ω—ñ–∫–∞_–ª—ñ—Å—Ç–∞–ø–∞–¥–∞_—Å–Ω–µ–∂–Ω—è'.split('_')
        },
        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
            'accusative' :
            'nominative';
        return months[nounCase][m.month()];
    }
    function be__weekdaysCaseReplace(m, format) {
        var weekdays = {
            'nominative': '–Ω—è–¥–∑–µ–ª—è_–ø–∞–Ω—è–¥–∑–µ–ª–∞–∫_–∞—û—Ç–æ—Ä–∞–∫_—Å–µ—Ä–∞–¥–∞_—á–∞—Ü–≤–µ—Ä_–ø—è—Ç–Ω—ñ—Ü–∞_—Å—É–±–æ—Ç–∞'.split('_'),
            'accusative': '–Ω—è–¥–∑–µ–ª—é_–ø–∞–Ω—è–¥–∑–µ–ª–∞–∫_–∞—û—Ç–æ—Ä–∞–∫_—Å–µ—Ä–∞–¥—É_—á–∞—Ü–≤–µ—Ä_–ø—è—Ç–Ω—ñ—Ü—É_—Å—É–±–æ—Ç—É'.split('_')
        },
        nounCase = (/\[ ?[–í–≤] ?(?:–º—ñ–Ω—É–ª—É—é|–Ω–∞—Å—Ç—É–ø–Ω—É—é)? ?\] ?dddd/).test(format) ?
            'accusative' :
            'nominative';
        return weekdays[nounCase][m.day()];
    }

    var be = _moment__default.defineLocale('be', {
        months : be__monthsCaseReplace,
        monthsShort : '—Å—Ç—É–¥_–ª—é—Ç_—Å–∞–∫_–∫—Ä–∞—Å_—Ç—Ä–∞–≤_—á—ç—Ä–≤_–ª—ñ–ø_–∂–Ω—ñ–≤_–≤–µ—Ä_–∫–∞—Å—Ç_–ª—ñ—Å—Ç_—Å–Ω–µ–∂'.split('_'),
        weekdays : be__weekdaysCaseReplace,
        weekdaysShort : '–Ω–¥_–ø–Ω_–∞—Ç_—Å—Ä_—á—Ü_–ø—Ç_—Å–±'.split('_'),
        weekdaysMin : '–Ω–¥_–ø–Ω_–∞—Ç_—Å—Ä_—á—Ü_–ø—Ç_—Å–±'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY –≥.',
            LLL : 'D MMMM YYYY –≥., LT',
            LLLL : 'dddd, D MMMM YYYY –≥., LT'
        },
        calendar : {
            sameDay: '[–°—ë–Ω–Ω—è —û] LT',
            nextDay: '[–ó–∞—û—Ç—Ä–∞ —û] LT',
            lastDay: '[–£—á–æ—Ä–∞ —û] LT',
            nextWeek: function () {
                return '[–£] dddd [—û] LT';
            },
            lastWeek: function () {
                switch (this.day()) {
                case 0:
                case 3:
                case 5:
                case 6:
                    return '[–£ –º—ñ–Ω—É–ª—É—é] dddd [—û] LT';
                case 1:
                case 2:
                case 4:
                    return '[–£ –º—ñ–Ω—É–ª—ã] dddd [—û] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : '–ø—Ä–∞–∑ %s',
            past : '%s —Ç–∞–º—É',
            s : '–Ω–µ–∫–∞–ª—å–∫—ñ —Å–µ–∫—É–Ω–¥',
            m : be__relativeTimeWithPlural,
            mm : be__relativeTimeWithPlural,
            h : be__relativeTimeWithPlural,
            hh : be__relativeTimeWithPlural,
            d : '–¥–∑–µ–Ω—å',
            dd : be__relativeTimeWithPlural,
            M : '–º–µ—Å—è—Ü',
            MM : be__relativeTimeWithPlural,
            y : '–≥–æ–¥',
            yy : be__relativeTimeWithPlural
        },
        meridiemParse: /–Ω–æ—á—ã|—Ä–∞–Ω—ñ—Ü—ã|–¥–Ω—è|–≤–µ—á–∞—Ä–∞/,
        isPM : function (input) {
            return /^(–¥–Ω—è|–≤–µ—á–∞—Ä–∞)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '–Ω–æ—á—ã';
            } else if (hour < 12) {
                return '—Ä–∞–Ω—ñ—Ü—ã';
            } else if (hour < 17) {
                return '–¥–Ω—è';
            } else {
                return '–≤–µ—á–∞—Ä–∞';
            }
        },
        ordinalParse: /\d{1,2}-(—ñ|—ã|–≥–∞)/,
        ordinal: function (number, period) {
            switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
            case 'w':
            case 'W':
                return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-—ñ' : number + '-—ã';
            case 'D':
                return number + '-–≥–∞';
            default:
                return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : bulgarian (bg)
    //! author : Krasen Borisov : https://github.com/kraz

    var bg = _moment__default.defineLocale('bg', {
        months : '—è–Ω—É–∞—Ä–∏_—Ñ–µ–≤—Ä—É–∞—Ä–∏_–º–∞—Ä—Ç_–∞–ø—Ä–∏–ª_–º–∞–π_—é–Ω–∏_—é–ª–∏_–∞–≤–≥—É—Å—Ç_—Å–µ–ø—Ç–µ–º–≤—Ä–∏_–æ–∫—Ç–æ–º–≤—Ä–∏_–Ω–æ–µ–º–≤—Ä–∏_–¥–µ–∫–µ–º–≤—Ä–∏'.split('_'),
        monthsShort : '—è–Ω—Ä_—Ñ–µ–≤_–º–∞—Ä_–∞–ø—Ä_–º–∞–π_—é–Ω–∏_—é–ª–∏_–∞–≤–≥_—Å–µ–ø_–æ–∫—Ç_–Ω–æ–µ_–¥–µ–∫'.split('_'),
        weekdays : '–Ω–µ–¥–µ–ª—è_–ø–æ–Ω–µ–¥–µ–ª–Ω–∏–∫_–≤—Ç–æ—Ä–Ω–∏–∫_—Å—Ä—è–¥–∞_—á–µ—Ç–≤—ä—Ä—Ç—ä–∫_–ø–µ—Ç—ä–∫_—Å—ä–±–æ—Ç–∞'.split('_'),
        weekdaysShort : '–Ω–µ–¥_–ø–æ–Ω_–≤—Ç–æ_—Å—Ä—è_—á–µ—Ç_–ø–µ—Ç_—Å—ä–±'.split('_'),
        weekdaysMin : '–Ω–¥_–ø–Ω_–≤—Ç_—Å—Ä_—á—Ç_–ø—Ç_—Å–±'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'LT:ss',
            L : 'D.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd, D MMMM YYYY LT'
        },
        calendar : {
            sameDay : '[–î–Ω–µ—Å –≤] LT',
            nextDay : '[–£—Ç—Ä–µ –≤] LT',
            nextWeek : 'dddd [–≤] LT',
            lastDay : '[–í—á–µ—Ä–∞ –≤] LT',
            lastWeek : function () {
                switch (this.day()) {
                case 0:
                case 3:
                case 6:
                    return '[–í –∏–∑–º–∏–Ω–∞–ª–∞—Ç–∞] dddd [–≤] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[–í –∏–∑–º–∏–Ω–∞–ª–∏—è] dddd [–≤] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : '—Å–ª–µ–¥ %s',
            past : '–ø—Ä–µ–¥–∏ %s',
            s : '–Ω—è–∫–æ–ª–∫–æ —Å–µ–∫—É–Ω–¥–∏',
            m : '–º–∏–Ω—É—Ç–∞',
            mm : '%d –º–∏–Ω—É—Ç–∏',
            h : '—á–∞—Å',
            hh : '%d —á–∞—Å–∞',
            d : '–¥–µ–Ω',
            dd : '%d –¥–Ω–∏',
            M : '–º–µ—Å–µ—Ü',
            MM : '%d –º–µ—Å–µ—Ü–∞',
            y : '–≥–æ–¥–∏–Ω–∞',
            yy : '%d –≥–æ–¥–∏–Ω–∏'
        },
        ordinalParse: /\d{1,2}-(–µ–≤|–µ–Ω|—Ç–∏|–≤–∏|—Ä–∏|–º–∏)/,
        ordinal : function (number) {
            var lastDigit = number % 10,
                last2Digits = number % 100;
            if (number === 0) {
                return number + '-–µ–≤';
            } else if (last2Digits === 0) {
                return number + '-–µ–Ω';
            } else if (last2Digits > 10 && last2Digits < 20) {
                return number + '-—Ç–∏';
            } else if (lastDigit === 1) {
                return number + '-–≤–∏';
            } else if (lastDigit === 2) {
                return number + '-—Ä–∏';
            } else if (lastDigit === 7 || lastDigit === 8) {
                return number + '-–º–∏';
            } else {
                return number + '-—Ç–∏';
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Bengali (bn)
    //! author : Kaushik Gandhi : https://github.com/kaushikgandhi

    var bn__symbolMap = {
        '1': '‡ßß',
        '2': '‡ß®',
        '3': '‡ß©',
        '4': '‡ß™',
        '5': '‡ß´',
        '6': '‡ß¨',
        '7': '‡ß≠',
        '8': '‡ßÆ',
        '9': '‡ßØ',
        '0': '‡ß¶'
    },
    bn__numberMap = {
        '‡ßß': '1',
        '‡ß®': '2',
        '‡ß©': '3',
        '‡ß™': '4',
        '‡ß´': '5',
        '‡ß¨': '6',
        '‡ß≠': '7',
        '‡ßÆ': '8',
        '‡ßØ': '9',
        '‡ß¶': '0'
    };

    var bn = _moment__default.defineLocale('bn', {
        months : '‡¶ú‡¶æ‡¶®‡ßÅ‡ßü‡¶æ‡¶∞‡ßÄ_‡¶´‡ßá‡¶¨‡ßÅ‡ßü‡¶æ‡¶∞‡ßÄ_‡¶Æ‡¶æ‡¶∞‡ßç‡¶ö_‡¶è‡¶™‡ßç‡¶∞‡¶ø‡¶≤_‡¶Æ‡ßá_‡¶ú‡ßÅ‡¶®_‡¶ú‡ßÅ‡¶≤‡¶æ‡¶á_‡¶Ö‡¶ó‡¶æ‡¶∏‡ßç‡¶ü_‡¶∏‡ßá‡¶™‡ßç‡¶ü‡ßá‡¶Æ‡ßç‡¶¨‡¶∞_‡¶Ö‡¶ï‡ßç‡¶ü‡ßã‡¶¨‡¶∞_‡¶®‡¶≠‡ßá‡¶Æ‡ßç‡¶¨‡¶∞_‡¶°‡¶ø‡¶∏‡ßá‡¶Æ‡ßç‡¶¨‡¶∞'.split('_'),
        monthsShort : '‡¶ú‡¶æ‡¶®‡ßÅ_‡¶´‡ßá‡¶¨_‡¶Æ‡¶æ‡¶∞‡ßç‡¶ö_‡¶è‡¶™‡¶∞_‡¶Æ‡ßá_‡¶ú‡ßÅ‡¶®_‡¶ú‡ßÅ‡¶≤_‡¶Ö‡¶ó_‡¶∏‡ßá‡¶™‡ßç‡¶ü_‡¶Ö‡¶ï‡ßç‡¶ü‡ßã_‡¶®‡¶≠_‡¶°‡¶ø‡¶∏‡ßá‡¶Æ‡ßç'.split('_'),
        weekdays : '‡¶∞‡¶¨‡¶ø‡¶¨‡¶æ‡¶∞_‡¶∏‡ßã‡¶Æ‡¶¨‡¶æ‡¶∞_‡¶Æ‡¶ô‡ßç‡¶ó‡¶≤‡¶¨‡¶æ‡¶∞_‡¶¨‡ßÅ‡¶ß‡¶¨‡¶æ‡¶∞_‡¶¨‡ßÉ‡¶π‡¶∏‡ßç‡¶™‡¶§‡ßç‡¶§‡¶ø‡¶¨‡¶æ‡¶∞_‡¶∂‡ßÅ‡¶ï‡ßç‡¶∞‡ßÅ‡¶¨‡¶æ‡¶∞_‡¶∂‡¶®‡¶ø‡¶¨‡¶æ‡¶∞'.split('_'),
        weekdaysShort : '‡¶∞‡¶¨‡¶ø_‡¶∏‡ßã‡¶Æ_‡¶Æ‡¶ô‡ßç‡¶ó‡¶≤_‡¶¨‡ßÅ‡¶ß_‡¶¨‡ßÉ‡¶π‡¶∏‡ßç‡¶™‡¶§‡ßç‡¶§‡¶ø_‡¶∂‡ßÅ‡¶ï‡ßç‡¶∞‡ßÅ_‡¶∂‡¶®‡¶ø'.split('_'),
        weekdaysMin : '‡¶∞‡¶¨_‡¶∏‡¶Æ_‡¶Æ‡¶ô‡ßç‡¶ó_‡¶¨‡ßÅ_‡¶¨‡ßç‡¶∞‡¶ø‡¶π_‡¶∂‡ßÅ_‡¶∂‡¶®‡¶ø'.split('_'),
        longDateFormat : {
            LT : 'A h:mm ‡¶∏‡¶Æ‡ßü',
            LTS : 'A h:mm:ss ‡¶∏‡¶Æ‡ßü',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, LT',
            LLLL : 'dddd, D MMMM YYYY, LT'
        },
        calendar : {
            sameDay : '[‡¶Ü‡¶ú] LT',
            nextDay : '[‡¶Ü‡¶ó‡¶æ‡¶Æ‡ßÄ‡¶ï‡¶æ‡¶≤] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[‡¶ó‡¶§‡¶ï‡¶æ‡¶≤] LT',
            lastWeek : '[‡¶ó‡¶§] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ‡¶™‡¶∞‡ßá',
            past : '%s ‡¶Ü‡¶ó‡ßá',
            s : '‡¶ï‡¶è‡¶ï ‡¶∏‡ßá‡¶ï‡ßá‡¶®‡ßç‡¶°',
            m : '‡¶è‡¶ï ‡¶Æ‡¶ø‡¶®‡¶ø‡¶ü',
            mm : '%d ‡¶Æ‡¶ø‡¶®‡¶ø‡¶ü',
            h : '‡¶è‡¶ï ‡¶ò‡¶®‡ßç‡¶ü‡¶æ',
            hh : '%d ‡¶ò‡¶®‡ßç‡¶ü‡¶æ',
            d : '‡¶è‡¶ï ‡¶¶‡¶ø‡¶®',
            dd : '%d ‡¶¶‡¶ø‡¶®',
            M : '‡¶è‡¶ï ‡¶Æ‡¶æ‡¶∏',
            MM : '%d ‡¶Æ‡¶æ‡¶∏',
            y : '‡¶è‡¶ï ‡¶¨‡¶õ‡¶∞',
            yy : '%d ‡¶¨‡¶õ‡¶∞'
        },
        preparse: function (string) {
            return string.replace(/[‡ßß‡ß®‡ß©‡ß™‡ß´‡ß¨‡ß≠‡ßÆ‡ßØ‡ß¶]/g, function (match) {
                return bn__numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return bn__symbolMap[match];
            });
        },
        meridiemParse: /‡¶∞‡¶æ‡¶§|‡¶∂‡¶ï‡¶æ‡¶≤|‡¶¶‡ßÅ‡¶™‡ßÅ‡¶∞|‡¶¨‡¶ø‡¶ï‡ßá‡¶≤|‡¶∞‡¶æ‡¶§/,
        isPM: function (input) {
            return /^(‡¶¶‡ßÅ‡¶™‡ßÅ‡¶∞|‡¶¨‡¶ø‡¶ï‡ßá‡¶≤|‡¶∞‡¶æ‡¶§)$/.test(input);
        },
        //Bengali is a vast language its spoken
        //in different forms in various parts of the world.
        //I have just generalized with most common one used
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '‡¶∞‡¶æ‡¶§';
            } else if (hour < 10) {
                return '‡¶∂‡¶ï‡¶æ‡¶≤';
            } else if (hour < 17) {
                return '‡¶¶‡ßÅ‡¶™‡ßÅ‡¶∞';
            } else if (hour < 20) {
                return '‡¶¨‡¶ø‡¶ï‡ßá‡¶≤';
            } else {
                return '‡¶∞‡¶æ‡¶§';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : tibetan (bo)
    //! author : Thupten N. Chakrishar : https://github.com/vajradog

    var bo__symbolMap = {
        '1': '‡º°',
        '2': '‡º¢',
        '3': '‡º£',
        '4': '‡º§',
        '5': '‡º•',
        '6': '‡º¶',
        '7': '‡ºß',
        '8': '‡º®',
        '9': '‡º©',
        '0': '‡º†'
    },
    bo__numberMap = {
        '‡º°': '1',
        '‡º¢': '2',
        '‡º£': '3',
        '‡º§': '4',
        '‡º•': '5',
        '‡º¶': '6',
        '‡ºß': '7',
        '‡º®': '8',
        '‡º©': '9',
        '‡º†': '0'
    };

    var bo = _moment__default.defineLocale('bo', {
        months : '‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωë‡ΩÑ‡ºã‡Ωî‡Ωº_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡ΩÇ‡Ωâ‡Ω≤‡Ω¶‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡ΩÇ‡Ω¶‡Ω¥‡Ωò‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡Ωû‡Ω≤‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ω£‡æî‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωë‡æ≤‡Ω¥‡ΩÇ‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡Ωë‡Ω¥‡Ωì‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡Ω¢‡æí‡æ±‡Ωë‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωë‡ΩÇ‡Ω¥‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡ΩÖ‡Ω¥‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡ΩÖ‡Ω¥‡ºã‡ΩÇ‡ΩÖ‡Ω≤‡ΩÇ‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡ΩÖ‡Ω¥‡ºã‡ΩÇ‡Ωâ‡Ω≤‡Ω¶‡ºã‡Ωî'.split('_'),
        monthsShort : '‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωë‡ΩÑ‡ºã‡Ωî‡Ωº_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡ΩÇ‡Ωâ‡Ω≤‡Ω¶‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡ΩÇ‡Ω¶‡Ω¥‡Ωò‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡Ωû‡Ω≤‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ω£‡æî‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωë‡æ≤‡Ω¥‡ΩÇ‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡Ωë‡Ω¥‡Ωì‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡Ω¢‡æí‡æ±‡Ωë‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωë‡ΩÇ‡Ω¥‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡ΩÖ‡Ω¥‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡ΩÖ‡Ω¥‡ºã‡ΩÇ‡ΩÖ‡Ω≤‡ΩÇ‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡ΩÖ‡Ω¥‡ºã‡ΩÇ‡Ωâ‡Ω≤‡Ω¶‡ºã‡Ωî'.split('_'),
        weekdays : '‡ΩÇ‡Ωü‡Ω†‡ºã‡Ωâ‡Ω≤‡ºã‡Ωò‡ºã_‡ΩÇ‡Ωü‡Ω†‡ºã‡Ωü‡æ≥‡ºã‡Ωñ‡ºã_‡ΩÇ‡Ωü‡Ω†‡ºã‡Ωò‡Ω≤‡ΩÇ‡ºã‡Ωë‡Ωò‡Ω¢‡ºã_‡ΩÇ‡Ωü‡Ω†‡ºã‡Ω£‡æ∑‡ΩÇ‡ºã‡Ωî‡ºã_‡ΩÇ‡Ωü‡Ω†‡ºã‡Ωï‡Ω¥‡Ω¢‡ºã‡Ωñ‡Ω¥_‡ΩÇ‡Ωü‡Ω†‡ºã‡Ωî‡ºã‡Ω¶‡ΩÑ‡Ω¶‡ºã_‡ΩÇ‡Ωü‡Ω†‡ºã‡Ω¶‡æ§‡Ω∫‡Ωì‡ºã‡Ωî‡ºã'.split('_'),
        weekdaysShort : '‡Ωâ‡Ω≤‡ºã‡Ωò‡ºã_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã_‡Ωò‡Ω≤‡ΩÇ‡ºã‡Ωë‡Ωò‡Ω¢‡ºã_‡Ω£‡æ∑‡ΩÇ‡ºã‡Ωî‡ºã_‡Ωï‡Ω¥‡Ω¢‡ºã‡Ωñ‡Ω¥_‡Ωî‡ºã‡Ω¶‡ΩÑ‡Ω¶‡ºã_‡Ω¶‡æ§‡Ω∫‡Ωì‡ºã‡Ωî‡ºã'.split('_'),
        weekdaysMin : '‡Ωâ‡Ω≤‡ºã‡Ωò‡ºã_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã_‡Ωò‡Ω≤‡ΩÇ‡ºã‡Ωë‡Ωò‡Ω¢‡ºã_‡Ω£‡æ∑‡ΩÇ‡ºã‡Ωî‡ºã_‡Ωï‡Ω¥‡Ω¢‡ºã‡Ωñ‡Ω¥_‡Ωî‡ºã‡Ω¶‡ΩÑ‡Ω¶‡ºã_‡Ω¶‡æ§‡Ω∫‡Ωì‡ºã‡Ωî‡ºã'.split('_'),
        longDateFormat : {
            LT : 'A h:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, LT',
            LLLL : 'dddd, D MMMM YYYY, LT'
        },
        calendar : {
            sameDay : '[‡Ωë‡Ω≤‡ºã‡Ω¢‡Ω≤‡ΩÑ] LT',
            nextDay : '[‡Ω¶‡ΩÑ‡ºã‡Ωâ‡Ω≤‡Ωì] LT',
            nextWeek : '[‡Ωñ‡Ωë‡Ω¥‡Ωì‡ºã‡Ωï‡æ≤‡ΩÇ‡ºã‡Ω¢‡æó‡Ω∫‡Ω¶‡ºã‡Ωò], LT',
            lastDay : '[‡ΩÅ‡ºã‡Ω¶‡ΩÑ] LT',
            lastWeek : '[‡Ωñ‡Ωë‡Ω¥‡Ωì‡ºã‡Ωï‡æ≤‡ΩÇ‡ºã‡Ωò‡Ωê‡Ω†‡ºã‡Ωò] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ‡Ω£‡ºã',
            past : '%s ‡Ω¶‡æî‡Ωì‡ºã‡Ω£',
            s : '‡Ω£‡Ωò‡ºã‡Ω¶‡ΩÑ',
            m : '‡Ω¶‡æê‡Ω¢‡ºã‡Ωò‡ºã‡ΩÇ‡ΩÖ‡Ω≤‡ΩÇ',
            mm : '%d ‡Ω¶‡æê‡Ω¢‡ºã‡Ωò',
            h : '‡ΩÜ‡Ω¥‡ºã‡Ωö‡Ωº‡Ωë‡ºã‡ΩÇ‡ΩÖ‡Ω≤‡ΩÇ',
            hh : '%d ‡ΩÜ‡Ω¥‡ºã‡Ωö‡Ωº‡Ωë',
            d : '‡Ωâ‡Ω≤‡Ωì‡ºã‡ΩÇ‡ΩÖ‡Ω≤‡ΩÇ',
            dd : '%d ‡Ωâ‡Ω≤‡Ωì‡ºã',
            M : '‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡ΩÇ‡ΩÖ‡Ω≤‡ΩÇ',
            MM : '%d ‡Ωü‡æ≥‡ºã‡Ωñ',
            y : '‡Ω£‡Ωº‡ºã‡ΩÇ‡ΩÖ‡Ω≤‡ΩÇ',
            yy : '%d ‡Ω£‡Ωº'
        },
        preparse: function (string) {
            return string.replace(/[‡º°‡º¢‡º£‡º§‡º•‡º¶‡ºß‡º®‡º©‡º†]/g, function (match) {
                return bo__numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return bo__symbolMap[match];
            });
        },
        meridiemParse: /‡Ωò‡Ωö‡Ωì‡ºã‡Ωò‡Ωº|‡Ωû‡Ωº‡ΩÇ‡Ω¶‡ºã‡ΩÄ‡Ω¶|‡Ωâ‡Ω≤‡Ωì‡ºã‡ΩÇ‡Ω¥‡ΩÑ|‡Ωë‡ΩÇ‡Ωº‡ΩÑ‡ºã‡Ωë‡ΩÇ|‡Ωò‡Ωö‡Ωì‡ºã‡Ωò‡Ωº/,
        isPM: function (input) {
            return /^(‡Ωâ‡Ω≤‡Ωì‡ºã‡ΩÇ‡Ω¥‡ΩÑ|‡Ωë‡ΩÇ‡Ωº‡ΩÑ‡ºã‡Ωë‡ΩÇ|‡Ωò‡Ωö‡Ωì‡ºã‡Ωò‡Ωº)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '‡Ωò‡Ωö‡Ωì‡ºã‡Ωò‡Ωº';
            } else if (hour < 10) {
                return '‡Ωû‡Ωº‡ΩÇ‡Ω¶‡ºã‡ΩÄ‡Ω¶';
            } else if (hour < 17) {
                return '‡Ωâ‡Ω≤‡Ωì‡ºã‡ΩÇ‡Ω¥‡ΩÑ';
            } else if (hour < 20) {
                return '‡Ωë‡ΩÇ‡Ωº‡ΩÑ‡ºã‡Ωë‡ΩÇ';
            } else {
                return '‡Ωò‡Ωö‡Ωì‡ºã‡Ωò‡Ωº';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : breton (br)
    //! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou

    function relativeTimeWithMutation(number, withoutSuffix, key) {
        var format = {
            'mm': 'munutenn',
            'MM': 'miz',
            'dd': 'devezh'
        };
        return number + ' ' + mutation(format[key], number);
    }
    function specialMutationForYears(number) {
        switch (lastNumber(number)) {
        case 1:
        case 3:
        case 4:
        case 5:
        case 9:
            return number + ' bloaz';
        default:
            return number + ' vloaz';
        }
    }
    function lastNumber(number) {
        if (number > 9) {
            return lastNumber(number % 10);
        }
        return number;
    }
    function mutation(text, number) {
        if (number === 2) {
            return softMutation(text);
        }
        return text;
    }
    function softMutation(text) {
        var mutationTable = {
            'm': 'v',
            'b': 'v',
            'd': 'z'
        };
        if (mutationTable[text.charAt(0)] === undefined) {
            return text;
        }
        return mutationTable[text.charAt(0)] + text.substring(1);
    }

    var br = _moment__default.defineLocale('br', {
        months : 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
        monthsShort : 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
        weekdays : 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
        weekdaysShort : 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
        weekdaysMin : 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
        longDateFormat : {
            LT : 'h[e]mm A',
            LTS : 'h[e]mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D [a viz] MMMM YYYY',
            LLL : 'D [a viz] MMMM YYYY LT',
            LLLL : 'dddd, D [a viz] MMMM YYYY LT'
        },
        calendar : {
            sameDay : '[Hiziv da] LT',
            nextDay : '[Warc\'hoazh da] LT',
            nextWeek : 'dddd [da] LT',
            lastDay : '[Dec\'h da] LT',
            lastWeek : 'dddd [paset da] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'a-benn %s',
            past : '%s \'zo',
            s : 'un nebeud segondenno√π',
            m : 'ur vunutenn',
            mm : relativeTimeWithMutation,
            h : 'un eur',
            hh : '%d eur',
            d : 'un devezh',
            dd : relativeTimeWithMutation,
            M : 'ur miz',
            MM : relativeTimeWithMutation,
            y : 'ur bloaz',
            yy : specialMutationForYears
        },
        ordinalParse: /\d{1,2}(a√±|vet)/,
        ordinal : function (number) {
            var output = (number === 1) ? 'a√±' : 'vet';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : bosnian (bs)
    //! author : Nedim Cholich : https://github.com/frontyard
    //! based on (hr) translation by Bojan Markoviƒá

    function bs__translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
        case 'm':
            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
        case 'mm':
            if (number === 1) {
                result += 'minuta';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'minute';
            } else {
                result += 'minuta';
            }
            return result;
        case 'h':
            return withoutSuffix ? 'jedan sat' : 'jednog sata';
        case 'hh':
            if (number === 1) {
                result += 'sat';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'sata';
            } else {
                result += 'sati';
            }
            return result;
        case 'dd':
            if (number === 1) {
                result += 'dan';
            } else {
                result += 'dana';
            }
            return result;
        case 'MM':
            if (number === 1) {
                result += 'mjesec';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'mjeseca';
            } else {
                result += 'mjeseci';
            }
            return result;
        case 'yy':
            if (number === 1) {
                result += 'godina';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'godine';
            } else {
                result += 'godina';
            }
            return result;
        }
    }

    var bs = _moment__default.defineLocale('bs', {
        months : 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_ƒçetvrtak_petak_subota'.split('_'),
        weekdaysShort : 'ned._pon._uto._sri._ƒçet._pet._sub.'.split('_'),
        weekdaysMin : 'ne_po_ut_sr_ƒçe_pe_su'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'LT:ss',
            L : 'DD. MM. YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY LT',
            LLLL : 'dddd, D. MMMM YYYY LT'
        },
        calendar : {
            sameDay  : '[danas u] LT',
            nextDay  : '[sutra u] LT',
            nextWeek : function () {
                switch (this.day()) {
                case 0:
                    return '[u] [nedjelju] [u] LT';
                case 3:
                    return '[u] [srijedu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[juƒçer u] LT',
            lastWeek : function () {
                switch (this.day()) {
                case 0:
                case 3:
                    return '[pro≈°lu] dddd [u] LT';
                case 6:
                    return '[pro≈°le] [subote] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[pro≈°li] dddd [u] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'prije %s',
            s      : 'par sekundi',
            m      : bs__translate,
            mm     : bs__translate,
            h      : bs__translate,
            hh     : bs__translate,
            d      : 'dan',
            dd     : bs__translate,
            M      : 'mjesec',
            MM     : bs__translate,
            y      : 'godinu',
            yy     : bs__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : catalan (ca)
    //! author : Juan G. Hurtado : https://github.com/juanghurtado

    var ca = _moment__default.defineLocale('ca', {
        months : 'gener_febrer_mar√ß_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
        monthsShort : 'gen._febr._mar._abr._mai._jun._jul._ag._set._oct._nov._des.'.split('_'),
        weekdays : 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
        weekdaysShort : 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
        weekdaysMin : 'Dg_Dl_Dt_Dc_Dj_Dv_Ds'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd D MMMM YYYY LT'
        },
        calendar : {
            sameDay : function () {
                return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            nextDay : function () {
                return '[dem√† a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            lastDay : function () {
                return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            lastWeek : function () {
                return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'en %s',
            past : 'fa %s',
            s : 'uns segons',
            m : 'un minut',
            mm : '%d minuts',
            h : 'una hora',
            hh : '%d hores',
            d : 'un dia',
            dd : '%d dies',
            M : 'un mes',
            MM : '%d mesos',
            y : 'un any',
            yy : '%d anys'
        },
        ordinalParse: /\d{1,2}(r|n|t|√®|a)/,
        ordinal : function (number, period) {
            var output = (number === 1) ? 'r' :
                (number === 2) ? 'n' :
                (number === 3) ? 'r' :
                (number === 4) ? 't' : '√®';
            if (period === 'w' || period === 'W') {
                output = 'a';
            }
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : czech (cs)
    //! author : petrbela : https://github.com/petrbela

    var cs__months = 'leden_√∫nor_b≈ôezen_duben_kvƒõten_ƒçerven_ƒçervenec_srpen_z√°≈ô√≠_≈ô√≠jen_listopad_prosinec'.split('_'),
        cs__monthsShort = 'led_√∫no_b≈ôe_dub_kvƒõ_ƒçvn_ƒçvc_srp_z√°≈ô_≈ô√≠j_lis_pro'.split('_');
    function cs__plural(n) {
        return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
    }
    function cs__translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
        case 's':  // a few seconds / in a few seconds / a few seconds ago
            return (withoutSuffix || isFuture) ? 'p√°r sekund' : 'p√°r sekundami';
        case 'm':  // a minute / in a minute / a minute ago
            return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
            if (withoutSuffix || isFuture) {
                return result + (cs__plural(number) ? 'minuty' : 'minut');
            } else {
                return result + 'minutami';
            }
            break;
        case 'h':  // an hour / in an hour / an hour ago
            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
        case 'hh': // 9 hours / in 9 hours / 9 hours ago
            if (withoutSuffix || isFuture) {
                return result + (cs__plural(number) ? 'hodiny' : 'hodin');
            } else {
                return result + 'hodinami';
            }
            break;
        case 'd':  // a day / in a day / a day ago
            return (withoutSuffix || isFuture) ? 'den' : 'dnem';
        case 'dd': // 9 days / in 9 days / 9 days ago
            if (withoutSuffix || isFuture) {
                return result + (cs__plural(number) ? 'dny' : 'dn√≠');
            } else {
                return result + 'dny';
            }
            break;
        case 'M':  // a month / in a month / a month ago
            return (withoutSuffix || isFuture) ? 'mƒõs√≠c' : 'mƒõs√≠cem';
        case 'MM': // 9 months / in 9 months / 9 months ago
            if (withoutSuffix || isFuture) {
                return result + (cs__plural(number) ? 'mƒõs√≠ce' : 'mƒõs√≠c≈Ø');
            } else {
                return result + 'mƒõs√≠ci';
            }
            break;
        case 'y':  // a year / in a year / a year ago
            return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
        case 'yy': // 9 years / in 9 years / 9 years ago
            if (withoutSuffix || isFuture) {
                return result + (cs__plural(number) ? 'roky' : 'let');
            } else {
                return result + 'lety';
            }
            break;
        }
    }

    var cs = _moment__default.defineLocale('cs', {
        months : cs__months,
        monthsShort : cs__monthsShort,
        monthsParse : (function (months, monthsShort) {
            var i, _monthsParse = [];
            for (i = 0; i < 12; i++) {
                // use custom parser to solve problem with July (ƒçervenec)
                _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
            }
            return _monthsParse;
        }(cs__months, cs__monthsShort)),
        weekdays : 'nedƒõle_pondƒõl√≠_√∫ter√Ω_st≈ôeda_ƒçtvrtek_p√°tek_sobota'.split('_'),
        weekdaysShort : 'ne_po_√∫t_st_ƒçt_p√°_so'.split('_'),
        weekdaysMin : 'ne_po_√∫t_st_ƒçt_p√°_so'.split('_'),
        longDateFormat : {
            LT: 'H:mm',
            LTS : 'LT:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY LT',
            LLLL : 'dddd D. MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[dnes v] LT',
            nextDay: '[z√≠tra v] LT',
            nextWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[v nedƒõli v] LT';
                case 1:
                case 2:
                    return '[v] dddd [v] LT';
                case 3:
                    return '[ve st≈ôedu v] LT';
                case 4:
                    return '[ve ƒçtvrtek v] LT';
                case 5:
                    return '[v p√°tek v] LT';
                case 6:
                    return '[v sobotu v] LT';
                }
            },
            lastDay: '[vƒçera v] LT',
            lastWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[minulou nedƒõli v] LT';
                case 1:
                case 2:
                    return '[minul√©] dddd [v] LT';
                case 3:
                    return '[minulou st≈ôedu v] LT';
                case 4:
                case 5:
                    return '[minul√Ω] dddd [v] LT';
                case 6:
                    return '[minulou sobotu v] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'za %s',
            past : 'p≈ôed %s',
            s : cs__translate,
            m : cs__translate,
            mm : cs__translate,
            h : cs__translate,
            hh : cs__translate,
            d : cs__translate,
            dd : cs__translate,
            M : cs__translate,
            MM : cs__translate,
            y : cs__translate,
            yy : cs__translate
        },
        ordinalParse : /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : chuvash (cv)
    //! author : Anatoly Mironov : https://github.com/mirontoli

    var cv = _moment__default.defineLocale('cv', {
        months : '–∫”ë—Ä–ª–∞—á_–Ω–∞—Ä”ë—Å_–ø—É—à_–∞–∫–∞_–º–∞–π_“´”ó—Ä—Ç–º–µ_—É—Ç”ë_“´—É—Ä–ª–∞_–∞–≤”ë–Ω_—é–ø–∞_—á”≥–∫_—Ä–∞—à—Ç–∞–≤'.split('_'),
        monthsShort : '–∫”ë—Ä_–Ω–∞—Ä_–ø—É—à_–∞–∫–∞_–º–∞–π_“´”ó—Ä_—É—Ç”ë_“´—É—Ä_–∞–≤–Ω_—é–ø–∞_—á”≥–∫_—Ä–∞—à'.split('_'),
        weekdays : '–≤—ã—Ä—Å–∞—Ä–Ω–∏–∫—É–Ω_—Ç—É–Ω—Ç–∏–∫—É–Ω_—ã—Ç–ª–∞—Ä–∏–∫—É–Ω_—é–Ω–∫—É–Ω_–∫”ó“´–Ω–µ—Ä–Ω–∏–∫—É–Ω_—ç—Ä–Ω–µ–∫—É–Ω_—à”ë–º–∞—Ç–∫—É–Ω'.split('_'),
        weekdaysShort : '–≤—ã—Ä_—Ç—É–Ω_—ã—Ç–ª_—é–Ω_–∫”ó“´_—ç—Ä–Ω_—à”ë–º'.split('_'),
        weekdaysMin : '–≤—Ä_—Ç–Ω_—ã—Ç_—é–Ω_–∫“´_—ç—Ä_—à–º'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD-MM-YYYY',
            LL : 'YYYY [“´—É–ª—Ö–∏] MMMM [—É–π”ë—Ö”ó–Ω] D[-–º”ó—à”ó]',
            LLL : 'YYYY [“´—É–ª—Ö–∏] MMMM [—É–π”ë—Ö”ó–Ω] D[-–º”ó—à”ó], LT',
            LLLL : 'dddd, YYYY [“´—É–ª—Ö–∏] MMMM [—É–π”ë—Ö”ó–Ω] D[-–º”ó—à”ó], LT'
        },
        calendar : {
            sameDay: '[–ü–∞—è–Ω] LT [—Å–µ—Ö–µ—Ç—Ä–µ]',
            nextDay: '[–´—Ä–∞–Ω] LT [—Å–µ—Ö–µ—Ç—Ä–µ]',
            lastDay: '[”ñ–Ω–µ—Ä] LT [—Å–µ—Ö–µ—Ç—Ä–µ]',
            nextWeek: '[“™–∏—Ç–µ—Å] dddd LT [—Å–µ—Ö–µ—Ç—Ä–µ]',
            lastWeek: '[–ò—Ä—Ç–Ω”ó] dddd LT [—Å–µ—Ö–µ—Ç—Ä–µ]',
            sameElse: 'L'
        },
        relativeTime : {
            future : function (output) {
                var affix = /—Å–µ—Ö–µ—Ç$/i.exec(output) ? '—Ä–µ–Ω' : /“´—É–ª$/i.exec(output) ? '—Ç–∞–Ω' : '—Ä–∞–Ω';
                return output + affix;
            },
            past : '%s –∫–∞—è–ª–ª–∞',
            s : '–ø”ó—Ä-–∏–∫ “´–µ–∫–∫—É–Ω—Ç',
            m : '–ø”ó—Ä –º–∏–Ω—É—Ç',
            mm : '%d –º–∏–Ω—É—Ç',
            h : '–ø”ó—Ä —Å–µ—Ö–µ—Ç',
            hh : '%d —Å–µ—Ö–µ—Ç',
            d : '–ø”ó—Ä –∫—É–Ω',
            dd : '%d –∫—É–Ω',
            M : '–ø”ó—Ä —É–π”ë—Ö',
            MM : '%d —É–π”ë—Ö',
            y : '–ø”ó—Ä “´—É–ª',
            yy : '%d “´—É–ª'
        },
        ordinalParse: /\d{1,2}-–º”ó—à/,
        ordinal : '%d-–º”ó—à',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Welsh (cy)
    //! author : Robert Allen

    var cy = _moment__default.defineLocale('cy', {
        months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
        monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
        weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
        weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
        weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
        // time formats are the same as en-gb
        longDateFormat: {
            LT: 'HH:mm',
            LTS : 'LT:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY LT',
            LLLL: 'dddd, D MMMM YYYY LT'
        },
        calendar: {
            sameDay: '[Heddiw am] LT',
            nextDay: '[Yfory am] LT',
            nextWeek: 'dddd [am] LT',
            lastDay: '[Ddoe am] LT',
            lastWeek: 'dddd [diwethaf am] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'mewn %s',
            past: '%s yn √¥l',
            s: 'ychydig eiliadau',
            m: 'munud',
            mm: '%d munud',
            h: 'awr',
            hh: '%d awr',
            d: 'diwrnod',
            dd: '%d diwrnod',
            M: 'mis',
            MM: '%d mis',
            y: 'blwyddyn',
            yy: '%d flynedd'
        },
        ordinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
        // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
        ordinal: function (number) {
            var b = number,
                output = '',
                lookup = [
                    '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
                    'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
                ];
            if (b > 20) {
                if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
                    output = 'fed'; // not 30ain, 70ain or 90ain
                } else {
                    output = 'ain';
                }
            } else if (b > 0) {
                output = lookup[b];
            }
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : danish (da)
    //! author : Ulrik Nielsen : https://github.com/mrbase

    var da = _moment__default.defineLocale('da', {
        months : 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
        weekdays : 's√∏ndag_mandag_tirsdag_onsdag_torsdag_fredag_l√∏rdag'.split('_'),
        weekdaysShort : 's√∏n_man_tir_ons_tor_fre_l√∏r'.split('_'),
        weekdaysMin : 's√∏_ma_ti_on_to_fr_l√∏'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY LT',
            LLLL : 'dddd [d.] D. MMMM YYYY LT'
        },
        calendar : {
            sameDay : '[I dag kl.] LT',
            nextDay : '[I morgen kl.] LT',
            nextWeek : 'dddd [kl.] LT',
            lastDay : '[I g√•r kl.] LT',
            lastWeek : '[sidste] dddd [kl] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : '%s siden',
            s : 'f√• sekunder',
            m : 'et minut',
            mm : '%d minutter',
            h : 'en time',
            hh : '%d timer',
            d : 'en dag',
            dd : '%d dage',
            M : 'en m√•ned',
            MM : '%d m√•neder',
            y : 'et √•r',
            yy : '%d √•r'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : austrian german (de-at)
    //! author : lluchs : https://github.com/lluchs
    //! author: Menelion Elens√∫le: https://github.com/Oire
    //! author : Martin Groller : https://github.com/MadMG

    function de_at__processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eine Minute', 'einer Minute'],
            'h': ['eine Stunde', 'einer Stunde'],
            'd': ['ein Tag', 'einem Tag'],
            'dd': [number + ' Tage', number + ' Tagen'],
            'M': ['ein Monat', 'einem Monat'],
            'MM': [number + ' Monate', number + ' Monaten'],
            'y': ['ein Jahr', 'einem Jahr'],
            'yy': [number + ' Jahre', number + ' Jahren']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var de_at = _moment__default.defineLocale('de-at', {
        months : 'J√§nner_Februar_M√§rz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort : 'J√§n._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        longDateFormat : {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY LT',
            LLLL : 'dddd, D. MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[Heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[Morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[Gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]'
        },
        relativeTime : {
            future : 'in %s',
            past : 'vor %s',
            s : 'ein paar Sekunden',
            m : de_at__processRelativeTime,
            mm : '%d Minuten',
            h : de_at__processRelativeTime,
            hh : '%d Stunden',
            d : de_at__processRelativeTime,
            dd : de_at__processRelativeTime,
            M : de_at__processRelativeTime,
            MM : de_at__processRelativeTime,
            y : de_at__processRelativeTime,
            yy : de_at__processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : german (de)
    //! author : lluchs : https://github.com/lluchs
    //! author: Menelion Elens√∫le: https://github.com/Oire

    function de__processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eine Minute', 'einer Minute'],
            'h': ['eine Stunde', 'einer Stunde'],
            'd': ['ein Tag', 'einem Tag'],
            'dd': [number + ' Tage', number + ' Tagen'],
            'M': ['ein Monat', 'einem Monat'],
            'MM': [number + ' Monate', number + ' Monaten'],
            'y': ['ein Jahr', 'einem Jahr'],
            'yy': [number + ' Jahre', number + ' Jahren']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var de = _moment__default.defineLocale('de', {
        months : 'Januar_Februar_M√§rz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort : 'Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        longDateFormat : {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY LT',
            LLLL : 'dddd, D. MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[Heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[Morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[Gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]'
        },
        relativeTime : {
            future : 'in %s',
            past : 'vor %s',
            s : 'ein paar Sekunden',
            m : de__processRelativeTime,
            mm : '%d Minuten',
            h : de__processRelativeTime,
            hh : '%d Stunden',
            d : de__processRelativeTime,
            dd : de__processRelativeTime,
            M : de__processRelativeTime,
            MM : de__processRelativeTime,
            y : de__processRelativeTime,
            yy : de__processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : modern greek (el)
    //! author : Aggelos Karalias : https://github.com/mehiel

    var el = _moment__default.defineLocale('el', {
        monthsNominativeEl : 'ŒôŒ±ŒΩŒøœÖŒ¨œÅŒπŒøœÇ_Œ¶ŒµŒ≤œÅŒøœÖŒ¨œÅŒπŒøœÇ_ŒúŒ¨œÅœÑŒπŒøœÇ_ŒëœÄœÅŒØŒªŒπŒøœÇ_ŒúŒ¨ŒπŒøœÇ_ŒôŒøœçŒΩŒπŒøœÇ_ŒôŒøœçŒªŒπŒøœÇ_ŒëœçŒ≥ŒøœÖœÉœÑŒøœÇ_Œ£ŒµœÄœÑŒ≠ŒºŒ≤œÅŒπŒøœÇ_ŒüŒ∫œÑœéŒ≤œÅŒπŒøœÇ_ŒùŒøŒ≠ŒºŒ≤œÅŒπŒøœÇ_ŒîŒµŒ∫Œ≠ŒºŒ≤œÅŒπŒøœÇ'.split('_'),
        monthsGenitiveEl : 'ŒôŒ±ŒΩŒøœÖŒ±œÅŒØŒøœÖ_Œ¶ŒµŒ≤œÅŒøœÖŒ±œÅŒØŒøœÖ_ŒúŒ±œÅœÑŒØŒøœÖ_ŒëœÄœÅŒπŒªŒØŒøœÖ_ŒúŒ±ŒêŒøœÖ_ŒôŒøœÖŒΩŒØŒøœÖ_ŒôŒøœÖŒªŒØŒøœÖ_ŒëœÖŒ≥ŒøœçœÉœÑŒøœÖ_Œ£ŒµœÄœÑŒµŒºŒ≤œÅŒØŒøœÖ_ŒüŒ∫œÑœâŒ≤œÅŒØŒøœÖ_ŒùŒøŒµŒºŒ≤œÅŒØŒøœÖ_ŒîŒµŒ∫ŒµŒºŒ≤œÅŒØŒøœÖ'.split('_'),
        months : function (momentToFormat, format) {
            if (/D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
                return this._monthsGenitiveEl[momentToFormat.month()];
            } else {
                return this._monthsNominativeEl[momentToFormat.month()];
            }
        },
        monthsShort : 'ŒôŒ±ŒΩ_Œ¶ŒµŒ≤_ŒúŒ±œÅ_ŒëœÄœÅ_ŒúŒ±œä_ŒôŒøœÖŒΩ_ŒôŒøœÖŒª_ŒëœÖŒ≥_Œ£ŒµœÄ_ŒüŒ∫œÑ_ŒùŒøŒµ_ŒîŒµŒ∫'.split('_'),
        weekdays : 'ŒöœÖœÅŒπŒ±Œ∫ŒÆ_ŒîŒµœÖœÑŒ≠œÅŒ±_Œ§œÅŒØœÑŒ∑_Œ§ŒµœÑŒ¨œÅœÑŒ∑_Œ†Œ≠ŒºœÄœÑŒ∑_Œ†Œ±œÅŒ±œÉŒ∫ŒµœÖŒÆ_Œ£Œ¨Œ≤Œ≤Œ±œÑŒø'.split('_'),
        weekdaysShort : 'ŒöœÖœÅ_ŒîŒµœÖ_Œ§œÅŒπ_Œ§ŒµœÑ_Œ†ŒµŒº_Œ†Œ±œÅ_Œ£Œ±Œ≤'.split('_'),
        weekdaysMin : 'ŒöœÖ_ŒîŒµ_Œ§œÅ_Œ§Œµ_Œ†Œµ_Œ†Œ±_Œ£Œ±'.split('_'),
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'ŒºŒº' : 'ŒúŒú';
            } else {
                return isLower ? 'œÄŒº' : 'Œ†Œú';
            }
        },
        isPM : function (input) {
            return ((input + '').toLowerCase()[0] === 'Œº');
        },
        meridiemParse : /[Œ†Œú]\.?Œú?\.?/i,
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd, D MMMM YYYY LT'
        },
        calendarEl : {
            sameDay : '[Œ£ŒÆŒºŒµœÅŒ± {}] LT',
            nextDay : '[ŒëœçœÅŒπŒø {}] LT',
            nextWeek : 'dddd [{}] LT',
            lastDay : '[ŒßŒ∏ŒµœÇ {}] LT',
            lastWeek : function () {
                switch (this.day()) {
                    case 6:
                        return '[œÑŒø œÄœÅŒøŒ∑Œ≥ŒøœçŒºŒµŒΩŒø] dddd [{}] LT';
                    default:
                        return '[œÑŒ∑ŒΩ œÄœÅŒøŒ∑Œ≥ŒøœçŒºŒµŒΩŒ∑] dddd [{}] LT';
                }
            },
            sameElse : 'L'
        },
        calendar : function (key, mom) {
            var output = this._calendarEl[key],
                hours = mom && mom.hours();
            if (typeof output === 'function') {
                output = output.apply(mom);
            }
            return output.replace('{}', (hours % 12 === 1 ? 'œÉœÑŒ∑' : 'œÉœÑŒπœÇ'));
        },
        relativeTime : {
            future : 'œÉŒµ %s',
            past : '%s œÄœÅŒπŒΩ',
            s : 'ŒªŒØŒ≥Œ± Œ¥ŒµœÖœÑŒµœÅœåŒªŒµœÄœÑŒ±',
            m : 'Œ≠ŒΩŒ± ŒªŒµœÄœÑœå',
            mm : '%d ŒªŒµœÄœÑŒ¨',
            h : 'ŒºŒØŒ± œéœÅŒ±',
            hh : '%d œéœÅŒµœÇ',
            d : 'ŒºŒØŒ± ŒºŒ≠œÅŒ±',
            dd : '%d ŒºŒ≠œÅŒµœÇ',
            M : 'Œ≠ŒΩŒ±œÇ ŒºŒÆŒΩŒ±œÇ',
            MM : '%d ŒºŒÆŒΩŒµœÇ',
            y : 'Œ≠ŒΩŒ±œÇ œáœÅœåŒΩŒøœÇ',
            yy : '%d œáœÅœåŒΩŒπŒ±'
        },
        ordinalParse: /\d{1,2}Œ∑/,
        ordinal: '%dŒ∑',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : australian english (en-au)

    var en_au = _moment__default.defineLocale('en-au', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd, D MMMM YYYY LT'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : canadian english (en-ca)
    //! author : Jonathan Abourbih : https://github.com/jonbca

    var en_ca = _moment__default.defineLocale('en-ca', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'YYYY-MM-DD',
            LL : 'D MMMM, YYYY',
            LLL : 'D MMMM, YYYY LT',
            LLLL : 'dddd, D MMMM, YYYY LT'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    //! moment.js locale configuration
    //! locale : great britain english (en-gb)
    //! author : Chris Gedrim : https://github.com/chrisgedrim

    var en_gb = _moment__default.defineLocale('en-gb', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd, D MMMM YYYY LT'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : esperanto (eo)
    //! author : Colin Dean : https://github.com/colindean
    //! komento: Mi estas malcerta se mi korekte traktis akuzativojn en tiu traduko.
    //!          Se ne, bonvolu korekti kaj avizi min por ke mi povas lerni!

    var eo = _moment__default.defineLocale('eo', {
        months : 'januaro_februaro_marto_aprilo_majo_junio_julio_a≈≠gusto_septembro_oktobro_novembro_decembro'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_a≈≠g_sep_okt_nov_dec'.split('_'),
        weekdays : 'Dimanƒâo_Lundo_Mardo_Merkredo_ƒ¥a≈≠do_Vendredo_Sabato'.split('_'),
        weekdaysShort : 'Dim_Lun_Mard_Merk_ƒ¥a≈≠_Ven_Sab'.split('_'),
        weekdaysMin : 'Di_Lu_Ma_Me_ƒ¥a_Ve_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'YYYY-MM-DD',
            LL : 'D[-an de] MMMM, YYYY',
            LLL : 'D[-an de] MMMM, YYYY LT',
            LLLL : 'dddd, [la] D[-an de] MMMM, YYYY LT'
        },
        meridiemParse: /[ap]\.t\.m/i,
        isPM: function (input) {
            return input.charAt(0).toLowerCase() === 'p';
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'p.t.m.' : 'P.T.M.';
            } else {
                return isLower ? 'a.t.m.' : 'A.T.M.';
            }
        },
        calendar : {
            sameDay : '[Hodia≈≠ je] LT',
            nextDay : '[Morga≈≠ je] LT',
            nextWeek : 'dddd [je] LT',
            lastDay : '[Hiera≈≠ je] LT',
            lastWeek : '[pasinta] dddd [je] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'je %s',
            past : 'anta≈≠ %s',
            s : 'sekundoj',
            m : 'minuto',
            mm : '%d minutoj',
            h : 'horo',
            hh : '%d horoj',
            d : 'tago',//ne 'diurno', ƒâar estas uzita por proksimumo
            dd : '%d tagoj',
            M : 'monato',
            MM : '%d monatoj',
            y : 'jaro',
            yy : '%d jaroj'
        },
        ordinalParse: /\d{1,2}a/,
        ordinal : '%da',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : spanish (es)
    //! author : Julio Napur√≠ : https://github.com/julionc

    var monthsShortDot = 'Ene._Feb._Mar._Abr._May._Jun._Jul._Ago._Sep._Oct._Nov._Dic.'.split('_'),
        es__monthsShort = 'Ene_Feb_Mar_Abr_May_Jun_Jul_Ago_Sep_Oct_Nov_Dic'.split('_');

    var es = _moment__default.defineLocale('es', {
        months : 'Enero_Febrero_Marzo_Abril_Mayo_Junio_Julio_Agosto_Septiembre_Octubre_Noviembre_Diciembre'.split('_'),
        monthsShort : function (m, format) {
            if (/-MMM-/.test(format)) {
                return es__monthsShort[m.month()];
            } else {
                return monthsShortDot[m.month()];
            }
        },
        weekdays : 'Domingo_Lunes_Martes_Mi√©rcoles_Jueves_Viernes_S√°bado'.split('_'),
        weekdaysShort : 'Dom._Lun._Mar._Mi√©._Jue._Vie._S√°b.'.split('_'),
        weekdaysMin : 'Do_Lu_Ma_Mi_Ju_Vi_S√°'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY LT',
            LLLL : 'dddd, D [de] MMMM [de] YYYY LT'
        },
        calendar : {
            sameDay : function () {
                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextDay : function () {
                return '[ma√±ana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastDay : function () {
                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastWeek : function () {
                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'en %s',
            past : 'hace %s',
            s : 'unos segundos',
            m : 'un minuto',
            mm : '%d minutos',
            h : 'una hora',
            hh : '%d horas',
            d : 'un d√≠a',
            dd : '%d d√≠as',
            M : 'un mes',
            MM : '%d meses',
            y : 'un a√±o',
            yy : '%d a√±os'
        },
        ordinalParse : /\d{1,2}¬∫/,
        ordinal : '%d¬∫',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : estonian (et)
    //! author : Henry Kehlmann : https://github.com/madhenry
    //! improvements : Illimar Tambek : https://github.com/ragulka

    function et__processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            's' : ['m√µne sekundi', 'm√µni sekund', 'paar sekundit'],
            'm' : ['√ºhe minuti', '√ºks minut'],
            'mm': [number + ' minuti', number + ' minutit'],
            'h' : ['√ºhe tunni', 'tund aega', '√ºks tund'],
            'hh': [number + ' tunni', number + ' tundi'],
            'd' : ['√ºhe p√§eva', '√ºks p√§ev'],
            'M' : ['kuu aja', 'kuu aega', '√ºks kuu'],
            'MM': [number + ' kuu', number + ' kuud'],
            'y' : ['√ºhe aasta', 'aasta', '√ºks aasta'],
            'yy': [number + ' aasta', number + ' aastat']
        };
        if (withoutSuffix) {
            return format[key][2] ? format[key][2] : format[key][1];
        }
        return isFuture ? format[key][0] : format[key][1];
    }

    var et = _moment__default.defineLocale('et', {
        months        : 'jaanuar_veebruar_m√§rts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
        monthsShort   : 'jaan_veebr_m√§rts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
        weekdays      : 'p√ºhap√§ev_esmasp√§ev_teisip√§ev_kolmap√§ev_neljap√§ev_reede_laup√§ev'.split('_'),
        weekdaysShort : 'P_E_T_K_N_R_L'.split('_'),
        weekdaysMin   : 'P_E_T_K_N_R_L'.split('_'),
        longDateFormat : {
            LT   : 'H:mm',
            LTS : 'LT:ss',
            L    : 'DD.MM.YYYY',
            LL   : 'D. MMMM YYYY',
            LLL  : 'D. MMMM YYYY LT',
            LLLL : 'dddd, D. MMMM YYYY LT'
        },
        calendar : {
            sameDay  : '[T√§na,] LT',
            nextDay  : '[Homme,] LT',
            nextWeek : '[J√§rgmine] dddd LT',
            lastDay  : '[Eile,] LT',
            lastWeek : '[Eelmine] dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s p√§rast',
            past   : '%s tagasi',
            s      : et__processRelativeTime,
            m      : et__processRelativeTime,
            mm     : et__processRelativeTime,
            h      : et__processRelativeTime,
            hh     : et__processRelativeTime,
            d      : et__processRelativeTime,
            dd     : '%d p√§eva',
            M      : et__processRelativeTime,
            MM     : et__processRelativeTime,
            y      : et__processRelativeTime,
            yy     : et__processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : euskara (eu)
    //! author : Eneko Illarramendi : https://github.com/eillarra

    var eu = _moment__default.defineLocale('eu', {
        months : 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
        monthsShort : 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
        weekdays : 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
        weekdaysShort : 'ig._al._ar._az._og._ol._lr.'.split('_'),
        weekdaysMin : 'ig_al_ar_az_og_ol_lr'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'YYYY-MM-DD',
            LL : 'YYYY[ko] MMMM[ren] D[a]',
            LLL : 'YYYY[ko] MMMM[ren] D[a] LT',
            LLLL : 'dddd, YYYY[ko] MMMM[ren] D[a] LT',
            l : 'YYYY-M-D',
            ll : 'YYYY[ko] MMM D[a]',
            lll : 'YYYY[ko] MMM D[a] LT',
            llll : 'ddd, YYYY[ko] MMM D[a] LT'
        },
        calendar : {
            sameDay : '[gaur] LT[etan]',
            nextDay : '[bihar] LT[etan]',
            nextWeek : 'dddd LT[etan]',
            lastDay : '[atzo] LT[etan]',
            lastWeek : '[aurreko] dddd LT[etan]',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s barru',
            past : 'duela %s',
            s : 'segundo batzuk',
            m : 'minutu bat',
            mm : '%d minutu',
            h : 'ordu bat',
            hh : '%d ordu',
            d : 'egun bat',
            dd : '%d egun',
            M : 'hilabete bat',
            MM : '%d hilabete',
            y : 'urte bat',
            yy : '%d urte'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Persian (fa)
    //! author : Ebrahim Byagowi : https://github.com/ebraminio

    var fa__symbolMap = {
        '1': '€±',
        '2': '€≤',
        '3': '€≥',
        '4': '€¥',
        '5': '€µ',
        '6': '€∂',
        '7': '€∑',
        '8': '€∏',
        '9': '€π',
        '0': '€∞'
    }, fa__numberMap = {
        '€±': '1',
        '€≤': '2',
        '€≥': '3',
        '€¥': '4',
        '€µ': '5',
        '€∂': '6',
        '€∑': '7',
        '€∏': '8',
        '€π': '9',
        '€∞': '0'
    };

    var fa = _moment__default.defineLocale('fa', {
        months : '⁄òÿßŸÜŸà€åŸá_ŸÅŸàÿ±€åŸá_ŸÖÿßÿ±ÿ≥_ÿ¢Ÿàÿ±€åŸÑ_ŸÖŸá_⁄òŸàÿ¶ŸÜ_⁄òŸàÿ¶€åŸá_ÿßŸàÿ™_ÿ≥Ÿæÿ™ÿßŸÖÿ®ÿ±_ÿß⁄©ÿ™ÿ®ÿ±_ŸÜŸàÿßŸÖÿ®ÿ±_ÿØÿ≥ÿßŸÖÿ®ÿ±'.split('_'),
        monthsShort : '⁄òÿßŸÜŸà€åŸá_ŸÅŸàÿ±€åŸá_ŸÖÿßÿ±ÿ≥_ÿ¢Ÿàÿ±€åŸÑ_ŸÖŸá_⁄òŸàÿ¶ŸÜ_⁄òŸàÿ¶€åŸá_ÿßŸàÿ™_ÿ≥Ÿæÿ™ÿßŸÖÿ®ÿ±_ÿß⁄©ÿ™ÿ®ÿ±_ŸÜŸàÿßŸÖÿ®ÿ±_ÿØÿ≥ÿßŸÖÿ®ÿ±'.split('_'),
        weekdays : '€å⁄©\u200cÿ¥ŸÜÿ®Ÿá_ÿØŸàÿ¥ŸÜÿ®Ÿá_ÿ≥Ÿá\u200cÿ¥ŸÜÿ®Ÿá_⁄ÜŸáÿßÿ±ÿ¥ŸÜÿ®Ÿá_ŸæŸÜÿ¨\u200cÿ¥ŸÜÿ®Ÿá_ÿ¨ŸÖÿπŸá_ÿ¥ŸÜÿ®Ÿá'.split('_'),
        weekdaysShort : '€å⁄©\u200cÿ¥ŸÜÿ®Ÿá_ÿØŸàÿ¥ŸÜÿ®Ÿá_ÿ≥Ÿá\u200cÿ¥ŸÜÿ®Ÿá_⁄ÜŸáÿßÿ±ÿ¥ŸÜÿ®Ÿá_ŸæŸÜÿ¨\u200cÿ¥ŸÜÿ®Ÿá_ÿ¨ŸÖÿπŸá_ÿ¥ŸÜÿ®Ÿá'.split('_'),
        weekdaysMin : '€å_ÿØ_ÿ≥_⁄Ü_Ÿæ_ÿ¨_ÿ¥'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd, D MMMM YYYY LT'
        },
        meridiemParse: /ŸÇÿ®ŸÑ ÿßÿ≤ ÿ∏Ÿáÿ±|ÿ®ÿπÿØ ÿßÿ≤ ÿ∏Ÿáÿ±/,
        isPM: function (input) {
            return /ÿ®ÿπÿØ ÿßÿ≤ ÿ∏Ÿáÿ±/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ŸÇÿ®ŸÑ ÿßÿ≤ ÿ∏Ÿáÿ±';
            } else {
                return 'ÿ®ÿπÿØ ÿßÿ≤ ÿ∏Ÿáÿ±';
            }
        },
        calendar : {
            sameDay : '[ÿßŸÖÿ±Ÿàÿ≤ ÿ≥ÿßÿπÿ™] LT',
            nextDay : '[ŸÅÿ±ÿØÿß ÿ≥ÿßÿπÿ™] LT',
            nextWeek : 'dddd [ÿ≥ÿßÿπÿ™] LT',
            lastDay : '[ÿØ€åÿ±Ÿàÿ≤ ÿ≥ÿßÿπÿ™] LT',
            lastWeek : 'dddd [Ÿæ€åÿ¥] [ÿ≥ÿßÿπÿ™] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'ÿØÿ± %s',
            past : '%s Ÿæ€åÿ¥',
            s : '⁄ÜŸÜÿØ€åŸÜ ÿ´ÿßŸÜ€åŸá',
            m : '€å⁄© ÿØŸÇ€åŸÇŸá',
            mm : '%d ÿØŸÇ€åŸÇŸá',
            h : '€å⁄© ÿ≥ÿßÿπÿ™',
            hh : '%d ÿ≥ÿßÿπÿ™',
            d : '€å⁄© ÿ±Ÿàÿ≤',
            dd : '%d ÿ±Ÿàÿ≤',
            M : '€å⁄© ŸÖÿßŸá',
            MM : '%d ŸÖÿßŸá',
            y : '€å⁄© ÿ≥ÿßŸÑ',
            yy : '%d ÿ≥ÿßŸÑ'
        },
        preparse: function (string) {
            return string.replace(/[€∞-€π]/g, function (match) {
                return fa__numberMap[match];
            }).replace(/ÿå/g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return fa__symbolMap[match];
            }).replace(/,/g, 'ÿå');
        },
        ordinalParse: /\d{1,2}ŸÖ/,
        ordinal : '%dŸÖ',
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12 // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : finnish (fi)
    //! author : Tarmo Aidantausta : https://github.com/bleadof

    var numbersPast = 'nolla yksi kaksi kolme nelj√§ viisi kuusi seitsem√§n kahdeksan yhdeks√§n'.split(' '),
        numbersFuture = [
            'nolla', 'yhden', 'kahden', 'kolmen', 'nelj√§n', 'viiden', 'kuuden',
            numbersPast[7], numbersPast[8], numbersPast[9]
        ];
    function fi__translate(number, withoutSuffix, key, isFuture) {
        var result = '';
        switch (key) {
        case 's':
            return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
        case 'm':
            return isFuture ? 'minuutin' : 'minuutti';
        case 'mm':
            result = isFuture ? 'minuutin' : 'minuuttia';
            break;
        case 'h':
            return isFuture ? 'tunnin' : 'tunti';
        case 'hh':
            result = isFuture ? 'tunnin' : 'tuntia';
            break;
        case 'd':
            return isFuture ? 'p√§iv√§n' : 'p√§iv√§';
        case 'dd':
            result = isFuture ? 'p√§iv√§n' : 'p√§iv√§√§';
            break;
        case 'M':
            return isFuture ? 'kuukauden' : 'kuukausi';
        case 'MM':
            result = isFuture ? 'kuukauden' : 'kuukautta';
            break;
        case 'y':
            return isFuture ? 'vuoden' : 'vuosi';
        case 'yy':
            result = isFuture ? 'vuoden' : 'vuotta';
            break;
        }
        result = verbalNumber(number, isFuture) + ' ' + result;
        return result;
    }
    function verbalNumber(number, isFuture) {
        return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
    }

    var fi = _moment__default.defineLocale('fi', {
        months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kes√§kuu_hein√§kuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
        monthsShort : 'tammi_helmi_maalis_huhti_touko_kes√§_hein√§_elo_syys_loka_marras_joulu'.split('_'),
        weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
        weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),
        weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD.MM.YYYY',
            LL : 'Do MMMM[ta] YYYY',
            LLL : 'Do MMMM[ta] YYYY, [klo] LT',
            LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] LT',
            l : 'D.M.YYYY',
            ll : 'Do MMM YYYY',
            lll : 'Do MMM YYYY, [klo] LT',
            llll : 'ddd, Do MMM YYYY, [klo] LT'
        },
        calendar : {
            sameDay : '[t√§n√§√§n] [klo] LT',
            nextDay : '[huomenna] [klo] LT',
            nextWeek : 'dddd [klo] LT',
            lastDay : '[eilen] [klo] LT',
            lastWeek : '[viime] dddd[na] [klo] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s p√§√§st√§',
            past : '%s sitten',
            s : fi__translate,
            m : fi__translate,
            mm : fi__translate,
            h : fi__translate,
            hh : fi__translate,
            d : fi__translate,
            dd : fi__translate,
            M : fi__translate,
            MM : fi__translate,
            y : fi__translate,
            yy : fi__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : faroese (fo)
    //! author : Ragnar Johannesen : https://github.com/ragnar123

    var fo = _moment__default.defineLocale('fo', {
        months : 'januar_februar_mars_apr√≠l_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
        weekdays : 'sunnudagur_m√°nadagur_t√Ωsdagur_mikudagur_h√≥sdagur_fr√≠ggjadagur_leygardagur'.split('_'),
        weekdaysShort : 'sun_m√°n_t√Ωs_mik_h√≥s_fr√≠_ley'.split('_'),
        weekdaysMin : 'su_m√°_t√Ω_mi_h√≥_fr_le'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd D. MMMM, YYYY LT'
        },
        calendar : {
            sameDay : '[√ç dag kl.] LT',
            nextDay : '[√ç morgin kl.] LT',
            nextWeek : 'dddd [kl.] LT',
            lastDay : '[√ç gj√°r kl.] LT',
            lastWeek : '[s√≠√∞stu] dddd [kl] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'um %s',
            past : '%s s√≠√∞ani',
            s : 'f√° sekund',
            m : 'ein minutt',
            mm : '%d minuttir',
            h : 'ein t√≠mi',
            hh : '%d t√≠mar',
            d : 'ein dagur',
            dd : '%d dagar',
            M : 'ein m√°na√∞i',
            MM : '%d m√°na√∞ir',
            y : 'eitt √°r',
            yy : '%d √°r'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : canadian french (fr-ca)
    //! author : Jonathan Abourbih : https://github.com/jonbca

    var fr_ca = _moment__default.defineLocale('fr-ca', {
        months : 'janvier_f√©vrier_mars_avril_mai_juin_juillet_ao√ªt_septembre_octobre_novembre_d√©cembre'.split('_'),
        monthsShort : 'janv._f√©vr._mars_avr._mai_juin_juil._ao√ªt_sept._oct._nov._d√©c.'.split('_'),
        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'YYYY-MM-DD',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd D MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[Aujourd\'hui √†] LT',
            nextDay: '[Demain √†] LT',
            nextWeek: 'dddd [√†] LT',
            lastDay: '[Hier √†] LT',
            lastWeek: 'dddd [dernier √†] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'dans %s',
            past : 'il y a %s',
            s : 'quelques secondes',
            m : 'une minute',
            mm : '%d minutes',
            h : 'une heure',
            hh : '%d heures',
            d : 'un jour',
            dd : '%d jours',
            M : 'un mois',
            MM : '%d mois',
            y : 'un an',
            yy : '%d ans'
        },
        ordinalParse: /\d{1,2}(er|)/,
        ordinal : function (number) {
            return number + (number === 1 ? 'er' : '');
        }
    });

    //! moment.js locale configuration
    //! locale : french (fr)
    //! author : John Fischer : https://github.com/jfroffice

    var fr = _moment__default.defineLocale('fr', {
        months : 'janvier_f√©vrier_mars_avril_mai_juin_juillet_ao√ªt_septembre_octobre_novembre_d√©cembre'.split('_'),
        monthsShort : 'janv._f√©vr._mars_avr._mai_juin_juil._ao√ªt_sept._oct._nov._d√©c.'.split('_'),
        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd D MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[Aujourd\'hui √†] LT',
            nextDay: '[Demain √†] LT',
            nextWeek: 'dddd [√†] LT',
            lastDay: '[Hier √†] LT',
            lastWeek: 'dddd [dernier √†] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'dans %s',
            past : 'il y a %s',
            s : 'quelques secondes',
            m : 'une minute',
            mm : '%d minutes',
            h : 'une heure',
            hh : '%d heures',
            d : 'un jour',
            dd : '%d jours',
            M : 'un mois',
            MM : '%d mois',
            y : 'un an',
            yy : '%d ans'
        },
        ordinalParse: /\d{1,2}(er|)/,
        ordinal : function (number) {
            return number + (number === 1 ? 'er' : '');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : frisian (fy)
    //! author : Robin van der Vliet : https://github.com/robin0van0der0v

    var fy__monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_'),
        fy__monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');

    var fy = _moment__default.defineLocale('fy', {
        months : 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
        monthsShort : function (m, format) {
            if (/-MMM-/.test(format)) {
                return fy__monthsShortWithoutDots[m.month()];
            } else {
                return fy__monthsShortWithDots[m.month()];
            }
        },
        weekdays : 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
        weekdaysShort : 'si._mo._ti._wo._to._fr._so.'.split('_'),
        weekdaysMin : 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD-MM-YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd D MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[hjoed om] LT',
            nextDay: '[moarn om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[juster om] LT',
            lastWeek: '[√¥fr√ªne] dddd [om] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'oer %s',
            past : '%s lyn',
            s : 'in pear sekonden',
            m : 'ien min√∫t',
            mm : '%d minuten',
            h : 'ien oere',
            hh : '%d oeren',
            d : 'ien dei',
            dd : '%d dagen',
            M : 'ien moanne',
            MM : '%d moannen',
            y : 'ien jier',
            yy : '%d jierren'
        },
        ordinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : galician (gl)
    //! author : Juan G. Hurtado : https://github.com/juanghurtado

    var gl = _moment__default.defineLocale('gl', {
        months : 'Xaneiro_Febreiro_Marzo_Abril_Maio_Xu√±o_Xullo_Agosto_Setembro_Outubro_Novembro_Decembro'.split('_'),
        monthsShort : 'Xan._Feb._Mar._Abr._Mai._Xu√±._Xul._Ago._Set._Out._Nov._Dec.'.split('_'),
        weekdays : 'Domingo_Luns_Martes_M√©rcores_Xoves_Venres_S√°bado'.split('_'),
        weekdaysShort : 'Dom._Lun._Mar._M√©r._Xov._Ven._S√°b.'.split('_'),
        weekdaysMin : 'Do_Lu_Ma_M√©_Xo_Ve_S√°'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd D MMMM YYYY LT'
        },
        calendar : {
            sameDay : function () {
                return '[hoxe ' + ((this.hours() !== 1) ? '√°s' : '√°') + '] LT';
            },
            nextDay : function () {
                return '[ma√±√° ' + ((this.hours() !== 1) ? '√°s' : '√°') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [' + ((this.hours() !== 1) ? '√°s' : 'a') + '] LT';
            },
            lastDay : function () {
                return '[onte ' + ((this.hours() !== 1) ? '√°' : 'a') + '] LT';
            },
            lastWeek : function () {
                return '[o] dddd [pasado ' + ((this.hours() !== 1) ? '√°s' : 'a') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : function (str) {
                if (str === 'uns segundos') {
                    return 'nuns segundos';
                }
                return 'en ' + str;
            },
            past : 'hai %s',
            s : 'uns segundos',
            m : 'un minuto',
            mm : '%d minutos',
            h : 'unha hora',
            hh : '%d horas',
            d : 'un d√≠a',
            dd : '%d d√≠as',
            M : 'un mes',
            MM : '%d meses',
            y : 'un ano',
            yy : '%d anos'
        },
        ordinalParse : /\d{1,2}¬∫/,
        ordinal : '%d¬∫',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Hebrew (he)
    //! author : Tomer Cohen : https://github.com/tomer
    //! author : Moshe Simantov : https://github.com/DevelopmentIL
    //! author : Tal Ater : https://github.com/TalAter

    var he = _moment__default.defineLocale('he', {
        months : '◊ô◊†◊ï◊ê◊®_◊§◊ë◊®◊ï◊ê◊®_◊û◊®◊•_◊ê◊§◊®◊ô◊ú_◊û◊ê◊ô_◊ô◊ï◊†◊ô_◊ô◊ï◊ú◊ô_◊ê◊ï◊í◊ï◊°◊ò_◊°◊§◊ò◊û◊ë◊®_◊ê◊ï◊ß◊ò◊ï◊ë◊®_◊†◊ï◊ë◊û◊ë◊®_◊ì◊¶◊û◊ë◊®'.split('_'),
        monthsShort : '◊ô◊†◊ï◊≥_◊§◊ë◊®◊≥_◊û◊®◊•_◊ê◊§◊®◊≥_◊û◊ê◊ô_◊ô◊ï◊†◊ô_◊ô◊ï◊ú◊ô_◊ê◊ï◊í◊≥_◊°◊§◊ò◊≥_◊ê◊ï◊ß◊≥_◊†◊ï◊ë◊≥_◊ì◊¶◊û◊≥'.split('_'),
        weekdays : '◊®◊ê◊©◊ï◊ü_◊©◊†◊ô_◊©◊ú◊ô◊©◊ô_◊®◊ë◊ô◊¢◊ô_◊ó◊û◊ô◊©◊ô_◊©◊ô◊©◊ô_◊©◊ë◊™'.split('_'),
        weekdaysShort : '◊ê◊≥_◊ë◊≥_◊í◊≥_◊ì◊≥_◊î◊≥_◊ï◊≥_◊©◊≥'.split('_'),
        weekdaysMin : '◊ê_◊ë_◊í_◊ì_◊î_◊ï_◊©'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [◊ë]MMMM YYYY',
            LLL : 'D [◊ë]MMMM YYYY LT',
            LLLL : 'dddd, D [◊ë]MMMM YYYY LT',
            l : 'D/M/YYYY',
            ll : 'D MMM YYYY',
            lll : 'D MMM YYYY LT',
            llll : 'ddd, D MMM YYYY LT'
        },
        calendar : {
            sameDay : '[◊î◊ô◊ï◊ù ◊ë÷æ]LT',
            nextDay : '[◊û◊ó◊® ◊ë÷æ]LT',
            nextWeek : 'dddd [◊ë◊©◊¢◊î] LT',
            lastDay : '[◊ê◊™◊û◊ï◊ú ◊ë÷æ]LT',
            lastWeek : '[◊ë◊ô◊ï◊ù] dddd [◊î◊ê◊ó◊®◊ï◊ü ◊ë◊©◊¢◊î] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '◊ë◊¢◊ï◊ì %s',
            past : '◊ú◊§◊†◊ô %s',
            s : '◊û◊°◊§◊® ◊©◊†◊ô◊ï◊™',
            m : '◊ì◊ß◊î',
            mm : '%d ◊ì◊ß◊ï◊™',
            h : '◊©◊¢◊î',
            hh : function (number) {
                if (number === 2) {
                    return '◊©◊¢◊™◊ô◊ô◊ù';
                }
                return number + ' ◊©◊¢◊ï◊™';
            },
            d : '◊ô◊ï◊ù',
            dd : function (number) {
                if (number === 2) {
                    return '◊ô◊ï◊û◊ô◊ô◊ù';
                }
                return number + ' ◊ô◊û◊ô◊ù';
            },
            M : '◊ó◊ï◊ì◊©',
            MM : function (number) {
                if (number === 2) {
                    return '◊ó◊ï◊ì◊©◊ô◊ô◊ù';
                }
                return number + ' ◊ó◊ï◊ì◊©◊ô◊ù';
            },
            y : '◊©◊†◊î',
            yy : function (number) {
                if (number === 2) {
                    return '◊©◊†◊™◊ô◊ô◊ù';
                } else if (number % 10 === 0 && number !== 10) {
                    return number + ' ◊©◊†◊î';
                }
                return number + ' ◊©◊†◊ô◊ù';
            }
        }
    });

    //! moment.js locale configuration
    //! locale : hindi (hi)
    //! author : Mayank Singhal : https://github.com/mayanksinghal

    var hi__symbolMap = {
        '1': '‡•ß',
        '2': '‡•®',
        '3': '‡•©',
        '4': '‡•™',
        '5': '‡•´',
        '6': '‡•¨',
        '7': '‡•≠',
        '8': '‡•Æ',
        '9': '‡•Ø',
        '0': '‡•¶'
    },
    hi__numberMap = {
        '‡•ß': '1',
        '‡•®': '2',
        '‡•©': '3',
        '‡•™': '4',
        '‡•´': '5',
        '‡•¨': '6',
        '‡•≠': '7',
        '‡•Æ': '8',
        '‡•Ø': '9',
        '‡•¶': '0'
    };

    var hi = _moment__default.defineLocale('hi', {
        months : '‡§ú‡§®‡§µ‡§∞‡•Ä_‡§´‡§º‡§∞‡§µ‡§∞‡•Ä_‡§Æ‡§æ‡§∞‡•ç‡§ö_‡§Ö‡§™‡•ç‡§∞‡•à‡§≤_‡§Æ‡§à_‡§ú‡•Ç‡§®_‡§ú‡•Å‡§≤‡§æ‡§à_‡§Ö‡§ó‡§∏‡•ç‡§§_‡§∏‡§ø‡§§‡§Æ‡•ç‡§¨‡§∞_‡§Ö‡§ï‡•ç‡§ü‡•Ç‡§¨‡§∞_‡§®‡§µ‡§Æ‡•ç‡§¨‡§∞_‡§¶‡§ø‡§∏‡§Æ‡•ç‡§¨‡§∞'.split('_'),
        monthsShort : '‡§ú‡§®._‡§´‡§º‡§∞._‡§Æ‡§æ‡§∞‡•ç‡§ö_‡§Ö‡§™‡•ç‡§∞‡•à._‡§Æ‡§à_‡§ú‡•Ç‡§®_‡§ú‡•Å‡§≤._‡§Ö‡§ó._‡§∏‡§ø‡§§._‡§Ö‡§ï‡•ç‡§ü‡•Ç._‡§®‡§µ._‡§¶‡§ø‡§∏.'.split('_'),
        weekdays : '‡§∞‡§µ‡§ø‡§µ‡§æ‡§∞_‡§∏‡•ã‡§Æ‡§µ‡§æ‡§∞_‡§Æ‡§Ç‡§ó‡§≤‡§µ‡§æ‡§∞_‡§¨‡•Å‡§ß‡§µ‡§æ‡§∞_‡§ó‡•Å‡§∞‡•Ç‡§µ‡§æ‡§∞_‡§∂‡•Å‡§ï‡•ç‡§∞‡§µ‡§æ‡§∞_‡§∂‡§®‡§ø‡§µ‡§æ‡§∞'.split('_'),
        weekdaysShort : '‡§∞‡§µ‡§ø_‡§∏‡•ã‡§Æ_‡§Æ‡§Ç‡§ó‡§≤_‡§¨‡•Å‡§ß_‡§ó‡•Å‡§∞‡•Ç_‡§∂‡•Å‡§ï‡•ç‡§∞_‡§∂‡§®‡§ø'.split('_'),
        weekdaysMin : '‡§∞_‡§∏‡•ã_‡§Æ‡§Ç_‡§¨‡•Å_‡§ó‡•Å_‡§∂‡•Å_‡§∂'.split('_'),
        longDateFormat : {
            LT : 'A h:mm ‡§¨‡§ú‡•á',
            LTS : 'A h:mm:ss ‡§¨‡§ú‡•á',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, LT',
            LLLL : 'dddd, D MMMM YYYY, LT'
        },
        calendar : {
            sameDay : '[‡§Ü‡§ú] LT',
            nextDay : '[‡§ï‡§≤] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[‡§ï‡§≤] LT',
            lastWeek : '[‡§™‡§ø‡§õ‡§≤‡•á] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ‡§Æ‡•á‡§Ç',
            past : '%s ‡§™‡§π‡§≤‡•á',
            s : '‡§ï‡•Å‡§õ ‡§π‡•Ä ‡§ï‡•ç‡§∑‡§£',
            m : '‡§è‡§ï ‡§Æ‡§ø‡§®‡§ü',
            mm : '%d ‡§Æ‡§ø‡§®‡§ü',
            h : '‡§è‡§ï ‡§ò‡§Ç‡§ü‡§æ',
            hh : '%d ‡§ò‡§Ç‡§ü‡•á',
            d : '‡§è‡§ï ‡§¶‡§ø‡§®',
            dd : '%d ‡§¶‡§ø‡§®',
            M : '‡§è‡§ï ‡§Æ‡§π‡•Ä‡§®‡•á',
            MM : '%d ‡§Æ‡§π‡•Ä‡§®‡•á',
            y : '‡§è‡§ï ‡§µ‡§∞‡•ç‡§∑',
            yy : '%d ‡§µ‡§∞‡•ç‡§∑'
        },
        preparse: function (string) {
            return string.replace(/[‡•ß‡•®‡•©‡•™‡•´‡•¨‡•≠‡•Æ‡•Ø‡•¶]/g, function (match) {
                return hi__numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return hi__symbolMap[match];
            });
        },
        // Hindi notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
        meridiemParse: /‡§∞‡§æ‡§§|‡§∏‡•Å‡§¨‡§π|‡§¶‡•ã‡§™‡§π‡§∞|‡§∂‡§æ‡§Æ/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '‡§∞‡§æ‡§§') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '‡§∏‡•Å‡§¨‡§π') {
                return hour;
            } else if (meridiem === '‡§¶‡•ã‡§™‡§π‡§∞') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '‡§∂‡§æ‡§Æ') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '‡§∞‡§æ‡§§';
            } else if (hour < 10) {
                return '‡§∏‡•Å‡§¨‡§π';
            } else if (hour < 17) {
                return '‡§¶‡•ã‡§™‡§π‡§∞';
            } else if (hour < 20) {
                return '‡§∂‡§æ‡§Æ';
            } else {
                return '‡§∞‡§æ‡§§';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : hrvatski (hr)
    //! author : Bojan Markoviƒá : https://github.com/bmarkovic

    function hr__translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
        case 'm':
            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
        case 'mm':
            if (number === 1) {
                result += 'minuta';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'minute';
            } else {
                result += 'minuta';
            }
            return result;
        case 'h':
            return withoutSuffix ? 'jedan sat' : 'jednog sata';
        case 'hh':
            if (number === 1) {
                result += 'sat';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'sata';
            } else {
                result += 'sati';
            }
            return result;
        case 'dd':
            if (number === 1) {
                result += 'dan';
            } else {
                result += 'dana';
            }
            return result;
        case 'MM':
            if (number === 1) {
                result += 'mjesec';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'mjeseca';
            } else {
                result += 'mjeseci';
            }
            return result;
        case 'yy':
            if (number === 1) {
                result += 'godina';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'godine';
            } else {
                result += 'godina';
            }
            return result;
        }
    }

    var hr = _moment__default.defineLocale('hr', {
        months : 'sijeƒçanj_veljaƒça_o≈æujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_'),
        monthsShort : 'sij._velj._o≈æu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_ƒçetvrtak_petak_subota'.split('_'),
        weekdaysShort : 'ned._pon._uto._sri._ƒçet._pet._sub.'.split('_'),
        weekdaysMin : 'ne_po_ut_sr_ƒçe_pe_su'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'LT:ss',
            L : 'DD. MM. YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY LT',
            LLLL : 'dddd, D. MMMM YYYY LT'
        },
        calendar : {
            sameDay  : '[danas u] LT',
            nextDay  : '[sutra u] LT',
            nextWeek : function () {
                switch (this.day()) {
                case 0:
                    return '[u] [nedjelju] [u] LT';
                case 3:
                    return '[u] [srijedu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[juƒçer u] LT',
            lastWeek : function () {
                switch (this.day()) {
                case 0:
                case 3:
                    return '[pro≈°lu] dddd [u] LT';
                case 6:
                    return '[pro≈°le] [subote] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[pro≈°li] dddd [u] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'prije %s',
            s      : 'par sekundi',
            m      : hr__translate,
            mm     : hr__translate,
            h      : hr__translate,
            hh     : hr__translate,
            d      : 'dan',
            dd     : hr__translate,
            M      : 'mjesec',
            MM     : hr__translate,
            y      : 'godinu',
            yy     : hr__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : hungarian (hu)
    //! author : Adam Brunner : https://github.com/adambrunner

    var weekEndings = 'vas√°rnap h√©tf≈ën kedden szerd√°n cs√ºt√∂rt√∂k√∂n p√©nteken szombaton'.split(' ');
    function hu__translate(number, withoutSuffix, key, isFuture) {
        var num = number,
            suffix;
        switch (key) {
        case 's':
            return (isFuture || withoutSuffix) ? 'n√©h√°ny m√°sodperc' : 'n√©h√°ny m√°sodperce';
        case 'm':
            return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
        case 'mm':
            return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
        case 'h':
            return 'egy' + (isFuture || withoutSuffix ? ' √≥ra' : ' √≥r√°ja');
        case 'hh':
            return num + (isFuture || withoutSuffix ? ' √≥ra' : ' √≥r√°ja');
        case 'd':
            return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
        case 'dd':
            return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
        case 'M':
            return 'egy' + (isFuture || withoutSuffix ? ' h√≥nap' : ' h√≥napja');
        case 'MM':
            return num + (isFuture || withoutSuffix ? ' h√≥nap' : ' h√≥napja');
        case 'y':
            return 'egy' + (isFuture || withoutSuffix ? ' √©v' : ' √©ve');
        case 'yy':
            return num + (isFuture || withoutSuffix ? ' √©v' : ' √©ve');
        }
        return '';
    }
    function week(isFuture) {
        return (isFuture ? '' : '[m√∫lt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
    }

    var hu = _moment__default.defineLocale('hu', {
        months : 'janu√°r_febru√°r_m√°rcius_√°prilis_m√°jus_j√∫nius_j√∫lius_augusztus_szeptember_okt√≥ber_november_december'.split('_'),
        monthsShort : 'jan_feb_m√°rc_√°pr_m√°j_j√∫n_j√∫l_aug_szept_okt_nov_dec'.split('_'),
        weekdays : 'vas√°rnap_h√©tf≈ë_kedd_szerda_cs√ºt√∂rt√∂k_p√©ntek_szombat'.split('_'),
        weekdaysShort : 'vas_h√©t_kedd_sze_cs√ºt_p√©n_szo'.split('_'),
        weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'LT:ss',
            L : 'YYYY.MM.DD.',
            LL : 'YYYY. MMMM D.',
            LLL : 'YYYY. MMMM D., LT',
            LLLL : 'YYYY. MMMM D., dddd LT'
        },
        meridiemParse: /de|du/i,
        isPM: function (input) {
            return input.charAt(1).toLowerCase() === 'u';
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower === true ? 'de' : 'DE';
            } else {
                return isLower === true ? 'du' : 'DU';
            }
        },
        calendar : {
            sameDay : '[ma] LT[-kor]',
            nextDay : '[holnap] LT[-kor]',
            nextWeek : function () {
                return week.call(this, true);
            },
            lastDay : '[tegnap] LT[-kor]',
            lastWeek : function () {
                return week.call(this, false);
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s m√∫lva',
            past : '%s',
            s : hu__translate,
            m : hu__translate,
            mm : hu__translate,
            h : hu__translate,
            hh : hu__translate,
            d : hu__translate,
            dd : hu__translate,
            M : hu__translate,
            MM : hu__translate,
            y : hu__translate,
            yy : hu__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Armenian (hy-am)
    //! author : Armendarabyan : https://github.com/armendarabyan

    function hy_am__monthsCaseReplace(m, format) {
        var months = {
            'nominative': '’∞’∏÷Ç’∂’æ’°÷Ä_÷É’•’ø÷Ä’æ’°÷Ä_’¥’°÷Ä’ø_’°’∫÷Ä’´’¨_’¥’°’µ’´’Ω_’∞’∏÷Ç’∂’´’Ω_’∞’∏÷Ç’¨’´’Ω_÷Ö’£’∏’Ω’ø’∏’Ω_’Ω’•’∫’ø’•’¥’¢’•÷Ä_’∞’∏’Ø’ø’•’¥’¢’•÷Ä_’∂’∏’µ’•’¥’¢’•÷Ä_’§’•’Ø’ø’•’¥’¢’•÷Ä'.split('_'),
            'accusative': '’∞’∏÷Ç’∂’æ’°÷Ä’´_÷É’•’ø÷Ä’æ’°÷Ä’´_’¥’°÷Ä’ø’´_’°’∫÷Ä’´’¨’´_’¥’°’µ’´’Ω’´_’∞’∏÷Ç’∂’´’Ω’´_’∞’∏÷Ç’¨’´’Ω’´_÷Ö’£’∏’Ω’ø’∏’Ω’´_’Ω’•’∫’ø’•’¥’¢’•÷Ä’´_’∞’∏’Ø’ø’•’¥’¢’•÷Ä’´_’∂’∏’µ’•’¥’¢’•÷Ä’´_’§’•’Ø’ø’•’¥’¢’•÷Ä’´'.split('_')
        },
        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
            'accusative' :
            'nominative';
        return months[nounCase][m.month()];
    }
    function hy_am__monthsShortCaseReplace(m, format) {
        var monthsShort = '’∞’∂’æ_÷É’ø÷Ä_’¥÷Ä’ø_’°’∫÷Ä_’¥’µ’Ω_’∞’∂’Ω_’∞’¨’Ω_÷Ö’£’Ω_’Ω’∫’ø_’∞’Ø’ø_’∂’¥’¢_’§’Ø’ø'.split('_');
        return monthsShort[m.month()];
    }
    function hy_am__weekdaysCaseReplace(m, format) {
        var weekdays = '’Ø’´÷Ä’°’Ø’´_’•÷Ä’Ø’∏÷Ç’∑’°’¢’©’´_’•÷Ä’•÷Ñ’∑’°’¢’©’´_’π’∏÷Ä’•÷Ñ’∑’°’¢’©’´_’∞’´’∂’£’∑’°’¢’©’´_’∏÷Ç÷Ä’¢’°’©_’∑’°’¢’°’©'.split('_');
        return weekdays[m.day()];
    }

    var hy_am = _moment__default.defineLocale('hy-am', {
        months : hy_am__monthsCaseReplace,
        monthsShort : hy_am__monthsShortCaseReplace,
        weekdays : hy_am__weekdaysCaseReplace,
        weekdaysShort : '’Ø÷Ä’Ø_’•÷Ä’Ø_’•÷Ä÷Ñ_’π÷Ä÷Ñ_’∞’∂’£_’∏÷Ç÷Ä’¢_’∑’¢’©'.split('_'),
        weekdaysMin : '’Ø÷Ä’Ø_’•÷Ä’Ø_’•÷Ä÷Ñ_’π÷Ä÷Ñ_’∞’∂’£_’∏÷Ç÷Ä’¢_’∑’¢’©'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY ’©.',
            LLL : 'D MMMM YYYY ’©., LT',
            LLLL : 'dddd, D MMMM YYYY ’©., LT'
        },
        calendar : {
            sameDay: '[’°’µ’Ω÷Ö÷Ä] LT',
            nextDay: '[’æ’°’≤’®] LT',
            lastDay: '[’•÷Ä’•’Ø] LT',
            nextWeek: function () {
                return 'dddd [÷Ö÷Ä’® ’™’°’¥’®] LT';
            },
            lastWeek: function () {
                return '[’°’∂÷Å’°’Æ] dddd [÷Ö÷Ä’® ’™’°’¥’®] LT';
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : '%s ’∞’•’ø’∏',
            past : '%s ’°’º’°’ª',
            s : '’¥’´ ÷Ñ’°’∂’´ ’æ’°’µ÷Ä’Ø’µ’°’∂',
            m : '÷Ä’∏’∫’•',
            mm : '%d ÷Ä’∏’∫’•',
            h : '’™’°’¥',
            hh : '%d ’™’°’¥',
            d : '÷Ö÷Ä',
            dd : '%d ÷Ö÷Ä',
            M : '’°’¥’´’Ω',
            MM : '%d ’°’¥’´’Ω',
            y : '’ø’°÷Ä’´',
            yy : '%d ’ø’°÷Ä’´'
        },
        meridiemParse: /’£’´’∑’•÷Ä’æ’°|’°’º’°’æ’∏’ø’æ’°|÷Å’•÷Ä’•’Ø’æ’°|’•÷Ä’•’Ø’∏’µ’°’∂/,
        isPM: function (input) {
            return /^(÷Å’•÷Ä’•’Ø’æ’°|’•÷Ä’•’Ø’∏’µ’°’∂)$/.test(input);
        },
        meridiem : function (hour) {
            if (hour < 4) {
                return '’£’´’∑’•÷Ä’æ’°';
            } else if (hour < 12) {
                return '’°’º’°’æ’∏’ø’æ’°';
            } else if (hour < 17) {
                return '÷Å’•÷Ä’•’Ø’æ’°';
            } else {
                return '’•÷Ä’•’Ø’∏’µ’°’∂';
            }
        },
        ordinalParse: /\d{1,2}|\d{1,2}-(’´’∂|÷Ä’§)/,
        ordinal: function (number, period) {
            switch (period) {
            case 'DDD':
            case 'w':
            case 'W':
            case 'DDDo':
                if (number === 1) {
                    return number + '-’´’∂';
                }
                return number + '-÷Ä’§';
            default:
                return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Bahasa Indonesia (id)
    //! author : Mohammad Satrio Utomo : https://github.com/tyok
    //! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan

    var id = _moment__default.defineLocale('id', {
        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des'.split('_'),
        weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
        weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'LT.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] LT',
            LLLL : 'dddd, D MMMM YYYY [pukul] LT'
        },
        meridiemParse: /pagi|siang|sore|malam/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'siang') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'sore' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'siang';
            } else if (hours < 19) {
                return 'sore';
            } else {
                return 'malam';
            }
        },
        calendar : {
            sameDay : '[Hari ini pukul] LT',
            nextDay : '[Besok pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kemarin pukul] LT',
            lastWeek : 'dddd [lalu pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dalam %s',
            past : '%s yang lalu',
            s : 'beberapa detik',
            m : 'semenit',
            mm : '%d menit',
            h : 'sejam',
            hh : '%d jam',
            d : 'sehari',
            dd : '%d hari',
            M : 'sebulan',
            MM : '%d bulan',
            y : 'setahun',
            yy : '%d tahun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : icelandic (is)
    //! author : Hinrik √ñrn Sigur√∞sson : https://github.com/hinrik

    function is__plural(n) {
        if (n % 100 === 11) {
            return true;
        } else if (n % 10 === 1) {
            return false;
        }
        return true;
    }
    function is__translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
        case 's':
            return withoutSuffix || isFuture ? 'nokkrar sek√∫ndur' : 'nokkrum sek√∫ndum';
        case 'm':
            return withoutSuffix ? 'm√≠n√∫ta' : 'm√≠n√∫tu';
        case 'mm':
            if (is__plural(number)) {
                return result + (withoutSuffix || isFuture ? 'm√≠n√∫tur' : 'm√≠n√∫tum');
            } else if (withoutSuffix) {
                return result + 'm√≠n√∫ta';
            }
            return result + 'm√≠n√∫tu';
        case 'hh':
            if (is__plural(number)) {
                return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
            }
            return result + 'klukkustund';
        case 'd':
            if (withoutSuffix) {
                return 'dagur';
            }
            return isFuture ? 'dag' : 'degi';
        case 'dd':
            if (is__plural(number)) {
                if (withoutSuffix) {
                    return result + 'dagar';
                }
                return result + (isFuture ? 'daga' : 'd√∂gum');
            } else if (withoutSuffix) {
                return result + 'dagur';
            }
            return result + (isFuture ? 'dag' : 'degi');
        case 'M':
            if (withoutSuffix) {
                return 'm√°nu√∞ur';
            }
            return isFuture ? 'm√°nu√∞' : 'm√°nu√∞i';
        case 'MM':
            if (is__plural(number)) {
                if (withoutSuffix) {
                    return result + 'm√°nu√∞ir';
                }
                return result + (isFuture ? 'm√°nu√∞i' : 'm√°nu√∞um');
            } else if (withoutSuffix) {
                return result + 'm√°nu√∞ur';
            }
            return result + (isFuture ? 'm√°nu√∞' : 'm√°nu√∞i');
        case 'y':
            return withoutSuffix || isFuture ? '√°r' : '√°ri';
        case 'yy':
            if (is__plural(number)) {
                return result + (withoutSuffix || isFuture ? '√°r' : '√°rum');
            }
            return result + (withoutSuffix || isFuture ? '√°r' : '√°ri');
        }
    }

    var is = _moment__default.defineLocale('is', {
        months : 'jan√∫ar_febr√∫ar_mars_apr√≠l_ma√≠_j√∫n√≠_j√∫l√≠_√°g√∫st_september_okt√≥ber_n√≥vember_desember'.split('_'),
        monthsShort : 'jan_feb_mar_apr_ma√≠_j√∫n_j√∫l_√°g√∫_sep_okt_n√≥v_des'.split('_'),
        weekdays : 'sunnudagur_m√°nudagur_√æri√∞judagur_mi√∞vikudagur_fimmtudagur_f√∂studagur_laugardagur'.split('_'),
        weekdaysShort : 'sun_m√°n_√æri_mi√∞_fim_f√∂s_lau'.split('_'),
        weekdaysMin : 'Su_M√°_√ûr_Mi_Fi_F√∂_La'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY [kl.] LT',
            LLLL : 'dddd, D. MMMM YYYY [kl.] LT'
        },
        calendar : {
            sameDay : '[√≠ dag kl.] LT',
            nextDay : '[√° morgun kl.] LT',
            nextWeek : 'dddd [kl.] LT',
            lastDay : '[√≠ g√¶r kl.] LT',
            lastWeek : '[s√≠√∞asta] dddd [kl.] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'eftir %s',
            past : 'fyrir %s s√≠√∞an',
            s : is__translate,
            m : is__translate,
            mm : is__translate,
            h : 'klukkustund',
            hh : is__translate,
            d : is__translate,
            dd : is__translate,
            M : is__translate,
            MM : is__translate,
            y : is__translate,
            yy : is__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : italian (it)
    //! author : Lorenzo : https://github.com/aliem
    //! author: Mattia Larentis: https://github.com/nostalgiaz

    var it = _moment__default.defineLocale('it', {
        months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
        monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
        weekdays : 'Domenica_Luned√¨_Marted√¨_Mercoled√¨_Gioved√¨_Venerd√¨_Sabato'.split('_'),
        weekdaysShort : 'Dom_Lun_Mar_Mer_Gio_Ven_Sab'.split('_'),
        weekdaysMin : 'D_L_Ma_Me_G_V_S'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd, D MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[Oggi alle] LT',
            nextDay: '[Domani alle] LT',
            nextWeek: 'dddd [alle] LT',
            lastDay: '[Ieri alle] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[la scorsa] dddd [alle] LT';
                    default:
                        return '[lo scorso] dddd [alle] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : function (s) {
                return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
            },
            past : '%s fa',
            s : 'alcuni secondi',
            m : 'un minuto',
            mm : '%d minuti',
            h : 'un\'ora',
            hh : '%d ore',
            d : 'un giorno',
            dd : '%d giorni',
            M : 'un mese',
            MM : '%d mesi',
            y : 'un anno',
            yy : '%d anni'
        },
        ordinalParse : /\d{1,2}¬∫/,
        ordinal: '%d¬∫',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : japanese (ja)
    //! author : LI Long : https://github.com/baryon

    var ja = _moment__default.defineLocale('ja', {
        months : '1Êúà_2Êúà_3Êúà_4Êúà_5Êúà_6Êúà_7Êúà_8Êúà_9Êúà_10Êúà_11Êúà_12Êúà'.split('_'),
        monthsShort : '1Êúà_2Êúà_3Êúà_4Êúà_5Êúà_6Êúà_7Êúà_8Êúà_9Êúà_10Êúà_11Êúà_12Êúà'.split('_'),
        weekdays : 'Êó•ÊõúÊó•_ÊúàÊõúÊó•_ÁÅ´ÊõúÊó•_Ê∞¥ÊõúÊó•_Êú®ÊõúÊó•_ÈáëÊõúÊó•_ÂúüÊõúÊó•'.split('_'),
        weekdaysShort : 'Êó•_Êúà_ÁÅ´_Ê∞¥_Êú®_Èáë_Âúü'.split('_'),
        weekdaysMin : 'Êó•_Êúà_ÁÅ´_Ê∞¥_Êú®_Èáë_Âúü'.split('_'),
        longDateFormat : {
            LT : 'AhÊôÇmÂàÜ',
            LTS : 'LTsÁßí',
            L : 'YYYY/MM/DD',
            LL : 'YYYYÂπ¥MÊúàDÊó•',
            LLL : 'YYYYÂπ¥MÊúàDÊó•LT',
            LLLL : 'YYYYÂπ¥MÊúàDÊó•LT dddd'
        },
        meridiemParse: /ÂçàÂâç|ÂçàÂæå/i,
        isPM : function (input) {
            return input === 'ÂçàÂæå';
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ÂçàÂâç';
            } else {
                return 'ÂçàÂæå';
            }
        },
        calendar : {
            sameDay : '[‰ªäÊó•] LT',
            nextDay : '[ÊòéÊó•] LT',
            nextWeek : '[Êù•ÈÄ±]dddd LT',
            lastDay : '[Êò®Êó•] LT',
            lastWeek : '[ÂâçÈÄ±]dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%sÂæå',
            past : '%sÂâç',
            s : 'Êï∞Áßí',
            m : '1ÂàÜ',
            mm : '%dÂàÜ',
            h : '1ÊôÇÈñì',
            hh : '%dÊôÇÈñì',
            d : '1Êó•',
            dd : '%dÊó•',
            M : '1„É∂Êúà',
            MM : '%d„É∂Êúà',
            y : '1Âπ¥',
            yy : '%dÂπ¥'
        }
    });

    //! moment.js locale configuration
    //! locale : Boso Jowo (jv)
    //! author : Rony Lantip : https://github.com/lantip
    //! reference: http://jv.wikipedia.org/wiki/Basa_Jawa

    var jv = _moment__default.defineLocale('jv', {
        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
        weekdays : 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
        weekdaysShort : 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'LT.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] LT',
            LLLL : 'dddd, D MMMM YYYY [pukul] LT'
        },
        meridiemParse: /enjing|siyang|sonten|ndalu/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'enjing') {
                return hour;
            } else if (meridiem === 'siyang') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'enjing';
            } else if (hours < 15) {
                return 'siyang';
            } else if (hours < 19) {
                return 'sonten';
            } else {
                return 'ndalu';
            }
        },
        calendar : {
            sameDay : '[Dinten puniko pukul] LT',
            nextDay : '[Mbenjang pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kala wingi pukul] LT',
            lastWeek : 'dddd [kepengker pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'wonten ing %s',
            past : '%s ingkang kepengker',
            s : 'sawetawis detik',
            m : 'setunggal menit',
            mm : '%d menit',
            h : 'setunggal jam',
            hh : '%d jam',
            d : 'sedinten',
            dd : '%d dinten',
            M : 'sewulan',
            MM : '%d wulan',
            y : 'setaun',
            yy : '%d taun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Georgian (ka)
    //! author : Irakli Janiashvili : https://github.com/irakli-janiashvili

    function ka__monthsCaseReplace(m, format) {
        var months = {
            'nominative': '·Éò·Éê·Éú·Éï·Éê·É†·Éò_·Éó·Éî·Éë·Éî·É†·Éï·Éê·Éö·Éò_·Éõ·Éê·É†·É¢·Éò_·Éê·Éû·É†·Éò·Éö·Éò_·Éõ·Éê·Éò·É°·Éò_·Éò·Éï·Éú·Éò·É°·Éò_·Éò·Éï·Éö·Éò·É°·Éò_·Éê·Éí·Éï·Éò·É°·É¢·Éù_·É°·Éî·É•·É¢·Éî·Éõ·Éë·Éî·É†·Éò_·Éù·É•·É¢·Éù·Éõ·Éë·Éî·É†·Éò_·Éú·Éù·Éî·Éõ·Éë·Éî·É†·Éò_·Éì·Éî·Éô·Éî·Éõ·Éë·Éî·É†·Éò'.split('_'),
            'accusative': '·Éò·Éê·Éú·Éï·Éê·É†·É°_·Éó·Éî·Éë·Éî·É†·Éï·Éê·Éö·É°_·Éõ·Éê·É†·É¢·É°_·Éê·Éû·É†·Éò·Éö·Éò·É°_·Éõ·Éê·Éò·É°·É°_·Éò·Éï·Éú·Éò·É°·É°_·Éò·Éï·Éö·Éò·É°·É°_·Éê·Éí·Éï·Éò·É°·É¢·É°_·É°·Éî·É•·É¢·Éî·Éõ·Éë·Éî·É†·É°_·Éù·É•·É¢·Éù·Éõ·Éë·Éî·É†·É°_·Éú·Éù·Éî·Éõ·Éë·Éî·É†·É°_·Éì·Éî·Éô·Éî·Éõ·Éë·Éî·É†·É°'.split('_')
        },
        nounCase = (/D[oD] *MMMM?/).test(format) ?
            'accusative' :
            'nominative';
        return months[nounCase][m.month()];
    }
    function ka__weekdaysCaseReplace(m, format) {
        var weekdays = {
            'nominative': '·Éô·Éï·Éò·É†·Éê_·Éù·É†·É®·Éê·Éë·Éê·Éó·Éò_·É°·Éê·Éõ·É®·Éê·Éë·Éê·Éó·Éò_·Éù·Éó·ÉÆ·É®·Éê·Éë·Éê·Éó·Éò_·ÉÆ·É£·Éó·É®·Éê·Éë·Éê·Éó·Éò_·Éû·Éê·É†·Éê·É°·Éô·Éî·Éï·Éò_·É®·Éê·Éë·Éê·Éó·Éò'.split('_'),
            'accusative': '·Éô·Éï·Éò·É†·Éê·É°_·Éù·É†·É®·Éê·Éë·Éê·Éó·É°_·É°·Éê·Éõ·É®·Éê·Éë·Éê·Éó·É°_·Éù·Éó·ÉÆ·É®·Éê·Éë·Éê·Éó·É°_·ÉÆ·É£·Éó·É®·Éê·Éë·Éê·Éó·É°_·Éû·Éê·É†·Éê·É°·Éô·Éî·Éï·É°_·É®·Éê·Éë·Éê·Éó·É°'.split('_')
        },
        nounCase = (/(·É¨·Éò·Éú·Éê|·É®·Éî·Éõ·Éì·Éî·Éí)/).test(format) ?
            'accusative' :
            'nominative';
        return weekdays[nounCase][m.day()];
    }

    var ka = _moment__default.defineLocale('ka', {
        months : ka__monthsCaseReplace,
        monthsShort : '·Éò·Éê·Éú_·Éó·Éî·Éë_·Éõ·Éê·É†_·Éê·Éû·É†_·Éõ·Éê·Éò_·Éò·Éï·Éú_·Éò·Éï·Éö_·Éê·Éí·Éï_·É°·Éî·É•_·Éù·É•·É¢_·Éú·Éù·Éî_·Éì·Éî·Éô'.split('_'),
        weekdays : ka__weekdaysCaseReplace,
        weekdaysShort : '·Éô·Éï·Éò_·Éù·É†·É®_·É°·Éê·Éõ_·Éù·Éó·ÉÆ_·ÉÆ·É£·Éó_·Éû·Éê·É†_·É®·Éê·Éë'.split('_'),
        weekdaysMin : '·Éô·Éï_·Éù·É†_·É°·Éê_·Éù·Éó_·ÉÆ·É£_·Éû·Éê_·É®·Éê'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd, D MMMM YYYY LT'
        },
        calendar : {
            sameDay : '[·Éì·É¶·Éî·É°] LT[-·Éñ·Éî]',
            nextDay : '[·ÉÆ·Éï·Éê·Éö] LT[-·Éñ·Éî]',
            lastDay : '[·Éí·É£·É®·Éò·Éú] LT[-·Éñ·Éî]',
            nextWeek : '[·É®·Éî·Éõ·Éì·Éî·Éí] dddd LT[-·Éñ·Éî]',
            lastWeek : '[·É¨·Éò·Éú·Éê] dddd LT-·Éñ·Éî',
            sameElse : 'L'
        },
        relativeTime : {
            future : function (s) {
                return (/(·É¨·Éê·Éõ·Éò|·É¨·É£·Éó·Éò|·É°·Éê·Éê·Éó·Éò|·É¨·Éî·Éö·Éò)/).test(s) ?
                    s.replace(/·Éò$/, '·É®·Éò') :
                    s + '·É®·Éò';
            },
            past : function (s) {
                if ((/(·É¨·Éê·Éõ·Éò|·É¨·É£·Éó·Éò|·É°·Éê·Éê·Éó·Éò|·Éì·É¶·Éî|·Éó·Éï·Éî)/).test(s)) {
                    return s.replace(/(·Éò|·Éî)$/, '·Éò·É° ·É¨·Éò·Éú');
                }
                if ((/·É¨·Éî·Éö·Éò/).test(s)) {
                    return s.replace(/·É¨·Éî·Éö·Éò$/, '·É¨·Éö·Éò·É° ·É¨·Éò·Éú');
                }
            },
            s : '·É†·Éê·Éõ·Éì·Éî·Éú·Éò·Éõ·Éî ·É¨·Éê·Éõ·Éò',
            m : '·É¨·É£·Éó·Éò',
            mm : '%d ·É¨·É£·Éó·Éò',
            h : '·É°·Éê·Éê·Éó·Éò',
            hh : '%d ·É°·Éê·Éê·Éó·Éò',
            d : '·Éì·É¶·Éî',
            dd : '%d ·Éì·É¶·Éî',
            M : '·Éó·Éï·Éî',
            MM : '%d ·Éó·Éï·Éî',
            y : '·É¨·Éî·Éö·Éò',
            yy : '%d ·É¨·Éî·Éö·Éò'
        },
        ordinalParse: /0|1-·Éö·Éò|·Éõ·Éî-\d{1,2}|\d{1,2}-·Éî/,
        ordinal : function (number) {
            if (number === 0) {
                return number;
            }
            if (number === 1) {
                return number + '-·Éö·Éò';
            }
            if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {
                return '·Éõ·Éî-' + number;
            }
            return number + '-·Éî';
        },
        week : {
            dow : 1,
            doy : 7
        }
    });

    //! moment.js locale configuration
    //! locale : khmer (km)
    //! author : Kruy Vanna : https://github.com/kruyvanna

    var km = _moment__default.defineLocale('km', {
        months: '·ûò·ûÄ·ûö·û∂_·ûÄ·ûª·ûò·üí·ûó·üà_·ûò·û∑·ûì·û∂_·ûò·üÅ·ûü·û∂_·ûß·ûü·ûó·û∂_·ûò·û∑·ûê·ûª·ûì·û∂_·ûÄ·ûÄ·üí·ûÄ·ûä·û∂_·ûü·û∏·û†·û∂_·ûÄ·ûâ·üí·ûâ·û∂_·ûè·ûª·ûõ·û∂_·ûú·û∑·ûÖ·üí·ûÜ·û∑·ûÄ·û∂_·ûí·üí·ûì·ûº'.split('_'),
        monthsShort: '·ûò·ûÄ·ûö·û∂_·ûÄ·ûª·ûò·üí·ûó·üà_·ûò·û∑·ûì·û∂_·ûò·üÅ·ûü·û∂_·ûß·ûü·ûó·û∂_·ûò·û∑·ûê·ûª·ûì·û∂_·ûÄ·ûÄ·üí·ûÄ·ûä·û∂_·ûü·û∏·û†·û∂_·ûÄ·ûâ·üí·ûâ·û∂_·ûè·ûª·ûõ·û∂_·ûú·û∑·ûÖ·üí·ûÜ·û∑·ûÄ·û∂_·ûí·üí·ûì·ûº'.split('_'),
        weekdays: '·û¢·û∂·ûë·û∑·ûè·üí·ûô_·ûÖ·üê·ûì·üí·ûë_·û¢·ûÑ·üí·ûÇ·û∂·ûö_·ûñ·ûª·ûí_·ûñ·üí·ûö·û†·ûü·üí·ûî·ûè·û∑·üç_·ûü·ûª·ûÄ·üí·ûö_·ûü·üÖ·ûö·üç'.split('_'),
        weekdaysShort: '·û¢·û∂·ûë·û∑·ûè·üí·ûô_·ûÖ·üê·ûì·üí·ûë_·û¢·ûÑ·üí·ûÇ·û∂·ûö_·ûñ·ûª·ûí_·ûñ·üí·ûö·û†·ûü·üí·ûî·ûè·û∑·üç_·ûü·ûª·ûÄ·üí·ûö_·ûü·üÖ·ûö·üç'.split('_'),
        weekdaysMin: '·û¢·û∂·ûë·û∑·ûè·üí·ûô_·ûÖ·üê·ûì·üí·ûë_·û¢·ûÑ·üí·ûÇ·û∂·ûö_·ûñ·ûª·ûí_·ûñ·üí·ûö·û†·ûü·üí·ûî·ûè·û∑·üç_·ûü·ûª·ûÄ·üí·ûö_·ûü·üÖ·ûö·üç'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS : 'LT:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY LT',
            LLLL: 'dddd, D MMMM YYYY LT'
        },
        calendar: {
            sameDay: '[·ûê·üí·ûÑ·üÉ·ûì·üà ·ûò·üâ·üÑ·ûÑ] LT',
            nextDay: '[·ûü·üí·û¢·üÇ·ûÄ ·ûò·üâ·üÑ·ûÑ] LT',
            nextWeek: 'dddd [·ûò·üâ·üÑ·ûÑ] LT',
            lastDay: '[·ûò·üí·ûü·û∑·ûõ·ûò·û∑·ûâ ·ûò·üâ·üÑ·ûÑ] LT',
            lastWeek: 'dddd [·ûü·ûî·üí·ûè·û∂·û†·üç·ûò·ûª·ûì] [·ûò·üâ·üÑ·ûÑ] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s·ûë·üÄ·ûè',
            past: '%s·ûò·ûª·ûì',
            s: '·ûî·üâ·ûª·ûì·üí·ûò·û∂·ûì·ûú·û∑·ûì·û∂·ûë·û∏',
            m: '·ûò·ûΩ·ûô·ûì·û∂·ûë·û∏',
            mm: '%d ·ûì·û∂·ûë·û∏',
            h: '·ûò·ûΩ·ûô·ûò·üâ·üÑ·ûÑ',
            hh: '%d ·ûò·üâ·üÑ·ûÑ',
            d: '·ûò·ûΩ·ûô·ûê·üí·ûÑ·üÉ',
            dd: '%d ·ûê·üí·ûÑ·üÉ',
            M: '·ûò·ûΩ·ûô·ûÅ·üÇ',
            MM: '%d ·ûÅ·üÇ',
            y: '·ûò·ûΩ·ûô·ûÜ·üí·ûì·û∂·üÜ',
            yy: '%d ·ûÜ·üí·ûì·û∂·üÜ'
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : korean (ko)
    //!
    //! authors
    //!
    //! - Kyungwook, Park : https://github.com/kyungw00k
    //! - Jeeeyul Lee <jeeeyul@gmail.com>

    var ko = _moment__default.defineLocale('ko', {
        months : '1Ïõî_2Ïõî_3Ïõî_4Ïõî_5Ïõî_6Ïõî_7Ïõî_8Ïõî_9Ïõî_10Ïõî_11Ïõî_12Ïõî'.split('_'),
        monthsShort : '1Ïõî_2Ïõî_3Ïõî_4Ïõî_5Ïõî_6Ïõî_7Ïõî_8Ïõî_9Ïõî_10Ïõî_11Ïõî_12Ïõî'.split('_'),
        weekdays : 'ÏùºÏöîÏùº_ÏõîÏöîÏùº_ÌôîÏöîÏùº_ÏàòÏöîÏùº_Î™©ÏöîÏùº_Í∏àÏöîÏùº_ÌÜ†ÏöîÏùº'.split('_'),
        weekdaysShort : 'Ïùº_Ïõî_Ìôî_Ïàò_Î™©_Í∏à_ÌÜ†'.split('_'),
        weekdaysMin : 'Ïùº_Ïõî_Ìôî_Ïàò_Î™©_Í∏à_ÌÜ†'.split('_'),
        longDateFormat : {
            LT : 'A hÏãú mÎ∂Ñ',
            LTS : 'A hÏãú mÎ∂Ñ sÏ¥à',
            L : 'YYYY.MM.DD',
            LL : 'YYYYÎÖÑ MMMM DÏùº',
            LLL : 'YYYYÎÖÑ MMMM DÏùº LT',
            LLLL : 'YYYYÎÖÑ MMMM DÏùº dddd LT'
        },
        calendar : {
            sameDay : 'Ïò§Îäò LT',
            nextDay : 'ÎÇ¥Ïùº LT',
            nextWeek : 'dddd LT',
            lastDay : 'Ïñ¥Ï†ú LT',
            lastWeek : 'ÏßÄÎÇúÏ£º dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ÌõÑ',
            past : '%s Ï†Ñ',
            s : 'Î™áÏ¥à',
            ss : '%dÏ¥à',
            m : 'ÏùºÎ∂Ñ',
            mm : '%dÎ∂Ñ',
            h : 'ÌïúÏãúÍ∞Ñ',
            hh : '%dÏãúÍ∞Ñ',
            d : 'ÌïòÎ£®',
            dd : '%dÏùº',
            M : 'ÌïúÎã¨',
            MM : '%dÎã¨',
            y : 'ÏùºÎÖÑ',
            yy : '%dÎÖÑ'
        },
        ordinalParse : /\d{1,2}Ïùº/,
        ordinal : '%dÏùº',
        meridiemParse : /Ïò§Ï†Ñ|Ïò§ÌõÑ/,
        isPM : function (token) {
            return token === 'Ïò§ÌõÑ';
        },
        meridiem : function (hour, minute, isUpper) {
            return hour < 12 ? 'Ïò§Ï†Ñ' : 'Ïò§ÌõÑ';
        }
    });

    //! moment.js locale configuration
    //! locale : Luxembourgish (lb)
    //! author : mweimerskirch : https://github.com/mweimerskirch, David Raison : https://github.com/kwisatz

    function lb__processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eng Minutt', 'enger Minutt'],
            'h': ['eng Stonn', 'enger Stonn'],
            'd': ['een Dag', 'engem Dag'],
            'M': ['ee Mount', 'engem Mount'],
            'y': ['ee Joer', 'engem Joer']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }
    function processFutureTime(string) {
        var number = string.substr(0, string.indexOf(' '));
        if (eifelerRegelAppliesToNumber(number)) {
            return 'a ' + string;
        }
        return 'an ' + string;
    }
    function processPastTime(string) {
        var number = string.substr(0, string.indexOf(' '));
        if (eifelerRegelAppliesToNumber(number)) {
            return 'viru ' + string;
        }
        return 'virun ' + string;
    }
    /**
     * Returns true if the word before the given number loses the '-n' ending.
     * e.g. 'an 10 Deeg' but 'a 5 Deeg'
     *
     * @param number {integer}
     * @returns {boolean}
     */
    function eifelerRegelAppliesToNumber(number) {
        number = parseInt(number, 10);
        if (isNaN(number)) {
            return false;
        }
        if (number < 0) {
            // Negative Number --> always true
            return true;
        } else if (number < 10) {
            // Only 1 digit
            if (4 <= number && number <= 7) {
                return true;
            }
            return false;
        } else if (number < 100) {
            // 2 digits
            var lastDigit = number % 10, firstDigit = number / 10;
            if (lastDigit === 0) {
                return eifelerRegelAppliesToNumber(firstDigit);
            }
            return eifelerRegelAppliesToNumber(lastDigit);
        } else if (number < 10000) {
            // 3 or 4 digits --> recursively check first digit
            while (number >= 10) {
                number = number / 10;
            }
            return eifelerRegelAppliesToNumber(number);
        } else {
            // Anything larger than 4 digits: recursively check first n-3 digits
            number = number / 1000;
            return eifelerRegelAppliesToNumber(number);
        }
    }

    var lb = _moment__default.defineLocale('lb', {
        months: 'Januar_Februar_M√§erz_Abr√´ll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
        weekdays: 'Sonndeg_M√©indeg_D√´nschdeg_M√´ttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
        weekdaysShort: 'So._M√©._D√´._M√´._Do._Fr._Sa.'.split('_'),
        weekdaysMin: 'So_M√©_D√´_M√´_Do_Fr_Sa'.split('_'),
        longDateFormat: {
            LT: 'H:mm [Auer]',
            LTS: 'H:mm:ss [Auer]',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY LT',
            LLLL: 'dddd, D. MMMM YYYY LT'
        },
        calendar: {
            sameDay: '[Haut um] LT',
            sameElse: 'L',
            nextDay: '[Muer um] LT',
            nextWeek: 'dddd [um] LT',
            lastDay: '[G√´schter um] LT',
            lastWeek: function () {
                // Different date string for 'D√´nschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
                switch (this.day()) {
                    case 2:
                    case 4:
                        return '[Leschten] dddd [um] LT';
                    default:
                        return '[Leschte] dddd [um] LT';
                }
            }
        },
        relativeTime : {
            future : processFutureTime,
            past : processPastTime,
            s : 'e puer Sekonnen',
            m : lb__processRelativeTime,
            mm : '%d Minutten',
            h : lb__processRelativeTime,
            hh : '%d Stonnen',
            d : lb__processRelativeTime,
            dd : '%d Deeg',
            M : lb__processRelativeTime,
            MM : '%d M√©int',
            y : lb__processRelativeTime,
            yy : '%d Joer'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Lithuanian (lt)
    //! author : Mindaugas Moz≈´ras : https://github.com/mmozuras

    var lt__units = {
        'm' : 'minutƒó_minutƒós_minutƒô',
        'mm': 'minutƒós_minuƒçi≈≥_minutes',
        'h' : 'valanda_valandos_valandƒÖ',
        'hh': 'valandos_valand≈≥_valandas',
        'd' : 'diena_dienos_dienƒÖ',
        'dd': 'dienos_dien≈≥_dienas',
        'M' : 'mƒónuo_mƒónesio_mƒónesƒØ',
        'MM': 'mƒónesiai_mƒónesi≈≥_mƒónesius',
        'y' : 'metai_met≈≥_metus',
        'yy': 'metai_met≈≥_metus'
    },
    weekDays = 'sekmadienis_pirmadienis_antradienis_treƒçiadienis_ketvirtadienis_penktadienis_≈°e≈°tadienis'.split('_');
    function translateSeconds(number, withoutSuffix, key, isFuture) {
        if (withoutSuffix) {
            return 'kelios sekundƒós';
        } else {
            return isFuture ? 'keli≈≥ sekund≈æi≈≥' : 'kelias sekundes';
        }
    }
    function translateSingular(number, withoutSuffix, key, isFuture) {
        return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
    }
    function special(number) {
        return number % 10 === 0 || (number > 10 && number < 20);
    }
    function forms(key) {
        return lt__units[key].split('_');
    }
    function lt__translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        if (number === 1) {
            return result + translateSingular(number, withoutSuffix, key[0], isFuture);
        } else if (withoutSuffix) {
            return result + (special(number) ? forms(key)[1] : forms(key)[0]);
        } else {
            if (isFuture) {
                return result + forms(key)[1];
            } else {
                return result + (special(number) ? forms(key)[1] : forms(key)[2]);
            }
        }
    }
    function relativeWeekDay(moment, format) {
        var nominative = format.indexOf('dddd HH:mm') === -1,
            weekDay = weekDays[moment.day()];
        return nominative ? weekDay : weekDay.substring(0, weekDay.length - 2) + 'ƒØ';
    }

    var lt = _moment__default.defineLocale('lt', {
        months : 'sausio_vasario_kovo_baland≈æio_gegu≈æƒós_bir≈æelio_liepos_rugpj≈´ƒçio_rugsƒójo_spalio_lapkriƒçio_gruod≈æio'.split('_'),
        monthsShort : 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
        weekdays : relativeWeekDay,
        weekdaysShort : 'Sek_Pir_Ant_Tre_Ket_Pen_≈†e≈°'.split('_'),
        weekdaysMin : 'S_P_A_T_K_Pn_≈†'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'YYYY-MM-DD',
            LL : 'YYYY [m.] MMMM D [d.]',
            LLL : 'YYYY [m.] MMMM D [d.], LT [val.]',
            LLLL : 'YYYY [m.] MMMM D [d.], dddd, LT [val.]',
            l : 'YYYY-MM-DD',
            ll : 'YYYY [m.] MMMM D [d.]',
            lll : 'YYYY [m.] MMMM D [d.], LT [val.]',
            llll : 'YYYY [m.] MMMM D [d.], ddd, LT [val.]'
        },
        calendar : {
            sameDay : '[≈†iandien] LT',
            nextDay : '[Rytoj] LT',
            nextWeek : 'dddd LT',
            lastDay : '[Vakar] LT',
            lastWeek : '[PraƒójusƒØ] dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'po %s',
            past : 'prie≈° %s',
            s : translateSeconds,
            m : translateSingular,
            mm : lt__translate,
            h : translateSingular,
            hh : lt__translate,
            d : translateSingular,
            dd : lt__translate,
            M : translateSingular,
            MM : lt__translate,
            y : translateSingular,
            yy : lt__translate
        },
        ordinalParse: /\d{1,2}-oji/,
        ordinal : function (number) {
            return number + '-oji';
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : latvian (lv)
    //! author : Kristaps Karlsons : https://github.com/skakri
    //! author : JƒÅnis Elmeris : https://github.com/JanisE

    var lv__units = {
        'm': 'min≈´tes_min≈´tƒìm_min≈´te_min≈´tes'.split('_'),
        'mm': 'min≈´tes_min≈´tƒìm_min≈´te_min≈´tes'.split('_'),
        'h': 'stundas_stundƒÅm_stunda_stundas'.split('_'),
        'hh': 'stundas_stundƒÅm_stunda_stundas'.split('_'),
        'd': 'dienas_dienƒÅm_diena_dienas'.split('_'),
        'dd': 'dienas_dienƒÅm_diena_dienas'.split('_'),
        'M': 'mƒìne≈°a_mƒìne≈°iem_mƒìnesis_mƒìne≈°i'.split('_'),
        'MM': 'mƒìne≈°a_mƒìne≈°iem_mƒìnesis_mƒìne≈°i'.split('_'),
        'y': 'gada_gadiem_gads_gadi'.split('_'),
        'yy': 'gada_gadiem_gads_gadi'.split('_')
    };
    /**
     * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
     */
    function lv__format(forms, number, withoutSuffix) {
        if (withoutSuffix) {
            // E.g. "21 min≈´te", "3 min≈´tes".
            return number % 10 === 1 && number !== 11 ? forms[2] : forms[3];
        } else {
            // E.g. "21 min≈´tes" as in "pƒìc 21 min≈´tes".
            // E.g. "3 min≈´tƒìm" as in "pƒìc 3 min≈´tƒìm".
            return number % 10 === 1 && number !== 11 ? forms[0] : forms[1];
        }
    }
    function lv__relativeTimeWithPlural(number, withoutSuffix, key) {
        return number + ' ' + lv__format(lv__units[key], number, withoutSuffix);
    }
    function relativeTimeWithSingular(number, withoutSuffix, key) {
        return lv__format(lv__units[key], number, withoutSuffix);
    }
    function relativeSeconds(number, withoutSuffix) {
        return withoutSuffix ? 'da≈æas sekundes' : 'da≈æƒÅm sekundƒìm';
    }

    var lv = _moment__default.defineLocale('lv', {
        months : 'janvƒÅris_februƒÅris_marts_aprƒ´lis_maijs_j≈´nijs_j≈´lijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
        monthsShort : 'jan_feb_mar_apr_mai_j≈´n_j≈´l_aug_sep_okt_nov_dec'.split('_'),
        weekdays : 'svƒìtdiena_pirmdiena_otrdiena_tre≈°diena_ceturtdiena_piektdiena_sestdiena'.split('_'),
        weekdaysShort : 'Sv_P_O_T_C_Pk_S'.split('_'),
        weekdaysMin : 'Sv_P_O_T_C_Pk_S'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD.MM.YYYY.',
            LL : 'YYYY. [gada] D. MMMM',
            LLL : 'YYYY. [gada] D. MMMM, LT',
            LLLL : 'YYYY. [gada] D. MMMM, dddd, LT'
        },
        calendar : {
            sameDay : '[≈†odien pulksten] LT',
            nextDay : '[Rƒ´t pulksten] LT',
            nextWeek : 'dddd [pulksten] LT',
            lastDay : '[Vakar pulksten] LT',
            lastWeek : '[PagƒÅju≈°ƒÅ] dddd [pulksten] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'pƒìc %s',
            past : 'pirms %s',
            s : relativeSeconds,
            m : relativeTimeWithSingular,
            mm : lv__relativeTimeWithPlural,
            h : relativeTimeWithSingular,
            hh : lv__relativeTimeWithPlural,
            d : relativeTimeWithSingular,
            dd : lv__relativeTimeWithPlural,
            M : relativeTimeWithSingular,
            MM : lv__relativeTimeWithPlural,
            y : relativeTimeWithSingular,
            yy : lv__relativeTimeWithPlural
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Montenegrin (me)
    //! author : Miodrag Nikaƒç <miodrag@restartit.me> : https://github.com/miodragnikac

    var me__translator = {
        words: { //Different grammatical cases
            m: ['jedan minut', 'jednog minuta'],
            mm: ['minut', 'minuta', 'minuta'],
            h: ['jedan sat', 'jednog sata'],
            hh: ['sat', 'sata', 'sati'],
            dd: ['dan', 'dana', 'dana'],
            MM: ['mjesec', 'mjeseca', 'mjeseci'],
            yy: ['godina', 'godine', 'godina']
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = me__translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + ' ' + me__translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };

    var me = _moment__default.defineLocale('me', {
        months: ['januar', 'februar', 'mart', 'april', 'maj', 'jun', 'jul', 'avgust', 'septembar', 'oktobar', 'novembar', 'decembar'],
        monthsShort: ['jan.', 'feb.', 'mar.', 'apr.', 'maj', 'jun', 'jul', 'avg.', 'sep.', 'okt.', 'nov.', 'dec.'],
        weekdays: ['nedjelja', 'ponedjeljak', 'utorak', 'srijeda', 'ƒçetvrtak', 'petak', 'subota'],
        weekdaysShort: ['ned.', 'pon.', 'uto.', 'sri.', 'ƒçet.', 'pet.', 'sub.'],
        weekdaysMin: ['ne', 'po', 'ut', 'sr', 'ƒçe', 'pe', 'su'],
        longDateFormat: {
            LT: 'H:mm',
            LTS : 'LT:ss',
            L: 'DD. MM. YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY LT',
            LLLL: 'dddd, D. MMMM YYYY LT'
        },
        calendar: {
            sameDay: '[danas u] LT',
            nextDay: '[sjutra u] LT',

            nextWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[u] [nedjelju] [u] LT';
                case 3:
                    return '[u] [srijedu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[juƒçe u] LT',
            lastWeek : function () {
                var lastWeekDays = [
                    '[pro≈°le] [nedjelje] [u] LT',
                    '[pro≈°log] [ponedjeljka] [u] LT',
                    '[pro≈°log] [utorka] [u] LT',
                    '[pro≈°le] [srijede] [u] LT',
                    '[pro≈°log] [ƒçetvrtka] [u] LT',
                    '[pro≈°log] [petka] [u] LT',
                    '[pro≈°le] [subote] [u] LT'
                ];
                return lastWeekDays[this.day()];
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'prije %s',
            s      : 'nekoliko sekundi',
            m      : me__translator.translate,
            mm     : me__translator.translate,
            h      : me__translator.translate,
            hh     : me__translator.translate,
            d      : 'dan',
            dd     : me__translator.translate,
            M      : 'mjesec',
            MM     : me__translator.translate,
            y      : 'godinu',
            yy     : me__translator.translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : macedonian (mk)
    //! author : Borislav Mickov : https://github.com/B0k0

    var mk = _moment__default.defineLocale('mk', {
        months : '—ò–∞–Ω—É–∞—Ä–∏_—Ñ–µ–≤—Ä—É–∞—Ä–∏_–º–∞—Ä—Ç_–∞–ø—Ä–∏–ª_–º–∞—ò_—ò—É–Ω–∏_—ò—É–ª–∏_–∞–≤–≥—É—Å—Ç_—Å–µ–ø—Ç–µ–º–≤—Ä–∏_–æ–∫—Ç–æ–º–≤—Ä–∏_–Ω–æ–µ–º–≤—Ä–∏_–¥–µ–∫–µ–º–≤—Ä–∏'.split('_'),
        monthsShort : '—ò–∞–Ω_—Ñ–µ–≤_–º–∞—Ä_–∞–ø—Ä_–º–∞—ò_—ò—É–Ω_—ò—É–ª_–∞–≤–≥_—Å–µ–ø_–æ–∫—Ç_–Ω–æ–µ_–¥–µ–∫'.split('_'),
        weekdays : '–Ω–µ–¥–µ–ª–∞_–ø–æ–Ω–µ–¥–µ–ª–Ω–∏–∫_–≤—Ç–æ—Ä–Ω–∏–∫_—Å—Ä–µ–¥–∞_—á–µ—Ç–≤—Ä—Ç–æ–∫_–ø–µ—Ç–æ–∫_—Å–∞–±–æ—Ç–∞'.split('_'),
        weekdaysShort : '–Ω–µ–¥_–ø–æ–Ω_–≤—Ç–æ_—Å—Ä–µ_—á–µ—Ç_–ø–µ—Ç_—Å–∞–±'.split('_'),
        weekdaysMin : '–Ωe_–øo_–≤—Ç_—Å—Ä_—á–µ_–ø–µ_—Åa'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'LT:ss',
            L : 'D.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd, D MMMM YYYY LT'
        },
        calendar : {
            sameDay : '[–î–µ–Ω–µ—Å –≤–æ] LT',
            nextDay : '[–£—Ç—Ä–µ –≤–æ] LT',
            nextWeek : 'dddd [–≤–æ] LT',
            lastDay : '[–í—á–µ—Ä–∞ –≤–æ] LT',
            lastWeek : function () {
                switch (this.day()) {
                case 0:
                case 3:
                case 6:
                    return '[–í–æ –∏–∑–º–∏–Ω–∞—Ç–∞—Ç–∞] dddd [–≤–æ] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[–í–æ –∏–∑–º–∏–Ω–∞—Ç–∏–æ—Ç] dddd [–≤–æ] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : '–ø–æ—Å–ª–µ %s',
            past : '–ø—Ä–µ–¥ %s',
            s : '–Ω–µ–∫–æ–ª–∫—É —Å–µ–∫—É–Ω–¥–∏',
            m : '–º–∏–Ω—É—Ç–∞',
            mm : '%d –º–∏–Ω—É—Ç–∏',
            h : '—á–∞—Å',
            hh : '%d —á–∞—Å–∞',
            d : '–¥–µ–Ω',
            dd : '%d –¥–µ–Ω–∞',
            M : '–º–µ—Å–µ—Ü',
            MM : '%d –º–µ—Å–µ—Ü–∏',
            y : '–≥–æ–¥–∏–Ω–∞',
            yy : '%d –≥–æ–¥–∏–Ω–∏'
        },
        ordinalParse: /\d{1,2}-(–µ–≤|–µ–Ω|—Ç–∏|–≤–∏|—Ä–∏|–º–∏)/,
        ordinal : function (number) {
            var lastDigit = number % 10,
                last2Digits = number % 100;
            if (number === 0) {
                return number + '-–µ–≤';
            } else if (last2Digits === 0) {
                return number + '-–µ–Ω';
            } else if (last2Digits > 10 && last2Digits < 20) {
                return number + '-—Ç–∏';
            } else if (lastDigit === 1) {
                return number + '-–≤–∏';
            } else if (lastDigit === 2) {
                return number + '-—Ä–∏';
            } else if (lastDigit === 7 || lastDigit === 8) {
                return number + '-–º–∏';
            } else {
                return number + '-—Ç–∏';
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : malayalam (ml)
    //! author : Floyd Pink : https://github.com/floydpink

    var ml = _moment__default.defineLocale('ml', {
        months : '‡¥ú‡¥®‡µÅ‡¥µ‡¥∞‡¥ø_‡¥´‡µÜ‡¥¨‡µç‡¥∞‡µÅ‡¥µ‡¥∞‡¥ø_‡¥Æ‡¥æ‡µº‡¥ö‡µç‡¥ö‡µç_‡¥è‡¥™‡µç‡¥∞‡¥ø‡µΩ_‡¥Æ‡µá‡¥Ø‡µç_‡¥ú‡µÇ‡µ∫_‡¥ú‡µÇ‡¥≤‡µà_‡¥ì‡¥ó‡¥∏‡µç‡¥±‡µç‡¥±‡µç_‡¥∏‡µÜ‡¥™‡µç‡¥±‡µç‡¥±‡¥Ç‡¥¨‡µº_‡¥í‡¥ï‡µç‡¥ü‡µã‡¥¨‡µº_‡¥®‡¥µ‡¥Ç‡¥¨‡µº_‡¥°‡¥ø‡¥∏‡¥Ç‡¥¨‡µº'.split('_'),
        monthsShort : '‡¥ú‡¥®‡µÅ._‡¥´‡µÜ‡¥¨‡µç‡¥∞‡µÅ._‡¥Æ‡¥æ‡µº._‡¥è‡¥™‡µç‡¥∞‡¥ø._‡¥Æ‡µá‡¥Ø‡µç_‡¥ú‡µÇ‡µ∫_‡¥ú‡µÇ‡¥≤‡µà._‡¥ì‡¥ó._‡¥∏‡µÜ‡¥™‡µç‡¥±‡µç‡¥±._‡¥í‡¥ï‡µç‡¥ü‡µã._‡¥®‡¥µ‡¥Ç._‡¥°‡¥ø‡¥∏‡¥Ç.'.split('_'),
        weekdays : '‡¥û‡¥æ‡¥Ø‡¥±‡¥æ‡¥¥‡µç‡¥ö_‡¥§‡¥ø‡¥ô‡µç‡¥ï‡¥≥‡¥æ‡¥¥‡µç‡¥ö_‡¥ö‡µä‡¥µ‡µç‡¥µ‡¥æ‡¥¥‡µç‡¥ö_‡¥¨‡µÅ‡¥ß‡¥®‡¥æ‡¥¥‡µç‡¥ö_‡¥µ‡µç‡¥Ø‡¥æ‡¥¥‡¥æ‡¥¥‡µç‡¥ö_‡¥µ‡µÜ‡¥≥‡µç‡¥≥‡¥ø‡¥Ø‡¥æ‡¥¥‡µç‡¥ö_‡¥∂‡¥®‡¥ø‡¥Ø‡¥æ‡¥¥‡µç‡¥ö'.split('_'),
        weekdaysShort : '‡¥û‡¥æ‡¥Ø‡µº_‡¥§‡¥ø‡¥ô‡µç‡¥ï‡µæ_‡¥ö‡µä‡¥µ‡µç‡¥µ_‡¥¨‡µÅ‡¥ß‡µª_‡¥µ‡µç‡¥Ø‡¥æ‡¥¥‡¥Ç_‡¥µ‡µÜ‡¥≥‡µç‡¥≥‡¥ø_‡¥∂‡¥®‡¥ø'.split('_'),
        weekdaysMin : '‡¥û‡¥æ_‡¥§‡¥ø_‡¥ö‡µä_‡¥¨‡µÅ_‡¥µ‡µç‡¥Ø‡¥æ_‡¥µ‡µÜ_‡¥∂'.split('_'),
        longDateFormat : {
            LT : 'A h:mm -‡¥®‡µÅ',
            LTS : 'A h:mm:ss -‡¥®‡µÅ',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, LT',
            LLLL : 'dddd, D MMMM YYYY, LT'
        },
        calendar : {
            sameDay : '[‡¥á‡¥®‡µç‡¥®‡µç] LT',
            nextDay : '[‡¥®‡¥æ‡¥≥‡µÜ] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[‡¥á‡¥®‡µç‡¥®‡¥≤‡µÜ] LT',
            lastWeek : '[‡¥ï‡¥¥‡¥ø‡¥û‡µç‡¥û] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ‡¥ï‡¥¥‡¥ø‡¥û‡µç‡¥û‡µç',
            past : '%s ‡¥Æ‡µÅ‡µª‡¥™‡µç',
            s : '‡¥Ö‡µΩ‡¥™ ‡¥®‡¥ø‡¥Æ‡¥ø‡¥∑‡¥ô‡µç‡¥ô‡µæ',
            m : '‡¥í‡¥∞‡µÅ ‡¥Æ‡¥ø‡¥®‡¥ø‡¥±‡µç‡¥±‡µç',
            mm : '%d ‡¥Æ‡¥ø‡¥®‡¥ø‡¥±‡µç‡¥±‡µç',
            h : '‡¥í‡¥∞‡µÅ ‡¥Æ‡¥£‡¥ø‡¥ï‡µç‡¥ï‡µÇ‡µº',
            hh : '%d ‡¥Æ‡¥£‡¥ø‡¥ï‡µç‡¥ï‡µÇ‡µº',
            d : '‡¥í‡¥∞‡µÅ ‡¥¶‡¥ø‡¥µ‡¥∏‡¥Ç',
            dd : '%d ‡¥¶‡¥ø‡¥µ‡¥∏‡¥Ç',
            M : '‡¥í‡¥∞‡µÅ ‡¥Æ‡¥æ‡¥∏‡¥Ç',
            MM : '%d ‡¥Æ‡¥æ‡¥∏‡¥Ç',
            y : '‡¥í‡¥∞‡µÅ ‡¥µ‡µº‡¥∑‡¥Ç',
            yy : '%d ‡¥µ‡µº‡¥∑‡¥Ç'
        },
        meridiemParse: /‡¥∞‡¥æ‡¥§‡µç‡¥∞‡¥ø|‡¥∞‡¥æ‡¥µ‡¥ø‡¥≤‡µÜ|‡¥â‡¥ö‡µç‡¥ö ‡¥ï‡¥¥‡¥ø‡¥û‡µç‡¥û‡µç|‡¥µ‡µà‡¥ï‡µÅ‡¥®‡µç‡¥®‡µá‡¥∞‡¥Ç|‡¥∞‡¥æ‡¥§‡µç‡¥∞‡¥ø/i,
        isPM : function (input) {
            return /^(‡¥â‡¥ö‡µç‡¥ö ‡¥ï‡¥¥‡¥ø‡¥û‡µç‡¥û‡µç|‡¥µ‡µà‡¥ï‡µÅ‡¥®‡µç‡¥®‡µá‡¥∞‡¥Ç|‡¥∞‡¥æ‡¥§‡µç‡¥∞‡¥ø)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '‡¥∞‡¥æ‡¥§‡µç‡¥∞‡¥ø';
            } else if (hour < 12) {
                return '‡¥∞‡¥æ‡¥µ‡¥ø‡¥≤‡µÜ';
            } else if (hour < 17) {
                return '‡¥â‡¥ö‡µç‡¥ö ‡¥ï‡¥¥‡¥ø‡¥û‡µç‡¥û‡µç';
            } else if (hour < 20) {
                return '‡¥µ‡µà‡¥ï‡µÅ‡¥®‡µç‡¥®‡µá‡¥∞‡¥Ç';
            } else {
                return '‡¥∞‡¥æ‡¥§‡µç‡¥∞‡¥ø';
            }
        }
    });

    //! moment.js locale configuration
    //! locale : Marathi (mr)
    //! author : Harshad Kale : https://github.com/kalehv

    var mr__symbolMap = {
        '1': '‡•ß',
        '2': '‡•®',
        '3': '‡•©',
        '4': '‡•™',
        '5': '‡•´',
        '6': '‡•¨',
        '7': '‡•≠',
        '8': '‡•Æ',
        '9': '‡•Ø',
        '0': '‡•¶'
    },
    mr__numberMap = {
        '‡•ß': '1',
        '‡•®': '2',
        '‡•©': '3',
        '‡•™': '4',
        '‡•´': '5',
        '‡•¨': '6',
        '‡•≠': '7',
        '‡•Æ': '8',
        '‡•Ø': '9',
        '‡•¶': '0'
    };

    var mr = _moment__default.defineLocale('mr', {
        months : '‡§ú‡§æ‡§®‡•á‡§µ‡§æ‡§∞‡•Ä_‡§´‡•á‡§¨‡•ç‡§∞‡•Å‡§µ‡§æ‡§∞‡•Ä_‡§Æ‡§æ‡§∞‡•ç‡§ö_‡§è‡§™‡•ç‡§∞‡§ø‡§≤_‡§Æ‡•á_‡§ú‡•Ç‡§®_‡§ú‡•Å‡§≤‡•à_‡§ë‡§ó‡§∏‡•ç‡§ü_‡§∏‡§™‡•ç‡§ü‡•á‡§Ç‡§¨‡§∞_‡§ë‡§ï‡•ç‡§ü‡•ã‡§¨‡§∞_‡§®‡•ã‡§µ‡•ç‡§π‡•á‡§Ç‡§¨‡§∞_‡§°‡§ø‡§∏‡•á‡§Ç‡§¨‡§∞'.split('_'),
        monthsShort: '‡§ú‡§æ‡§®‡•á._‡§´‡•á‡§¨‡•ç‡§∞‡•Å._‡§Æ‡§æ‡§∞‡•ç‡§ö._‡§è‡§™‡•ç‡§∞‡§ø._‡§Æ‡•á._‡§ú‡•Ç‡§®._‡§ú‡•Å‡§≤‡•à._‡§ë‡§ó._‡§∏‡§™‡•ç‡§ü‡•á‡§Ç._‡§ë‡§ï‡•ç‡§ü‡•ã._‡§®‡•ã‡§µ‡•ç‡§π‡•á‡§Ç._‡§°‡§ø‡§∏‡•á‡§Ç.'.split('_'),
        weekdays : '‡§∞‡§µ‡§ø‡§µ‡§æ‡§∞_‡§∏‡•ã‡§Æ‡§µ‡§æ‡§∞_‡§Æ‡§Ç‡§ó‡§≥‡§µ‡§æ‡§∞_‡§¨‡•Å‡§ß‡§µ‡§æ‡§∞_‡§ó‡•Å‡§∞‡•Ç‡§µ‡§æ‡§∞_‡§∂‡•Å‡§ï‡•ç‡§∞‡§µ‡§æ‡§∞_‡§∂‡§®‡§ø‡§µ‡§æ‡§∞'.split('_'),
        weekdaysShort : '‡§∞‡§µ‡§ø_‡§∏‡•ã‡§Æ_‡§Æ‡§Ç‡§ó‡§≥_‡§¨‡•Å‡§ß_‡§ó‡•Å‡§∞‡•Ç_‡§∂‡•Å‡§ï‡•ç‡§∞_‡§∂‡§®‡§ø'.split('_'),
        weekdaysMin : '‡§∞_‡§∏‡•ã_‡§Æ‡§Ç_‡§¨‡•Å_‡§ó‡•Å_‡§∂‡•Å_‡§∂'.split('_'),
        longDateFormat : {
            LT : 'A h:mm ‡§µ‡§æ‡§ú‡§§‡§æ',
            LTS : 'A h:mm:ss ‡§µ‡§æ‡§ú‡§§‡§æ',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, LT',
            LLLL : 'dddd, D MMMM YYYY, LT'
        },
        calendar : {
            sameDay : '[‡§Ü‡§ú] LT',
            nextDay : '[‡§â‡§¶‡•ç‡§Ø‡§æ] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[‡§ï‡§æ‡§≤] LT',
            lastWeek: '[‡§Æ‡§æ‡§ó‡•Ä‡§≤] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ‡§®‡§Ç‡§§‡§∞',
            past : '%s ‡§™‡•Ç‡§∞‡•ç‡§µ‡•Ä',
            s : '‡§∏‡•á‡§ï‡§Ç‡§¶',
            m: '‡§è‡§ï ‡§Æ‡§ø‡§®‡§ø‡§ü',
            mm: '%d ‡§Æ‡§ø‡§®‡§ø‡§ü‡•á',
            h : '‡§è‡§ï ‡§§‡§æ‡§∏',
            hh : '%d ‡§§‡§æ‡§∏',
            d : '‡§è‡§ï ‡§¶‡§ø‡§µ‡§∏',
            dd : '%d ‡§¶‡§ø‡§µ‡§∏',
            M : '‡§è‡§ï ‡§Æ‡§π‡§ø‡§®‡§æ',
            MM : '%d ‡§Æ‡§π‡§ø‡§®‡•á',
            y : '‡§è‡§ï ‡§µ‡§∞‡•ç‡§∑',
            yy : '%d ‡§µ‡§∞‡•ç‡§∑‡•á'
        },
        preparse: function (string) {
            return string.replace(/[‡•ß‡•®‡•©‡•™‡•´‡•¨‡•≠‡•Æ‡•Ø‡•¶]/g, function (match) {
                return mr__numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return mr__symbolMap[match];
            });
        },
        meridiemParse: /‡§∞‡§æ‡§§‡•ç‡§∞‡•Ä|‡§∏‡§ï‡§æ‡§≥‡•Ä|‡§¶‡•Å‡§™‡§æ‡§∞‡•Ä|‡§∏‡§æ‡§Ø‡§Ç‡§ï‡§æ‡§≥‡•Ä/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '‡§∞‡§æ‡§§‡•ç‡§∞‡•Ä') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '‡§∏‡§ï‡§æ‡§≥‡•Ä') {
                return hour;
            } else if (meridiem === '‡§¶‡•Å‡§™‡§æ‡§∞‡•Ä') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '‡§∏‡§æ‡§Ø‡§Ç‡§ï‡§æ‡§≥‡•Ä') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return '‡§∞‡§æ‡§§‡•ç‡§∞‡•Ä';
            } else if (hour < 10) {
                return '‡§∏‡§ï‡§æ‡§≥‡•Ä';
            } else if (hour < 17) {
                return '‡§¶‡•Å‡§™‡§æ‡§∞‡•Ä';
            } else if (hour < 20) {
                return '‡§∏‡§æ‡§Ø‡§Ç‡§ï‡§æ‡§≥‡•Ä';
            } else {
                return '‡§∞‡§æ‡§§‡•ç‡§∞‡•Ä';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Bahasa Malaysia (ms-MY)
    //! author : Weldan Jamili : https://github.com/weldan

    var ms_my = _moment__default.defineLocale('ms-my', {
        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'LT.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] LT',
            LLLL : 'dddd, D MMMM YYYY [pukul] LT'
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'tengahari') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'petang' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'tengahari';
            } else if (hours < 19) {
                return 'petang';
            } else {
                return 'malam';
            }
        },
        calendar : {
            sameDay : '[Hari ini pukul] LT',
            nextDay : '[Esok pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kelmarin pukul] LT',
            lastWeek : 'dddd [lepas pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dalam %s',
            past : '%s yang lepas',
            s : 'beberapa saat',
            m : 'seminit',
            mm : '%d minit',
            h : 'sejam',
            hh : '%d jam',
            d : 'sehari',
            dd : '%d hari',
            M : 'sebulan',
            MM : '%d bulan',
            y : 'setahun',
            yy : '%d tahun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Burmese (my)
    //! author : Squar team, mysquar.com

    var my__symbolMap = {
        '1': '·ÅÅ',
        '2': '·ÅÇ',
        '3': '·ÅÉ',
        '4': '·ÅÑ',
        '5': '·ÅÖ',
        '6': '·ÅÜ',
        '7': '·Åá',
        '8': '·Åà',
        '9': '·Åâ',
        '0': '·ÅÄ'
    }, my__numberMap = {
        '·ÅÅ': '1',
        '·ÅÇ': '2',
        '·ÅÉ': '3',
        '·ÅÑ': '4',
        '·ÅÖ': '5',
        '·ÅÜ': '6',
        '·Åá': '7',
        '·Åà': '8',
        '·Åâ': '9',
        '·ÅÄ': '0'
    };

    var my = _moment__default.defineLocale('my', {
        months: '·Äá·Äî·Ä∫·Äî·Äù·Ä´·Äõ·ÄÆ_·Äñ·Ä±·Äñ·Ä±·Ä¨·Ä∫·Äù·Ä´·Äõ·ÄÆ_·Äô·Äê·Ä∫_·Äß·Äï·Äº·ÄÆ_·Äô·Ä±_·Äá·ÄΩ·Äî·Ä∫_·Äá·Ä∞·Äú·Ä≠·ÄØ·ÄÑ·Ä∫_·Äû·Äº·ÄÇ·ÄØ·Äê·Ä∫_·ÄÖ·ÄÄ·Ä∫·Äê·ÄÑ·Ä∫·Äò·Ä¨_·Ä°·Ä±·Ä¨·ÄÄ·Ä∫·Äê·Ä≠·ÄØ·Äò·Ä¨_·Äî·Ä≠·ÄØ·Äù·ÄÑ·Ä∫·Äò·Ä¨_·Äí·ÄÆ·Äá·ÄÑ·Ä∫·Äò·Ä¨'.split('_'),
        monthsShort: '·Äá·Äî·Ä∫_·Äñ·Ä±_·Äô·Äê·Ä∫_·Äï·Äº·ÄÆ_·Äô·Ä±_·Äá·ÄΩ·Äî·Ä∫_·Äú·Ä≠·ÄØ·ÄÑ·Ä∫_·Äû·Äº_·ÄÖ·ÄÄ·Ä∫_·Ä°·Ä±·Ä¨·ÄÄ·Ä∫_·Äî·Ä≠·ÄØ_·Äí·ÄÆ'.split('_'),
        weekdays: '·Äê·Äî·ÄÑ·Ä∫·Äπ·ÄÇ·Äî·ÄΩ·Ä±_·Äê·Äî·ÄÑ·Ä∫·Äπ·Äú·Ä¨_·Ä°·ÄÑ·Ä∫·Äπ·ÄÇ·Ä´_·Äó·ÄØ·Äí·Äπ·Äì·Äü·Ä∞·Ä∏_·ÄÄ·Äº·Ä¨·Äû·Äï·Äê·Ä±·Ä∏_·Äû·Ä±·Ä¨·ÄÄ·Äº·Ä¨_·ÄÖ·Äî·Ä±'.split('_'),
        weekdaysShort: '·Äî·ÄΩ·Ä±_·Äú·Ä¨_·ÄÇ·Ä´_·Äü·Ä∞·Ä∏_·ÄÄ·Äº·Ä¨_·Äû·Ä±·Ä¨_·Äî·Ä±'.split('_'),
        weekdaysMin: '·Äî·ÄΩ·Ä±_·Äú·Ä¨_·ÄÇ·Ä´_·Äü·Ä∞·Ä∏_·ÄÄ·Äº·Ä¨_·Äû·Ä±·Ä¨_·Äî·Ä±'.split('_'),

        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY LT',
            LLLL: 'dddd D MMMM YYYY LT'
        },
        calendar: {
            sameDay: '[·Äö·Äî·Ä±.] LT [·Äô·Äæ·Ä¨]',
            nextDay: '[·Äô·Äî·ÄÄ·Ä∫·Äñ·Äº·Äî·Ä∫] LT [·Äô·Äæ·Ä¨]',
            nextWeek: 'dddd LT [·Äô·Äæ·Ä¨]',
            lastDay: '[·Äô·Äî·Ä±.·ÄÄ] LT [·Äô·Äæ·Ä¨]',
            lastWeek: '[·Äï·Äº·ÄÆ·Ä∏·ÄÅ·Ä≤·Ä∑·Äû·Ä±·Ä¨] dddd LT [·Äô·Äæ·Ä¨]',
            sameElse: 'L'
        },
        relativeTime: {
            future: '·Äú·Ä¨·Äô·Ää·Ä∫·Ä∑ %s ·Äô·Äæ·Ä¨',
            past: '·Äú·ÄΩ·Äî·Ä∫·ÄÅ·Ä≤·Ä∑·Äû·Ä±·Ä¨ %s ·ÄÄ',
            s: '·ÄÖ·ÄÄ·Äπ·ÄÄ·Äî·Ä∫.·Ä°·Äî·Ää·Ä∫·Ä∏·ÄÑ·Äö·Ä∫',
            m: '·Äê·ÄÖ·Ä∫·Äô·Ä≠·Äî·ÄÖ·Ä∫',
            mm: '%d ·Äô·Ä≠·Äî·ÄÖ·Ä∫',
            h: '·Äê·ÄÖ·Ä∫·Äî·Ä¨·Äõ·ÄÆ',
            hh: '%d ·Äî·Ä¨·Äõ·ÄÆ',
            d: '·Äê·ÄÖ·Ä∫·Äõ·ÄÄ·Ä∫',
            dd: '%d ·Äõ·ÄÄ·Ä∫',
            M: '·Äê·ÄÖ·Ä∫·Äú',
            MM: '%d ·Äú',
            y: '·Äê·ÄÖ·Ä∫·Äî·Äæ·ÄÖ·Ä∫',
            yy: '%d ·Äî·Äæ·ÄÖ·Ä∫'
        },
        preparse: function (string) {
            return string.replace(/[·ÅÅ·ÅÇ·ÅÉ·ÅÑ·ÅÖ·ÅÜ·Åá·Åà·Åâ·ÅÄ]/g, function (match) {
                return my__numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return my__symbolMap[match];
            });
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : norwegian bokm√•l (nb)
    //! authors : Espen Hovlandsdal : https://github.com/rexxars
    //!           Sigurd Gartmann : https://github.com/sigurdga

    var nb = _moment__default.defineLocale('nb', {
        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
        weekdays : 's√∏ndag_mandag_tirsdag_onsdag_torsdag_fredag_l√∏rdag'.split('_'),
        weekdaysShort : 's√∏n_man_tirs_ons_tors_fre_l√∏r'.split('_'),
        weekdaysMin : 's√∏_ma_ti_on_to_fr_l√∏'.split('_'),
        longDateFormat : {
            LT : 'H.mm',
            LTS : 'LT.ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY [kl.] LT',
            LLLL : 'dddd D. MMMM YYYY [kl.] LT'
        },
        calendar : {
            sameDay: '[i dag kl.] LT',
            nextDay: '[i morgen kl.] LT',
            nextWeek: 'dddd [kl.] LT',
            lastDay: '[i g√•r kl.] LT',
            lastWeek: '[forrige] dddd [kl.] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : 'for %s siden',
            s : 'noen sekunder',
            m : 'ett minutt',
            mm : '%d minutter',
            h : 'en time',
            hh : '%d timer',
            d : 'en dag',
            dd : '%d dager',
            M : 'en m√•ned',
            MM : '%d m√•neder',
            y : 'ett √•r',
            yy : '%d √•r'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : nepali/nepalese
    //! author : suvash : https://github.com/suvash

    var ne__symbolMap = {
        '1': '‡•ß',
        '2': '‡•®',
        '3': '‡•©',
        '4': '‡•™',
        '5': '‡•´',
        '6': '‡•¨',
        '7': '‡•≠',
        '8': '‡•Æ',
        '9': '‡•Ø',
        '0': '‡•¶'
    },
    ne__numberMap = {
        '‡•ß': '1',
        '‡•®': '2',
        '‡•©': '3',
        '‡•™': '4',
        '‡•´': '5',
        '‡•¨': '6',
        '‡•≠': '7',
        '‡•Æ': '8',
        '‡•Ø': '9',
        '‡•¶': '0'
    };

    var ne = _moment__default.defineLocale('ne', {
        months : '‡§ú‡§®‡§µ‡§∞‡•Ä_‡§´‡•á‡§¨‡•ç‡§∞‡•Å‡§µ‡§∞‡•Ä_‡§Æ‡§æ‡§∞‡•ç‡§ö_‡§Ö‡§™‡•ç‡§∞‡§ø‡§≤_‡§Æ‡§à_‡§ú‡•Å‡§®_‡§ú‡•Å‡§≤‡§æ‡§à_‡§Ö‡§ó‡§∑‡•ç‡§ü_‡§∏‡•á‡§™‡•ç‡§ü‡•á‡§Æ‡•ç‡§¨‡§∞_‡§Ö‡§ï‡•ç‡§ü‡•ã‡§¨‡§∞_‡§®‡•ã‡§≠‡•á‡§Æ‡•ç‡§¨‡§∞_‡§°‡§ø‡§∏‡•á‡§Æ‡•ç‡§¨‡§∞'.split('_'),
        monthsShort : '‡§ú‡§®._‡§´‡•á‡§¨‡•ç‡§∞‡•Å._‡§Æ‡§æ‡§∞‡•ç‡§ö_‡§Ö‡§™‡•ç‡§∞‡§ø._‡§Æ‡§à_‡§ú‡•Å‡§®_‡§ú‡•Å‡§≤‡§æ‡§à._‡§Ö‡§ó._‡§∏‡•á‡§™‡•ç‡§ü._‡§Ö‡§ï‡•ç‡§ü‡•ã._‡§®‡•ã‡§≠‡•á._‡§°‡§ø‡§∏‡•á.'.split('_'),
        weekdays : '‡§Ü‡§á‡§§‡§¨‡§æ‡§∞_‡§∏‡•ã‡§Æ‡§¨‡§æ‡§∞_‡§Æ‡§ô‡•ç‡§ó‡§≤‡§¨‡§æ‡§∞_‡§¨‡•Å‡§ß‡§¨‡§æ‡§∞_‡§¨‡§ø‡§π‡§ø‡§¨‡§æ‡§∞_‡§∂‡•Å‡§ï‡•ç‡§∞‡§¨‡§æ‡§∞_‡§∂‡§®‡§ø‡§¨‡§æ‡§∞'.split('_'),
        weekdaysShort : '‡§Ü‡§á‡§§._‡§∏‡•ã‡§Æ._‡§Æ‡§ô‡•ç‡§ó‡§≤._‡§¨‡•Å‡§ß._‡§¨‡§ø‡§π‡§ø._‡§∂‡•Å‡§ï‡•ç‡§∞._‡§∂‡§®‡§ø.'.split('_'),
        weekdaysMin : '‡§Ü‡§á._‡§∏‡•ã._‡§Æ‡§ô‡•ç_‡§¨‡•Å._‡§¨‡§ø._‡§∂‡•Å._‡§∂.'.split('_'),
        longDateFormat : {
            LT : 'A‡§ï‡•ã h:mm ‡§¨‡§ú‡•á',
            LTS : 'A‡§ï‡•ã h:mm:ss ‡§¨‡§ú‡•á',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, LT',
            LLLL : 'dddd, D MMMM YYYY, LT'
        },
        preparse: function (string) {
            return string.replace(/[‡•ß‡•®‡•©‡•™‡•´‡•¨‡•≠‡•Æ‡•Ø‡•¶]/g, function (match) {
                return ne__numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return ne__symbolMap[match];
            });
        },
        meridiemParse: /‡§∞‡§æ‡§§‡•Ä|‡§¨‡§ø‡§π‡§æ‡§®|‡§¶‡§ø‡§â‡§Å‡§∏‡•ã|‡§¨‡•á‡§≤‡•Å‡§ï‡§æ|‡§∏‡§æ‡§Å‡§ù|‡§∞‡§æ‡§§‡•Ä/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '‡§∞‡§æ‡§§‡•Ä') {
                return hour < 3 ? hour : hour + 12;
            } else if (meridiem === '‡§¨‡§ø‡§π‡§æ‡§®') {
                return hour;
            } else if (meridiem === '‡§¶‡§ø‡§â‡§Å‡§∏‡•ã') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '‡§¨‡•á‡§≤‡•Å‡§ï‡§æ' || meridiem === '‡§∏‡§æ‡§Å‡§ù') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 3) {
                return '‡§∞‡§æ‡§§‡•Ä';
            } else if (hour < 10) {
                return '‡§¨‡§ø‡§π‡§æ‡§®';
            } else if (hour < 15) {
                return '‡§¶‡§ø‡§â‡§Å‡§∏‡•ã';
            } else if (hour < 18) {
                return '‡§¨‡•á‡§≤‡•Å‡§ï‡§æ';
            } else if (hour < 20) {
                return '‡§∏‡§æ‡§Å‡§ù';
            } else {
                return '‡§∞‡§æ‡§§‡•Ä';
            }
        },
        calendar : {
            sameDay : '[‡§Ü‡§ú] LT',
            nextDay : '[‡§≠‡•ã‡§≤‡•Ä] LT',
            nextWeek : '[‡§Ü‡§â‡§Å‡§¶‡•ã] dddd[,] LT',
            lastDay : '[‡§π‡§ø‡§ú‡•ã] LT',
            lastWeek : '[‡§ó‡§è‡§ï‡•ã] dddd[,] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s‡§Æ‡§æ',
            past : '%s ‡§Ö‡§ó‡§æ‡§°‡•Ä',
            s : '‡§ï‡•á‡§π‡•Ä ‡§∏‡§Æ‡§Ø',
            m : '‡§è‡§ï ‡§Æ‡§ø‡§®‡•á‡§ü',
            mm : '%d ‡§Æ‡§ø‡§®‡•á‡§ü',
            h : '‡§è‡§ï ‡§ò‡§£‡•ç‡§ü‡§æ',
            hh : '%d ‡§ò‡§£‡•ç‡§ü‡§æ',
            d : '‡§è‡§ï ‡§¶‡§ø‡§®',
            dd : '%d ‡§¶‡§ø‡§®',
            M : '‡§è‡§ï ‡§Æ‡§π‡§ø‡§®‡§æ',
            MM : '%d ‡§Æ‡§π‡§ø‡§®‡§æ',
            y : '‡§è‡§ï ‡§¨‡§∞‡•ç‡§∑',
            yy : '%d ‡§¨‡§∞‡•ç‡§∑'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : dutch (nl)
    //! author : Joris R√∂ling : https://github.com/jjupiter

    var nl__monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
        nl__monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

    var nl = _moment__default.defineLocale('nl', {
        months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
        monthsShort : function (m, format) {
            if (/-MMM-/.test(format)) {
                return nl__monthsShortWithoutDots[m.month()];
            } else {
                return nl__monthsShortWithDots[m.month()];
            }
        },
        weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
        weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
        weekdaysMin : 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD-MM-YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd D MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[vandaag om] LT',
            nextDay: '[morgen om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[gisteren om] LT',
            lastWeek: '[afgelopen] dddd [om] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'over %s',
            past : '%s geleden',
            s : 'een paar seconden',
            m : '√©√©n minuut',
            mm : '%d minuten',
            h : '√©√©n uur',
            hh : '%d uur',
            d : '√©√©n dag',
            dd : '%d dagen',
            M : '√©√©n maand',
            MM : '%d maanden',
            y : '√©√©n jaar',
            yy : '%d jaar'
        },
        ordinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : norwegian nynorsk (nn)
    //! author : https://github.com/mechuwind

    var nn = _moment__default.defineLocale('nn', {
        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
        weekdays : 'sundag_m√•ndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
        weekdaysShort : 'sun_m√•n_tys_ons_tor_fre_lau'.split('_'),
        weekdaysMin : 'su_m√•_ty_on_to_fr_l√∏'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd D MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[I dag klokka] LT',
            nextDay: '[I morgon klokka] LT',
            nextWeek: 'dddd [klokka] LT',
            lastDay: '[I g√•r klokka] LT',
            lastWeek: '[F√∏reg√•ande] dddd [klokka] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : 'for %s sidan',
            s : 'nokre sekund',
            m : 'eit minutt',
            mm : '%d minutt',
            h : 'ein time',
            hh : '%d timar',
            d : 'ein dag',
            dd : '%d dagar',
            M : 'ein m√•nad',
            MM : '%d m√•nader',
            y : 'eit √•r',
            yy : '%d √•r'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : polish (pl)
    //! author : Rafal Hirsz : https://github.com/evoL

    var monthsNominative = 'stycze≈Ñ_luty_marzec_kwiecie≈Ñ_maj_czerwiec_lipiec_sierpie≈Ñ_wrzesie≈Ñ_pa≈∫dziernik_listopad_grudzie≈Ñ'.split('_'),
        monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrze≈õnia_pa≈∫dziernika_listopada_grudnia'.split('_');
    function pl__plural(n) {
        return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
    }
    function pl__translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
        case 'm':
            return withoutSuffix ? 'minuta' : 'minutƒô';
        case 'mm':
            return result + (pl__plural(number) ? 'minuty' : 'minut');
        case 'h':
            return withoutSuffix  ? 'godzina'  : 'godzinƒô';
        case 'hh':
            return result + (pl__plural(number) ? 'godziny' : 'godzin');
        case 'MM':
            return result + (pl__plural(number) ? 'miesiƒÖce' : 'miesiƒôcy');
        case 'yy':
            return result + (pl__plural(number) ? 'lata' : 'lat');
        }
    }

    var pl = _moment__default.defineLocale('pl', {
        months : function (momentToFormat, format) {
            if (format === '') {
                // Hack: if format empty we know this is used to generate
                // RegExp by moment. Give then back both valid forms of months
                // in RegExp ready format.
                return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
            } else if (/D MMMM/.test(format)) {
                return monthsSubjective[momentToFormat.month()];
            } else {
                return monthsNominative[momentToFormat.month()];
            }
        },
        monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa≈∫_lis_gru'.split('_'),
        weekdays : 'niedziela_poniedzia≈Çek_wtorek_≈õroda_czwartek_piƒÖtek_sobota'.split('_'),
        weekdaysShort : 'nie_pon_wt_≈õr_czw_pt_sb'.split('_'),
        weekdaysMin : 'N_Pn_Wt_≈ör_Cz_Pt_So'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd, D MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[Dzi≈õ o] LT',
            nextDay: '[Jutro o] LT',
            nextWeek: '[W] dddd [o] LT',
            lastDay: '[Wczoraj o] LT',
            lastWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[W zesz≈ÇƒÖ niedzielƒô o] LT';
                case 3:
                    return '[W zesz≈ÇƒÖ ≈õrodƒô o] LT';
                case 6:
                    return '[W zesz≈ÇƒÖ sobotƒô o] LT';
                default:
                    return '[W zesz≈Çy] dddd [o] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'za %s',
            past : '%s temu',
            s : 'kilka sekund',
            m : pl__translate,
            mm : pl__translate,
            h : pl__translate,
            hh : pl__translate,
            d : '1 dzie≈Ñ',
            dd : '%d dni',
            M : 'miesiƒÖc',
            MM : pl__translate,
            y : 'rok',
            yy : pl__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : brazilian portuguese (pt-br)
    //! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira

    var pt_br = _moment__default.defineLocale('pt-br', {
        months : 'Janeiro_Fevereiro_Mar√ßo_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
        weekdays : 'Domingo_Segunda-Feira_Ter√ßa-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_S√°bado'.split('_'),
        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_S√°b'.split('_'),
        weekdaysMin : 'Dom_2¬™_3¬™_4¬™_5¬™_6¬™_S√°b'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY [√†s] LT',
            LLLL : 'dddd, D [de] MMMM [de] YYYY [√†s] LT'
        },
        calendar : {
            sameDay: '[Hoje √†s] LT',
            nextDay: '[Amanh√£ √†s] LT',
            nextWeek: 'dddd [√†s] LT',
            lastDay: '[Ontem √†s] LT',
            lastWeek: function () {
                return (this.day() === 0 || this.day() === 6) ?
                    '[√öltimo] dddd [√†s] LT' : // Saturday + Sunday
                    '[√öltima] dddd [√†s] LT'; // Monday - Friday
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'em %s',
            past : '%s atr√°s',
            s : 'segundos',
            m : 'um minuto',
            mm : '%d minutos',
            h : 'uma hora',
            hh : '%d horas',
            d : 'um dia',
            dd : '%d dias',
            M : 'um m√™s',
            MM : '%d meses',
            y : 'um ano',
            yy : '%d anos'
        },
        ordinalParse: /\d{1,2}¬∫/,
        ordinal : '%d¬∫'
    });

    //! moment.js locale configuration
    //! locale : portuguese (pt)
    //! author : Jefferson : https://github.com/jalex79

    var pt = _moment__default.defineLocale('pt', {
        months : 'Janeiro_Fevereiro_Mar√ßo_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
        weekdays : 'Domingo_Segunda-Feira_Ter√ßa-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_S√°bado'.split('_'),
        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_S√°b'.split('_'),
        weekdaysMin : 'Dom_2¬™_3¬™_4¬™_5¬™_6¬™_S√°b'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY LT',
            LLLL : 'dddd, D [de] MMMM [de] YYYY LT'
        },
        calendar : {
            sameDay: '[Hoje √†s] LT',
            nextDay: '[Amanh√£ √†s] LT',
            nextWeek: 'dddd [√†s] LT',
            lastDay: '[Ontem √†s] LT',
            lastWeek: function () {
                return (this.day() === 0 || this.day() === 6) ?
                    '[√öltimo] dddd [√†s] LT' : // Saturday + Sunday
                    '[√öltima] dddd [√†s] LT'; // Monday - Friday
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'em %s',
            past : 'h√° %s',
            s : 'segundos',
            m : 'um minuto',
            mm : '%d minutos',
            h : 'uma hora',
            hh : '%d horas',
            d : 'um dia',
            dd : '%d dias',
            M : 'um m√™s',
            MM : '%d meses',
            y : 'um ano',
            yy : '%d anos'
        },
        ordinalParse: /\d{1,2}¬∫/,
        ordinal : '%d¬∫',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : romanian (ro)
    //! author : Vlad Gurdiga : https://github.com/gurdiga
    //! author : Valentin Agachi : https://github.com/avaly

    function ro__relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
                'mm': 'minute',
                'hh': 'ore',
                'dd': 'zile',
                'MM': 'luni',
                'yy': 'ani'
            },
            separator = ' ';
        if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
            separator = ' de ';
        }
        return number + separator + format[key];
    }

    var ro = _moment__default.defineLocale('ro', {
        months : 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
        monthsShort : 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
        weekdays : 'duminicƒÉ_luni_mar»õi_miercuri_joi_vineri_s√¢mbƒÉtƒÉ'.split('_'),
        weekdaysShort : 'Dum_Lun_Mar_Mie_Joi_Vin_S√¢m'.split('_'),
        weekdaysMin : 'Du_Lu_Ma_Mi_Jo_Vi_S√¢'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'LT:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd, D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay: '[azi la] LT',
            nextDay: '[m√¢ine la] LT',
            nextWeek: 'dddd [la] LT',
            lastDay: '[ieri la] LT',
            lastWeek: '[fosta] dddd [la] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'peste %s',
            past : '%s √Æn urmƒÉ',
            s : 'c√¢teva secunde',
            m : 'un minut',
            mm : ro__relativeTimeWithPlural,
            h : 'o orƒÉ',
            hh : ro__relativeTimeWithPlural,
            d : 'o zi',
            dd : ro__relativeTimeWithPlural,
            M : 'o lunƒÉ',
            MM : ro__relativeTimeWithPlural,
            y : 'un an',
            yy : ro__relativeTimeWithPlural
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : russian (ru)
    //! author : Viktorminator : https://github.com/Viktorminator
    //! Author : Menelion Elens√∫le : https://github.com/Oire

    function ru__plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
    }
    function ru__relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'mm': withoutSuffix ? '–º–∏–Ω—É—Ç–∞_–º–∏–Ω—É—Ç—ã_–º–∏–Ω—É—Ç' : '–º–∏–Ω—É—Ç—É_–º–∏–Ω—É—Ç—ã_–º–∏–Ω—É—Ç',
            'hh': '—á–∞—Å_—á–∞—Å–∞_—á–∞—Å–æ–≤',
            'dd': '–¥–µ–Ω—å_–¥–Ω—è_–¥–Ω–µ–π',
            'MM': '–º–µ—Å—è—Ü_–º–µ—Å—è—Ü–∞_–º–µ—Å—è—Ü–µ–≤',
            'yy': '–≥–æ–¥_–≥–æ–¥–∞_–ª–µ—Ç'
        };
        if (key === 'm') {
            return withoutSuffix ? '–º–∏–Ω—É—Ç–∞' : '–º–∏–Ω—É—Ç—É';
        }
        else {
            return number + ' ' + ru__plural(format[key], +number);
        }
    }
    function ru__monthsCaseReplace(m, format) {
        var months = {
            'nominative': '—è–Ω–≤–∞—Ä—å_—Ñ–µ–≤—Ä–∞–ª—å_–º–∞—Ä—Ç_–∞–ø—Ä–µ–ª—å_–º–∞–π_–∏—é–Ω—å_–∏—é–ª—å_–∞–≤–≥—É—Å—Ç_—Å–µ–Ω—Ç—è–±—Ä—å_–æ–∫—Ç—è–±—Ä—å_–Ω–æ—è–±—Ä—å_–¥–µ–∫–∞–±—Ä—å'.split('_'),
            'accusative': '—è–Ω–≤–∞—Ä—è_—Ñ–µ–≤—Ä–∞–ª—è_–º–∞—Ä—Ç–∞_–∞–ø—Ä–µ–ª—è_–º–∞—è_–∏—é–Ω—è_–∏—é–ª—è_–∞–≤–≥—É—Å—Ç–∞_—Å–µ–Ω—Ç—è–±—Ä—è_–æ–∫—Ç—è–±—Ä—è_–Ω–æ—è–±—Ä—è_–¥–µ–∫–∞–±—Ä—è'.split('_')
        },
        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
            'accusative' :
            'nominative';
        return months[nounCase][m.month()];
    }
    function ru__monthsShortCaseReplace(m, format) {
        var monthsShort = {
            'nominative': '—è–Ω–≤_—Ñ–µ–≤_–º–∞—Ä—Ç_–∞–ø—Ä_–º–∞–π_–∏—é–Ω—å_–∏—é–ª—å_–∞–≤–≥_—Å–µ–Ω_–æ–∫—Ç_–Ω–æ—è_–¥–µ–∫'.split('_'),
            'accusative': '—è–Ω–≤_—Ñ–µ–≤_–º–∞—Ä_–∞–ø—Ä_–º–∞—è_–∏—é–Ω—è_–∏—é–ª—è_–∞–≤–≥_—Å–µ–Ω_–æ–∫—Ç_–Ω–æ—è_–¥–µ–∫'.split('_')
        },
        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
            'accusative' :
            'nominative';
        return monthsShort[nounCase][m.month()];
    }
    function ru__weekdaysCaseReplace(m, format) {
        var weekdays = {
            'nominative': '–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ_–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫_–≤—Ç–æ—Ä–Ω–∏–∫_—Å—Ä–µ–¥–∞_—á–µ—Ç–≤–µ—Ä–≥_–ø—è—Ç–Ω–∏—Ü–∞_—Å—É–±–±–æ—Ç–∞'.split('_'),
            'accusative': '–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ_–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫_–≤—Ç–æ—Ä–Ω–∏–∫_—Å—Ä–µ–¥—É_—á–µ—Ç–≤–µ—Ä–≥_–ø—è—Ç–Ω–∏—Ü—É_—Å—É–±–±–æ—Ç—É'.split('_')
        },
        nounCase = (/\[ ?[–í–≤] ?(?:–ø—Ä–æ—à–ª—É—é|—Å–ª–µ–¥—É—é—â—É—é|—ç—Ç—É)? ?\] ?dddd/).test(format) ?
            'accusative' :
            'nominative';
        return weekdays[nounCase][m.day()];
    }

    var ru = _moment__default.defineLocale('ru', {
        months : ru__monthsCaseReplace,
        monthsShort : ru__monthsShortCaseReplace,
        weekdays : ru__weekdaysCaseReplace,
        weekdaysShort : '–≤—Å_–ø–Ω_–≤—Ç_—Å—Ä_—á—Ç_–ø—Ç_—Å–±'.split('_'),
        weekdaysMin : '–≤—Å_–ø–Ω_–≤—Ç_—Å—Ä_—á—Ç_–ø—Ç_—Å–±'.split('_'),
        monthsParse : [/^—è–Ω–≤/i, /^—Ñ–µ–≤/i, /^–º–∞—Ä/i, /^–∞–ø—Ä/i, /^–º–∞[–π|—è]/i, /^–∏—é–Ω/i, /^–∏—é–ª/i, /^–∞–≤–≥/i, /^—Å–µ–Ω/i, /^–æ–∫—Ç/i, /^–Ω–æ—è/i, /^–¥–µ–∫/i],
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY –≥.',
            LLL : 'D MMMM YYYY –≥., LT',
            LLLL : 'dddd, D MMMM YYYY –≥., LT'
        },
        calendar : {
            sameDay: '[–°–µ–≥–æ–¥–Ω—è –≤] LT',
            nextDay: '[–ó–∞–≤—Ç—Ä–∞ –≤] LT',
            lastDay: '[–í—á–µ—Ä–∞ –≤] LT',
            nextWeek: function () {
                return this.day() === 2 ? '[–í–æ] dddd [–≤] LT' : '[–í] dddd [–≤] LT';
            },
            lastWeek: function (now) {
                if (now.week() !== this.week()) {
                    switch (this.day()) {
                    case 0:
                        return '[–í –ø—Ä–æ—à–ª–æ–µ] dddd [–≤] LT';
                    case 1:
                    case 2:
                    case 4:
                        return '[–í –ø—Ä–æ—à–ª—ã–π] dddd [–≤] LT';
                    case 3:
                    case 5:
                    case 6:
                        return '[–í –ø—Ä–æ—à–ª—É—é] dddd [–≤] LT';
                    }
                } else {
                    if (this.day() === 2) {
                        return '[–í–æ] dddd [–≤] LT';
                    } else {
                        return '[–í] dddd [–≤] LT';
                    }
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : '—á–µ—Ä–µ–∑ %s',
            past : '%s –Ω–∞–∑–∞–¥',
            s : '–Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥',
            m : ru__relativeTimeWithPlural,
            mm : ru__relativeTimeWithPlural,
            h : '—á–∞—Å',
            hh : ru__relativeTimeWithPlural,
            d : '–¥–µ–Ω—å',
            dd : ru__relativeTimeWithPlural,
            M : '–º–µ—Å—è—Ü',
            MM : ru__relativeTimeWithPlural,
            y : '–≥–æ–¥',
            yy : ru__relativeTimeWithPlural
        },
        meridiemParse: /–Ω–æ—á–∏|—É—Ç—Ä–∞|–¥–Ω—è|–≤–µ—á–µ—Ä–∞/i,
        isPM : function (input) {
            return /^(–¥–Ω—è|–≤–µ—á–µ—Ä–∞)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '–Ω–æ—á–∏';
            } else if (hour < 12) {
                return '—É—Ç—Ä–∞';
            } else if (hour < 17) {
                return '–¥–Ω—è';
            } else {
                return '–≤–µ—á–µ—Ä–∞';
            }
        },
        ordinalParse: /\d{1,2}-(–π|–≥–æ|—è)/,
        ordinal: function (number, period) {
            switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
                return number + '-–π';
            case 'D':
                return number + '-–≥–æ';
            case 'w':
            case 'W':
                return number + '-—è';
            default:
                return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Sinhalese (si)
    //! author : Sampath Sitinamaluwa : https://github.com/sampathsris

    var si = _moment__default.defineLocale('si', {
        months : '‡∂¢‡∂±‡∑Ä‡∑è‡∂ª‡∑í_‡∂¥‡∑ô‡∂∂‡∂ª‡∑Ä‡∑è‡∂ª‡∑í_‡∂∏‡∑è‡∂ª‡∑ä‡∂≠‡∑î_‡∂Ö‡∂¥‡∑ä‚Äç‡∂ª‡∑ö‡∂Ω‡∑ä_‡∂∏‡∑ê‡∂∫‡∑í_‡∂¢‡∑ñ‡∂±‡∑í_‡∂¢‡∑ñ‡∂Ω‡∑í_‡∂Ö‡∂ú‡∑ù‡∑É‡∑ä‡∂≠‡∑î_‡∑É‡∑ê‡∂¥‡∑ä‡∂≠‡∑ê‡∂∏‡∑ä‡∂∂‡∂ª‡∑ä_‡∂î‡∂ö‡∑ä‡∂≠‡∑ù‡∂∂‡∂ª‡∑ä_‡∂±‡∑ú‡∑Ä‡∑ê‡∂∏‡∑ä‡∂∂‡∂ª‡∑ä_‡∂Ø‡∑ô‡∑É‡∑ê‡∂∏‡∑ä‡∂∂‡∂ª‡∑ä'.split('_'),
        monthsShort : '‡∂¢‡∂±_‡∂¥‡∑ô‡∂∂_‡∂∏‡∑è‡∂ª‡∑ä_‡∂Ö‡∂¥‡∑ä_‡∂∏‡∑ê‡∂∫‡∑í_‡∂¢‡∑ñ‡∂±‡∑í_‡∂¢‡∑ñ‡∂Ω‡∑í_‡∂Ö‡∂ú‡∑ù_‡∑É‡∑ê‡∂¥‡∑ä_‡∂î‡∂ö‡∑ä_‡∂±‡∑ú‡∑Ä‡∑ê_‡∂Ø‡∑ô‡∑É‡∑ê'.split('_'),
        weekdays : '‡∂â‡∂ª‡∑í‡∂Ø‡∑è_‡∑É‡∂≥‡∑î‡∂Ø‡∑è_‡∂Ö‡∂ü‡∑Ñ‡∂ª‡∑î‡∑Ä‡∑è‡∂Ø‡∑è_‡∂∂‡∂Ø‡∑è‡∂Ø‡∑è_‡∂∂‡∑ä‚Äç‡∂ª‡∑Ñ‡∑É‡∑ä‡∂¥‡∂≠‡∑í‡∂±‡∑ä‡∂Ø‡∑è_‡∑É‡∑í‡∂ö‡∑î‡∂ª‡∑è‡∂Ø‡∑è_‡∑É‡∑ô‡∂±‡∑É‡∑î‡∂ª‡∑è‡∂Ø‡∑è'.split('_'),
        weekdaysShort : '‡∂â‡∂ª‡∑í_‡∑É‡∂≥‡∑î_‡∂Ö‡∂ü_‡∂∂‡∂Ø‡∑è_‡∂∂‡∑ä‚Äç‡∂ª‡∑Ñ_‡∑É‡∑í‡∂ö‡∑î_‡∑É‡∑ô‡∂±'.split('_'),
        weekdaysMin : '‡∂â_‡∑É_‡∂Ö_‡∂∂_‡∂∂‡∑ä‚Äç‡∂ª_‡∑É‡∑í_‡∑É‡∑ô'.split('_'),
        longDateFormat : {
            LT : 'a h:mm',
            LTS : 'a h:mm:ss',
            L : 'YYYY/MM/DD',
            LL : 'YYYY MMMM D',
            LLL : 'YYYY MMMM D, LT',
            LLLL : 'YYYY MMMM D [‡∑Ä‡∑ê‡∂±‡∑í] dddd, LTS'
        },
        calendar : {
            sameDay : '[‡∂Ö‡∂Ø] LT[‡∂ß]',
            nextDay : '[‡∑Ñ‡∑ô‡∂ß] LT[‡∂ß]',
            nextWeek : 'dddd LT[‡∂ß]',
            lastDay : '[‡∂ä‡∂∫‡∑ö] LT[‡∂ß]',
            lastWeek : '[‡∂¥‡∑É‡∑î‡∂ú‡∑í‡∂∫] dddd LT[‡∂ß]',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s‡∂ö‡∑í‡∂±‡∑ä',
            past : '%s‡∂ö‡∂ß ‡∂¥‡∑ô‡∂ª',
            s : '‡∂≠‡∂≠‡∑ä‡∂¥‡∂ª ‡∂ö‡∑í‡∑Ñ‡∑í‡∂¥‡∂∫',
            m : '‡∂∏‡∑í‡∂±‡∑í‡∂≠‡∑ä‡∂≠‡∑î‡∑Ä',
            mm : '‡∂∏‡∑í‡∂±‡∑í‡∂≠‡∑ä‡∂≠‡∑î %d',
            h : '‡∂¥‡∑ê‡∂∫',
            hh : '‡∂¥‡∑ê‡∂∫ %d',
            d : '‡∂Ø‡∑í‡∂±‡∂∫',
            dd : '‡∂Ø‡∑í‡∂± %d',
            M : '‡∂∏‡∑è‡∑É‡∂∫',
            MM : '‡∂∏‡∑è‡∑É %d',
            y : '‡∑Ä‡∑É‡∂ª',
            yy : '‡∑Ä‡∑É‡∂ª %d'
        },
        ordinalParse: /\d{1,2} ‡∑Ä‡∑ê‡∂±‡∑í/,
        ordinal : function (number) {
            return number + ' ‡∑Ä‡∑ê‡∂±‡∑í';
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? '‡∂¥.‡∑Ä.' : '‡∂¥‡∑É‡∑ä ‡∑Ä‡∂ª‡∑î';
            } else {
                return isLower ? '‡∂¥‡∑ô.‡∑Ä.' : '‡∂¥‡∑ô‡∂ª ‡∑Ä‡∂ª‡∑î';
            }
        }
    });

    //! moment.js locale configuration
    //! locale : slovak (sk)
    //! author : Martin Minka : https://github.com/k2s
    //! based on work of petrbela : https://github.com/petrbela

    var sk__months = 'janu√°r_febru√°r_marec_apr√≠l_m√°j_j√∫n_j√∫l_august_september_okt√≥ber_november_december'.split('_'),
        sk__monthsShort = 'jan_feb_mar_apr_m√°j_j√∫n_j√∫l_aug_sep_okt_nov_dec'.split('_');
    function sk__plural(n) {
        return (n > 1) && (n < 5);
    }
    function sk__translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
        case 's':  // a few seconds / in a few seconds / a few seconds ago
            return (withoutSuffix || isFuture) ? 'p√°r sek√∫nd' : 'p√°r sekundami';
        case 'm':  // a minute / in a minute / a minute ago
            return withoutSuffix ? 'min√∫ta' : (isFuture ? 'min√∫tu' : 'min√∫tou');
        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
            if (withoutSuffix || isFuture) {
                return result + (sk__plural(number) ? 'min√∫ty' : 'min√∫t');
            } else {
                return result + 'min√∫tami';
            }
            break;
        case 'h':  // an hour / in an hour / an hour ago
            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
        case 'hh': // 9 hours / in 9 hours / 9 hours ago
            if (withoutSuffix || isFuture) {
                return result + (sk__plural(number) ? 'hodiny' : 'hod√≠n');
            } else {
                return result + 'hodinami';
            }
            break;
        case 'd':  // a day / in a day / a day ago
            return (withoutSuffix || isFuture) ? 'de≈à' : 'd≈àom';
        case 'dd': // 9 days / in 9 days / 9 days ago
            if (withoutSuffix || isFuture) {
                return result + (sk__plural(number) ? 'dni' : 'dn√≠');
            } else {
                return result + 'd≈àami';
            }
            break;
        case 'M':  // a month / in a month / a month ago
            return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';
        case 'MM': // 9 months / in 9 months / 9 months ago
            if (withoutSuffix || isFuture) {
                return result + (sk__plural(number) ? 'mesiace' : 'mesiacov');
            } else {
                return result + 'mesiacmi';
            }
            break;
        case 'y':  // a year / in a year / a year ago
            return (withoutSuffix || isFuture) ? 'rok' : 'rokom';
        case 'yy': // 9 years / in 9 years / 9 years ago
            if (withoutSuffix || isFuture) {
                return result + (sk__plural(number) ? 'roky' : 'rokov');
            } else {
                return result + 'rokmi';
            }
            break;
        }
    }

    var sk = _moment__default.defineLocale('sk', {
        months : sk__months,
        monthsShort : sk__monthsShort,
        monthsParse : (function (months, monthsShort) {
            var i, _monthsParse = [];
            for (i = 0; i < 12; i++) {
                // use custom parser to solve problem with July (ƒçervenec)
                _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
            }
            return _monthsParse;
        }(sk__months, sk__monthsShort)),
        weekdays : 'nedeƒæa_pondelok_utorok_streda_≈°tvrtok_piatok_sobota'.split('_'),
        weekdaysShort : 'ne_po_ut_st_≈°t_pi_so'.split('_'),
        weekdaysMin : 'ne_po_ut_st_≈°t_pi_so'.split('_'),
        longDateFormat : {
            LT: 'H:mm',
            LTS : 'LT:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY LT',
            LLLL : 'dddd D. MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[dnes o] LT',
            nextDay: '[zajtra o] LT',
            nextWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[v nedeƒæu o] LT';
                case 1:
                case 2:
                    return '[v] dddd [o] LT';
                case 3:
                    return '[v stredu o] LT';
                case 4:
                    return '[vo ≈°tvrtok o] LT';
                case 5:
                    return '[v piatok o] LT';
                case 6:
                    return '[v sobotu o] LT';
                }
            },
            lastDay: '[vƒçera o] LT',
            lastWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[minul√∫ nedeƒæu o] LT';
                case 1:
                case 2:
                    return '[minul√Ω] dddd [o] LT';
                case 3:
                    return '[minul√∫ stredu o] LT';
                case 4:
                case 5:
                    return '[minul√Ω] dddd [o] LT';
                case 6:
                    return '[minul√∫ sobotu o] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'za %s',
            past : 'pred %s',
            s : sk__translate,
            m : sk__translate,
            mm : sk__translate,
            h : sk__translate,
            hh : sk__translate,
            d : sk__translate,
            dd : sk__translate,
            M : sk__translate,
            MM : sk__translate,
            y : sk__translate,
            yy : sk__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : slovenian (sl)
    //! author : Robert Sedov≈°ek : https://github.com/sedovsek

    function sl__processRelativeTime(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
        case 's':
            return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';
        case 'm':
            return withoutSuffix ? 'ena minuta' : 'eno minuto';
        case 'mm':
            if (number === 1) {
                result += withoutSuffix ? 'minuta' : 'minuto';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'minute' : 'minutami';
            } else {
                result += withoutSuffix || isFuture ? 'minut' : 'minutami';
            }
            return result;
        case 'h':
            return withoutSuffix ? 'ena ura' : 'eno uro';
        case 'hh':
            if (number === 1) {
                result += withoutSuffix ? 'ura' : 'uro';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'uri' : 'urama';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'ure' : 'urami';
            } else {
                result += withoutSuffix || isFuture ? 'ur' : 'urami';
            }
            return result;
        case 'd':
            return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
        case 'dd':
            if (number === 1) {
                result += withoutSuffix || isFuture ? 'dan' : 'dnem';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
            } else {
                result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
            }
            return result;
        case 'M':
            return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
        case 'MM':
            if (number === 1) {
                result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
            } else {
                result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
            }
            return result;
        case 'y':
            return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
        case 'yy':
            if (number === 1) {
                result += withoutSuffix || isFuture ? 'leto' : 'letom';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'leti' : 'letoma';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'leta' : 'leti';
            } else {
                result += withoutSuffix || isFuture ? 'let' : 'leti';
            }
            return result;
        }
    }

    var sl = _moment__default.defineLocale('sl', {
        months : 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
        weekdays : 'nedelja_ponedeljek_torek_sreda_ƒçetrtek_petek_sobota'.split('_'),
        weekdaysShort : 'ned._pon._tor._sre._ƒçet._pet._sob.'.split('_'),
        weekdaysMin : 'ne_po_to_sr_ƒçe_pe_so'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'LT:ss',
            L : 'DD. MM. YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY LT',
            LLLL : 'dddd, D. MMMM YYYY LT'
        },
        calendar : {
            sameDay  : '[danes ob] LT',
            nextDay  : '[jutri ob] LT',

            nextWeek : function () {
                switch (this.day()) {
                case 0:
                    return '[v] [nedeljo] [ob] LT';
                case 3:
                    return '[v] [sredo] [ob] LT';
                case 6:
                    return '[v] [soboto] [ob] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[v] dddd [ob] LT';
                }
            },
            lastDay  : '[vƒçeraj ob] LT',
            lastWeek : function () {
                switch (this.day()) {
                case 0:
                    return '[prej≈°njo] [nedeljo] [ob] LT';
                case 3:
                    return '[prej≈°njo] [sredo] [ob] LT';
                case 6:
                    return '[prej≈°njo] [soboto] [ob] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[prej≈°nji] dddd [ob] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'ƒçez %s',
            past   : 'pred %s',
            s      : sl__processRelativeTime,
            m      : sl__processRelativeTime,
            mm     : sl__processRelativeTime,
            h      : sl__processRelativeTime,
            hh     : sl__processRelativeTime,
            d      : sl__processRelativeTime,
            dd     : sl__processRelativeTime,
            M      : sl__processRelativeTime,
            MM     : sl__processRelativeTime,
            y      : sl__processRelativeTime,
            yy     : sl__processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Albanian (sq)
    //! author : Flak√´rim Ismani : https://github.com/flakerimi
    //! author: Menelion Elens√∫le: https://github.com/Oire (tests)
    //! author : Oerd Cukalla : https://github.com/oerd (fixes)

    var sq = _moment__default.defineLocale('sq', {
        months : 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_N√´ntor_Dhjetor'.split('_'),
        monthsShort : 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_N√´n_Dhj'.split('_'),
        weekdays : 'E Diel_E H√´n√´_E Mart√´_E M√´rkur√´_E Enjte_E Premte_E Shtun√´'.split('_'),
        weekdaysShort : 'Die_H√´n_Mar_M√´r_Enj_Pre_Sht'.split('_'),
        weekdaysMin : 'D_H_Ma_M√´_E_P_Sh'.split('_'),
        meridiemParse: /PD|MD/,
        isPM: function (input) {
            return input.charAt(0) === 'M';
        },
        meridiem : function (hours, minutes, isLower) {
            return hours < 12 ? 'PD' : 'MD';
        },
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd, D MMMM YYYY LT'
        },
        calendar : {
            sameDay : '[Sot n√´] LT',
            nextDay : '[Nes√´r n√´] LT',
            nextWeek : 'dddd [n√´] LT',
            lastDay : '[Dje n√´] LT',
            lastWeek : 'dddd [e kaluar n√´] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'n√´ %s',
            past : '%s m√´ par√´',
            s : 'disa sekonda',
            m : 'nj√´ minut√´',
            mm : '%d minuta',
            h : 'nj√´ or√´',
            hh : '%d or√´',
            d : 'nj√´ dit√´',
            dd : '%d dit√´',
            M : 'nj√´ muaj',
            MM : '%d muaj',
            y : 'nj√´ vit',
            yy : '%d vite'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Serbian-cyrillic (sr-cyrl)
    //! author : Milan Janaƒçkoviƒá<milanjanackovic@gmail.com> : https://github.com/milan-j

    var sr_cyrl__translator = {
        words: { //Different grammatical cases
            m: ['—ò–µ–¥–∞–Ω –º–∏–Ω—É—Ç', '—ò–µ–¥–Ω–µ –º–∏–Ω—É—Ç–µ'],
            mm: ['–º–∏–Ω—É—Ç', '–º–∏–Ω—É—Ç–µ', '–º–∏–Ω—É—Ç–∞'],
            h: ['—ò–µ–¥–∞–Ω —Å–∞—Ç', '—ò–µ–¥–Ω–æ–≥ —Å–∞—Ç–∞'],
            hh: ['—Å–∞—Ç', '—Å–∞—Ç–∞', '—Å–∞—Ç–∏'],
            dd: ['–¥–∞–Ω', '–¥–∞–Ω–∞', '–¥–∞–Ω–∞'],
            MM: ['–º–µ—Å–µ—Ü', '–º–µ—Å–µ—Ü–∞', '–º–µ—Å–µ—Ü–∏'],
            yy: ['–≥–æ–¥–∏–Ω–∞', '–≥–æ–¥–∏–Ω–µ', '–≥–æ–¥–∏–Ω–∞']
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = sr_cyrl__translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + ' ' + sr_cyrl__translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };

    var sr_cyrl = _moment__default.defineLocale('sr-cyrl', {
        months: ['—ò–∞–Ω—É–∞—Ä', '—Ñ–µ–±—Ä—É–∞—Ä', '–º–∞—Ä—Ç', '–∞–ø—Ä–∏–ª', '–º–∞—ò', '—ò—É–Ω', '—ò—É–ª', '–∞–≤–≥—É—Å—Ç', '—Å–µ–ø—Ç–µ–º–±–∞—Ä', '–æ–∫—Ç–æ–±–∞—Ä', '–Ω–æ–≤–µ–º–±–∞—Ä', '–¥–µ—Ü–µ–º–±–∞—Ä'],
        monthsShort: ['—ò–∞–Ω.', '—Ñ–µ–±.', '–º–∞—Ä.', '–∞–ø—Ä.', '–º–∞—ò', '—ò—É–Ω', '—ò—É–ª', '–∞–≤–≥.', '—Å–µ–ø.', '–æ–∫—Ç.', '–Ω–æ–≤.', '–¥–µ—Ü.'],
        weekdays: ['–Ω–µ–¥–µ—ô–∞', '–ø–æ–Ω–µ–¥–µ—ô–∞–∫', '—É—Ç–æ—Ä–∞–∫', '—Å—Ä–µ–¥–∞', '—á–µ—Ç–≤—Ä—Ç–∞–∫', '–ø–µ—Ç–∞–∫', '—Å—É–±–æ—Ç–∞'],
        weekdaysShort: ['–Ω–µ–¥.', '–ø–æ–Ω.', '—É—Ç–æ.', '—Å—Ä–µ.', '—á–µ—Ç.', '–ø–µ—Ç.', '—Å—É–±.'],
        weekdaysMin: ['–Ω–µ', '–ø–æ', '—É—Ç', '—Å—Ä', '—á–µ', '–ø–µ', '—Å—É'],
        longDateFormat: {
            LT: 'H:mm',
            LTS : 'LT:ss',
            L: 'DD. MM. YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY LT',
            LLLL: 'dddd, D. MMMM YYYY LT'
        },
        calendar: {
            sameDay: '[–¥–∞–Ω–∞—Å —É] LT',
            nextDay: '[—Å—É—Ç—Ä–∞ —É] LT',
            nextWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[—É] [–Ω–µ–¥–µ—ô—É] [—É] LT';
                case 3:
                    return '[—É] [—Å—Ä–µ–¥—É] [—É] LT';
                case 6:
                    return '[—É] [—Å—É–±–æ—Ç—É] [—É] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[—É] dddd [—É] LT';
                }
            },
            lastDay  : '[—ò—É—á–µ —É] LT',
            lastWeek : function () {
                var lastWeekDays = [
                    '[–ø—Ä–æ—à–ª–µ] [–Ω–µ–¥–µ—ô–µ] [—É] LT',
                    '[–ø—Ä–æ—à–ª–æ–≥] [–ø–æ–Ω–µ–¥–µ—ô–∫–∞] [—É] LT',
                    '[–ø—Ä–æ—à–ª–æ–≥] [—É—Ç–æ—Ä–∫–∞] [—É] LT',
                    '[–ø—Ä–æ—à–ª–µ] [—Å—Ä–µ–¥–µ] [—É] LT',
                    '[–ø—Ä–æ—à–ª–æ–≥] [—á–µ—Ç–≤—Ä—Ç–∫–∞] [—É] LT',
                    '[–ø—Ä–æ—à–ª–æ–≥] [–ø–µ—Ç–∫–∞] [—É] LT',
                    '[–ø—Ä–æ—à–ª–µ] [—Å—É–±–æ—Ç–µ] [—É] LT'
                ];
                return lastWeekDays[this.day()];
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : '–∑–∞ %s',
            past   : '–ø—Ä–µ %s',
            s      : '–Ω–µ–∫–æ–ª–∏–∫–æ —Å–µ–∫—É–Ω–¥–∏',
            m      : sr_cyrl__translator.translate,
            mm     : sr_cyrl__translator.translate,
            h      : sr_cyrl__translator.translate,
            hh     : sr_cyrl__translator.translate,
            d      : '–¥–∞–Ω',
            dd     : sr_cyrl__translator.translate,
            M      : '–º–µ—Å–µ—Ü',
            MM     : sr_cyrl__translator.translate,
            y      : '–≥–æ–¥–∏–Ω—É',
            yy     : sr_cyrl__translator.translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Serbian-latin (sr)
    //! author : Milan Janaƒçkoviƒá<milanjanackovic@gmail.com> : https://github.com/milan-j

    var sr__translator = {
        words: { //Different grammatical cases
            m: ['jedan minut', 'jedne minute'],
            mm: ['minut', 'minute', 'minuta'],
            h: ['jedan sat', 'jednog sata'],
            hh: ['sat', 'sata', 'sati'],
            dd: ['dan', 'dana', 'dana'],
            MM: ['mesec', 'meseca', 'meseci'],
            yy: ['godina', 'godine', 'godina']
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = sr__translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + ' ' + sr__translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };

    var sr = _moment__default.defineLocale('sr', {
        months: ['januar', 'februar', 'mart', 'april', 'maj', 'jun', 'jul', 'avgust', 'septembar', 'oktobar', 'novembar', 'decembar'],
        monthsShort: ['jan.', 'feb.', 'mar.', 'apr.', 'maj', 'jun', 'jul', 'avg.', 'sep.', 'okt.', 'nov.', 'dec.'],
        weekdays: ['nedelja', 'ponedeljak', 'utorak', 'sreda', 'ƒçetvrtak', 'petak', 'subota'],
        weekdaysShort: ['ned.', 'pon.', 'uto.', 'sre.', 'ƒçet.', 'pet.', 'sub.'],
        weekdaysMin: ['ne', 'po', 'ut', 'sr', 'ƒçe', 'pe', 'su'],
        longDateFormat: {
            LT: 'H:mm',
            LTS : 'LT:ss',
            L: 'DD. MM. YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY LT',
            LLLL: 'dddd, D. MMMM YYYY LT'
        },
        calendar: {
            sameDay: '[danas u] LT',
            nextDay: '[sutra u] LT',
            nextWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[u] [nedelju] [u] LT';
                case 3:
                    return '[u] [sredu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[juƒçe u] LT',
            lastWeek : function () {
                var lastWeekDays = [
                    '[pro≈°le] [nedelje] [u] LT',
                    '[pro≈°log] [ponedeljka] [u] LT',
                    '[pro≈°log] [utorka] [u] LT',
                    '[pro≈°le] [srede] [u] LT',
                    '[pro≈°log] [ƒçetvrtka] [u] LT',
                    '[pro≈°log] [petka] [u] LT',
                    '[pro≈°le] [subote] [u] LT'
                ];
                return lastWeekDays[this.day()];
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'pre %s',
            s      : 'nekoliko sekundi',
            m      : sr__translator.translate,
            mm     : sr__translator.translate,
            h      : sr__translator.translate,
            hh     : sr__translator.translate,
            d      : 'dan',
            dd     : sr__translator.translate,
            M      : 'mesec',
            MM     : sr__translator.translate,
            y      : 'godinu',
            yy     : sr__translator.translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : swedish (sv)
    //! author : Jens Alm : https://github.com/ulmus

    var sv = _moment__default.defineLocale('sv', {
        months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
        weekdays : 's√∂ndag_m√•ndag_tisdag_onsdag_torsdag_fredag_l√∂rdag'.split('_'),
        weekdaysShort : 's√∂n_m√•n_tis_ons_tor_fre_l√∂r'.split('_'),
        weekdaysMin : 's√∂_m√•_ti_on_to_fr_l√∂'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'YYYY-MM-DD',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd D MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[Idag] LT',
            nextDay: '[Imorgon] LT',
            lastDay: '[Ig√•r] LT',
            nextWeek: '[P√•] dddd LT',
            lastWeek: '[I] dddd[s] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : 'f√∂r %s sedan',
            s : 'n√•gra sekunder',
            m : 'en minut',
            mm : '%d minuter',
            h : 'en timme',
            hh : '%d timmar',
            d : 'en dag',
            dd : '%d dagar',
            M : 'en m√•nad',
            MM : '%d m√•nader',
            y : 'ett √•r',
            yy : '%d √•r'
        },
        ordinalParse: /\d{1,2}(e|a)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'e' :
                (b === 1) ? 'a' :
                (b === 2) ? 'a' :
                (b === 3) ? 'e' : 'e';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : tamil (ta)
    //! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404

    var ta = _moment__default.defineLocale('ta', {
        months : '‡Æú‡Æ©‡Æµ‡Æ∞‡Æø_‡Æ™‡Æø‡Æ™‡Øç‡Æ∞‡Æµ‡Æ∞‡Æø_‡ÆÆ‡Ææ‡Æ∞‡Øç‡Æö‡Øç_‡Æè‡Æ™‡Øç‡Æ∞‡Æ≤‡Øç_‡ÆÆ‡Øá_‡Æú‡ØÇ‡Æ©‡Øç_‡Æú‡ØÇ‡Æ≤‡Øà_‡ÆÜ‡Æï‡Æ∏‡Øç‡Æü‡Øç_‡Æö‡ØÜ‡Æ™‡Øç‡Æü‡ØÜ‡ÆÆ‡Øç‡Æ™‡Æ∞‡Øç_‡ÆÖ‡Æï‡Øç‡Æü‡Øá‡Ææ‡Æ™‡Æ∞‡Øç_‡Æ®‡Æµ‡ÆÆ‡Øç‡Æ™‡Æ∞‡Øç_‡Æü‡Æø‡Æö‡ÆÆ‡Øç‡Æ™‡Æ∞‡Øç'.split('_'),
        monthsShort : '‡Æú‡Æ©‡Æµ‡Æ∞‡Æø_‡Æ™‡Æø‡Æ™‡Øç‡Æ∞‡Æµ‡Æ∞‡Æø_‡ÆÆ‡Ææ‡Æ∞‡Øç‡Æö‡Øç_‡Æè‡Æ™‡Øç‡Æ∞‡Æ≤‡Øç_‡ÆÆ‡Øá_‡Æú‡ØÇ‡Æ©‡Øç_‡Æú‡ØÇ‡Æ≤‡Øà_‡ÆÜ‡Æï‡Æ∏‡Øç‡Æü‡Øç_‡Æö‡ØÜ‡Æ™‡Øç‡Æü‡ØÜ‡ÆÆ‡Øç‡Æ™‡Æ∞‡Øç_‡ÆÖ‡Æï‡Øç‡Æü‡Øá‡Ææ‡Æ™‡Æ∞‡Øç_‡Æ®‡Æµ‡ÆÆ‡Øç‡Æ™‡Æ∞‡Øç_‡Æü‡Æø‡Æö‡ÆÆ‡Øç‡Æ™‡Æ∞‡Øç'.split('_'),
        weekdays : '‡Æû‡Ææ‡ÆØ‡Æø‡Æ±‡Øç‡Æ±‡ØÅ‡Æï‡Øç‡Æï‡Æø‡Æ¥‡ÆÆ‡Øà_‡Æ§‡Æø‡Æô‡Øç‡Æï‡Æü‡Øç‡Æï‡Æø‡Æ¥‡ÆÆ‡Øà_‡Æö‡ØÜ‡Æµ‡Øç‡Æµ‡Ææ‡ÆØ‡Øç‡Æï‡Æø‡Æ¥‡ÆÆ‡Øà_‡Æ™‡ØÅ‡Æ§‡Æ©‡Øç‡Æï‡Æø‡Æ¥‡ÆÆ‡Øà_‡Æµ‡Æø‡ÆØ‡Ææ‡Æ¥‡Æï‡Øç‡Æï‡Æø‡Æ¥‡ÆÆ‡Øà_‡Æµ‡ØÜ‡Æ≥‡Øç‡Æ≥‡Æø‡Æï‡Øç‡Æï‡Æø‡Æ¥‡ÆÆ‡Øà_‡Æö‡Æ©‡Æø‡Æï‡Øç‡Æï‡Æø‡Æ¥‡ÆÆ‡Øà'.split('_'),
        weekdaysShort : '‡Æû‡Ææ‡ÆØ‡Æø‡Æ±‡ØÅ_‡Æ§‡Æø‡Æô‡Øç‡Æï‡Æ≥‡Øç_‡Æö‡ØÜ‡Æµ‡Øç‡Æµ‡Ææ‡ÆØ‡Øç_‡Æ™‡ØÅ‡Æ§‡Æ©‡Øç_‡Æµ‡Æø‡ÆØ‡Ææ‡Æ¥‡Æ©‡Øç_‡Æµ‡ØÜ‡Æ≥‡Øç‡Æ≥‡Æø_‡Æö‡Æ©‡Æø'.split('_'),
        weekdaysMin : '‡Æû‡Ææ_‡Æ§‡Æø_‡Æö‡ØÜ_‡Æ™‡ØÅ_‡Æµ‡Æø_‡Æµ‡ØÜ_‡Æö'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, LT',
            LLLL : 'dddd, D MMMM YYYY, LT'
        },
        calendar : {
            sameDay : '[‡Æá‡Æ©‡Øç‡Æ±‡ØÅ] LT',
            nextDay : '[‡Æ®‡Ææ‡Æ≥‡Øà] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[‡Æ®‡Øá‡Æ±‡Øç‡Æ±‡ØÅ] LT',
            lastWeek : '[‡Æï‡Æü‡Æ®‡Øç‡Æ§ ‡Æµ‡Ææ‡Æ∞‡ÆÆ‡Øç] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ‡Æá‡Æ≤‡Øç',
            past : '%s ‡ÆÆ‡ØÅ‡Æ©‡Øç',
            s : '‡Æí‡Æ∞‡ØÅ ‡Æö‡Æø‡Æ≤ ‡Æµ‡Æø‡Æ®‡Ææ‡Æü‡Æø‡Æï‡Æ≥‡Øç',
            m : '‡Æí‡Æ∞‡ØÅ ‡Æ®‡Æø‡ÆÆ‡Æø‡Æü‡ÆÆ‡Øç',
            mm : '%d ‡Æ®‡Æø‡ÆÆ‡Æø‡Æü‡Æô‡Øç‡Æï‡Æ≥‡Øç',
            h : '‡Æí‡Æ∞‡ØÅ ‡ÆÆ‡Æ£‡Æø ‡Æ®‡Øá‡Æ∞‡ÆÆ‡Øç',
            hh : '%d ‡ÆÆ‡Æ£‡Æø ‡Æ®‡Øá‡Æ∞‡ÆÆ‡Øç',
            d : '‡Æí‡Æ∞‡ØÅ ‡Æ®‡Ææ‡Æ≥‡Øç',
            dd : '%d ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Øç',
            M : '‡Æí‡Æ∞‡ØÅ ‡ÆÆ‡Ææ‡Æ§‡ÆÆ‡Øç',
            MM : '%d ‡ÆÆ‡Ææ‡Æ§‡Æô‡Øç‡Æï‡Æ≥‡Øç',
            y : '‡Æí‡Æ∞‡ØÅ ‡Æµ‡Æ∞‡ØÅ‡Æü‡ÆÆ‡Øç',
            yy : '%d ‡ÆÜ‡Æ£‡Øç‡Æü‡ØÅ‡Æï‡Æ≥‡Øç'
        },
        ordinalParse: /\d{1,2}‡Æµ‡Æ§‡ØÅ/,
        ordinal : function (number) {
            return number + '‡Æµ‡Æ§‡ØÅ';
        },
        // refer http://ta.wikipedia.org/s/1er1
        meridiemParse: /‡ÆØ‡Ææ‡ÆÆ‡ÆÆ‡Øç|‡Æµ‡Øà‡Æï‡Æ±‡Øà|‡Æï‡Ææ‡Æ≤‡Øà|‡Æ®‡Æ£‡Øç‡Æ™‡Æï‡Æ≤‡Øç|‡Æé‡Æ±‡Øç‡Æ™‡Ææ‡Æü‡ØÅ|‡ÆÆ‡Ææ‡Æ≤‡Øà/,
        meridiem : function (hour, minute, isLower) {
            if (hour < 2) {
                return ' ‡ÆØ‡Ææ‡ÆÆ‡ÆÆ‡Øç';
            } else if (hour < 6) {
                return ' ‡Æµ‡Øà‡Æï‡Æ±‡Øà';  // ‡Æµ‡Øà‡Æï‡Æ±‡Øà
            } else if (hour < 10) {
                return ' ‡Æï‡Ææ‡Æ≤‡Øà'; // ‡Æï‡Ææ‡Æ≤‡Øà
            } else if (hour < 14) {
                return ' ‡Æ®‡Æ£‡Øç‡Æ™‡Æï‡Æ≤‡Øç'; // ‡Æ®‡Æ£‡Øç‡Æ™‡Æï‡Æ≤‡Øç
            } else if (hour < 18) {
                return ' ‡Æé‡Æ±‡Øç‡Æ™‡Ææ‡Æü‡ØÅ'; // ‡Æé‡Æ±‡Øç‡Æ™‡Ææ‡Æü‡ØÅ
            } else if (hour < 22) {
                return ' ‡ÆÆ‡Ææ‡Æ≤‡Øà'; // ‡ÆÆ‡Ææ‡Æ≤‡Øà
            } else {
                return ' ‡ÆØ‡Ææ‡ÆÆ‡ÆÆ‡Øç';
            }
        },
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '‡ÆØ‡Ææ‡ÆÆ‡ÆÆ‡Øç') {
                return hour < 2 ? hour : hour + 12;
            } else if (meridiem === '‡Æµ‡Øà‡Æï‡Æ±‡Øà' || meridiem === '‡Æï‡Ææ‡Æ≤‡Øà') {
                return hour;
            } else if (meridiem === '‡Æ®‡Æ£‡Øç‡Æ™‡Æï‡Æ≤‡Øç') {
                return hour >= 10 ? hour : hour + 12;
            } else {
                return hour + 12;
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : thai (th)
    //! author : Kridsada Thanabulpong : https://github.com/sirn

    var th = _moment__default.defineLocale('th', {
        months : '‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°_‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå_‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°_‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô_‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°_‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô_‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°_‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°_‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô_‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°_‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô_‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°'.split('_'),
        monthsShort : '‡∏°‡∏Å‡∏£‡∏≤_‡∏Å‡∏∏‡∏°‡∏†‡∏≤_‡∏°‡∏µ‡∏ô‡∏≤_‡πÄ‡∏°‡∏©‡∏≤_‡∏û‡∏§‡∏©‡∏†‡∏≤_‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤_‡∏Å‡∏£‡∏Å‡∏é‡∏≤_‡∏™‡∏¥‡∏á‡∏´‡∏≤_‡∏Å‡∏±‡∏ô‡∏¢‡∏≤_‡∏ï‡∏∏‡∏•‡∏≤_‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤_‡∏ò‡∏±‡∏ô‡∏ß‡∏≤'.split('_'),
        weekdays : '‡∏≠‡∏≤‡∏ó‡∏¥‡∏ï‡∏¢‡πå_‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå_‡∏≠‡∏±‡∏á‡∏Ñ‡∏≤‡∏£_‡∏û‡∏∏‡∏ò_‡∏û‡∏§‡∏´‡∏±‡∏™‡∏ö‡∏î‡∏µ_‡∏®‡∏∏‡∏Å‡∏£‡πå_‡πÄ‡∏™‡∏≤‡∏£‡πå'.split('_'),
        weekdaysShort : '‡∏≠‡∏≤‡∏ó‡∏¥‡∏ï‡∏¢‡πå_‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå_‡∏≠‡∏±‡∏á‡∏Ñ‡∏≤‡∏£_‡∏û‡∏∏‡∏ò_‡∏û‡∏§‡∏´‡∏±‡∏™_‡∏®‡∏∏‡∏Å‡∏£‡πå_‡πÄ‡∏™‡∏≤‡∏£‡πå'.split('_'), // yes, three characters difference
        weekdaysMin : '‡∏≠‡∏≤._‡∏à._‡∏≠._‡∏û._‡∏û‡∏§._‡∏®._‡∏™.'.split('_'),
        longDateFormat : {
            LT : 'H ‡∏ô‡∏≤‡∏¨‡∏¥‡∏Å‡∏≤ m ‡∏ô‡∏≤‡∏ó‡∏µ',
            LTS : 'LT s ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ',
            L : 'YYYY/MM/DD',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY ‡πÄ‡∏ß‡∏•‡∏≤ LT',
            LLLL : '‡∏ß‡∏±‡∏ôdddd‡∏ó‡∏µ‡πà D MMMM YYYY ‡πÄ‡∏ß‡∏•‡∏≤ LT'
        },
        meridiemParse: /‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏ó‡∏µ‡πà‡∏¢‡∏á|‡∏´‡∏•‡∏±‡∏á‡πÄ‡∏ó‡∏µ‡πà‡∏¢‡∏á/,
        isPM: function (input) {
            return input === '‡∏´‡∏•‡∏±‡∏á‡πÄ‡∏ó‡∏µ‡πà‡∏¢‡∏á';
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏ó‡∏µ‡πà‡∏¢‡∏á';
            } else {
                return '‡∏´‡∏•‡∏±‡∏á‡πÄ‡∏ó‡∏µ‡πà‡∏¢‡∏á';
            }
        },
        calendar : {
            sameDay : '[‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ ‡πÄ‡∏ß‡∏•‡∏≤] LT',
            nextDay : '[‡∏û‡∏£‡∏∏‡πà‡∏á‡∏ô‡∏µ‡πâ ‡πÄ‡∏ß‡∏•‡∏≤] LT',
            nextWeek : 'dddd[‡∏´‡∏ô‡πâ‡∏≤ ‡πÄ‡∏ß‡∏•‡∏≤] LT',
            lastDay : '[‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ß‡∏≤‡∏ô‡∏ô‡∏µ‡πâ ‡πÄ‡∏ß‡∏•‡∏≤] LT',
            lastWeek : '[‡∏ß‡∏±‡∏ô]dddd[‡∏ó‡∏µ‡πà‡πÅ‡∏•‡πâ‡∏ß ‡πÄ‡∏ß‡∏•‡∏≤] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '‡∏≠‡∏µ‡∏Å %s',
            past : '%s‡∏ó‡∏µ‡πà‡πÅ‡∏•‡πâ‡∏ß',
            s : '‡πÑ‡∏°‡πà‡∏Å‡∏µ‡πà‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ',
            m : '1 ‡∏ô‡∏≤‡∏ó‡∏µ',
            mm : '%d ‡∏ô‡∏≤‡∏ó‡∏µ',
            h : '1 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á',
            hh : '%d ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á',
            d : '1 ‡∏ß‡∏±‡∏ô',
            dd : '%d ‡∏ß‡∏±‡∏ô',
            M : '1 ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô',
            MM : '%d ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô',
            y : '1 ‡∏õ‡∏µ',
            yy : '%d ‡∏õ‡∏µ'
        }
    });

    //! moment.js locale configuration
    //! locale : Tagalog/Filipino (tl-ph)
    //! author : Dan Hagman

    var tl_ph = _moment__default.defineLocale('tl-ph', {
        months : 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
        monthsShort : 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
        weekdays : 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
        weekdaysShort : 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
        weekdaysMin : 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'MM/D/YYYY',
            LL : 'MMMM D, YYYY',
            LLL : 'MMMM D, YYYY LT',
            LLLL : 'dddd, MMMM DD, YYYY LT'
        },
        calendar : {
            sameDay: '[Ngayon sa] LT',
            nextDay: '[Bukas sa] LT',
            nextWeek: 'dddd [sa] LT',
            lastDay: '[Kahapon sa] LT',
            lastWeek: 'dddd [huling linggo] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'sa loob ng %s',
            past : '%s ang nakalipas',
            s : 'ilang segundo',
            m : 'isang minuto',
            mm : '%d minuto',
            h : 'isang oras',
            hh : '%d oras',
            d : 'isang araw',
            dd : '%d araw',
            M : 'isang buwan',
            MM : '%d buwan',
            y : 'isang taon',
            yy : '%d taon'
        },
        ordinalParse: /\d{1,2}/,
        ordinal : function (number) {
            return number;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : turkish (tr)
    //! authors : Erhan Gundogan : https://github.com/erhangundogan,
    //!           Burak Yiƒüit Kaya: https://github.com/BYK

    var tr__suffixes = {
        1: '\'inci',
        5: '\'inci',
        8: '\'inci',
        70: '\'inci',
        80: '\'inci',
        2: '\'nci',
        7: '\'nci',
        20: '\'nci',
        50: '\'nci',
        3: '\'√ºnc√º',
        4: '\'√ºnc√º',
        100: '\'√ºnc√º',
        6: '\'ncƒ±',
        9: '\'uncu',
        10: '\'uncu',
        30: '\'uncu',
        60: '\'ƒ±ncƒ±',
        90: '\'ƒ±ncƒ±'
    };

    var tr = _moment__default.defineLocale('tr', {
        months : 'Ocak_≈ûubat_Mart_Nisan_Mayƒ±s_Haziran_Temmuz_Aƒüustos_Eyl√ºl_Ekim_Kasƒ±m_Aralƒ±k'.split('_'),
        monthsShort : 'Oca_≈ûub_Mar_Nis_May_Haz_Tem_Aƒüu_Eyl_Eki_Kas_Ara'.split('_'),
        weekdays : 'Pazar_Pazartesi_Salƒ±_√áar≈üamba_Per≈üembe_Cuma_Cumartesi'.split('_'),
        weekdaysShort : 'Paz_Pts_Sal_√áar_Per_Cum_Cts'.split('_'),
        weekdaysMin : 'Pz_Pt_Sa_√áa_Pe_Cu_Ct'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd, D MMMM YYYY LT'
        },
        calendar : {
            sameDay : '[bug√ºn saat] LT',
            nextDay : '[yarƒ±n saat] LT',
            nextWeek : '[haftaya] dddd [saat] LT',
            lastDay : '[d√ºn] LT',
            lastWeek : '[ge√ßen hafta] dddd [saat] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s sonra',
            past : '%s √∂nce',
            s : 'birka√ß saniye',
            m : 'bir dakika',
            mm : '%d dakika',
            h : 'bir saat',
            hh : '%d saat',
            d : 'bir g√ºn',
            dd : '%d g√ºn',
            M : 'bir ay',
            MM : '%d ay',
            y : 'bir yƒ±l',
            yy : '%d yƒ±l'
        },
        ordinalParse: /\d{1,2}'(inci|nci|√ºnc√º|ncƒ±|uncu|ƒ±ncƒ±)/,
        ordinal : function (number) {
            if (number === 0) {  // special case for zero
                return number + '\'ƒ±ncƒ±';
            }
            var a = number % 10,
                b = number % 100 - a,
                c = number >= 100 ? 100 : null;
            return number + (tr__suffixes[a] || tr__suffixes[b] || tr__suffixes[c]);
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Morocco Central Atlas Tamazi…£t in Latin (tzm-latn)
    //! author : Abdel Said : https://github.com/abdelsaid

    var tzm_latn = _moment__default.defineLocale('tzm-latn', {
        months : 'innayr_brÀ§ayrÀ§_marÀ§sÀ§_ibrir_mayyw_ywnyw_ywlywz_…£w≈°t_≈°wtanbir_ktÀ§wbrÀ§_nwwanbir_dwjnbir'.split('_'),
        monthsShort : 'innayr_brÀ§ayrÀ§_marÀ§sÀ§_ibrir_mayyw_ywnyw_ywlywz_…£w≈°t_≈°wtanbir_ktÀ§wbrÀ§_nwwanbir_dwjnbir'.split('_'),
        weekdays : 'asamas_aynas_asinas_akras_akwas_asimwas_asi·∏çyas'.split('_'),
        weekdaysShort : 'asamas_aynas_asinas_akras_akwas_asimwas_asi·∏çyas'.split('_'),
        weekdaysMin : 'asamas_aynas_asinas_akras_akwas_asimwas_asi·∏çyas'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd D MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[asdkh g] LT',
            nextDay: '[aska g] LT',
            nextWeek: 'dddd [g] LT',
            lastDay: '[assant g] LT',
            lastWeek: 'dddd [g] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'dadkh s yan %s',
            past : 'yan %s',
            s : 'imik',
            m : 'minu·∏ç',
            mm : '%d minu·∏ç',
            h : 'sa…õa',
            hh : '%d tassa…õin',
            d : 'ass',
            dd : '%d ossan',
            M : 'ayowr',
            MM : '%d iyyirn',
            y : 'asgas',
            yy : '%d isgasn'
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Morocco Central Atlas Tamazi…£t (tzm)
    //! author : Abdel Said : https://github.com/abdelsaid

    var tzm = _moment__default.defineLocale('tzm', {
        months : '‚µâ‚µè‚µè‚¥∞‚µ¢‚µî_‚¥±‚µï‚¥∞‚µ¢‚µï_‚µé‚¥∞‚µï‚µö_‚µâ‚¥±‚µî‚µâ‚µî_‚µé‚¥∞‚µ¢‚µ¢‚µì_‚µ¢‚µì‚µè‚µ¢‚µì_‚µ¢‚µì‚µç‚µ¢‚µì‚µ£_‚µñ‚µì‚µõ‚µú_‚µõ‚µì‚µú‚¥∞‚µè‚¥±‚µâ‚µî_‚¥Ω‚µü‚µì‚¥±‚µï_‚µè‚µì‚µ°‚¥∞‚µè‚¥±‚µâ‚µî_‚¥∑‚µì‚µä‚µè‚¥±‚µâ‚µî'.split('_'),
        monthsShort : '‚µâ‚µè‚µè‚¥∞‚µ¢‚µî_‚¥±‚µï‚¥∞‚µ¢‚µï_‚µé‚¥∞‚µï‚µö_‚µâ‚¥±‚µî‚µâ‚µî_‚µé‚¥∞‚µ¢‚µ¢‚µì_‚µ¢‚µì‚µè‚µ¢‚µì_‚µ¢‚µì‚µç‚µ¢‚µì‚µ£_‚µñ‚µì‚µõ‚µú_‚µõ‚µì‚µú‚¥∞‚µè‚¥±‚µâ‚µî_‚¥Ω‚µü‚µì‚¥±‚µï_‚µè‚µì‚µ°‚¥∞‚µè‚¥±‚µâ‚µî_‚¥∑‚µì‚µä‚µè‚¥±‚µâ‚µî'.split('_'),
        weekdays : '‚¥∞‚µô‚¥∞‚µé‚¥∞‚µô_‚¥∞‚µ¢‚µè‚¥∞‚µô_‚¥∞‚µô‚µâ‚µè‚¥∞‚µô_‚¥∞‚¥Ω‚µî‚¥∞‚µô_‚¥∞‚¥Ω‚µ°‚¥∞‚µô_‚¥∞‚µô‚µâ‚µé‚µ°‚¥∞‚µô_‚¥∞‚µô‚µâ‚¥π‚µ¢‚¥∞‚µô'.split('_'),
        weekdaysShort : '‚¥∞‚µô‚¥∞‚µé‚¥∞‚µô_‚¥∞‚µ¢‚µè‚¥∞‚µô_‚¥∞‚µô‚µâ‚µè‚¥∞‚µô_‚¥∞‚¥Ω‚µî‚¥∞‚µô_‚¥∞‚¥Ω‚µ°‚¥∞‚µô_‚¥∞‚µô‚µâ‚µé‚µ°‚¥∞‚µô_‚¥∞‚µô‚µâ‚¥π‚µ¢‚¥∞‚µô'.split('_'),
        weekdaysMin : '‚¥∞‚µô‚¥∞‚µé‚¥∞‚µô_‚¥∞‚µ¢‚µè‚¥∞‚µô_‚¥∞‚µô‚µâ‚µè‚¥∞‚µô_‚¥∞‚¥Ω‚µî‚¥∞‚µô_‚¥∞‚¥Ω‚µ°‚¥∞‚µô_‚¥∞‚µô‚µâ‚µé‚µ°‚¥∞‚µô_‚¥∞‚µô‚µâ‚¥π‚µ¢‚¥∞‚µô'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS: 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'dddd D MMMM YYYY LT'
        },
        calendar : {
            sameDay: '[‚¥∞‚µô‚¥∑‚µÖ ‚¥¥] LT',
            nextDay: '[‚¥∞‚µô‚¥Ω‚¥∞ ‚¥¥] LT',
            nextWeek: 'dddd [‚¥¥] LT',
            lastDay: '[‚¥∞‚µö‚¥∞‚µè‚µú ‚¥¥] LT',
            lastWeek: 'dddd [‚¥¥] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : '‚¥∑‚¥∞‚¥∑‚µÖ ‚µô ‚µ¢‚¥∞‚µè %s',
            past : '‚µ¢‚¥∞‚µè %s',
            s : '‚µâ‚µé‚µâ‚¥Ω',
            m : '‚µé‚µâ‚µè‚µì‚¥∫',
            mm : '%d ‚µé‚µâ‚µè‚µì‚¥∫',
            h : '‚µô‚¥∞‚µÑ‚¥∞',
            hh : '%d ‚µú‚¥∞‚µô‚µô‚¥∞‚µÑ‚µâ‚µè',
            d : '‚¥∞‚µô‚µô',
            dd : '%d o‚µô‚µô‚¥∞‚µè',
            M : '‚¥∞‚µ¢o‚µì‚µî',
            MM : '%d ‚µâ‚µ¢‚µ¢‚µâ‚µî‚µè',
            y : '‚¥∞‚µô‚¥≥‚¥∞‚µô',
            yy : '%d ‚µâ‚µô‚¥≥‚¥∞‚µô‚µè'
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : ukrainian (uk)
    //! author : zemlanin : https://github.com/zemlanin
    //! Author : Menelion Elens√∫le : https://github.com/Oire

    function uk__plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
    }
    function uk__relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'mm': '—Ö–≤–∏–ª–∏–Ω–∞_—Ö–≤–∏–ª–∏–Ω–∏_—Ö–≤–∏–ª–∏–Ω',
            'hh': '–≥–æ–¥–∏–Ω–∞_–≥–æ–¥–∏–Ω–∏_–≥–æ–¥–∏–Ω',
            'dd': '–¥–µ–Ω—å_–¥–Ω—ñ_–¥–Ω—ñ–≤',
            'MM': '–º—ñ—Å—è—Ü—å_–º—ñ—Å—è—Ü—ñ_–º—ñ—Å—è—Ü—ñ–≤',
            'yy': '—Ä—ñ–∫_—Ä–æ–∫–∏_—Ä–æ–∫—ñ–≤'
        };
        if (key === 'm') {
            return withoutSuffix ? '—Ö–≤–∏–ª–∏–Ω–∞' : '—Ö–≤–∏–ª–∏–Ω—É';
        }
        else if (key === 'h') {
            return withoutSuffix ? '–≥–æ–¥–∏–Ω–∞' : '–≥–æ–¥–∏–Ω—É';
        }
        else {
            return number + ' ' + uk__plural(format[key], +number);
        }
    }
    function uk__monthsCaseReplace(m, format) {
        var months = {
            'nominative': '—Å—ñ—á–µ–Ω—å_–ª—é—Ç–∏–π_–±–µ—Ä–µ–∑–µ–Ω—å_–∫–≤—ñ—Ç–µ–Ω—å_—Ç—Ä–∞–≤–µ–Ω—å_—á–µ—Ä–≤–µ–Ω—å_–ª–∏–ø–µ–Ω—å_—Å–µ—Ä–ø–µ–Ω—å_–≤–µ—Ä–µ—Å–µ–Ω—å_–∂–æ–≤—Ç–µ–Ω—å_–ª–∏—Å—Ç–æ–ø–∞–¥_–≥—Ä—É–¥–µ–Ω—å'.split('_'),
            'accusative': '—Å—ñ—á–Ω—è_–ª—é—Ç–æ–≥–æ_–±–µ—Ä–µ–∑–Ω—è_–∫–≤—ñ—Ç–Ω—è_—Ç—Ä–∞–≤–Ω—è_—á–µ—Ä–≤–Ω—è_–ª–∏–ø–Ω—è_—Å–µ—Ä–ø–Ω—è_–≤–µ—Ä–µ—Å–Ω—è_–∂–æ–≤—Ç–Ω—è_–ª–∏—Å—Ç–æ–ø–∞–¥–∞_–≥—Ä—É–¥–Ω—è'.split('_')
        },
        nounCase = (/D[oD]? *MMMM?/).test(format) ?
            'accusative' :
            'nominative';
        return months[nounCase][m.month()];
    }
    function uk__weekdaysCaseReplace(m, format) {
        var weekdays = {
            'nominative': '–Ω–µ–¥—ñ–ª—è_–ø–æ–Ω–µ–¥—ñ–ª–æ–∫_–≤—ñ–≤—Ç–æ—Ä–æ–∫_—Å–µ—Ä–µ–¥–∞_—á–µ—Ç–≤–µ—Ä_–ø‚Äô—è—Ç–Ω–∏—Ü—è_—Å—É–±–æ—Ç–∞'.split('_'),
            'accusative': '–Ω–µ–¥—ñ–ª—é_–ø–æ–Ω–µ–¥—ñ–ª–æ–∫_–≤—ñ–≤—Ç–æ—Ä–æ–∫_—Å–µ—Ä–µ–¥—É_—á–µ—Ç–≤–µ—Ä_–ø‚Äô—è—Ç–Ω–∏—Ü—é_—Å—É–±–æ—Ç—É'.split('_'),
            'genitive': '–Ω–µ–¥—ñ–ª—ñ_–ø–æ–Ω–µ–¥—ñ–ª–∫–∞_–≤—ñ–≤—Ç–æ—Ä–∫–∞_—Å–µ—Ä–µ–¥–∏_—á–µ—Ç–≤–µ—Ä–≥–∞_–ø‚Äô—è—Ç–Ω–∏—Ü—ñ_—Å—É–±–æ—Ç–∏'.split('_')
        },
        nounCase = (/(\[[–í–≤–£—É]\]) ?dddd/).test(format) ?
            'accusative' :
            ((/\[?(?:–º–∏–Ω—É–ª–æ—ó|–Ω–∞—Å—Ç—É–ø–Ω–æ—ó)? ?\] ?dddd/).test(format) ?
                'genitive' :
                'nominative');
        return weekdays[nounCase][m.day()];
    }
    function processHoursFunction(str) {
        return function () {
            return str + '–æ' + (this.hours() === 11 ? '–±' : '') + '] LT';
        };
    }

    var uk = _moment__default.defineLocale('uk', {
        months : uk__monthsCaseReplace,
        monthsShort : '—Å—ñ—á_–ª—é—Ç_–±–µ—Ä_–∫–≤—ñ—Ç_—Ç—Ä–∞–≤_—á–µ—Ä–≤_–ª–∏–ø_—Å–µ—Ä–ø_–≤–µ—Ä_–∂–æ–≤—Ç_–ª–∏—Å—Ç_–≥—Ä—É–¥'.split('_'),
        weekdays : uk__weekdaysCaseReplace,
        weekdaysShort : '–Ω–¥_–ø–Ω_–≤—Ç_—Å—Ä_—á—Ç_–ø—Ç_—Å–±'.split('_'),
        weekdaysMin : '–Ω–¥_–ø–Ω_–≤—Ç_—Å—Ä_—á—Ç_–ø—Ç_—Å–±'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY —Ä.',
            LLL : 'D MMMM YYYY —Ä., LT',
            LLLL : 'dddd, D MMMM YYYY —Ä., LT'
        },
        calendar : {
            sameDay: processHoursFunction('[–°—å–æ–≥–æ–¥–Ω—ñ '),
            nextDay: processHoursFunction('[–ó–∞–≤—Ç—Ä–∞ '),
            lastDay: processHoursFunction('[–í—á–æ—Ä–∞ '),
            nextWeek: processHoursFunction('[–£] dddd ['),
            lastWeek: function () {
                switch (this.day()) {
                case 0:
                case 3:
                case 5:
                case 6:
                    return processHoursFunction('[–ú–∏–Ω—É–ª–æ—ó] dddd [').call(this);
                case 1:
                case 2:
                case 4:
                    return processHoursFunction('[–ú–∏–Ω—É–ª–æ–≥–æ] dddd [').call(this);
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : '–∑–∞ %s',
            past : '%s —Ç–æ–º—É',
            s : '–¥–µ–∫—ñ–ª—å–∫–∞ —Å–µ–∫—É–Ω–¥',
            m : uk__relativeTimeWithPlural,
            mm : uk__relativeTimeWithPlural,
            h : '–≥–æ–¥–∏–Ω—É',
            hh : uk__relativeTimeWithPlural,
            d : '–¥–µ–Ω—å',
            dd : uk__relativeTimeWithPlural,
            M : '–º—ñ—Å—è—Ü—å',
            MM : uk__relativeTimeWithPlural,
            y : '—Ä—ñ–∫',
            yy : uk__relativeTimeWithPlural
        },
        // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
        meridiemParse: /–Ω–æ—á—ñ|—Ä–∞–Ω–∫—É|–¥–Ω—è|–≤–µ—á–æ—Ä–∞/,
        isPM: function (input) {
            return /^(–¥–Ω—è|–≤–µ—á–æ—Ä–∞)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '–Ω–æ—á—ñ';
            } else if (hour < 12) {
                return '—Ä–∞–Ω–∫—É';
            } else if (hour < 17) {
                return '–¥–Ω—è';
            } else {
                return '–≤–µ—á–æ—Ä–∞';
            }
        },
        ordinalParse: /\d{1,2}-(–π|–≥–æ)/,
        ordinal: function (number, period) {
            switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
            case 'w':
            case 'W':
                return number + '-–π';
            case 'D':
                return number + '-–≥–æ';
            default:
                return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : uzbek (uz)
    //! author : Sardor Muminov : https://github.com/muminoff

    var uz = _moment__default.defineLocale('uz', {
        months : '—è–Ω–≤–∞—Ä—å_—Ñ–µ–≤—Ä–∞–ª—å_–º–∞—Ä—Ç_–∞–ø—Ä–µ–ª—å_–º–∞–π_–∏—é–Ω—å_–∏—é–ª—å_–∞–≤–≥—É—Å—Ç_—Å–µ–Ω—Ç—è–±—Ä—å_–æ–∫—Ç—è–±—Ä—å_–Ω–æ—è–±—Ä—å_–¥–µ–∫–∞–±—Ä—å'.split('_'),
        monthsShort : '—è–Ω–≤_—Ñ–µ–≤_–º–∞—Ä_–∞–ø—Ä_–º–∞–π_–∏—é–Ω_–∏—é–ª_–∞–≤–≥_—Å–µ–Ω_–æ–∫—Ç_–Ω–æ—è_–¥–µ–∫'.split('_'),
        weekdays : '–Ø–∫—à–∞–Ω–±–∞_–î—É—à–∞–Ω–±–∞_–°–µ—à–∞–Ω–±–∞_–ß–æ—Ä—à–∞–Ω–±–∞_–ü–∞–π—à–∞–Ω–±–∞_–ñ—É–º–∞_–®–∞–Ω–±–∞'.split('_'),
        weekdaysShort : '–Ø–∫—à_–î—É—à_–°–µ—à_–ß–æ—Ä_–ü–∞–π_–ñ—É–º_–®–∞–Ω'.split('_'),
        weekdaysMin : '–Ø–∫_–î—É_–°–µ_–ß–æ_–ü–∞_–ñ—É_–®–∞'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY LT',
            LLLL : 'D MMMM YYYY, dddd LT'
        },
        calendar : {
            sameDay : '[–ë—É–≥—É–Ω —Å–æ–∞—Ç] LT [–¥–∞]',
            nextDay : '[–≠—Ä—Ç–∞–≥–∞] LT [–¥–∞]',
            nextWeek : 'dddd [–∫—É–Ω–∏ —Å–æ–∞—Ç] LT [–¥–∞]',
            lastDay : '[–ö–µ—á–∞ —Å–æ–∞—Ç] LT [–¥–∞]',
            lastWeek : '[–£—Ç–≥–∞–Ω] dddd [–∫—É–Ω–∏ —Å–æ–∞—Ç] LT [–¥–∞]',
            sameElse : 'L'
        },
        relativeTime : {
            future : '–Ø–∫–∏–Ω %s –∏—á–∏–¥–∞',
            past : '–ë–∏—Ä –Ω–µ—á–∞ %s –æ–ª–¥–∏–Ω',
            s : '—Ñ—É—Ä—Å–∞—Ç',
            m : '–±–∏—Ä –¥–∞–∫–∏–∫–∞',
            mm : '%d –¥–∞–∫–∏–∫–∞',
            h : '–±–∏—Ä —Å–æ–∞—Ç',
            hh : '%d —Å–æ–∞—Ç',
            d : '–±–∏—Ä –∫—É–Ω',
            dd : '%d –∫—É–Ω',
            M : '–±–∏—Ä –æ–π',
            MM : '%d –æ–π',
            y : '–±–∏—Ä –π–∏–ª',
            yy : '%d –π–∏–ª'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : vietnamese (vi)
    //! author : Bang Nguyen : https://github.com/bangnk

    var vi = _moment__default.defineLocale('vi', {
        months : 'th√°ng 1_th√°ng 2_th√°ng 3_th√°ng 4_th√°ng 5_th√°ng 6_th√°ng 7_th√°ng 8_th√°ng 9_th√°ng 10_th√°ng 11_th√°ng 12'.split('_'),
        monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
        weekdays : 'ch·ªß nh·∫≠t_th·ª© hai_th·ª© ba_th·ª© t∆∞_th·ª© nƒÉm_th·ª© s√°u_th·ª© b·∫£y'.split('_'),
        weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
        weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM [nƒÉm] YYYY',
            LLL : 'D MMMM [nƒÉm] YYYY LT',
            LLLL : 'dddd, D MMMM [nƒÉm] YYYY LT',
            l : 'DD/M/YYYY',
            ll : 'D MMM YYYY',
            lll : 'D MMM YYYY LT',
            llll : 'ddd, D MMM YYYY LT'
        },
        calendar : {
            sameDay: '[H√¥m nay l√∫c] LT',
            nextDay: '[Ng√†y mai l√∫c] LT',
            nextWeek: 'dddd [tu·∫ßn t·ªõi l√∫c] LT',
            lastDay: '[H√¥m qua l√∫c] LT',
            lastWeek: 'dddd [tu·∫ßn r·ªìi l√∫c] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : '%s t·ªõi',
            past : '%s tr∆∞·ªõc',
            s : 'v√†i gi√¢y',
            m : 'm·ªôt ph√∫t',
            mm : '%d ph√∫t',
            h : 'm·ªôt gi·ªù',
            hh : '%d gi·ªù',
            d : 'm·ªôt ng√†y',
            dd : '%d ng√†y',
            M : 'm·ªôt th√°ng',
            MM : '%d th√°ng',
            y : 'm·ªôt nƒÉm',
            yy : '%d nƒÉm'
        },
        ordinalParse: /\d{1,2}/,
        ordinal : function (number) {
            return number;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : chinese (zh-cn)
    //! author : suupic : https://github.com/suupic
    //! author : Zeno Zeng : https://github.com/zenozeng

    var zh_cn = _moment__default.defineLocale('zh-cn', {
        months : '‰∏ÄÊúà_‰∫åÊúà_‰∏âÊúà_ÂõõÊúà_‰∫îÊúà_ÂÖ≠Êúà_‰∏ÉÊúà_ÂÖ´Êúà_‰πùÊúà_ÂçÅÊúà_ÂçÅ‰∏ÄÊúà_ÂçÅ‰∫åÊúà'.split('_'),
        monthsShort : '1Êúà_2Êúà_3Êúà_4Êúà_5Êúà_6Êúà_7Êúà_8Êúà_9Êúà_10Êúà_11Êúà_12Êúà'.split('_'),
        weekdays : 'ÊòüÊúüÊó•_ÊòüÊúü‰∏Ä_ÊòüÊúü‰∫å_ÊòüÊúü‰∏â_ÊòüÊúüÂõõ_ÊòüÊúü‰∫î_ÊòüÊúüÂÖ≠'.split('_'),
        weekdaysShort : 'Âë®Êó•_Âë®‰∏Ä_Âë®‰∫å_Âë®‰∏â_Âë®Âõõ_Âë®‰∫î_Âë®ÂÖ≠'.split('_'),
        weekdaysMin : 'Êó•_‰∏Ä_‰∫å_‰∏â_Âõõ_‰∫î_ÂÖ≠'.split('_'),
        longDateFormat : {
            LT : 'AhÁÇπmmÂàÜ',
            LTS : 'AhÁÇπmÂàÜsÁßí',
            L : 'YYYY-MM-DD',
            LL : 'YYYYÂπ¥MMMDÊó•',
            LLL : 'YYYYÂπ¥MMMDÊó•LT',
            LLLL : 'YYYYÂπ¥MMMDÊó•ddddLT',
            l : 'YYYY-MM-DD',
            ll : 'YYYYÂπ¥MMMDÊó•',
            lll : 'YYYYÂπ¥MMMDÊó•LT',
            llll : 'YYYYÂπ¥MMMDÊó•ddddLT'
        },
        meridiemParse: /ÂáåÊô®|Êó©‰∏ä|‰∏äÂçà|‰∏≠Âçà|‰∏ãÂçà|Êôö‰∏ä/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'ÂáåÊô®' || meridiem === 'Êó©‰∏ä' ||
                    meridiem === '‰∏äÂçà') {
                return hour;
            } else if (meridiem === '‰∏ãÂçà' || meridiem === 'Êôö‰∏ä') {
                return hour + 12;
            } else {
                // '‰∏≠Âçà'
                return hour >= 11 ? hour : hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return 'ÂáåÊô®';
            } else if (hm < 900) {
                return 'Êó©‰∏ä';
            } else if (hm < 1130) {
                return '‰∏äÂçà';
            } else if (hm < 1230) {
                return '‰∏≠Âçà';
            } else if (hm < 1800) {
                return '‰∏ãÂçà';
            } else {
                return 'Êôö‰∏ä';
            }
        },
        calendar : {
            sameDay : function () {
                return this.minutes() === 0 ? '[‰ªäÂ§©]Ah[ÁÇπÊï¥]' : '[‰ªäÂ§©]LT';
            },
            nextDay : function () {
                return this.minutes() === 0 ? '[ÊòéÂ§©]Ah[ÁÇπÊï¥]' : '[ÊòéÂ§©]LT';
            },
            lastDay : function () {
                return this.minutes() === 0 ? '[Êò®Â§©]Ah[ÁÇπÊï¥]' : '[Êò®Â§©]LT';
            },
            nextWeek : function () {
                var startOfWeek, prefix;
                startOfWeek = _moment__default().startOf('week');
                prefix = this.unix() - startOfWeek.unix() >= 7 * 24 * 3600 ? '[‰∏ã]' : '[Êú¨]';
                return this.minutes() === 0 ? prefix + 'dddAhÁÇπÊï¥' : prefix + 'dddAhÁÇπmm';
            },
            lastWeek : function () {
                var startOfWeek, prefix;
                startOfWeek = _moment__default().startOf('week');
                prefix = this.unix() < startOfWeek.unix()  ? '[‰∏ä]' : '[Êú¨]';
                return this.minutes() === 0 ? prefix + 'dddAhÁÇπÊï¥' : prefix + 'dddAhÁÇπmm';
            },
            sameElse : 'LL'
        },
        ordinalParse: /\d{1,2}(Êó•|Êúà|Âë®)/,
        ordinal : function (number, period) {
            switch (period) {
            case 'd':
            case 'D':
            case 'DDD':
                return number + 'Êó•';
            case 'M':
                return number + 'Êúà';
            case 'w':
            case 'W':
                return number + 'Âë®';
            default:
                return number;
            }
        },
        relativeTime : {
            future : '%sÂÜÖ',
            past : '%sÂâç',
            s : 'Âá†Áßí',
            m : '1 ÂàÜÈíü',
            mm : '%d ÂàÜÈíü',
            h : '1 Â∞èÊó∂',
            hh : '%d Â∞èÊó∂',
            d : '1 Â§©',
            dd : '%d Â§©',
            M : '1 ‰∏™Êúà',
            MM : '%d ‰∏™Êúà',
            y : '1 Âπ¥',
            yy : '%d Âπ¥'
        },
        week : {
            // GB/T 7408-1994„ÄäÊï∞ÊçÆÂÖÉÂíå‰∫§Êç¢Ê†ºÂºè¬∑‰ø°ÊÅØ‰∫§Êç¢¬∑Êó•ÊúüÂíåÊó∂Èó¥Ë°®Á§∫Ê≥ï„Äã‰∏éISO 8601:1988Á≠âÊïà
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : traditional chinese (zh-tw)
    //! author : Ben : https://github.com/ben-lin

    var zh_tw = _moment__default.defineLocale('zh-tw', {
        months : '‰∏ÄÊúà_‰∫åÊúà_‰∏âÊúà_ÂõõÊúà_‰∫îÊúà_ÂÖ≠Êúà_‰∏ÉÊúà_ÂÖ´Êúà_‰πùÊúà_ÂçÅÊúà_ÂçÅ‰∏ÄÊúà_ÂçÅ‰∫åÊúà'.split('_'),
        monthsShort : '1Êúà_2Êúà_3Êúà_4Êúà_5Êúà_6Êúà_7Êúà_8Êúà_9Êúà_10Êúà_11Êúà_12Êúà'.split('_'),
        weekdays : 'ÊòüÊúüÊó•_ÊòüÊúü‰∏Ä_ÊòüÊúü‰∫å_ÊòüÊúü‰∏â_ÊòüÊúüÂõõ_ÊòüÊúü‰∫î_ÊòüÊúüÂÖ≠'.split('_'),
        weekdaysShort : 'ÈÄ±Êó•_ÈÄ±‰∏Ä_ÈÄ±‰∫å_ÈÄ±‰∏â_ÈÄ±Âõõ_ÈÄ±‰∫î_ÈÄ±ÂÖ≠'.split('_'),
        weekdaysMin : 'Êó•_‰∏Ä_‰∫å_‰∏â_Âõõ_‰∫î_ÂÖ≠'.split('_'),
        longDateFormat : {
            LT : 'AhÈªûmmÂàÜ',
            LTS : 'AhÈªûmÂàÜsÁßí',
            L : 'YYYYÂπ¥MMMDÊó•',
            LL : 'YYYYÂπ¥MMMDÊó•',
            LLL : 'YYYYÂπ¥MMMDÊó•LT',
            LLLL : 'YYYYÂπ¥MMMDÊó•ddddLT',
            l : 'YYYYÂπ¥MMMDÊó•',
            ll : 'YYYYÂπ¥MMMDÊó•',
            lll : 'YYYYÂπ¥MMMDÊó•LT',
            llll : 'YYYYÂπ¥MMMDÊó•ddddLT'
        },
        meridiemParse: /Êó©‰∏ä|‰∏äÂçà|‰∏≠Âçà|‰∏ãÂçà|Êôö‰∏ä/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'Êó©‰∏ä' || meridiem === '‰∏äÂçà') {
                return hour;
            } else if (meridiem === '‰∏≠Âçà') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === '‰∏ãÂçà' || meridiem === 'Êôö‰∏ä') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 900) {
                return 'Êó©‰∏ä';
            } else if (hm < 1130) {
                return '‰∏äÂçà';
            } else if (hm < 1230) {
                return '‰∏≠Âçà';
            } else if (hm < 1800) {
                return '‰∏ãÂçà';
            } else {
                return 'Êôö‰∏ä';
            }
        },
        calendar : {
            sameDay : '[‰ªäÂ§©]LT',
            nextDay : '[ÊòéÂ§©]LT',
            nextWeek : '[‰∏ã]ddddLT',
            lastDay : '[Êò®Â§©]LT',
            lastWeek : '[‰∏ä]ddddLT',
            sameElse : 'L'
        },
        ordinalParse: /\d{1,2}(Êó•|Êúà|ÈÄ±)/,
        ordinal : function (number, period) {
            switch (period) {
            case 'd' :
            case 'D' :
            case 'DDD' :
                return number + 'Êó•';
            case 'M' :
                return number + 'Êúà';
            case 'w' :
            case 'W' :
                return number + 'ÈÄ±';
            default :
                return number;
            }
        },
        relativeTime : {
            future : '%sÂÖß',
            past : '%sÂâç',
            s : 'ÂπæÁßí',
            m : '‰∏ÄÂàÜÈêò',
            mm : '%dÂàÜÈêò',
            h : '‰∏ÄÂ∞èÊôÇ',
            hh : '%dÂ∞èÊôÇ',
            d : '‰∏ÄÂ§©',
            dd : '%dÂ§©',
            M : '‰∏ÄÂÄãÊúà',
            MM : '%dÂÄãÊúà',
            y : '‰∏ÄÂπ¥',
            yy : '%dÂπ¥'
        }
    });

    var moment_with_locales = _moment__default;

    return moment_with_locales;

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('af');

    test('parse', function (assert) {
        var tests = 'Januarie Jan_Februarie Feb_Maart Mar_April Apr_Mei Mei_Junie Jun_Julie Jul_Augustus Aug_September Sep_Oktober Okt_November Nov_Desember Des'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Sondag, Februarie 14de 2010, 3:25:50 nm'],
                ['ddd, hA',                            'Son, 3NM'],
                ['M Mo MM MMMM MMM',                   '2 2de 02 Februarie Feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14de 14'],
                ['d do dddd ddd dd',                   '0 0de Sondag Son So'],
                ['DDD DDDo DDDD',                      '45 45ste 045'],
                ['w wo ww',                            '6 6de 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'nm NM'],
                ['[the] DDDo [day of the year]',       'the 45ste day of the year'],
                ['LT',                                 '15:25'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 Februarie 2010'],
                ['LLL',                                '14 Februarie 2010 15:25'],
                ['LLLL',                               'Sondag, 14 Februarie 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Feb 2010'],
                ['lll',                                '14 Feb 2010 15:25'],
                ['llll',                               'Son, 14 Feb 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1ste', '1ste');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2de', '2de');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3de', '3de');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4de', '4de');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5de', '5de');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6de', '6de');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7de', '7de');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8ste', '8ste');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9de', '9de');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10de', '10de');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11de', '11de');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12de', '12de');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13de', '13de');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14de', '14de');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15de', '15de');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16de', '16de');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17de', '17de');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18de', '18de');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19de', '19de');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20ste', '20ste');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21ste', '21ste');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22ste', '22ste');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23ste', '23ste');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24ste', '24ste');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25ste', '25ste');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26ste', '26ste');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27ste', '27ste');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28ste', '28ste');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29ste', '29ste');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30ste', '30ste');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31ste', '31ste');
    });

    test('format month', function (assert) {
        var expected = 'Januarie Jan_Februarie Feb_Maart Mar_April Apr_Mei Mei_Junie Jun_Julie Jul_Augustus Aug_September Sep_Oktober Okt_November Nov_Desember Des'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Sondag Son So_Maandag Maa Ma_Dinsdag Din Di_Woensdag Woe Wo_Donderdag Don Do_Vrydag Vry Vr_Saterdag Sat Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\'n paar sekondes', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\'n minuut',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\'n minuut',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minute',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minute',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\'n uur',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\'n uur',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ure',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ure',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ure',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\'n dag',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\'n dag',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dae',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\'n dag',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dae',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dae',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\'n maand',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\'n maand',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\'n maand',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 maande',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 maande',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 maande',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\'n maand',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 maande',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\'n jaar',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 jaar',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\'n jaar',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 jaar',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'oor \'n paar sekondes',  'prefix');
        assert.equal(moment(0).from(30000), '\'n paar sekondes gelede', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '\'n paar sekondes gelede',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'oor \'n paar sekondes', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'oor 5 dae', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Vandag om 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Vandag om 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Vandag om 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'M√¥re om 02:00',    'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Vandag om 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Gister om 02:00',   'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[Laas] dddd [om] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[Laas] dddd [om] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[Laas] dddd [om] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52ste', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1ste', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1ste', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),    '2 02 2de', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),    '2 02 2de', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('ar-ma');

    test('parse', function (assert) {
        var tests = 'ŸäŸÜÿßŸäÿ±:ŸäŸÜÿßŸäÿ±_ŸÅÿ®ÿ±ÿßŸäÿ±:ŸÅÿ®ÿ±ÿßŸäÿ±_ŸÖÿßÿ±ÿ≥:ŸÖÿßÿ±ÿ≥_ÿ£ÿ®ÿ±ŸäŸÑ:ÿ£ÿ®ÿ±ŸäŸÑ_ŸÖÿßŸä:ŸÖÿßŸä_ŸäŸàŸÜŸäŸà:ŸäŸàŸÜŸäŸà_ŸäŸàŸÑŸäŸàÿ≤:ŸäŸàŸÑŸäŸàÿ≤_ÿ∫ÿ¥ÿ™:ÿ∫ÿ¥ÿ™_ÿ¥ÿ™ŸÜÿ®ÿ±:ÿ¥ÿ™ŸÜÿ®ÿ±_ÿ£ŸÉÿ™Ÿàÿ®ÿ±:ÿ£ŸÉÿ™Ÿàÿ®ÿ±_ŸÜŸàŸÜÿ®ÿ±:ŸÜŸàŸÜÿ®ÿ±_ÿØÿ¨ŸÜÿ®ÿ±:ÿØÿ¨ŸÜÿ®ÿ±'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(':');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'ÿßŸÑÿ£ÿ≠ÿØ, ŸÅÿ®ÿ±ÿßŸäÿ± 14 2010, 3:25:50 pm'],
                ['ddd, hA',                            'ÿßÿ≠ÿØ, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2 02 ŸÅÿ®ÿ±ÿßŸäÿ± ŸÅÿ®ÿ±ÿßŸäÿ±'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 ÿßŸÑÿ£ÿ≠ÿØ ÿßÿ≠ÿØ ÿ≠'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '8 8 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LT',                                 '15:25'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 ŸÅÿ®ÿ±ÿßŸäÿ± 2010'],
                ['LLL',                                '14 ŸÅÿ®ÿ±ÿßŸäÿ± 2010 15:25'],
                ['LLLL',                               'ÿßŸÑÿ£ÿ≠ÿØ 14 ŸÅÿ®ÿ±ÿßŸäÿ± 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 ŸÅÿ®ÿ±ÿßŸäÿ± 2010'],
                ['lll',                                '14 ŸÅÿ®ÿ±ÿßŸäÿ± 2010 15:25'],
                ['llll',                               'ÿßÿ≠ÿØ 14 ŸÅÿ®ÿ±ÿßŸäÿ± 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = 'ŸäŸÜÿßŸäÿ± ŸäŸÜÿßŸäÿ±_ŸÅÿ®ÿ±ÿßŸäÿ± ŸÅÿ®ÿ±ÿßŸäÿ±_ŸÖÿßÿ±ÿ≥ ŸÖÿßÿ±ÿ≥_ÿ£ÿ®ÿ±ŸäŸÑ ÿ£ÿ®ÿ±ŸäŸÑ_ŸÖÿßŸä ŸÖÿßŸä_ŸäŸàŸÜŸäŸà ŸäŸàŸÜŸäŸà_ŸäŸàŸÑŸäŸàÿ≤ ŸäŸàŸÑŸäŸàÿ≤_ÿ∫ÿ¥ÿ™ ÿ∫ÿ¥ÿ™_ÿ¥ÿ™ŸÜÿ®ÿ± ÿ¥ÿ™ŸÜÿ®ÿ±_ÿ£ŸÉÿ™Ÿàÿ®ÿ± ÿ£ŸÉÿ™Ÿàÿ®ÿ±_ŸÜŸàŸÜÿ®ÿ± ŸÜŸàŸÜÿ®ÿ±_ÿØÿ¨ŸÜÿ®ÿ± ÿØÿ¨ŸÜÿ®ÿ±'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'ÿßŸÑÿ£ÿ≠ÿØ ÿßÿ≠ÿØ ÿ≠_ÿßŸÑÿ•ÿ™ŸÜŸäŸÜ ÿßÿ™ŸÜŸäŸÜ ŸÜ_ÿßŸÑÿ´ŸÑÿßÿ´ÿßÿ° ÿ´ŸÑÿßÿ´ÿßÿ° ÿ´_ÿßŸÑÿ£ÿ±ÿ®ÿπÿßÿ° ÿßÿ±ÿ®ÿπÿßÿ° ÿ±_ÿßŸÑÿÆŸÖŸäÿ≥ ÿÆŸÖŸäÿ≥ ÿÆ_ÿßŸÑÿ¨ŸÖÿπÿ© ÿ¨ŸÖÿπÿ© ÿ¨_ÿßŸÑÿ≥ÿ®ÿ™ ÿ≥ÿ®ÿ™ ÿ≥'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'ÿ´ŸàÿßŸÜ', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ÿØŸÇŸäŸÇÿ©',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ÿØŸÇŸäŸÇÿ©',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ÿØŸÇÿßÿ¶ŸÇ',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ÿØŸÇÿßÿ¶ŸÇ',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ÿ≥ÿßÿπÿ©',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ÿ≥ÿßÿπÿ©',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ÿ≥ÿßÿπÿßÿ™',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ÿ≥ÿßÿπÿßÿ™',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ÿ≥ÿßÿπÿßÿ™',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ŸäŸàŸÖ',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ŸäŸàŸÖ',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ÿ£ŸäÿßŸÖ',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ŸäŸàŸÖ',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ÿ£ŸäÿßŸÖ',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ÿ£ŸäÿßŸÖ',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ÿ¥Ÿáÿ±',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ÿ¥Ÿáÿ±',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ÿ¥Ÿáÿ±',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ÿ£ÿ¥Ÿáÿ±',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ÿ£ÿ¥Ÿáÿ±',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ÿ£ÿ¥Ÿáÿ±',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ÿ¥Ÿáÿ±',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ÿ£ÿ¥Ÿáÿ±',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ÿ≥ŸÜÿ©',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ÿ≥ŸÜŸàÿßÿ™',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'ÿ≥ŸÜÿ©',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ÿ≥ŸÜŸàÿßÿ™',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'ŸÅŸä ÿ´ŸàÿßŸÜ',  'prefix');
        assert.equal(moment(0).from(30000), 'ŸÖŸÜÿ∞ ÿ´ŸàÿßŸÜ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'ŸÖŸÜÿ∞ ÿ´ŸàÿßŸÜ',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'ŸÅŸä ÿ´ŸàÿßŸÜ', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'ŸÅŸä 5 ÿ£ŸäÿßŸÖ', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'ÿßŸÑŸäŸàŸÖ ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ© 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'ÿßŸÑŸäŸàŸÖ ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ© 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'ÿßŸÑŸäŸàŸÖ ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ© 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'ÿ∫ÿØÿß ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ© 02:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'ÿßŸÑŸäŸàŸÖ ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ© 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'ÿ£ŸÖÿ≥ ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ© 02:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 31]).week(), 1, 'Dec 31 2011 should be week 1');
        assert.equal(moment([2012,  0,  6]).week(), 1, 'Jan  6 2012 should be week 1');
        assert.equal(moment([2012,  0,  7]).week(), 2, 'Jan  7 2012 should be week 2');
        assert.equal(moment([2012,  0, 13]).week(), 2, 'Jan 13 2012 should be week 2');
        assert.equal(moment([2012,  0, 14]).week(), 3, 'Jan 14 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 30]).week(), 1, 'Dec 30 2006 should be week 1');
        assert.equal(moment([2007,  0,  5]).week(), 1, 'Jan  5 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 2, 'Jan  6 2007 should be week 2');
        assert.equal(moment([2007,  0, 12]).week(), 2, 'Jan 12 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 3, 'Jan 13 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 1, 'Dec 29 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  4]).week(), 1, 'Jan  4 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 2, 'Jan  5 2008 should be week 2');
        assert.equal(moment([2008,  0, 11]).week(), 2, 'Jan 11 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 3, 'Jan 12 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 28]).week(), 1, 'Dec 28 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  3]).week(), 1, 'Jan  3 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 2, 'Jan  4 2003 should be week 2');
        assert.equal(moment([2003,  0, 10]).week(), 2, 'Jan 10 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 3, 'Jan 11 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 27]).week(), 1, 'Dec 27 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  2]).week(), 1, 'Jan  2 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 2, 'Jan  3 2009 should be week 2');
        assert.equal(moment([2009,  0,  9]).week(), 2, 'Jan  9 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 3, 'Jan 10 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 26]).week(), 1, 'Dec 26 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 2, 'Jan  2 2010 should be week 2');
        assert.equal(moment([2010,  0,  8]).week(), 2, 'Jan  8 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 3, 'Jan  9 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2011, 0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011, 0,  7]).week(), 1, 'Jan  7 2011 should be week 1');
        assert.equal(moment([2011, 0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011, 0, 14]).week(), 2, 'Jan 14 2011 should be week 2');
        assert.equal(moment([2011, 0, 15]).week(), 3, 'Jan 15 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 31]).format('w ww wo'), '1 01 1', 'Dec 31 2011 should be week 1');
        assert.equal(moment([2012,  0,  6]).format('w ww wo'), '1 01 1', 'Jan  6 2012 should be week 1');
        assert.equal(moment([2012,  0,  7]).format('w ww wo'), '2 02 2', 'Jan  7 2012 should be week 2');
        assert.equal(moment([2012,  0, 13]).format('w ww wo'), '2 02 2', 'Jan 13 2012 should be week 2');
        assert.equal(moment([2012,  0, 14]).format('w ww wo'), '3 03 3', 'Jan 14 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('ar-sa');

    test('parse', function (assert) {
        var tests = 'ŸäŸÜÿßŸäÿ±:ŸäŸÜÿßŸäÿ±_ŸÅÿ®ÿ±ÿßŸäÿ±:ŸÅÿ®ÿ±ÿßŸäÿ±_ŸÖÿßÿ±ÿ≥:ŸÖÿßÿ±ÿ≥_ÿ£ÿ®ÿ±ŸäŸÑ:ÿ£ÿ®ÿ±ŸäŸÑ_ŸÖÿßŸäŸà:ŸÖÿßŸäŸà_ŸäŸàŸÜŸäŸà:ŸäŸàŸÜŸäŸà_ŸäŸàŸÑŸäŸà:ŸäŸàŸÑŸäŸà_ÿ£ÿ∫ÿ≥ÿ∑ÿ≥:ÿ£ÿ∫ÿ≥ÿ∑ÿ≥_ÿ≥ÿ®ÿ™ŸÖÿ®ÿ±:ÿ≥ÿ®ÿ™ŸÖÿ®ÿ±_ÿ£ŸÉÿ™Ÿàÿ®ÿ±:ÿ£ŸÉÿ™Ÿàÿ®ÿ±_ŸÜŸàŸÅŸÖÿ®ÿ±:ŸÜŸàŸÅŸÖÿ®ÿ±_ÿØŸäÿ≥ŸÖÿ®ÿ±:ÿØŸäÿ≥ŸÖÿ®ÿ±'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1) + ' instead is month ' + moment(input, mmm).month());
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(':');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'ÿßŸÑÿ£ÿ≠ÿØÿå ŸÅÿ®ÿ±ÿßŸäÿ± Ÿ°Ÿ§ Ÿ¢Ÿ†Ÿ°Ÿ†ÿå Ÿ£:Ÿ¢Ÿ•:Ÿ•Ÿ† ŸÖ'],
                ['ddd, hA',                            'ÿ£ÿ≠ÿØÿå Ÿ£ŸÖ'],
                ['M Mo MM MMMM MMM',                   'Ÿ¢ Ÿ¢ Ÿ†Ÿ¢ ŸÅÿ®ÿ±ÿßŸäÿ± ŸÅÿ®ÿ±ÿßŸäÿ±'],
                ['YYYY YY',                            'Ÿ¢Ÿ†Ÿ°Ÿ† Ÿ°Ÿ†'],
                ['D Do DD',                            'Ÿ°Ÿ§ Ÿ°Ÿ§ Ÿ°Ÿ§'],
                ['d do dddd ddd dd',                   'Ÿ† Ÿ† ÿßŸÑÿ£ÿ≠ÿØ ÿ£ÿ≠ÿØ ÿ≠'],
                ['DDD DDDo DDDD',                      'Ÿ§Ÿ• Ÿ§Ÿ• Ÿ†Ÿ§Ÿ•'],
                ['w wo ww',                            'Ÿ® Ÿ® Ÿ†Ÿ®'],
                ['h hh',                               'Ÿ£ Ÿ†Ÿ£'],
                ['H HH',                               'Ÿ°Ÿ• Ÿ°Ÿ•'],
                ['m mm',                               'Ÿ¢Ÿ• Ÿ¢Ÿ•'],
                ['s ss',                               'Ÿ•Ÿ† Ÿ•Ÿ†'],
                ['a A',                                'ŸÖ ŸÖ'],
                ['[the] DDDo [day of the year]',       'the Ÿ§Ÿ• day of the year'],
                ['LT',                                 'Ÿ°Ÿ•:Ÿ¢Ÿ•'],
                ['LTS',                                'Ÿ°Ÿ•:Ÿ¢Ÿ•:Ÿ•Ÿ†'],
                ['L',                                  'Ÿ°Ÿ§/Ÿ†Ÿ¢/Ÿ¢Ÿ†Ÿ°Ÿ†'],
                ['LL',                                 'Ÿ°Ÿ§ ŸÅÿ®ÿ±ÿßŸäÿ± Ÿ¢Ÿ†Ÿ°Ÿ†'],
                ['LLL',                                'Ÿ°Ÿ§ ŸÅÿ®ÿ±ÿßŸäÿ± Ÿ¢Ÿ†Ÿ°Ÿ† Ÿ°Ÿ•:Ÿ¢Ÿ•'],
                ['LLLL',                               'ÿßŸÑÿ£ÿ≠ÿØ Ÿ°Ÿ§ ŸÅÿ®ÿ±ÿßŸäÿ± Ÿ¢Ÿ†Ÿ°Ÿ† Ÿ°Ÿ•:Ÿ¢Ÿ•'],
                ['l',                                  'Ÿ°Ÿ§/Ÿ¢/Ÿ¢Ÿ†Ÿ°Ÿ†'],
                ['ll',                                 'Ÿ°Ÿ§ ŸÅÿ®ÿ±ÿßŸäÿ± Ÿ¢Ÿ†Ÿ°Ÿ†'],
                ['lll',                                'Ÿ°Ÿ§ ŸÅÿ®ÿ±ÿßŸäÿ± Ÿ¢Ÿ†Ÿ°Ÿ† Ÿ°Ÿ•:Ÿ¢Ÿ•'],
                ['llll',                               'ÿ£ÿ≠ÿØ Ÿ°Ÿ§ ŸÅÿ®ÿ±ÿßŸäÿ± Ÿ¢Ÿ†Ÿ°Ÿ† Ÿ°Ÿ•:Ÿ¢Ÿ•']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), 'Ÿ°', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), 'Ÿ¢', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), 'Ÿ£', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), 'Ÿ§', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), 'Ÿ•', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), 'Ÿ¶', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), 'Ÿß', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), 'Ÿ®', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), 'Ÿ©', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), 'Ÿ°Ÿ†', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), 'Ÿ°Ÿ°', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), 'Ÿ°Ÿ¢', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), 'Ÿ°Ÿ£', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), 'Ÿ°Ÿ§', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), 'Ÿ°Ÿ•', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), 'Ÿ°Ÿ¶', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), 'Ÿ°Ÿß', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), 'Ÿ°Ÿ®', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), 'Ÿ°Ÿ©', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), 'Ÿ¢Ÿ†', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), 'Ÿ¢Ÿ°', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), 'Ÿ¢Ÿ¢', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), 'Ÿ¢Ÿ£', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), 'Ÿ¢Ÿ§', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), 'Ÿ¢Ÿ•', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), 'Ÿ¢Ÿ¶', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), 'Ÿ¢Ÿß', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), 'Ÿ¢Ÿ®', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), 'Ÿ¢Ÿ©', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), 'Ÿ£Ÿ†', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), 'Ÿ£Ÿ°', '31');
    });

    test('format month', function (assert) {
        var expected = 'ŸäŸÜÿßŸäÿ± ŸäŸÜÿßŸäÿ±_ŸÅÿ®ÿ±ÿßŸäÿ± ŸÅÿ®ÿ±ÿßŸäÿ±_ŸÖÿßÿ±ÿ≥ ŸÖÿßÿ±ÿ≥_ÿ£ÿ®ÿ±ŸäŸÑ ÿ£ÿ®ÿ±ŸäŸÑ_ŸÖÿßŸäŸà ŸÖÿßŸäŸà_ŸäŸàŸÜŸäŸà ŸäŸàŸÜŸäŸà_ŸäŸàŸÑŸäŸà ŸäŸàŸÑŸäŸà_ÿ£ÿ∫ÿ≥ÿ∑ÿ≥ ÿ£ÿ∫ÿ≥ÿ∑ÿ≥_ÿ≥ÿ®ÿ™ŸÖÿ®ÿ± ÿ≥ÿ®ÿ™ŸÖÿ®ÿ±_ÿ£ŸÉÿ™Ÿàÿ®ÿ± ÿ£ŸÉÿ™Ÿàÿ®ÿ±_ŸÜŸàŸÅŸÖÿ®ÿ± ŸÜŸàŸÅŸÖÿ®ÿ±_ÿØŸäÿ≥ŸÖÿ®ÿ± ÿØŸäÿ≥ŸÖÿ®ÿ±'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'ÿßŸÑÿ£ÿ≠ÿØ ÿ£ÿ≠ÿØ ÿ≠_ÿßŸÑÿ•ÿ´ŸÜŸäŸÜ ÿ•ÿ´ŸÜŸäŸÜ ŸÜ_ÿßŸÑÿ´ŸÑÿßÿ´ÿßÿ° ÿ´ŸÑÿßÿ´ÿßÿ° ÿ´_ÿßŸÑÿ£ÿ±ÿ®ÿπÿßÿ° ÿ£ÿ±ÿ®ÿπÿßÿ° ÿ±_ÿßŸÑÿÆŸÖŸäÿ≥ ÿÆŸÖŸäÿ≥ ÿÆ_ÿßŸÑÿ¨ŸÖÿπÿ© ÿ¨ŸÖÿπÿ© ÿ¨_ÿßŸÑÿ≥ÿ®ÿ™ ÿ≥ÿ®ÿ™ ÿ≥'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'ÿ´ŸàÿßŸÜ', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ÿØŸÇŸäŸÇÿ©',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ÿØŸÇŸäŸÇÿ©',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  'Ÿ¢ ÿØŸÇÿßÿ¶ŸÇ',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  'Ÿ§Ÿ§ ÿØŸÇÿßÿ¶ŸÇ',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ÿ≥ÿßÿπÿ©',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ÿ≥ÿßÿπÿ©',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  'Ÿ¢ ÿ≥ÿßÿπÿßÿ™',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   'Ÿ• ÿ≥ÿßÿπÿßÿ™',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  'Ÿ¢Ÿ° ÿ≥ÿßÿπÿßÿ™',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ŸäŸàŸÖ',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ŸäŸàŸÖ',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  'Ÿ¢ ÿ£ŸäÿßŸÖ',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ŸäŸàŸÖ',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   'Ÿ• ÿ£ŸäÿßŸÖ',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  'Ÿ¢Ÿ• ÿ£ŸäÿßŸÖ',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ÿ¥Ÿáÿ±',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ÿ¥Ÿáÿ±',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ÿ¥Ÿáÿ±',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  'Ÿ¢ ÿ£ÿ¥Ÿáÿ±',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  'Ÿ¢ ÿ£ÿ¥Ÿáÿ±',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  'Ÿ£ ÿ£ÿ¥Ÿáÿ±',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ÿ¥Ÿáÿ±',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   'Ÿ• ÿ£ÿ¥Ÿáÿ±',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ÿ≥ŸÜÿ©',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), 'Ÿ¢ ÿ≥ŸÜŸàÿßÿ™',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'ÿ≥ŸÜÿ©',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   'Ÿ• ÿ≥ŸÜŸàÿßÿ™',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'ŸÅŸä ÿ´ŸàÿßŸÜ',  'prefix');
        assert.equal(moment(0).from(30000), 'ŸÖŸÜÿ∞ ÿ´ŸàÿßŸÜ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'ŸÖŸÜÿ∞ ÿ´ŸàÿßŸÜ',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'ŸÅŸä ÿ´ŸàÿßŸÜ', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'ŸÅŸä Ÿ• ÿ£ŸäÿßŸÖ', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'ÿßŸÑŸäŸàŸÖ ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ© Ÿ†Ÿ¢:Ÿ†Ÿ†',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'ÿßŸÑŸäŸàŸÖ ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ© Ÿ†Ÿ¢:Ÿ¢Ÿ•',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'ÿßŸÑŸäŸàŸÖ ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ© Ÿ†Ÿ£:Ÿ†Ÿ†',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'ÿ∫ÿØÿß ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ© Ÿ†Ÿ¢:Ÿ†Ÿ†',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'ÿßŸÑŸäŸàŸÖ ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ© Ÿ†Ÿ°:Ÿ†Ÿ†',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'ÿ£ŸÖÿ≥ ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ© Ÿ†Ÿ¢:Ÿ†Ÿ†', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 31]).week(), 1, 'Dec 31 2011 should be week 1');
        assert.equal(moment([2012,  0,  6]).week(), 1, 'Jan  6 2012 should be week 1');
        assert.equal(moment([2012,  0,  7]).week(), 2, 'Jan  7 2012 should be week 2');
        assert.equal(moment([2012,  0, 13]).week(), 2, 'Jan 13 2012 should be week 2');
        assert.equal(moment([2012,  0, 14]).week(), 3, 'Jan 14 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 30]).week(), 1, 'Dec 30 2006 should be week 1');
        assert.equal(moment([2007,  0,  5]).week(), 1, 'Jan  5 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 2, 'Jan  6 2007 should be week 2');
        assert.equal(moment([2007,  0, 12]).week(), 2, 'Jan 12 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 3, 'Jan 13 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 1, 'Dec 29 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  4]).week(), 1, 'Jan  4 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 2, 'Jan  5 2008 should be week 2');
        assert.equal(moment([2008,  0, 11]).week(), 2, 'Jan 11 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 3, 'Jan 12 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 28]).week(), 1, 'Dec 28 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  3]).week(), 1, 'Jan  3 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 2, 'Jan  4 2003 should be week 2');
        assert.equal(moment([2003,  0, 10]).week(), 2, 'Jan 10 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 3, 'Jan 11 2003 should be week 3');

        assert.equal(moment('2003 1 6', 'gggg w d').format('YYYY-MM-DD'), 'Ÿ¢Ÿ†Ÿ†Ÿ¢-Ÿ°Ÿ¢-Ÿ¢Ÿ®', 'Week 1 of 2003 should be Dec 28 2002');
        assert.equal(moment('2003 1 0', 'gggg w e').format('YYYY-MM-DD'), 'Ÿ¢Ÿ†Ÿ†Ÿ¢-Ÿ°Ÿ¢-Ÿ¢Ÿ®', 'Week 1 of 2003 should be Dec 28 2002');
        assert.equal(moment('2003 1 6', 'gggg w d').format('gggg w d'), 'Ÿ¢Ÿ†Ÿ†Ÿ£ Ÿ° Ÿ¶', 'Saturday of week 1 of 2003 parsed should be formatted as 2003 1 6');
        assert.equal(moment('2003 1 0', 'gggg w e').format('gggg w e'), 'Ÿ¢Ÿ†Ÿ†Ÿ£ Ÿ° Ÿ†', '1st day of week 1 of 2003 parsed should be formatted as 2003 1 0');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 27]).week(), 1, 'Dec 27 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  2]).week(), 1, 'Jan  2 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 2, 'Jan  3 2009 should be week 2');
        assert.equal(moment([2009,  0,  9]).week(), 2, 'Jan  9 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 3, 'Jan 10 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 26]).week(), 1, 'Dec 26 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 2, 'Jan  2 2010 should be week 2');
        assert.equal(moment([2010,  0,  8]).week(), 2, 'Jan  8 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 3, 'Jan  9 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2011, 0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011, 0,  7]).week(), 1, 'Jan  7 2011 should be week 1');
        assert.equal(moment([2011, 0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011, 0, 14]).week(), 2, 'Jan 14 2011 should be week 2');
        assert.equal(moment([2011, 0, 15]).week(), 3, 'Jan 15 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 31]).format('w ww wo'), 'Ÿ° Ÿ†Ÿ° Ÿ°', 'Dec 31 2011 should be week 1');
        assert.equal(moment([2012,  0,  6]).format('w ww wo'), 'Ÿ° Ÿ†Ÿ° Ÿ°', 'Jan  6 2012 should be week 1');
        assert.equal(moment([2012,  0,  7]).format('w ww wo'), 'Ÿ¢ Ÿ†Ÿ¢ Ÿ¢', 'Jan  7 2012 should be week 2');
        assert.equal(moment([2012,  0, 13]).format('w ww wo'), 'Ÿ¢ Ÿ†Ÿ¢ Ÿ¢', 'Jan 13 2012 should be week 2');
        assert.equal(moment([2012,  0, 14]).format('w ww wo'), 'Ÿ£ Ÿ†Ÿ£ Ÿ£', 'Jan 14 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('ar-tn');

    test('parse', function (assert) {
        var tests = 'ÿ¨ÿßŸÜŸÅŸä:ÿ¨ÿßŸÜŸÅŸä_ŸÅŸäŸÅÿ±Ÿä:ŸÅŸäŸÅÿ±Ÿä_ŸÖÿßÿ±ÿ≥:ŸÖÿßÿ±ÿ≥_ÿ£ŸÅÿ±ŸäŸÑ:ÿ£ŸÅÿ±ŸäŸÑ_ŸÖÿßŸä:ŸÖÿßŸä_ÿ¨ŸàÿßŸÜ:ÿ¨ŸàÿßŸÜ_ÿ¨ŸàŸäŸÑŸäÿ©:ÿ¨ŸàŸäŸÑŸäÿ©_ÿ£Ÿàÿ™:ÿ£Ÿàÿ™_ÿ≥ÿ®ÿ™ŸÖÿ®ÿ±:ÿ≥ÿ®ÿ™ŸÖÿ®ÿ±_ÿ£ŸÉÿ™Ÿàÿ®ÿ±:ÿ£ŸÉÿ™Ÿàÿ®ÿ±_ŸÜŸàŸÅŸÖÿ®ÿ±:ŸÜŸàŸÅŸÖÿ®ÿ±_ÿØŸäÿ≥ŸÖÿ®ÿ±:ÿØŸäÿ≥ŸÖÿ®ÿ±'.split('_'),
            i;

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(':');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a', 'ÿßŸÑÿ£ÿ≠ÿØ, ŸÅŸäŸÅÿ±Ÿä 14 2010, 3:25:50 pm'],
                ['ddd, hA', 'ÿ£ÿ≠ÿØ, 3PM'],
                ['M Mo MM MMMM MMM', '2 2 02 ŸÅŸäŸÅÿ±Ÿä ŸÅŸäŸÅÿ±Ÿä'],
                ['YYYY YY', '2010 10'],
                ['D Do DD', '14 14 14'],
                ['d do dddd ddd dd', '0 0 ÿßŸÑÿ£ÿ≠ÿØ ÿ£ÿ≠ÿØ ÿ≠'],
                ['DDD DDDo DDDD', '45 45 045'],
                ['w wo ww', '6 6 06'],
                ['h hh', '3 03'],
                ['H HH', '15 15'],
                ['m mm', '25 25'],
                ['s ss', '50 50'],
                ['a A', 'pm PM'],
                ['[the] DDDo [day of the year]', 'the 45 day of the year'],
                ['LT', '15:25'],
                ['LTS', '15:25:50'],
                ['L', '14/02/2010'],
                ['LL', '14 ŸÅŸäŸÅÿ±Ÿä 2010'],
                ['LLL', '14 ŸÅŸäŸÅÿ±Ÿä 2010 15:25'],
                ['LLLL', 'ÿßŸÑÿ£ÿ≠ÿØ 14 ŸÅŸäŸÅÿ±Ÿä 2010 15:25'],
                ['l', '14/2/2010'],
                ['ll', '14 ŸÅŸäŸÅÿ±Ÿä 2010'],
                ['lll', '14 ŸÅŸäŸÅÿ±Ÿä 2010 15:25'],
                ['llll', 'ÿ£ÿ≠ÿØ 14 ŸÅŸäŸÅÿ±Ÿä 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = 'ÿ¨ÿßŸÜŸÅŸä ÿ¨ÿßŸÜŸÅŸä_ŸÅŸäŸÅÿ±Ÿä ŸÅŸäŸÅÿ±Ÿä_ŸÖÿßÿ±ÿ≥ ŸÖÿßÿ±ÿ≥_ÿ£ŸÅÿ±ŸäŸÑ ÿ£ŸÅÿ±ŸäŸÑ_ŸÖÿßŸä ŸÖÿßŸä_ÿ¨ŸàÿßŸÜ ÿ¨ŸàÿßŸÜ_ÿ¨ŸàŸäŸÑŸäÿ© ÿ¨ŸàŸäŸÑŸäÿ©_ÿ£Ÿàÿ™ ÿ£Ÿàÿ™_ÿ≥ÿ®ÿ™ŸÖÿ®ÿ± ÿ≥ÿ®ÿ™ŸÖÿ®ÿ±_ÿ£ŸÉÿ™Ÿàÿ®ÿ± ÿ£ŸÉÿ™Ÿàÿ®ÿ±_ŸÜŸàŸÅŸÖÿ®ÿ± ŸÜŸàŸÅŸÖÿ®ÿ±_ÿØŸäÿ≥ŸÖÿ®ÿ± ÿØŸäÿ≥ŸÖÿ®ÿ±'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'ÿßŸÑÿ£ÿ≠ÿØ ÿ£ÿ≠ÿØ ÿ≠_ÿßŸÑÿ•ÿ´ŸÜŸäŸÜ ÿ•ÿ´ŸÜŸäŸÜ ŸÜ_ÿßŸÑÿ´ŸÑÿßÿ´ÿßÿ° ÿ´ŸÑÿßÿ´ÿßÿ° ÿ´_ÿßŸÑÿ£ÿ±ÿ®ÿπÿßÿ° ÿ£ÿ±ÿ®ÿπÿßÿ° ÿ±_ÿßŸÑÿÆŸÖŸäÿ≥ ÿÆŸÖŸäÿ≥ ÿÆ_ÿßŸÑÿ¨ŸÖÿπÿ© ÿ¨ŸÖÿπÿ© ÿ¨_ÿßŸÑÿ≥ÿ®ÿ™ ÿ≥ÿ®ÿ™ ÿ≥'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({
            s: 44
        }), true), 'ÿ´ŸàÿßŸÜ', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            s: 45
        }), true), 'ÿØŸÇŸäŸÇÿ©', '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            s: 89
        }), true), 'ÿØŸÇŸäŸÇÿ©', '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            s: 90
        }), true), '2 ÿØŸÇÿßÿ¶ŸÇ', '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            m: 44
        }), true), '44 ÿØŸÇÿßÿ¶ŸÇ', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            m: 45
        }), true), 'ÿ≥ÿßÿπÿ©', '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            m: 89
        }), true), 'ÿ≥ÿßÿπÿ©', '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            m: 90
        }), true), '2 ÿ≥ÿßÿπÿßÿ™', '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            h: 5
        }), true), '5 ÿ≥ÿßÿπÿßÿ™', '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            h: 21
        }), true), '21 ÿ≥ÿßÿπÿßÿ™', '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            h: 22
        }), true), 'ŸäŸàŸÖ', '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            h: 35
        }), true), 'ŸäŸàŸÖ', '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            h: 36
        }), true), '2 ÿ£ŸäÿßŸÖ', '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 1
        }), true), 'ŸäŸàŸÖ', '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 5
        }), true), '5 ÿ£ŸäÿßŸÖ', '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 25
        }), true), '25 ÿ£ŸäÿßŸÖ', '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 26
        }), true), 'ÿ¥Ÿáÿ±', '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 30
        }), true), 'ÿ¥Ÿáÿ±', '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 43
        }), true), 'ÿ¥Ÿáÿ±', '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 46
        }), true), '2 ÿ£ÿ¥Ÿáÿ±', '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 74
        }), true), '2 ÿ£ÿ¥Ÿáÿ±', '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 76
        }), true), '3 ÿ£ÿ¥Ÿáÿ±', '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            M: 1
        }), true), 'ÿ¥Ÿáÿ±', '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            M: 5
        }), true), '5 ÿ£ÿ¥Ÿáÿ±', '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 345
        }), true), 'ÿ≥ŸÜÿ©', '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 548
        }), true), '2 ÿ≥ŸÜŸàÿßÿ™', '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            y: 1
        }), true), 'ÿ≥ŸÜÿ©', '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            y: 5
        }), true), '5 ÿ≥ŸÜŸàÿßÿ™', '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'ŸÅŸä ÿ´ŸàÿßŸÜ', 'prefix');
        assert.equal(moment(0).from(30000), 'ŸÖŸÜÿ∞ ÿ´ŸàÿßŸÜ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'ŸÖŸÜÿ∞ ÿ´ŸàÿßŸÜ', 'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({
            s: 30
        }).fromNow(), 'ŸÅŸä ÿ´ŸàÿßŸÜ', 'in a few seconds');
        assert.equal(moment().add({
            d: 5
        }).fromNow(), 'ŸÅŸä 5 ÿ£ŸäÿßŸÖ', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(), 'ÿßŸÑŸäŸàŸÖ ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ© 02:00', 'today at the same time');
        assert.equal(moment(a).add({
            m: 25
        }).calendar(), 'ÿßŸÑŸäŸàŸÖ ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ© 02:25', 'Now plus 25 min');
        assert.equal(moment(a).add({
            h: 1
        }).calendar(), 'ÿßŸÑŸäŸàŸÖ ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ© 03:00', 'Now plus 1 hour');
        assert.equal(moment(a).add({
            d: 1
        }).calendar(), 'ÿ∫ÿØÿß ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ© 02:00', 'tomorrow at the same time');
        assert.equal(moment(a).subtract({
            h: 1
        }).calendar(), 'ÿßŸÑŸäŸàŸÖ ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ© 01:00', 'Now minus 1 hour');
        assert.equal(moment(a).subtract({
            d: 1
        }).calendar(), 'ÿ£ŸÖÿ≥ ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ© 02:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({
                d: i
            });
            assert.equal(m.calendar(), m.format('dddd [ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT'), 'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format('dddd [ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT'), 'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format('dddd [ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT'), 'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({
                d: i
            });
            assert.equal(m.calendar(), m.format('dddd [ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT'), 'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format('dddd [ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT'), 'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format('dddd [ÿπŸÑŸâ ÿßŸÑÿ≥ÿßÿπÿ©] LT'), 'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({
                w: 1
            }),
            weeksFromNow = moment().add({
                w: 1
            });

        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '1 week ago');
        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), 'in 1 week');

        weeksAgo = moment().subtract({
            w: 2
        });
        weeksFromNow = moment().add({
            w: 2
        });

        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '2 weeks ago');
        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), 'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'), '1 01 1', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '1 01 1', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('ar');

    var months = [
        'ŸÉÿßŸÜŸàŸÜ ÿßŸÑÿ´ÿßŸÜŸä ŸäŸÜÿßŸäÿ±',
        'ÿ¥ÿ®ÿßÿ∑ ŸÅÿ®ÿ±ÿßŸäÿ±',
        'ÿ¢ÿ∞ÿßÿ± ŸÖÿßÿ±ÿ≥',
        'ŸÜŸäÿ≥ÿßŸÜ ÿ£ÿ®ÿ±ŸäŸÑ',
        'ÿ£Ÿäÿßÿ± ŸÖÿßŸäŸà',
        'ÿ≠ÿ≤Ÿäÿ±ÿßŸÜ ŸäŸàŸÜŸäŸà',
        'ÿ™ŸÖŸàÿ≤ ŸäŸàŸÑŸäŸà',
        'ÿ¢ÿ® ÿ£ÿ∫ÿ≥ÿ∑ÿ≥',
        'ÿ£ŸäŸÑŸàŸÑ ÿ≥ÿ®ÿ™ŸÖÿ®ÿ±',
        'ÿ™ÿ¥ÿ±ŸäŸÜ ÿßŸÑÿ£ŸàŸÑ ÿ£ŸÉÿ™Ÿàÿ®ÿ±',
        'ÿ™ÿ¥ÿ±ŸäŸÜ ÿßŸÑÿ´ÿßŸÜŸä ŸÜŸàŸÅŸÖÿ®ÿ±',
        'ŸÉÿßŸÜŸàŸÜ ÿßŸÑÿ£ŸàŸÑ ÿØŸäÿ≥ŸÖÿ®ÿ±'
    ];

    test('parse', function (assert) {
        var tests = months, i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1) + ' instead is month ' + moment(input, mmm).month());
        }
        for (i = 0; i < 12; i++) {
            equalTest(tests[i], 'MMM', i);
            equalTest(tests[i], 'MMM', i);
            equalTest(tests[i], 'MMMM', i);
            equalTest(tests[i], 'MMMM', i);
            equalTest(tests[i].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'ÿßŸÑÿ£ÿ≠ÿØÿå ÿ¥ÿ®ÿßÿ∑ ŸÅÿ®ÿ±ÿßŸäÿ± Ÿ°Ÿ§ Ÿ¢Ÿ†Ÿ°Ÿ†ÿå Ÿ£:Ÿ¢Ÿ•:Ÿ•Ÿ† ŸÖ'],
                ['ddd, hA',                            'ÿ£ÿ≠ÿØÿå Ÿ£ŸÖ'],
                ['M Mo MM MMMM MMM',                   'Ÿ¢ Ÿ¢ Ÿ†Ÿ¢ ÿ¥ÿ®ÿßÿ∑ ŸÅÿ®ÿ±ÿßŸäÿ± ÿ¥ÿ®ÿßÿ∑ ŸÅÿ®ÿ±ÿßŸäÿ±'],
                ['YYYY YY',                            'Ÿ¢Ÿ†Ÿ°Ÿ† Ÿ°Ÿ†'],
                ['D Do DD',                            'Ÿ°Ÿ§ Ÿ°Ÿ§ Ÿ°Ÿ§'],
                ['d do dddd ddd dd',                   'Ÿ† Ÿ† ÿßŸÑÿ£ÿ≠ÿØ ÿ£ÿ≠ÿØ ÿ≠'],
                ['DDD DDDo DDDD',                      'Ÿ§Ÿ• Ÿ§Ÿ• Ÿ†Ÿ§Ÿ•'],
                ['w wo ww',                            'Ÿ® Ÿ® Ÿ†Ÿ®'],
                ['h hh',                               'Ÿ£ Ÿ†Ÿ£'],
                ['H HH',                               'Ÿ°Ÿ• Ÿ°Ÿ•'],
                ['m mm',                               'Ÿ¢Ÿ• Ÿ¢Ÿ•'],
                ['s ss',                               'Ÿ•Ÿ† Ÿ•Ÿ†'],
                ['a A',                                'ŸÖ ŸÖ'],
                ['[the] DDDo [day of the year]',       'the Ÿ§Ÿ• day of the year'],
                ['LT',                                 'Ÿ°Ÿ•:Ÿ¢Ÿ•'],
                ['LTS',                                'Ÿ°Ÿ•:Ÿ¢Ÿ•:Ÿ•Ÿ†'],
                ['L',                                  'Ÿ°Ÿ§/\u200fŸ¢/\u200fŸ¢Ÿ†Ÿ°Ÿ†'],
                ['LL',                                 'Ÿ°Ÿ§ ÿ¥ÿ®ÿßÿ∑ ŸÅÿ®ÿ±ÿßŸäÿ± Ÿ¢Ÿ†Ÿ°Ÿ†'],
                ['LLL',                                'Ÿ°Ÿ§ ÿ¥ÿ®ÿßÿ∑ ŸÅÿ®ÿ±ÿßŸäÿ± Ÿ¢Ÿ†Ÿ°Ÿ† Ÿ°Ÿ•:Ÿ¢Ÿ•'],
                ['LLLL',                               'ÿßŸÑÿ£ÿ≠ÿØ Ÿ°Ÿ§ ÿ¥ÿ®ÿßÿ∑ ŸÅÿ®ÿ±ÿßŸäÿ± Ÿ¢Ÿ†Ÿ°Ÿ† Ÿ°Ÿ•:Ÿ¢Ÿ•'],
                ['l',                                  'Ÿ°Ÿ§/\u200fŸ¢/\u200fŸ¢Ÿ†Ÿ°Ÿ†'],
                ['ll',                                 'Ÿ°Ÿ§ ÿ¥ÿ®ÿßÿ∑ ŸÅÿ®ÿ±ÿßŸäÿ± Ÿ¢Ÿ†Ÿ°Ÿ†'],
                ['lll',                                'Ÿ°Ÿ§ ÿ¥ÿ®ÿßÿ∑ ŸÅÿ®ÿ±ÿßŸäÿ± Ÿ¢Ÿ†Ÿ°Ÿ† Ÿ°Ÿ•:Ÿ¢Ÿ•'],
                ['llll',                               'ÿ£ÿ≠ÿØ Ÿ°Ÿ§ ÿ¥ÿ®ÿßÿ∑ ŸÅÿ®ÿ±ÿßŸäÿ± Ÿ¢Ÿ†Ÿ°Ÿ† Ÿ°Ÿ•:Ÿ¢Ÿ•']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), 'Ÿ°', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), 'Ÿ¢', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), 'Ÿ£', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), 'Ÿ§', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), 'Ÿ•', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), 'Ÿ¶', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), 'Ÿß', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), 'Ÿ®', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), 'Ÿ©', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), 'Ÿ°Ÿ†', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), 'Ÿ°Ÿ°', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), 'Ÿ°Ÿ¢', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), 'Ÿ°Ÿ£', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), 'Ÿ°Ÿ§', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), 'Ÿ°Ÿ•', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), 'Ÿ°Ÿ¶', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), 'Ÿ°Ÿß', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), 'Ÿ°Ÿ®', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), 'Ÿ°Ÿ©', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), 'Ÿ¢Ÿ†', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), 'Ÿ¢Ÿ°', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), 'Ÿ¢Ÿ¢', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), 'Ÿ¢Ÿ£', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), 'Ÿ¢Ÿ§', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), 'Ÿ¢Ÿ•', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), 'Ÿ¢Ÿ¶', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), 'Ÿ¢Ÿß', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), 'Ÿ¢Ÿ®', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), 'Ÿ¢Ÿ©', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), 'Ÿ£Ÿ†', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), 'Ÿ£Ÿ°', '31');
    });

    test('format month', function (assert) {
        var expected = months, i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM'), expected[i], expected[i]);
            assert.equal(moment([2011, i, 1]).format('MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'ÿßŸÑÿ£ÿ≠ÿØ ÿ£ÿ≠ÿØ ÿ≠_ÿßŸÑÿ•ÿ´ŸÜŸäŸÜ ÿ•ÿ´ŸÜŸäŸÜ ŸÜ_ÿßŸÑÿ´ŸÑÿßÿ´ÿßÿ° ÿ´ŸÑÿßÿ´ÿßÿ° ÿ´_ÿßŸÑÿ£ÿ±ÿ®ÿπÿßÿ° ÿ£ÿ±ÿ®ÿπÿßÿ° ÿ±_ÿßŸÑÿÆŸÖŸäÿ≥ ÿÆŸÖŸäÿ≥ ÿÆ_ÿßŸÑÿ¨ŸÖÿπÿ© ÿ¨ŸÖÿπÿ© ÿ¨_ÿßŸÑÿ≥ÿ®ÿ™ ÿ≥ÿ®ÿ™ ÿ≥'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'Ÿ§Ÿ§ ÿ´ÿßŸÜŸäÿ©', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ÿØŸÇŸäŸÇÿ© Ÿàÿßÿ≠ÿØÿ©',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ÿØŸÇŸäŸÇÿ© Ÿàÿßÿ≠ÿØÿ©',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  'ÿØŸÇŸäŸÇÿ™ÿßŸÜ',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  'Ÿ§Ÿ§ ÿØŸÇŸäŸÇÿ©',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ÿ≥ÿßÿπÿ© Ÿàÿßÿ≠ÿØÿ©',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ÿ≥ÿßÿπÿ© Ÿàÿßÿ≠ÿØÿ©',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  'ÿ≥ÿßÿπÿ™ÿßŸÜ',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   'Ÿ• ÿ≥ÿßÿπÿßÿ™',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  'Ÿ¢Ÿ° ÿ≥ÿßÿπÿ©',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ŸäŸàŸÖ Ÿàÿßÿ≠ÿØ',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ŸäŸàŸÖ Ÿàÿßÿ≠ÿØ',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  'ŸäŸàŸÖÿßŸÜ',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ŸäŸàŸÖ Ÿàÿßÿ≠ÿØ',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   'Ÿ• ÿ£ŸäÿßŸÖ',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  'Ÿ¢Ÿ• ŸäŸàŸÖŸãÿß',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ÿ¥Ÿáÿ± Ÿàÿßÿ≠ÿØ',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ÿ¥Ÿáÿ± Ÿàÿßÿ≠ÿØ',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ÿ¥Ÿáÿ± Ÿàÿßÿ≠ÿØ',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  'ÿ¥Ÿáÿ±ÿßŸÜ',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  'ÿ¥Ÿáÿ±ÿßŸÜ',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  'Ÿ£ ÿ£ÿ¥Ÿáÿ±',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ÿ¥Ÿáÿ± Ÿàÿßÿ≠ÿØ',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   'Ÿ• ÿ£ÿ¥Ÿáÿ±',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ÿπÿßŸÖ Ÿàÿßÿ≠ÿØ',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), 'ÿπÿßŸÖÿßŸÜ',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'ÿπÿßŸÖ Ÿàÿßÿ≠ÿØ',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   'Ÿ• ÿ£ÿπŸàÿßŸÖ',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'ÿ®ÿπÿØ Ÿ£Ÿ† ÿ´ÿßŸÜŸäÿ©',  'prefix');
        assert.equal(moment(0).from(30000), 'ŸÖŸÜÿ∞ Ÿ£Ÿ† ÿ´ÿßŸÜŸäÿ©', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'ŸÖŸÜÿ∞ ÿ´ÿßŸÜŸäÿ© Ÿàÿßÿ≠ÿØÿ©',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'ÿ®ÿπÿØ Ÿ£Ÿ† ÿ´ÿßŸÜŸäÿ©', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'ÿ®ÿπÿØ Ÿ• ÿ£ŸäÿßŸÖ', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'ÿßŸÑŸäŸàŸÖ ÿπŸÜÿØ ÿßŸÑÿ≥ÿßÿπÿ© Ÿ†Ÿ¢:Ÿ†Ÿ†',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'ÿßŸÑŸäŸàŸÖ ÿπŸÜÿØ ÿßŸÑÿ≥ÿßÿπÿ© Ÿ†Ÿ¢:Ÿ¢Ÿ•',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'ÿßŸÑŸäŸàŸÖ ÿπŸÜÿØ ÿßŸÑÿ≥ÿßÿπÿ© Ÿ†Ÿ£:Ÿ†Ÿ†',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'ÿ∫ÿØŸãÿß ÿπŸÜÿØ ÿßŸÑÿ≥ÿßÿπÿ© Ÿ†Ÿ¢:Ÿ†Ÿ†',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'ÿßŸÑŸäŸàŸÖ ÿπŸÜÿØ ÿßŸÑÿ≥ÿßÿπÿ© Ÿ†Ÿ°:Ÿ†Ÿ†',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'ÿ£ŸÖÿ≥ ÿπŸÜÿØ ÿßŸÑÿ≥ÿßÿπÿ© Ÿ†Ÿ¢:Ÿ†Ÿ†', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [ÿπŸÜÿØ ÿßŸÑÿ≥ÿßÿπÿ©] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [ÿπŸÜÿØ ÿßŸÑÿ≥ÿßÿπÿ©] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [ÿπŸÜÿØ ÿßŸÑÿ≥ÿßÿπÿ©] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [ÿπŸÜÿØ ÿßŸÑÿ≥ÿßÿπÿ©] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [ÿπŸÜÿØ ÿßŸÑÿ≥ÿßÿπÿ©] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [ÿπŸÜÿØ ÿßŸÑÿ≥ÿßÿπÿ©] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 31]).week(), 1, 'Dec 31 2011 should be week 1');
        assert.equal(moment([2012,  0,  6]).week(), 1, 'Jan  6 2012 should be week 1');
        assert.equal(moment([2012,  0,  7]).week(), 2, 'Jan  7 2012 should be week 2');
        assert.equal(moment([2012,  0, 13]).week(), 2, 'Jan 13 2012 should be week 2');
        assert.equal(moment([2012,  0, 14]).week(), 3, 'Jan 14 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 30]).week(), 1, 'Dec 30 2006 should be week 1');
        assert.equal(moment([2007,  0,  5]).week(), 1, 'Jan  5 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 2, 'Jan  6 2007 should be week 2');
        assert.equal(moment([2007,  0, 12]).week(), 2, 'Jan 12 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 3, 'Jan 13 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 1, 'Dec 29 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  4]).week(), 1, 'Jan  4 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 2, 'Jan  5 2008 should be week 2');
        assert.equal(moment([2008,  0, 11]).week(), 2, 'Jan 11 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 3, 'Jan 12 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 28]).week(), 1, 'Dec 28 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  3]).week(), 1, 'Jan  3 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 2, 'Jan  4 2003 should be week 2');
        assert.equal(moment([2003,  0, 10]).week(), 2, 'Jan 10 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 3, 'Jan 11 2003 should be week 3');

        assert.equal(moment('2003 1 6', 'gggg w d').format('YYYY-MM-DD'), 'Ÿ¢Ÿ†Ÿ†Ÿ¢-Ÿ°Ÿ¢-Ÿ¢Ÿ®', 'Week 1 of 2003 should be Dec 28 2002');
        assert.equal(moment('2003 1 0', 'gggg w e').format('YYYY-MM-DD'), 'Ÿ¢Ÿ†Ÿ†Ÿ¢-Ÿ°Ÿ¢-Ÿ¢Ÿ®', 'Week 1 of 2003 should be Dec 28 2002');
        assert.equal(moment('2003 1 6', 'gggg w d').format('gggg w d'), 'Ÿ¢Ÿ†Ÿ†Ÿ£ Ÿ° Ÿ¶', 'Saturday of week 1 of 2003 parsed should be formatted as 2003 1 6');
        assert.equal(moment('2003 1 0', 'gggg w e').format('gggg w e'), 'Ÿ¢Ÿ†Ÿ†Ÿ£ Ÿ° Ÿ†', '1st day of week 1 of 2003 parsed should be formatted as 2003 1 0');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 27]).week(), 1, 'Dec 27 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  2]).week(), 1, 'Jan  2 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 2, 'Jan  3 2009 should be week 2');
        assert.equal(moment([2009,  0,  9]).week(), 2, 'Jan  9 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 3, 'Jan 10 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 26]).week(), 1, 'Dec 26 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 2, 'Jan  2 2010 should be week 2');
        assert.equal(moment([2010,  0,  8]).week(), 2, 'Jan  8 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 3, 'Jan  9 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2011, 0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011, 0,  7]).week(), 1, 'Jan  7 2011 should be week 1');
        assert.equal(moment([2011, 0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011, 0, 14]).week(), 2, 'Jan 14 2011 should be week 2');
        assert.equal(moment([2011, 0, 15]).week(), 3, 'Jan 15 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 31]).format('w ww wo'), 'Ÿ° Ÿ†Ÿ° Ÿ°', 'Dec 31 2011 should be week 1');
        assert.equal(moment([2012,  0,  6]).format('w ww wo'), 'Ÿ° Ÿ†Ÿ° Ÿ°', 'Jan  6 2012 should be week 1');
        assert.equal(moment([2012,  0,  7]).format('w ww wo'), 'Ÿ¢ Ÿ†Ÿ¢ Ÿ¢', 'Jan  7 2012 should be week 2');
        assert.equal(moment([2012,  0, 13]).format('w ww wo'), 'Ÿ¢ Ÿ†Ÿ¢ Ÿ¢', 'Jan 13 2012 should be week 2');
        assert.equal(moment([2012,  0, 14]).format('w ww wo'), 'Ÿ£ Ÿ†Ÿ£ Ÿ£', 'Jan 14 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

    test('no leading zeros in long date formats', function (assert) {
        var i, j, longDateStr, shortDateStr;
        for (i = 1; i <= 9; ++i) {
            for (j = 1; j <= 9; ++j) {
                longDateStr = moment([2014, i, j]).format('L');
                shortDateStr = moment([2014, i, j]).format('l');
                assert.equal(longDateStr, shortDateStr, 'should not have leading zeros in month or day');
            }
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('az');

    test('parse', function (assert) {
        var tests = 'yanvar yan_fevral fev_mart mar_Aprel apr_may may_iyun iyn_iyul iyl_Avqust avq_sentyabr sen_oktyabr okt_noyabr noy_dekabr dek'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, D MMMM YYYY, HH:mm:ss',        'Bazar, 14 fevral 2010, 15:25:50'],
                ['ddd, A h',                           'Baz, g√ºnd√ºz 3'],
                ['M Mo MM MMMM MMM',                   '2 2-nci 02 fevral fev'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14-√ºnc√º 14'],
                ['d do dddd ddd dd',                   '0 0-ƒ±ncƒ± Bazar Baz Bz'],
                ['DDD DDDo DDDD',                      '45 45-inci 045'],
                ['w wo ww',                            '7 7-nci 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'g√ºnd√ºz g√ºnd√ºz'],
                ['[ilin] DDDo [g√ºn√º]',                 'ilin 45-inci g√ºn√º'],
                ['LT',                                 '15:25'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14 fevral 2010'],
                ['LLL',                                '14 fevral 2010 15:25'],
                ['LLLL',                               'Bazar, 14 fevral 2010 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14 fev 2010'],
                ['lll',                                '14 fev 2010 15:25'],
                ['llll',                               'Baz, 14 fev 2010 15:25']
            ],
            DDDo = [
                [359, '360-ƒ±ncƒ±'],
                [199, '200-√ºnc√º'],
                [149, '150-nci']
            ],
            dt = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            DDDoDt,
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(dt.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
        for (i = 0; i < DDDo.length; i++) {
            DDDoDt = moment([2010]);
            assert.equal(DDDoDt.add(DDDo[i][0], 'days').format('DDDo'), DDDo[i][1], DDDo[i][0] + ' ---> ' + DDDo[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-inci', '1st');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-nci', '2nd');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-√ºnc√º', '3rd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-√ºnc√º', '4th');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-inci', '5th');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-ncƒ±', '6th');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-nci', '7th');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-inci', '8th');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-uncu', '9th');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-uncu', '10th');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-inci', '11th');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-nci', '12th');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-√ºnc√º', '13th');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-√ºnc√º', '14th');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-inci', '15th');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-ncƒ±', '16th');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-nci', '17th');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-inci', '18th');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-uncu', '19th');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-nci', '20th');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-inci', '21th');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-nci', '22th');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-√ºnc√º', '23th');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-√ºnc√º', '24th');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-inci', '25th');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-ncƒ±', '26th');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-nci', '27th');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-inci', '28th');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-uncu', '29th');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-uncu', '30th');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-inci', '31st');
    });

    test('format month', function (assert) {
        var expected = 'yanvar yan_fevral fev_mart mar_aprel apr_may may_iyun iyn_iyul iyl_avqust avq_sentyabr sen_oktyabr okt_noyabr noy_dekabr dek'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Bazar Baz Bz_Bazar ert…ôsi BzE BE_√á…ôr≈ü…ônb…ô ax≈üamƒ± √áAx √áA_√á…ôr≈ü…ônb…ô √á…ôr √á…ô_C√ºm…ô ax≈üamƒ± CAx CA_C√ºm…ô C√ºm C√º_≈û…ônb…ô ≈û…ôn ≈û…ô'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'birne√ß…ô saniyy…ô', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'bir d…ôqiq…ô',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'bir d…ôqiq…ô',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 d…ôqiq…ô',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 d…ôqiq…ô',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'bir saat',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'bir saat',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 saat',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 saat',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 saat',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'bir g√ºn',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'bir g√ºn',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 g√ºn',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'bir g√ºn',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 g√ºn',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 g√ºn',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'bir ay',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'bir ay',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ay',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ay',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ay',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'bir ay',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ay',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'bir il',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 il',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'bir il',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 il',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'birne√ß…ô saniyy…ô sonra',  'prefix');
        assert.equal(moment(0).from(30000), 'birne√ß…ô saniyy…ô …ôvv…ôl', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'birne√ß…ô saniyy…ô …ôvv…ôl',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'birne√ß…ô saniyy…ô sonra', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5 g√ºn sonra', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'bug√ºn saat 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'bug√ºn saat 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'bug√ºn saat 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'sabah saat 02:00',     'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'bug√ºn saat 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'd√ºn…ôn 02:00',          'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[g…ôl…ôn h…ôft…ô] dddd [saat] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[g…ôl…ôn h…ôft…ô] dddd [saat] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[g…ôl…ôn h…ôft…ô] dddd [saat] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[ke√ß…ôn h…ôft…ô] dddd [saat] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[ke√ß…ôn h…ôft…ô] dddd [saat] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[ke√ß…ôn h…ôft…ô] dddd [saat] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-inci', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-inci', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-nci', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-nci', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-√ºnc√º', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('be');

    test('parse', function (assert) {
        var tests = '—Å—Ç—É–¥–∑–µ–Ω—å —Å—Ç—É–¥_–ª—é—Ç—ã –ª—é—Ç_—Å–∞–∫–∞–≤—ñ–∫ —Å–∞–∫_–∫—Ä–∞—Å–∞–≤—ñ–∫ –∫—Ä–∞—Å_—Ç—Ä–∞–≤–µ–Ω—å —Ç—Ä–∞–≤_—á—ç—Ä–≤–µ–Ω—å —á—ç—Ä–≤_–ª—ñ–ø–µ–Ω—å –ª—ñ–ø_–∂–Ω—ñ–≤–µ–Ω—å –∂–Ω—ñ–≤_–≤–µ—Ä–∞—Å–µ–Ω—å –≤–µ—Ä_–∫–∞—Å—Ç—Ä—ã—á–Ω—ñ–∫ –∫–∞—Å—Ç_–ª—ñ—Å—Ç–∞–ø–∞–¥ –ª—ñ—Å—Ç_—Å–Ω–µ–∂–∞–Ω—å —Å–Ω–µ–∂'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, HH:mm:ss',       '–Ω—è–¥–∑–µ–ª—è, 14-–≥–∞ –ª—é—Ç–∞–≥–∞ 2010, 15:25:50'],
                ['ddd, h A',                           '–Ω–¥, 3 –¥–Ω—è'],
                ['M Mo MM MMMM MMM',                   '2 2-—ñ 02 –ª—é—Ç—ã –ª—é—Ç'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14-–≥–∞ 14'],
                ['d do dddd ddd dd',                   '0 0-—ã –Ω—è–¥–∑–µ–ª—è –Ω–¥ –Ω–¥'],
                ['DDD DDDo DDDD',                      '45 45-—ã 045'],
                ['w wo ww',                            '7 7-—ã 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                '–¥–Ω—è –¥–Ω—è'],
                ['DDDo [–¥–∑–µ–Ω—å –≥–æ–¥–∞]',                   '45-—ã –¥–∑–µ–Ω—å –≥–æ–¥–∞'],
                ['LT',                                 '15:25'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14 –ª—é—Ç–∞–≥–∞ 2010 –≥.'],
                ['LLL',                                '14 –ª—é—Ç–∞–≥–∞ 2010 –≥., 15:25'],
                ['LLLL',                               '–Ω—è–¥–∑–µ–ª—è, 14 –ª—é—Ç–∞–≥–∞ 2010 –≥., 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14 –ª—é—Ç 2010 –≥.'],
                ['lll',                                '14 –ª—é—Ç 2010 –≥., 15:25'],
                ['llll',                               '–Ω–¥, 14 –ª—é—Ç 2010 –≥., 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format meridiem', function (assert) {
        assert.equal(moment([2012, 11, 28, 0, 0]).format('A'), '–Ω–æ—á—ã', 'night');
        assert.equal(moment([2012, 11, 28, 3, 59]).format('A'), '–Ω–æ—á—ã', 'night');
        assert.equal(moment([2012, 11, 28, 4, 0]).format('A'), '—Ä–∞–Ω—ñ—Ü—ã', 'morning');
        assert.equal(moment([2012, 11, 28, 11, 59]).format('A'), '—Ä–∞–Ω—ñ—Ü—ã', 'morning');
        assert.equal(moment([2012, 11, 28, 12, 0]).format('A'), '–¥–Ω—è', 'afternoon');
        assert.equal(moment([2012, 11, 28, 16, 59]).format('A'), '–¥–Ω—è', 'afternoon');
        assert.equal(moment([2012, 11, 28, 17, 0]).format('A'), '–≤–µ—á–∞—Ä–∞', 'evening');
        assert.equal(moment([2012, 11, 28, 23, 59]).format('A'), '–≤–µ—á–∞—Ä–∞', 'evening');
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-—ã', '1-—ã');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-—ñ', '2-—ñ');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-—ñ', '3-—ñ');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-—ã', '4-—ã');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-—ã', '5-—ã');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-—ã', '6-—ã');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-—ã', '7-—ã');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-—ã', '8-—ã');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-—ã', '9-—ã');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-—ã', '10-—ã');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-—ã', '11-—ã');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-—ã', '12-—ã');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-—ã', '13-—ã');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-—ã', '14-—ã');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-—ã', '15-—ã');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-—ã', '16-—ã');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-—ã', '17-—ã');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-—ã', '18-—ã');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-—ã', '19-—ã');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-—ã', '20-—ã');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-—ã', '21-—ã');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-—ñ', '22-—ñ');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-—ñ', '23-—ñ');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-—ã', '24-—ã');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-—ã', '25-—ã');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-—ã', '26-—ã');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-—ã', '27-—ã');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-—ã', '28-—ã');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-—ã', '29-—ã');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-—ã', '30-—ã');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-—ã', '31-—ã');
    });

    test('format month', function (assert) {
        var expected = '—Å—Ç—É–¥–∑–µ–Ω—å —Å—Ç—É–¥_–ª—é—Ç—ã –ª—é—Ç_—Å–∞–∫–∞–≤—ñ–∫ —Å–∞–∫_–∫—Ä–∞—Å–∞–≤—ñ–∫ –∫—Ä–∞—Å_—Ç—Ä–∞–≤–µ–Ω—å —Ç—Ä–∞–≤_—á—ç—Ä–≤–µ–Ω—å —á—ç—Ä–≤_–ª—ñ–ø–µ–Ω—å –ª—ñ–ø_–∂–Ω—ñ–≤–µ–Ω—å –∂–Ω—ñ–≤_–≤–µ—Ä–∞—Å–µ–Ω—å –≤–µ—Ä_–∫–∞—Å—Ç—Ä—ã—á–Ω—ñ–∫ –∫–∞—Å—Ç_–ª—ñ—Å—Ç–∞–ø–∞–¥ –ª—ñ—Å—Ç_—Å–Ω–µ–∂–∞–Ω—å —Å–Ω–µ–∂'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format month case', function (assert) {
        var months = {
            'nominative': '—Å—Ç—É–¥–∑–µ–Ω—å_–ª—é—Ç—ã_—Å–∞–∫–∞–≤—ñ–∫_–∫—Ä–∞—Å–∞–≤—ñ–∫_—Ç—Ä–∞–≤–µ–Ω—å_—á—ç—Ä–≤–µ–Ω—å_–ª—ñ–ø–µ–Ω—å_–∂–Ω—ñ–≤–µ–Ω—å_–≤–µ—Ä–∞—Å–µ–Ω—å_–∫–∞—Å—Ç—Ä—ã—á–Ω—ñ–∫_–ª—ñ—Å—Ç–∞–ø–∞–¥_—Å–Ω–µ–∂–∞–Ω—å'.split('_'),
            'accusative': '—Å—Ç—É–¥–∑–µ–Ω—è_–ª—é—Ç–∞–≥–∞_—Å–∞–∫–∞–≤—ñ–∫–∞_–∫—Ä–∞—Å–∞–≤—ñ–∫–∞_—Ç—Ä–∞—û–Ω—è_—á—ç—Ä–≤–µ–Ω—è_–ª—ñ–ø–µ–Ω—è_–∂–Ω—ñ—û–Ω—è_–≤–µ—Ä–∞—Å–Ω—è_–∫–∞—Å—Ç—Ä—ã—á–Ω—ñ–∫–∞_–ª—ñ—Å—Ç–∞–ø–∞–¥–∞_—Å–Ω–µ–∂–Ω—è'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2011, i, 1]).format('D MMMM'), '1 ' + months.accusative[i], '1 ' + months.accusative[i]);
            assert.equal(moment([2011, i, 1]).format('MMMM'), months.nominative[i], '1 ' + months.nominative[i]);
        }
    });

    test('format month case with escaped symbols', function (assert) {
        var months = {
            'nominative': '—Å—Ç—É–¥–∑–µ–Ω—å_–ª—é—Ç—ã_—Å–∞–∫–∞–≤—ñ–∫_–∫—Ä–∞—Å–∞–≤—ñ–∫_—Ç—Ä–∞–≤–µ–Ω—å_—á—ç—Ä–≤–µ–Ω—å_–ª—ñ–ø–µ–Ω—å_–∂–Ω—ñ–≤–µ–Ω—å_–≤–µ—Ä–∞—Å–µ–Ω—å_–∫–∞—Å—Ç—Ä—ã—á–Ω—ñ–∫_–ª—ñ—Å—Ç–∞–ø–∞–¥_—Å–Ω–µ–∂–∞–Ω—å'.split('_'),
            'accusative': '—Å—Ç—É–¥–∑–µ–Ω—è_–ª—é—Ç–∞–≥–∞_—Å–∞–∫–∞–≤—ñ–∫–∞_–∫—Ä–∞—Å–∞–≤—ñ–∫–∞_—Ç—Ä–∞—û–Ω—è_—á—ç—Ä–≤–µ–Ω—è_–ª—ñ–ø–µ–Ω—è_–∂–Ω—ñ—û–Ω—è_–≤–µ—Ä–∞—Å–Ω—è_–∫–∞—Å—Ç—Ä—ã—á–Ω—ñ–∫–∞_–ª—ñ—Å—Ç–∞–ø–∞–¥–∞_—Å–Ω–µ–∂–Ω—è'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2013, i, 1]).format('D[] MMMM'), '1 ' + months.accusative[i], '1 ' + months.accusative[i]);
            assert.equal(moment([2013, i, 1]).format('[<i>]D[</i>] [<b>]MMMM[</b>]'), '<i>1</i> <b>' + months.accusative[i] + '</b>', '1 <b>' + months.accusative[i] + '</b>');
            assert.equal(moment([2013, i, 1]).format('D[-—ã –¥–∑–µ–Ω—å] MMMM'), '1-—ã –¥–∑–µ–Ω—å ' + months.accusative[i], '1-—ã –¥–∑–µ–Ω—å ' + months.accusative[i]);
            assert.equal(moment([2013, i, 1]).format('D, MMMM'), '1, ' + months.nominative[i], '1, ' + months.nominative[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '–Ω—è–¥–∑–µ–ª—è –Ω–¥ –Ω–¥_–ø–∞–Ω—è–¥–∑–µ–ª–∞–∫ –ø–Ω –ø–Ω_–∞—û—Ç–æ—Ä–∞–∫ –∞—Ç –∞—Ç_—Å–µ—Ä–∞–¥–∞ —Å—Ä —Å—Ä_—á–∞—Ü–≤–µ—Ä —á—Ü —á—Ü_–ø—è—Ç–Ω—ñ—Ü–∞ –ø—Ç –ø—Ç_—Å—É–±–æ—Ç–∞ —Å–± —Å–±'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '–Ω–µ–∫–∞–ª—å–∫—ñ —Å–µ–∫—É–Ω–¥',    '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '—Ö–≤—ñ–ª—ñ–Ω–∞',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '—Ö–≤—ñ–ª—ñ–Ω–∞',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 —Ö–≤—ñ–ª—ñ–Ω—ã',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 31}), true),  '31 —Ö–≤—ñ–ª—ñ–Ω–∞',  '31 minutes = 31 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 —Ö–≤—ñ–ª—ñ–Ω—ã', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '–≥–∞–¥–∑—ñ–Ω–∞',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '–≥–∞–¥–∑—ñ–Ω–∞',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 –≥–∞–¥–∑—ñ–Ω—ã',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 –≥–∞–¥–∑—ñ–Ω',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 –≥–∞–¥–∑—ñ–Ω–∞',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '–¥–∑–µ–Ω—å',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '–¥–∑–µ–Ω—å',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 –¥–Ω—ñ',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '–¥–∑–µ–Ω—å',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 –¥–∑—ë–Ω',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 11}), true),  '11 –¥–∑—ë–Ω',     '11 days = 11 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 21}), true),  '21 –¥–∑–µ–Ω—å',     '21 days = 21 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 –¥–∑—ë–Ω',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '–º–µ—Å—è—Ü',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '–º–µ—Å—è—Ü',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '–º–µ—Å—è—Ü',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 –º–µ—Å—è—Ü—ã',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 –º–µ—Å—è—Ü—ã',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 –º–µ—Å—è—Ü—ã',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '–º–µ—Å—è—Ü',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 –º–µ—Å—è—Ü–∞—û',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '–≥–æ–¥',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 –≥–∞–¥—ã',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '–≥–æ–¥',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 –≥–∞–¥–æ—û',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '–ø—Ä–∞–∑ –Ω–µ–∫–∞–ª—å–∫—ñ —Å–µ–∫—É–Ω–¥', 'prefix');
        assert.equal(moment(0).from(30000), '–Ω–µ–∫–∞–ª—å–∫—ñ —Å–µ–∫—É–Ω–¥ —Ç–∞–º—É', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '–ø—Ä–∞–∑ –Ω–µ–∫–∞–ª—å–∫—ñ —Å–µ–∫—É–Ω–¥', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '–ø—Ä–∞–∑ 5 –¥–∑—ë–Ω', 'in 5 days');
        assert.equal(moment().add({m: 31}).fromNow(), '–ø—Ä–∞–∑ 31 —Ö–≤—ñ–ª—ñ–Ω—É', 'in 31 minutes = in 31 minutes');
        assert.equal(moment().subtract({m: 31}).fromNow(), '31 —Ö–≤—ñ–ª—ñ–Ω—É —Ç–∞–º—É', '31 minutes ago = 31 minutes ago');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '–°—ë–Ω–Ω—è —û 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '–°—ë–Ω–Ω—è —û 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '–°—ë–Ω–Ω—è —û 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '–ó–∞—û—Ç—Ä–∞ —û 02:00',      'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '–°—ë–Ω–Ω—è —û 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '–£—á–æ—Ä–∞ —û 02:00',       'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        function makeFormat(d) {
            return '[–£] dddd [—û] LT';
        }

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
            case 3:
            case 5:
            case 6:
                return '[–£ –º—ñ–Ω—É–ª—É—é] dddd [—û] LT';
            case 1:
            case 2:
            case 4:
                return '[–£ –º—ñ–Ω—É–ª—ã] dddd [—û] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-—ã', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-—ã', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-—ñ', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-—ñ', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-—ñ', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('bg');

    test('parse', function (assert) {
        var tests = '—è–Ω—É–∞—Ä–∏ —è–Ω—Ä_—Ñ–µ–≤—Ä—É–∞—Ä–∏ —Ñ–µ–≤_–º–∞—Ä—Ç –º–∞—Ä_–∞–ø—Ä–∏–ª –∞–ø—Ä_–º–∞–π –º–∞–π_—é–Ω–∏ —é–Ω–∏_—é–ª–∏ —é–ª–∏_–∞–≤–≥—É—Å—Ç –∞–≤–≥_—Å–µ–ø—Ç–µ–º–≤—Ä–∏ —Å–µ–ø_–æ–∫—Ç–æ–º–≤—Ä–∏ –æ–∫—Ç_–Ω–æ–µ–º–≤—Ä–∏ –Ω–æ–µ_–¥–µ–∫–µ–º–≤—Ä–∏ –¥–µ–∫'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, H:mm:ss',        '–Ω–µ–¥–µ–ª—è, —Ñ–µ–≤—Ä—É–∞—Ä–∏ 14-—Ç–∏ 2010, 15:25:50'],
                ['ddd, hA',                            '–Ω–µ–¥, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2-—Ä–∏ 02 —Ñ–µ–≤—Ä—É–∞—Ä–∏ —Ñ–µ–≤'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14-—Ç–∏ 14'],
                ['d do dddd ddd dd',                   '0 0-–µ–≤ –Ω–µ–¥–µ–ª—è –Ω–µ–¥ –Ω–¥'],
                ['DDD DDDo DDDD',                      '45 45-—Ç–∏ 045'],
                ['w wo ww',                            '7 7-–º–∏ 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45-—Ç–∏ day of the year'],
                ['LT',                                 '15:25'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14 —Ñ–µ–≤—Ä—É–∞—Ä–∏ 2010'],
                ['LLL',                                '14 —Ñ–µ–≤—Ä—É–∞—Ä–∏ 2010 15:25'],
                ['LLLL',                               '–Ω–µ–¥–µ–ª—è, 14 —Ñ–µ–≤—Ä—É–∞—Ä–∏ 2010 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14 —Ñ–µ–≤ 2010'],
                ['lll',                                '14 —Ñ–µ–≤ 2010 15:25'],
                ['llll',                               '–Ω–µ–¥, 14 —Ñ–µ–≤ 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-–≤–∏', '1-–≤–∏');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-—Ä–∏', '2-—Ä–∏');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-—Ç–∏', '3-—Ç–∏');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-—Ç–∏', '4-—Ç–∏');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-—Ç–∏', '5-—Ç–∏');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-—Ç–∏', '6-—Ç–∏');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-–º–∏', '7-–º–∏');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-–º–∏', '8-–º–∏');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-—Ç–∏', '9-—Ç–∏');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-—Ç–∏', '10-—Ç–∏');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-—Ç–∏', '11-—Ç–∏');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-—Ç–∏', '12-—Ç–∏');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-—Ç–∏', '13-—Ç–∏');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-—Ç–∏', '14-—Ç–∏');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-—Ç–∏', '15-—Ç–∏');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-—Ç–∏', '16-—Ç–∏');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-—Ç–∏', '17-—Ç–∏');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-—Ç–∏', '18-—Ç–∏');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-—Ç–∏', '19-—Ç–∏');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-—Ç–∏', '20-—Ç–∏');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-–≤–∏', '21-–≤–∏');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-—Ä–∏', '22-—Ä–∏');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-—Ç–∏', '23-—Ç–∏');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-—Ç–∏', '24-—Ç–∏');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-—Ç–∏', '25-—Ç–∏');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-—Ç–∏', '26-—Ç–∏');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-–º–∏', '27-–º–∏');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-–º–∏', '28-–º–∏');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-—Ç–∏', '29-—Ç–∏');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-—Ç–∏', '30-—Ç–∏');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-–≤–∏', '31-–≤–∏');
    });

    test('format month', function (assert) {
        var expected = '—è–Ω—É–∞—Ä–∏ —è–Ω—Ä_—Ñ–µ–≤—Ä—É–∞—Ä–∏ —Ñ–µ–≤_–º–∞—Ä—Ç –º–∞—Ä_–∞–ø—Ä–∏–ª –∞–ø—Ä_–º–∞–π –º–∞–π_—é–Ω–∏ —é–Ω–∏_—é–ª–∏ —é–ª–∏_–∞–≤–≥—É—Å—Ç –∞–≤–≥_—Å–µ–ø—Ç–µ–º–≤—Ä–∏ —Å–µ–ø_–æ–∫—Ç–æ–º–≤—Ä–∏ –æ–∫—Ç_–Ω–æ–µ–º–≤—Ä–∏ –Ω–æ–µ_–¥–µ–∫–µ–º–≤—Ä–∏ –¥–µ–∫'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '–Ω–µ–¥–µ–ª—è –Ω–µ–¥ –Ω–¥_–ø–æ–Ω–µ–¥–µ–ª–Ω–∏–∫ –ø–æ–Ω –ø–Ω_–≤—Ç–æ—Ä–Ω–∏–∫ –≤—Ç–æ –≤—Ç_—Å—Ä—è–¥–∞ —Å—Ä—è —Å—Ä_—á–µ—Ç–≤—ä—Ä—Ç—ä–∫ —á–µ—Ç —á—Ç_–ø–µ—Ç—ä–∫ –ø–µ—Ç –ø—Ç_—Å—ä–±–æ—Ç–∞ —Å—ä–± —Å–±'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '–Ω—è–∫–æ–ª–∫–æ —Å–µ–∫—É–Ω–¥–∏', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '–º–∏–Ω—É—Ç–∞',          '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '–º–∏–Ω—É—Ç–∞',          '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 –º–∏–Ω—É—Ç–∏',        '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 –º–∏–Ω—É—Ç–∏',       '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '—á–∞—Å',             '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '—á–∞—Å',             '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 —á–∞—Å–∞',          '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 —á–∞—Å–∞',          '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 —á–∞—Å–∞',         '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '–¥–µ–Ω',             '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '–¥–µ–Ω',             '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 –¥–Ω–∏',           '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '–¥–µ–Ω',             '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 –¥–Ω–∏',           '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 –¥–Ω–∏',          '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '–º–µ—Å–µ—Ü',           '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '–º–µ—Å–µ—Ü',           '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '–º–µ—Å–µ—Ü',           '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 –º–µ—Å–µ—Ü–∞',        '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 –º–µ—Å–µ—Ü–∞',        '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 –º–µ—Å–µ—Ü–∞',        '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '–º–µ—Å–µ—Ü',           '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 –º–µ—Å–µ—Ü–∞',        '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '–≥–æ–¥–∏–Ω–∞',          '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 –≥–æ–¥–∏–Ω–∏',        '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '–≥–æ–¥–∏–Ω–∞',          '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 –≥–æ–¥–∏–Ω–∏',        '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '—Å–ª–µ–¥ –Ω—è–∫–æ–ª–∫–æ —Å–µ–∫—É–Ω–¥–∏',  'prefix');
        assert.equal(moment(0).from(30000), '–ø—Ä–µ–¥–∏ –Ω—è–∫–æ–ª–∫–æ —Å–µ–∫—É–Ω–¥–∏', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '–ø—Ä–µ–¥–∏ –Ω—è–∫–æ–ª–∫–æ —Å–µ–∫—É–Ω–¥–∏',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '—Å–ª–µ–¥ –Ω—è–∫–æ–ª–∫–æ —Å–µ–∫—É–Ω–¥–∏', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '—Å–ª–µ–¥ 5 –¥–Ω–∏', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '–î–Ω–µ—Å –≤ 2:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '–î–Ω–µ—Å –≤ 2:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '–î–Ω–µ—Å –≤ 3:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '–£—Ç—Ä–µ –≤ 2:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '–î–Ω–µ—Å –≤ 1:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '–í—á–µ—Ä–∞ –≤ 2:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [–≤] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [–≤] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [–≤] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
            case 3:
            case 6:
                return '[–í –∏–∑–º–∏–Ω–∞–ª–∞—Ç–∞] dddd [–≤] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[–í –∏–∑–º–∏–Ω–∞–ª–∏—è] dddd [–≤] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-–≤–∏', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-–≤–∏', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-—Ä–∏', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-—Ä–∏', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-—Ç–∏', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('bn');

    test('parse', function (assert) {
        var tests = '‡¶ú‡¶æ‡¶®‡ßÅ‡ßü‡¶æ‡¶∞‡ßÄ ‡¶ú‡¶æ‡¶®‡ßÅ_‡¶´‡ßá‡¶¨‡ßÅ‡ßü‡¶æ‡¶∞‡ßÄ ‡¶´‡ßá‡¶¨_‡¶Æ‡¶æ‡¶∞‡ßç‡¶ö ‡¶Æ‡¶æ‡¶∞‡ßç‡¶ö_‡¶è‡¶™‡ßç‡¶∞‡¶ø‡¶≤ ‡¶è‡¶™‡¶∞_‡¶Æ‡ßá ‡¶Æ‡ßá_‡¶ú‡ßÅ‡¶® ‡¶ú‡ßÅ‡¶®_‡¶ú‡ßÅ‡¶≤‡¶æ‡¶á ‡¶ú‡ßÅ‡¶≤_‡¶Ö‡¶ó‡¶æ‡¶∏‡ßç‡¶ü ‡¶Ö‡¶ó_‡¶∏‡ßá‡¶™‡ßç‡¶ü‡ßá‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶∏‡ßá‡¶™‡ßç‡¶ü_‡¶Ö‡¶ï‡ßç‡¶ü‡ßã‡¶¨‡¶∞ ‡¶Ö‡¶ï‡ßç‡¶ü‡ßã_‡¶®‡¶≠‡ßá‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶®‡¶≠_‡¶°‡¶ø‡¶∏‡ßá‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶°‡¶ø‡¶∏‡ßá‡¶Æ‡ßç'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, a h:mm:ss ‡¶∏‡¶Æ‡ßü',  '‡¶∞‡¶¨‡¶ø‡¶¨‡¶æ‡¶∞, ‡ßß‡ß™ ‡¶´‡ßá‡¶¨‡ßÅ‡ßü‡¶æ‡¶∞‡ßÄ ‡ß®‡ß¶‡ßß‡ß¶, ‡¶¶‡ßÅ‡¶™‡ßÅ‡¶∞ ‡ß©:‡ß®‡ß´:‡ß´‡ß¶ ‡¶∏‡¶Æ‡ßü'],
                ['ddd, a h ‡¶∏‡¶Æ‡ßü',                       '‡¶∞‡¶¨‡¶ø, ‡¶¶‡ßÅ‡¶™‡ßÅ‡¶∞ ‡ß© ‡¶∏‡¶Æ‡ßü'],
                ['M Mo MM MMMM MMM',                   '‡ß® ‡ß® ‡ß¶‡ß® ‡¶´‡ßá‡¶¨‡ßÅ‡ßü‡¶æ‡¶∞‡ßÄ ‡¶´‡ßá‡¶¨'],
                ['YYYY YY',                            '‡ß®‡ß¶‡ßß‡ß¶ ‡ßß‡ß¶'],
                ['D Do DD',                            '‡ßß‡ß™ ‡ßß‡ß™ ‡ßß‡ß™'],
                ['d do dddd ddd dd',                   '‡ß¶ ‡ß¶ ‡¶∞‡¶¨‡¶ø‡¶¨‡¶æ‡¶∞ ‡¶∞‡¶¨‡¶ø ‡¶∞‡¶¨'],
                ['DDD DDDo DDDD',                      '‡ß™‡ß´ ‡ß™‡ß´ ‡ß¶‡ß™‡ß´'],
                ['w wo ww',                            '‡ßÆ ‡ßÆ ‡ß¶‡ßÆ'],
                ['h hh',                               '‡ß© ‡ß¶‡ß©'],
                ['H HH',                               '‡ßß‡ß´ ‡ßß‡ß´'],
                ['m mm',                               '‡ß®‡ß´ ‡ß®‡ß´'],
                ['s ss',                               '‡ß´‡ß¶ ‡ß´‡ß¶'],
                ['a A',                                '‡¶¶‡ßÅ‡¶™‡ßÅ‡¶∞ ‡¶¶‡ßÅ‡¶™‡ßÅ‡¶∞'],
                ['LT',                                 '‡¶¶‡ßÅ‡¶™‡ßÅ‡¶∞ ‡ß©:‡ß®‡ß´ ‡¶∏‡¶Æ‡ßü'],
                ['LTS',                                '‡¶¶‡ßÅ‡¶™‡ßÅ‡¶∞ ‡ß©:‡ß®‡ß´:‡ß´‡ß¶ ‡¶∏‡¶Æ‡ßü'],
                ['L',                                  '‡ßß‡ß™/‡ß¶‡ß®/‡ß®‡ß¶‡ßß‡ß¶'],
                ['LL',                                 '‡ßß‡ß™ ‡¶´‡ßá‡¶¨‡ßÅ‡ßü‡¶æ‡¶∞‡ßÄ ‡ß®‡ß¶‡ßß‡ß¶'],
                ['LLL',                                '‡ßß‡ß™ ‡¶´‡ßá‡¶¨‡ßÅ‡ßü‡¶æ‡¶∞‡ßÄ ‡ß®‡ß¶‡ßß‡ß¶, ‡¶¶‡ßÅ‡¶™‡ßÅ‡¶∞ ‡ß©:‡ß®‡ß´ ‡¶∏‡¶Æ‡ßü'],
                ['LLLL',                               '‡¶∞‡¶¨‡¶ø‡¶¨‡¶æ‡¶∞, ‡ßß‡ß™ ‡¶´‡ßá‡¶¨‡ßÅ‡ßü‡¶æ‡¶∞‡ßÄ ‡ß®‡ß¶‡ßß‡ß¶, ‡¶¶‡ßÅ‡¶™‡ßÅ‡¶∞ ‡ß©:‡ß®‡ß´ ‡¶∏‡¶Æ‡ßü'],
                ['l',                                  '‡ßß‡ß™/‡ß®/‡ß®‡ß¶‡ßß‡ß¶'],
                ['ll',                                 '‡ßß‡ß™ ‡¶´‡ßá‡¶¨ ‡ß®‡ß¶‡ßß‡ß¶'],
                ['lll',                                '‡ßß‡ß™ ‡¶´‡ßá‡¶¨ ‡ß®‡ß¶‡ßß‡ß¶, ‡¶¶‡ßÅ‡¶™‡ßÅ‡¶∞ ‡ß©:‡ß®‡ß´ ‡¶∏‡¶Æ‡ßü'],
                ['llll',                               '‡¶∞‡¶¨‡¶ø, ‡ßß‡ß™ ‡¶´‡ßá‡¶¨ ‡ß®‡ß¶‡ßß‡ß¶, ‡¶¶‡ßÅ‡¶™‡ßÅ‡¶∞ ‡ß©:‡ß®‡ß´ ‡¶∏‡¶Æ‡ßü']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '‡ßß', '‡ßß');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '‡ß®', '‡ß®');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '‡ß©', '‡ß©');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '‡ß™', '‡ß™');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '‡ß´', '‡ß´');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '‡ß¨', '‡ß¨');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '‡ß≠', '‡ß≠');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '‡ßÆ', '‡ßÆ');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '‡ßØ', '‡ßØ');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '‡ßß‡ß¶', '‡ßß‡ß¶');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '‡ßß‡ßß', '‡ßß‡ßß');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '‡ßß‡ß®', '‡ßß‡ß®');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '‡ßß‡ß©', '‡ßß‡ß©');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '‡ßß‡ß™', '‡ßß‡ß™');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '‡ßß‡ß´', '‡ßß‡ß´');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '‡ßß‡ß¨', '‡ßß‡ß¨');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '‡ßß‡ß≠', '‡ßß‡ß≠');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '‡ßß‡ßÆ', '‡ßß‡ßÆ');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '‡ßß‡ßØ', '‡ßß‡ßØ');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '‡ß®‡ß¶', '‡ß®‡ß¶');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '‡ß®‡ßß', '‡ß®‡ßß');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '‡ß®‡ß®', '‡ß®‡ß®');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '‡ß®‡ß©', '‡ß®‡ß©');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '‡ß®‡ß™', '‡ß®‡ß™');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '‡ß®‡ß´', '‡ß®‡ß´');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '‡ß®‡ß¨', '‡ß®‡ß¨');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '‡ß®‡ß≠', '‡ß®‡ß≠');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '‡ß®‡ßÆ', '‡•®‡ßÆ');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '‡ß®‡ßØ', '‡ß®‡ßØ');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '‡ß©‡ß¶', '‡ß©‡ß¶');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '‡ß©‡ßß', '‡ß©‡ßß');
    });

    test('format month', function (assert) {
        var expected = '‡¶ú‡¶æ‡¶®‡ßÅ‡ßü‡¶æ‡¶∞‡ßÄ ‡¶ú‡¶æ‡¶®‡ßÅ_‡¶´‡ßá‡¶¨‡ßÅ‡ßü‡¶æ‡¶∞‡ßÄ ‡¶´‡ßá‡¶¨_‡¶Æ‡¶æ‡¶∞‡ßç‡¶ö ‡¶Æ‡¶æ‡¶∞‡ßç‡¶ö_‡¶è‡¶™‡ßç‡¶∞‡¶ø‡¶≤ ‡¶è‡¶™‡¶∞_‡¶Æ‡ßá ‡¶Æ‡ßá_‡¶ú‡ßÅ‡¶® ‡¶ú‡ßÅ‡¶®_‡¶ú‡ßÅ‡¶≤‡¶æ‡¶á ‡¶ú‡ßÅ‡¶≤_‡¶Ö‡¶ó‡¶æ‡¶∏‡ßç‡¶ü ‡¶Ö‡¶ó_‡¶∏‡ßá‡¶™‡ßç‡¶ü‡ßá‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶∏‡ßá‡¶™‡ßç‡¶ü_‡¶Ö‡¶ï‡ßç‡¶ü‡ßã‡¶¨‡¶∞ ‡¶Ö‡¶ï‡ßç‡¶ü‡ßã_‡¶®‡¶≠‡ßá‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶®‡¶≠_‡¶°‡¶ø‡¶∏‡ßá‡¶Æ‡ßç‡¶¨‡¶∞ ‡¶°‡¶ø‡¶∏‡ßá‡¶Æ‡ßç'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '‡¶∞‡¶¨‡¶ø‡¶¨‡¶æ‡¶∞ ‡¶∞‡¶¨‡¶ø ‡¶∞‡¶¨_‡¶∏‡ßã‡¶Æ‡¶¨‡¶æ‡¶∞ ‡¶∏‡ßã‡¶Æ ‡¶∏‡¶Æ_‡¶Æ‡¶ô‡ßç‡¶ó‡¶≤‡¶¨‡¶æ‡¶∞ ‡¶Æ‡¶ô‡ßç‡¶ó‡¶≤ ‡¶Æ‡¶ô‡ßç‡¶ó_‡¶¨‡ßÅ‡¶ß‡¶¨‡¶æ‡¶∞ ‡¶¨‡ßÅ‡¶ß ‡¶¨‡ßÅ_‡¶¨‡ßÉ‡¶π‡¶∏‡ßç‡¶™‡¶§‡ßç‡¶§‡¶ø‡¶¨‡¶æ‡¶∞ ‡¶¨‡ßÉ‡¶π‡¶∏‡ßç‡¶™‡¶§‡ßç‡¶§‡¶ø ‡¶¨‡ßç‡¶∞‡¶ø‡¶π_‡¶∂‡ßÅ‡¶ï‡ßç‡¶∞‡ßÅ‡¶¨‡¶æ‡¶∞ ‡¶∂‡ßÅ‡¶ï‡ßç‡¶∞‡ßÅ ‡¶∂‡ßÅ_‡¶∂‡¶®‡¶ø‡¶¨‡¶æ‡¶∞ ‡¶∂‡¶®‡¶ø ‡¶∂‡¶®‡¶ø'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '‡¶ï‡¶è‡¶ï ‡¶∏‡ßá‡¶ï‡ßá‡¶®‡ßç‡¶°', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '‡¶è‡¶ï ‡¶Æ‡¶ø‡¶®‡¶ø‡¶ü',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '‡¶è‡¶ï ‡¶Æ‡¶ø‡¶®‡¶ø‡¶ü',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '‡ß® ‡¶Æ‡¶ø‡¶®‡¶ø‡¶ü',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '‡ß™‡ß™ ‡¶Æ‡¶ø‡¶®‡¶ø‡¶ü',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '‡¶è‡¶ï ‡¶ò‡¶®‡ßç‡¶ü‡¶æ',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '‡¶è‡¶ï ‡¶ò‡¶®‡ßç‡¶ü‡¶æ',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '‡ß® ‡¶ò‡¶®‡ßç‡¶ü‡¶æ',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '‡ß´ ‡¶ò‡¶®‡ßç‡¶ü‡¶æ',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '‡ß®‡ßß ‡¶ò‡¶®‡ßç‡¶ü‡¶æ',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '‡¶è‡¶ï ‡¶¶‡¶ø‡¶®',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '‡¶è‡¶ï ‡¶¶‡¶ø‡¶®',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '‡ß® ‡¶¶‡¶ø‡¶®',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '‡¶è‡¶ï ‡¶¶‡¶ø‡¶®',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '‡ß´ ‡¶¶‡¶ø‡¶®',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '‡ß®‡ß´ ‡¶¶‡¶ø‡¶®',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '‡¶è‡¶ï ‡¶Æ‡¶æ‡¶∏',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '‡¶è‡¶ï ‡¶Æ‡¶æ‡¶∏',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '‡ß® ‡¶Æ‡¶æ‡¶∏',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '‡ß® ‡¶Æ‡¶æ‡¶∏',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '‡ß© ‡¶Æ‡¶æ‡¶∏',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '‡¶è‡¶ï ‡¶Æ‡¶æ‡¶∏',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '‡ß´ ‡¶Æ‡¶æ‡¶∏',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '‡¶è‡¶ï ‡¶¨‡¶õ‡¶∞',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '‡ß® ‡¶¨‡¶õ‡¶∞',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '‡¶è‡¶ï ‡¶¨‡¶õ‡¶∞',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '‡ß´ ‡¶¨‡¶õ‡¶∞',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '‡¶ï‡¶è‡¶ï ‡¶∏‡ßá‡¶ï‡ßá‡¶®‡ßç‡¶° ‡¶™‡¶∞‡ßá',  'prefix');
        assert.equal(moment(0).from(30000), '‡¶ï‡¶è‡¶ï ‡¶∏‡ßá‡¶ï‡ßá‡¶®‡ßç‡¶° ‡¶Ü‡¶ó‡ßá', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '‡¶ï‡¶è‡¶ï ‡¶∏‡ßá‡¶ï‡ßá‡¶®‡ßç‡¶° ‡¶Ü‡¶ó‡ßá',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '‡¶ï‡¶è‡¶ï ‡¶∏‡ßá‡¶ï‡ßá‡¶®‡ßç‡¶° ‡¶™‡¶∞‡ßá', '‡¶ï‡¶è‡¶ï ‡¶∏‡ßá‡¶ï‡ßá‡¶®‡ßç‡¶° ‡¶™‡¶∞‡ßá');
        assert.equal(moment().add({d: 5}).fromNow(), '‡ß´ ‡¶¶‡¶ø‡¶® ‡¶™‡¶∞‡ßá', '‡ß´ ‡¶¶‡¶ø‡¶® ‡¶™‡¶∞‡ßá');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '‡¶Ü‡¶ú ‡¶∞‡¶æ‡¶§ ‡ß®:‡ß¶‡ß¶ ‡¶∏‡¶Æ‡ßü',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '‡¶Ü‡¶ú ‡¶∞‡¶æ‡¶§ ‡ß®:‡ß®‡ß´ ‡¶∏‡¶Æ‡ßü',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 3}).calendar(),       '‡¶Ü‡¶ú ‡¶∂‡¶ï‡¶æ‡¶≤ ‡ß´:‡ß¶‡ß¶ ‡¶∏‡¶Æ‡ßü',     'Now plus 3 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '‡¶Ü‡¶ó‡¶æ‡¶Æ‡ßÄ‡¶ï‡¶æ‡¶≤ ‡¶∞‡¶æ‡¶§ ‡ß®:‡ß¶‡ß¶ ‡¶∏‡¶Æ‡ßü',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '‡¶Ü‡¶ú ‡¶∞‡¶æ‡¶§ ‡ßß:‡ß¶‡ß¶ ‡¶∏‡¶Æ‡ßü',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '‡¶ó‡¶§‡¶ï‡¶æ‡¶≤ ‡¶∞‡¶æ‡¶§ ‡ß®:‡ß¶‡ß¶ ‡¶∏‡¶Æ‡ßü', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[‡¶ó‡¶§] dddd[,] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[‡¶ó‡¶§] dddd[,] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[‡¶ó‡¶§] dddd[,] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), '‡¶∞‡¶æ‡¶§', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), '‡¶∂‡¶ï‡¶æ‡¶≤', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), '‡¶¶‡ßÅ‡¶™‡ßÅ‡¶∞', 'during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), '‡¶¨‡¶ø‡¶ï‡ßá‡¶≤', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), '‡¶¨‡¶ø‡¶ï‡ßá‡¶≤', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('a'), '‡¶∞‡¶æ‡¶§', 'night');

        assert.equal(moment([2011, 2, 23,  2, 30]).format('A'), '‡¶∞‡¶æ‡¶§', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('A'), '‡¶∂‡¶ï‡¶æ‡¶≤', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('A'), '‡¶¶‡ßÅ‡¶™‡ßÅ‡¶∞', ' during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('A'), '‡¶¨‡¶ø‡¶ï‡ßá‡¶≤', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('A'), '‡¶¨‡¶ø‡¶ï‡ßá‡¶≤', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('A'), '‡¶∞‡¶æ‡¶§', 'night');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '‡ßß ‡ß¶‡ßß ‡ßß', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '‡ßß ‡ß¶‡ßß ‡ßß', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '‡ß® ‡ß¶‡ß® ‡ß®', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '‡ß® ‡ß¶‡ß® ‡ß®', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '‡ß© ‡ß¶‡ß© ‡ß©', 'Jan 15 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('bo');

    test('parse', function (assert) {
        var tests = '‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωë‡ΩÑ‡ºã‡Ωî‡Ωº ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωë‡ΩÑ‡ºã‡Ωî‡Ωº._‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡ΩÇ‡Ωâ‡Ω≤‡Ω¶‡ºã‡Ωî ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡ΩÇ‡Ωâ‡Ω≤‡Ω¶‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡ΩÇ‡Ω¶‡Ω¥‡Ωò‡ºã‡Ωî ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡ΩÇ‡Ω¶‡Ω¥‡Ωò‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡Ωû‡Ω≤‡ºã‡Ωî ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡Ωû‡Ω≤‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ω£‡æî‡ºã‡Ωî ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ω£‡æî‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωë‡æ≤‡Ω¥‡ΩÇ‡ºã‡Ωî ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωë‡æ≤‡Ω¥‡ΩÇ‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡Ωë‡Ω¥‡Ωì‡ºã‡Ωî ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡Ωë‡Ω¥‡Ωì‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡Ω¢‡æí‡æ±‡Ωë‡ºã‡Ωî ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡Ω¢‡æí‡æ±‡Ωë‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωë‡ΩÇ‡Ω¥‡ºã‡Ωî ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωë‡ΩÇ‡Ω¥‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡ΩÖ‡Ω¥‡ºã‡Ωî ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡ΩÖ‡Ω¥‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡ΩÖ‡Ω¥‡ºã‡ΩÇ‡ΩÖ‡Ω≤‡ΩÇ‡ºã‡Ωî ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡ΩÖ‡Ω¥‡ºã‡ΩÇ‡ΩÖ‡Ω≤‡ΩÇ‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡ΩÖ‡Ω¥‡ºã‡ΩÇ‡Ωâ‡Ω≤‡Ω¶‡ºã‡Ωî ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡ΩÖ‡Ω¥‡ºã‡ΩÇ‡Ωâ‡Ω≤‡Ω¶‡ºã‡Ωî'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, a h:mm:ss ‡Ω£‡ºã',  '‡ΩÇ‡Ωü‡Ω†‡ºã‡Ωâ‡Ω≤‡ºã‡Ωò‡ºã, ‡º°‡º§ ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡ΩÇ‡Ωâ‡Ω≤‡Ω¶‡ºã‡Ωî ‡º¢‡º†‡º°‡º†, ‡Ωâ‡Ω≤‡Ωì‡ºã‡ΩÇ‡Ω¥‡ΩÑ ‡º£:‡º¢‡º•:‡º•‡º† ‡Ω£‡ºã'],
                ['ddd, a h ‡Ω£‡ºã',                       '‡Ωâ‡Ω≤‡ºã‡Ωò‡ºã, ‡Ωâ‡Ω≤‡Ωì‡ºã‡ΩÇ‡Ω¥‡ΩÑ ‡º£ ‡Ω£‡ºã'],
                ['M Mo MM MMMM MMM',                   '‡º¢ ‡º¢ ‡º†‡º¢ ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡ΩÇ‡Ωâ‡Ω≤‡Ω¶‡ºã‡Ωî ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡ΩÇ‡Ωâ‡Ω≤‡Ω¶‡ºã‡Ωî'],
                ['YYYY YY',                            '‡º¢‡º†‡º°‡º† ‡º°‡º†'],
                ['D Do DD',                            '‡º°‡º§ ‡º°‡º§ ‡º°‡º§'],
                ['d do dddd ddd dd',                   '‡º† ‡º† ‡ΩÇ‡Ωü‡Ω†‡ºã‡Ωâ‡Ω≤‡ºã‡Ωò‡ºã ‡Ωâ‡Ω≤‡ºã‡Ωò‡ºã ‡Ωâ‡Ω≤‡ºã‡Ωò‡ºã'],
                ['DDD DDDo DDDD',                      '‡º§‡º• ‡º§‡º• ‡º†‡º§‡º•'],
                ['w wo ww',                            '‡º® ‡º® ‡º†‡º®'],
                ['h hh',                               '‡º£ ‡º†‡º£'],
                ['H HH',                               '‡º°‡º• ‡º°‡º•'],
                ['m mm',                               '‡º¢‡º• ‡º¢‡º•'],
                ['s ss',                               '‡º•‡º† ‡º•‡º†'],
                ['a A',                                '‡Ωâ‡Ω≤‡Ωì‡ºã‡ΩÇ‡Ω¥‡ΩÑ ‡Ωâ‡Ω≤‡Ωì‡ºã‡ΩÇ‡Ω¥‡ΩÑ'],
                ['LT',                                 '‡Ωâ‡Ω≤‡Ωì‡ºã‡ΩÇ‡Ω¥‡ΩÑ ‡º£:‡º¢‡º•'],
                ['LTS',                                '‡Ωâ‡Ω≤‡Ωì‡ºã‡ΩÇ‡Ω¥‡ΩÑ ‡º£:‡º¢‡º•:‡º•‡º†'],
                ['L',                                  '‡º°‡º§/‡º†‡º¢/‡º¢‡º†‡º°‡º†'],
                ['LL',                                 '‡º°‡º§ ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡ΩÇ‡Ωâ‡Ω≤‡Ω¶‡ºã‡Ωî ‡º¢‡º†‡º°‡º†'],
                ['LLL',                                '‡º°‡º§ ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡ΩÇ‡Ωâ‡Ω≤‡Ω¶‡ºã‡Ωî ‡º¢‡º†‡º°‡º†, ‡Ωâ‡Ω≤‡Ωì‡ºã‡ΩÇ‡Ω¥‡ΩÑ ‡º£:‡º¢‡º•'],
                ['LLLL',                               '‡ΩÇ‡Ωü‡Ω†‡ºã‡Ωâ‡Ω≤‡ºã‡Ωò‡ºã, ‡º°‡º§ ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡ΩÇ‡Ωâ‡Ω≤‡Ω¶‡ºã‡Ωî ‡º¢‡º†‡º°‡º†, ‡Ωâ‡Ω≤‡Ωì‡ºã‡ΩÇ‡Ω¥‡ΩÑ ‡º£:‡º¢‡º•'],
                ['l',                                  '‡º°‡º§/‡º¢/‡º¢‡º†‡º°‡º†'],
                ['ll',                                 '‡º°‡º§ ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡ΩÇ‡Ωâ‡Ω≤‡Ω¶‡ºã‡Ωî ‡º¢‡º†‡º°‡º†'],
                ['lll',                                '‡º°‡º§ ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡ΩÇ‡Ωâ‡Ω≤‡Ω¶‡ºã‡Ωî ‡º¢‡º†‡º°‡º†, ‡Ωâ‡Ω≤‡Ωì‡ºã‡ΩÇ‡Ω¥‡ΩÑ ‡º£:‡º¢‡º•'],
                ['llll',                               '‡Ωâ‡Ω≤‡ºã‡Ωò‡ºã, ‡º°‡º§ ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡ΩÇ‡Ωâ‡Ω≤‡Ω¶‡ºã‡Ωî ‡º¢‡º†‡º°‡º†, ‡Ωâ‡Ω≤‡Ωì‡ºã‡ΩÇ‡Ω¥‡ΩÑ ‡º£:‡º¢‡º•']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '‡º°', '‡º°');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '‡º¢', '‡º¢');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '‡º£', '‡º£');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '‡º§', '‡º§');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '‡º•', '‡º•');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '‡º¶', '‡º¶');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '‡ºß', '‡ºß');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '‡º®', '‡º®');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '‡º©', '‡º©');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '‡º°‡º†', '‡º°‡º†');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '‡º°‡º°', '‡º°‡º°');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '‡º°‡º¢', '‡º°‡º¢');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '‡º°‡º£', '‡º°‡º£');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '‡º°‡º§', '‡º°‡º§');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '‡º°‡º•', '‡º°‡º•');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '‡º°‡º¶', '‡º°‡º¶');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '‡º°‡ºß', '‡º°‡ºß');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '‡º°‡º®', '‡º°‡º®');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '‡º°‡º©', '‡º°‡º©');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '‡º¢‡º†', '‡º¢‡º†');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '‡º¢‡º°', '‡º¢‡º°');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '‡º¢‡º¢', '‡º¢‡º¢');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '‡º¢‡º£', '‡º¢‡º£');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '‡º¢‡º§', '‡º¢‡º§');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '‡º¢‡º•', '‡º¢‡º•');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '‡º¢‡º¶', '‡º¢‡º¶');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '‡º¢‡ºß', '‡º¢‡ºß');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '‡º¢‡º®', '‡º¢‡º®');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '‡º¢‡º©', '‡º¢‡º©');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '‡º£‡º†', '‡º£‡º†');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '‡º£‡º°', '‡º£‡º°');
    });

    test('format month', function (assert) {
        var expected = '‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωë‡ΩÑ‡ºã‡Ωî‡Ωº ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωë‡ΩÑ‡ºã‡Ωî‡Ωº_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡ΩÇ‡Ωâ‡Ω≤‡Ω¶‡ºã‡Ωî ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡ΩÇ‡Ωâ‡Ω≤‡Ω¶‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡ΩÇ‡Ω¶‡Ω¥‡Ωò‡ºã‡Ωî ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡ΩÇ‡Ω¶‡Ω¥‡Ωò‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡Ωû‡Ω≤‡ºã‡Ωî ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡Ωû‡Ω≤‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ω£‡æî‡ºã‡Ωî ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ω£‡æî‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωë‡æ≤‡Ω¥‡ΩÇ‡ºã‡Ωî ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωë‡æ≤‡Ω¥‡ΩÇ‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡Ωë‡Ω¥‡Ωì‡ºã‡Ωî ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡Ωë‡Ω¥‡Ωì‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡Ω¢‡æí‡æ±‡Ωë‡ºã‡Ωî ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡Ω¢‡æí‡æ±‡Ωë‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωë‡ΩÇ‡Ω¥‡ºã‡Ωî ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωë‡ΩÇ‡Ω¥‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡ΩÖ‡Ω¥‡ºã‡Ωî ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡ΩÖ‡Ω¥‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡ΩÖ‡Ω¥‡ºã‡ΩÇ‡ΩÖ‡Ω≤‡ΩÇ‡ºã‡Ωî ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡ΩÖ‡Ω¥‡ºã‡ΩÇ‡ΩÖ‡Ω≤‡ΩÇ‡ºã‡Ωî_‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡ΩÖ‡Ω¥‡ºã‡ΩÇ‡Ωâ‡Ω≤‡Ω¶‡ºã‡Ωî ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡Ωñ‡ΩÖ‡Ω¥‡ºã‡ΩÇ‡Ωâ‡Ω≤‡Ω¶‡ºã‡Ωî'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '‡ΩÇ‡Ωü‡Ω†‡ºã‡Ωâ‡Ω≤‡ºã‡Ωò‡ºã ‡Ωâ‡Ω≤‡ºã‡Ωò‡ºã ‡Ωâ‡Ω≤‡ºã‡Ωò‡ºã_‡ΩÇ‡Ωü‡Ω†‡ºã‡Ωü‡æ≥‡ºã‡Ωñ‡ºã ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã ‡Ωü‡æ≥‡ºã‡Ωñ‡ºã_‡ΩÇ‡Ωü‡Ω†‡ºã‡Ωò‡Ω≤‡ΩÇ‡ºã‡Ωë‡Ωò‡Ω¢‡ºã ‡Ωò‡Ω≤‡ΩÇ‡ºã‡Ωë‡Ωò‡Ω¢‡ºã ‡Ωò‡Ω≤‡ΩÇ‡ºã‡Ωë‡Ωò‡Ω¢‡ºã_‡ΩÇ‡Ωü‡Ω†‡ºã‡Ω£‡æ∑‡ΩÇ‡ºã‡Ωî‡ºã ‡Ω£‡æ∑‡ΩÇ‡ºã‡Ωî‡ºã ‡Ω£‡æ∑‡ΩÇ‡ºã‡Ωî‡ºã_‡ΩÇ‡Ωü‡Ω†‡ºã‡Ωï‡Ω¥‡Ω¢‡ºã‡Ωñ‡Ω¥ ‡Ωï‡Ω¥‡Ω¢‡ºã‡Ωñ‡Ω¥ ‡Ωï‡Ω¥‡Ω¢‡ºã‡Ωñ‡Ω¥_‡ΩÇ‡Ωü‡Ω†‡ºã‡Ωî‡ºã‡Ω¶‡ΩÑ‡Ω¶‡ºã ‡Ωî‡ºã‡Ω¶‡ΩÑ‡Ω¶‡ºã ‡Ωî‡ºã‡Ω¶‡ΩÑ‡Ω¶‡ºã_‡ΩÇ‡Ωü‡Ω†‡ºã‡Ω¶‡æ§‡Ω∫‡Ωì‡ºã‡Ωî‡ºã ‡Ω¶‡æ§‡Ω∫‡Ωì‡ºã‡Ωî‡ºã ‡Ω¶‡æ§‡Ω∫‡Ωì‡ºã‡Ωî‡ºã'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '‡Ω£‡Ωò‡ºã‡Ω¶‡ΩÑ', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '‡Ω¶‡æê‡Ω¢‡ºã‡Ωò‡ºã‡ΩÇ‡ΩÖ‡Ω≤‡ΩÇ',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '‡Ω¶‡æê‡Ω¢‡ºã‡Ωò‡ºã‡ΩÇ‡ΩÖ‡Ω≤‡ΩÇ',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '‡º¢ ‡Ω¶‡æê‡Ω¢‡ºã‡Ωò',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '‡º§‡º§ ‡Ω¶‡æê‡Ω¢‡ºã‡Ωò',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '‡ΩÜ‡Ω¥‡ºã‡Ωö‡Ωº‡Ωë‡ºã‡ΩÇ‡ΩÖ‡Ω≤‡ΩÇ',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '‡ΩÜ‡Ω¥‡ºã‡Ωö‡Ωº‡Ωë‡ºã‡ΩÇ‡ΩÖ‡Ω≤‡ΩÇ',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '‡º¢ ‡ΩÜ‡Ω¥‡ºã‡Ωö‡Ωº‡Ωë',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '‡º• ‡ΩÜ‡Ω¥‡ºã‡Ωö‡Ωº‡Ωë',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '‡º¢‡º° ‡ΩÜ‡Ω¥‡ºã‡Ωö‡Ωº‡Ωë',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '‡Ωâ‡Ω≤‡Ωì‡ºã‡ΩÇ‡ΩÖ‡Ω≤‡ΩÇ',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '‡Ωâ‡Ω≤‡Ωì‡ºã‡ΩÇ‡ΩÖ‡Ω≤‡ΩÇ',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '‡º¢ ‡Ωâ‡Ω≤‡Ωì‡ºã',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '‡Ωâ‡Ω≤‡Ωì‡ºã‡ΩÇ‡ΩÖ‡Ω≤‡ΩÇ',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '‡º• ‡Ωâ‡Ω≤‡Ωì‡ºã',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '‡º¢‡º• ‡Ωâ‡Ω≤‡Ωì‡ºã',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡ΩÇ‡ΩÖ‡Ω≤‡ΩÇ',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡ΩÇ‡ΩÖ‡Ω≤‡ΩÇ',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡ΩÇ‡ΩÖ‡Ω≤‡ΩÇ',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '‡º¢ ‡Ωü‡æ≥‡ºã‡Ωñ',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '‡º¢ ‡Ωü‡æ≥‡ºã‡Ωñ',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '‡º£ ‡Ωü‡æ≥‡ºã‡Ωñ',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '‡Ωü‡æ≥‡ºã‡Ωñ‡ºã‡ΩÇ‡ΩÖ‡Ω≤‡ΩÇ',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '‡º• ‡Ωü‡æ≥‡ºã‡Ωñ',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '‡Ω£‡Ωº‡ºã‡ΩÇ‡ΩÖ‡Ω≤‡ΩÇ',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '‡º¢ ‡Ω£‡Ωº',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '‡Ω£‡Ωº‡ºã‡ΩÇ‡ΩÖ‡Ω≤‡ΩÇ',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '‡º• ‡Ω£‡Ωº',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '‡Ω£‡Ωò‡ºã‡Ω¶‡ΩÑ ‡Ω£‡ºã',  'prefix');
        assert.equal(moment(0).from(30000), '‡Ω£‡Ωò‡ºã‡Ω¶‡ΩÑ ‡Ω¶‡æî‡Ωì‡ºã‡Ω£', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '‡Ω£‡Ωò‡ºã‡Ω¶‡ΩÑ ‡Ω¶‡æî‡Ωì‡ºã‡Ω£',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '‡Ω£‡Ωò‡ºã‡Ω¶‡ΩÑ ‡Ω£‡ºã', '‡Ω£‡Ωò‡ºã‡Ω¶‡ΩÑ ‡Ω£‡ºã');
        assert.equal(moment().add({d: 5}).fromNow(), '‡º• ‡Ωâ‡Ω≤‡Ωì‡ºã ‡Ω£‡ºã', '‡º• ‡Ωâ‡Ω≤‡Ωì‡ºã ‡Ω£‡ºã');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '‡Ωë‡Ω≤‡ºã‡Ω¢‡Ω≤‡ΩÑ ‡Ωò‡Ωö‡Ωì‡ºã‡Ωò‡Ωº ‡º¢:‡º†‡º†',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '‡Ωë‡Ω≤‡ºã‡Ω¢‡Ω≤‡ΩÑ ‡Ωò‡Ωö‡Ωì‡ºã‡Ωò‡Ωº ‡º¢:‡º¢‡º•',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 3}).calendar(),       '‡Ωë‡Ω≤‡ºã‡Ω¢‡Ω≤‡ΩÑ ‡Ωû‡Ωº‡ΩÇ‡Ω¶‡ºã‡ΩÄ‡Ω¶ ‡º•:‡º†‡º†',     'Now plus 3 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '‡Ω¶‡ΩÑ‡ºã‡Ωâ‡Ω≤‡Ωì ‡Ωò‡Ωö‡Ωì‡ºã‡Ωò‡Ωº ‡º¢:‡º†‡º†',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '‡Ωë‡Ω≤‡ºã‡Ω¢‡Ω≤‡ΩÑ ‡Ωò‡Ωö‡Ωì‡ºã‡Ωò‡Ωº ‡º°:‡º†‡º†',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '‡ΩÅ‡ºã‡Ω¶‡ΩÑ ‡Ωò‡Ωö‡Ωì‡ºã‡Ωò‡Ωº ‡º¢:‡º†‡º†', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[‡Ωñ‡Ωë‡Ω¥‡Ωì‡ºã‡Ωï‡æ≤‡ΩÇ‡ºã‡Ω¢‡æó‡Ω∫‡Ω¶‡ºã‡Ωò][,] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[‡Ωñ‡Ωë‡Ω¥‡Ωì‡ºã‡Ωï‡æ≤‡ΩÇ‡ºã‡Ω¢‡æó‡Ω∫‡Ω¶‡ºã‡Ωò][,] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[‡Ωñ‡Ωë‡Ω¥‡Ωì‡ºã‡Ωï‡æ≤‡ΩÇ‡ºã‡Ω¢‡æó‡Ω∫‡Ω¶‡ºã‡Ωò][,] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[‡Ωñ‡Ωë‡Ω¥‡Ωì‡ºã‡Ωï‡æ≤‡ΩÇ‡ºã‡Ωò‡Ωê‡Ω†‡ºã‡Ωò] dddd[,] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[‡Ωñ‡Ωë‡Ω¥‡Ωì‡ºã‡Ωï‡æ≤‡ΩÇ‡ºã‡Ωò‡Ωê‡Ω†‡ºã‡Ωò] dddd[,] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[‡Ωñ‡Ωë‡Ω¥‡Ωì‡ºã‡Ωï‡æ≤‡ΩÇ‡ºã‡Ωò‡Ωê‡Ω†‡ºã‡Ωò] dddd[,] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), '‡Ωò‡Ωö‡Ωì‡ºã‡Ωò‡Ωº', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), '‡Ωû‡Ωº‡ΩÇ‡Ω¶‡ºã‡ΩÄ‡Ω¶', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), '‡Ωâ‡Ω≤‡Ωì‡ºã‡ΩÇ‡Ω¥‡ΩÑ', 'during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), '‡Ωë‡ΩÇ‡Ωº‡ΩÑ‡ºã‡Ωë‡ΩÇ', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), '‡Ωë‡ΩÇ‡Ωº‡ΩÑ‡ºã‡Ωë‡ΩÇ', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('a'), '‡Ωò‡Ωö‡Ωì‡ºã‡Ωò‡Ωº', 'night');

        assert.equal(moment([2011, 2, 23,  2, 30]).format('A'), '‡Ωò‡Ωö‡Ωì‡ºã‡Ωò‡Ωº', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('A'), '‡Ωû‡Ωº‡ΩÇ‡Ω¶‡ºã‡ΩÄ‡Ω¶', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('A'), '‡Ωâ‡Ω≤‡Ωì‡ºã‡ΩÇ‡Ω¥‡ΩÑ', ' during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('A'), '‡Ωë‡ΩÇ‡Ωº‡ΩÑ‡ºã‡Ωë‡ΩÇ', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('A'), '‡Ωë‡ΩÇ‡Ωº‡ΩÑ‡ºã‡Ωë‡ΩÇ', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('A'), '‡Ωò‡Ωö‡Ωì‡ºã‡Ωò‡Ωº', 'night');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '‡º° ‡º†‡º° ‡º°', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '‡º° ‡º†‡º° ‡º°', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '‡º¢ ‡º†‡º¢ ‡º¢', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '‡º¢ ‡º†‡º¢ ‡º¢', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '‡º£ ‡º†‡º£ ‡º£', 'Jan 15 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('br');

    test('parse', function (assert) {
        var tests = 'Genver Gen_C\'hwevrer C\'hwe_Meurzh Meu_Ebrel Ebr_Mae Mae_Mezheven Eve_Gouere Gou_Eost Eos_Gwengolo Gwe_Here Her_Du Du_Kerzu Ker'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        moment.locale('br');
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Sul, C\'hwevrer 14vet 2010, 3:25:50 pm'],
                ['ddd, h A',                            'Sul, 3 PM'],
                ['M Mo MM MMMM MMM',                   '2 2vet 02 C\'hwevrer C\'hwe'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14vet 14'],
                ['d do dddd ddd dd',                   '0 0vet Sul Sul Su'],
                ['DDD DDDo DDDD',                      '45 45vet 045'],
                ['w wo ww',                            '6 6vet 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['DDDo [devezh] [ar] [vloaz]',       '45vet devezh ar vloaz'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 a viz C\'hwevrer 2010'],
                ['LLL',                                '14 a viz C\'hwevrer 2010 3e25 PM'],
                ['LLLL',                               'Sul, 14 a viz C\'hwevrer 2010 3e25 PM']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        moment.locale('br');
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1a√±', '1a√±');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2vet', '2vet');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3vet', '3vet');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4vet', '4vet');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5vet', '5vet');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6vet', '6vet');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7vet', '7vet');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8vet', '8vet');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9vet', '9vet');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10vet', '10vet');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11vet', '11vet');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12vet', '12vet');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13vet', '13vet');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14vet', '14vet');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15vet', '15vet');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16vet', '16vet');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17vet', '17vet');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18vet', '18vet');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19vet', '19vet');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20vet', '20vet');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21vet', '21vet');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22vet', '22vet');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23vet', '23vet');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24vet', '24vet');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25vet', '25vet');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26vet', '26vet');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27vet', '27vet');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28vet', '28vet');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29vet', '29vet');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30vet', '30vet');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31vet', '31vet');
    });

    test('format month', function (assert) {
        moment.locale('br');
        var expected = 'Genver Gen_C\'hwevrer C\'hwe_Meurzh Meu_Ebrel Ebr_Mae Mae_Mezheven Eve_Gouere Gou_Eost Eos_Gwengolo Gwe_Here Her_Du Du_Kerzu Ker'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        moment.locale('br');
        var expected = 'Sul Sul Su_Lun Lun Lu_Meurzh Meu Me_Merc\'her Mer Mer_Yaou Yao Ya_Gwener Gwe Gw_Sadorn Sad Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        moment.locale('br');
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'un nebeud segondenno√π', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ur vunutenn',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ur vunutenn',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 vunutenn',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 munutenn',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'un eur',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'un eur',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 eur',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 eur',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 eur',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'un devezh',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'un devezh',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 zevezh',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'un devezh',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 devezh',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 devezh',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ur miz',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ur miz',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ur miz',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 viz',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 viz',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 miz',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ur miz',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 miz',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ur bloaz',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 vloaz',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'ur bloaz',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 bloaz',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        moment.locale('br');
        assert.equal(moment(30000).from(0), 'a-benn un nebeud segondenno√π',  'prefix');
        assert.equal(moment(0).from(30000), 'un nebeud segondenno√π \'zo', 'suffix');
    });

    test('now from now', function (assert) {
        moment.locale('br');
        assert.equal(moment().fromNow(), 'un nebeud segondenno√π \'zo',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        moment.locale('br');
        assert.equal(moment().add({s: 30}).fromNow(), 'a-benn un nebeud segondenno√π', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'a-benn 5 devezh', 'in 5 days');
    });

    test('calendar day', function (assert) {
        moment.locale('br');

        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Hiziv da 2e00 AM',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Hiziv da 2e25 AM',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Hiziv da 3e00 AM',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Warc\'hoazh da 2e00 AM',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Hiziv da 1e00 AM',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Dec\'h da 2e00 AM', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        moment.locale('br');

        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [da] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [da] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [da] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        moment.locale('br');

        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [paset da] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [paset da] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [paset da] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        moment.locale('br');
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('special mutations for years', function (assert) {
        moment.locale('br');
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true), 'ur bloaz', 'mutation 1 year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 2}), true), '2 vloaz', 'mutation 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 3}), true), '3 bloaz', 'mutation 3 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 4}), true), '4 bloaz', 'mutation 4 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true), '5 bloaz', 'mutation 5 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 9}), true), '9 bloaz', 'mutation 9 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 10}), true), '10 vloaz', 'mutation 10 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 21}), true), '21 bloaz', 'mutation 21 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 22}), true), '22 vloaz', 'mutation 22 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 133}), true), '133 bloaz', 'mutation 133 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 148}), true), '148 vloaz', 'mutation 148 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 261}), true), '261 bloaz', 'mutation 261 years');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('bs');

    test('parse', function (assert) {
        var tests = 'januar jan._februar feb._mart mar._april apr._maj maj._juni jun._juli jul._august aug._septembar sep._oktobar okt._novembar nov._decembar dec.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'nedjelja, 14. februar 2010, 3:25:50 pm'],
                ['ddd, hA',                            'ned., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. nedjelja ned. ne'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '7 7. 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14. 02. 2010'],
                ['LL',                                 '14. februar 2010'],
                ['LLL',                                '14. februar 2010 15:25'],
                ['LLLL',                               'nedjelja, 14. februar 2010 15:25'],
                ['l',                                  '14. 2. 2010'],
                ['ll',                                 '14. feb. 2010'],
                ['lll',                                '14. feb. 2010 15:25'],
                ['llll',                               'ned., 14. feb. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'januar jan._februar feb._mart mar._april apr._maj maj._juni jun._juli jul._august aug._septembar sep._oktobar okt._novembar nov._decembar dec.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'nedjelja ned. ne_ponedjeljak pon. po_utorak uto. ut_srijeda sri. sr_ƒçetvrtak ƒçet. ƒçe_petak pet. pe_subota sub. su'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'par sekundi', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'jedna minuta',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'jedna minuta',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minute',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuta',     '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'jedan sat',      '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'jedan sat',      '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 sata',        '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 sati',         '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 sati',        '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'dan',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'dan',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dana',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'dan',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dana',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dana',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mjesec',     '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mjesec',     '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mjesec',     '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mjeseca',     '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mjeseca',     '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mjeseca',     '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mjesec',     '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mjeseci',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'godinu',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 godine',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'godinu',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 godina',        '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'za par sekundi',  'prefix');
        assert.equal(moment(0).from(30000), 'prije par sekundi', 'prefix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'prije par sekundi',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'za par sekundi', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'za 5 dana', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'danas u 2:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'danas u 2:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'danas u 3:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'sutra u 2:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'danas u 1:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'juƒçer u 2:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
                return '[u] [nedjelju] [u] LT';
            case 3:
                return '[u] [srijedu] [u] LT';
            case 6:
                return '[u] [subotu] [u] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[u] dddd [u] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
            case 3:
                return '[pro≈°lu] dddd [u] LT';
            case 6:
                return '[pro≈°le] [subote] [u] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[pro≈°li] dddd [u] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('ca');

    test('parse', function (assert) {
        var tests = 'gener gen._febrer febr._mar√ß mar._abril abr._maig mai._juny jun._juliol jul._agost ag._setembre set._octubre oct._novembre nov._desembre des.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'diumenge, 14√® febrer 2010, 3:25:50 pm'],
                ['ddd, hA',                            'dg., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2n 02 febrer febr.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14√® 14'],
                ['d do dddd ddd dd',                   '0 0√® diumenge dg. Dg'],
                ['DDD DDDo DDDD',                      '45 45√® 045'],
                ['w wo ww',                            '6 6a 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45√® day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 febrer 2010'],
                ['LLL',                                '14 febrer 2010 15:25'],
                ['LLLL',                               'diumenge 14 febrer 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 febr. 2010'],
                ['lll',                                '14 febr. 2010 15:25'],
                ['llll',                               'dg. 14 febr. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1r', '1r');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2n', '2n');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3r', '3r');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4t', '4t');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5√®', '5√®');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6√®', '6√®');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7√®', '7√®');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8√®', '8√®');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9√®', '9√®');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10√®', '10√®');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11√®', '11√®');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12√®', '12√®');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13√®', '13√®');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14√®', '14√®');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15√®', '15√®');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16√®', '16√®');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17√®', '17√®');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18√®', '18√®');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19√®', '19√®');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20√®', '20√®');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21√®', '21√®');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22√®', '22√®');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23√®', '23√®');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24√®', '24√®');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25√®', '25√®');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26√®', '26√®');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27√®', '27√®');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28√®', '28√®');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29√®', '29√®');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30√®', '30√®');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31√®', '31√®');
    });

    test('format month', function (assert) {
        var expected = 'gener gen._febrer febr._mar√ß mar._abril abr._maig mai._juny jun._juliol jul._agost ag._setembre set._octubre oct._novembre nov._desembre des.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'diumenge dg. Dg_dilluns dl. Dl_dimarts dt. Dt_dimecres dc. Dc_dijous dj. Dj_divendres dv. Dv_dissabte ds. Ds'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'uns segons', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'un minut',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'un minut',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuts',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuts',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'una hora',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'una hora',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hores',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hores',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hores',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'un dia',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'un dia',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dies',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'un dia',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dies',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dies',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'un mes',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'un mes',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'un mes',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mesos',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mesos',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mesos',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'un mes',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mesos',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'un any',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 anys',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'un any',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 anys',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'en uns segons',  'prefix');
        assert.equal(moment(0).from(30000), 'fa uns segons', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'fa uns segons',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'en uns segons', 'en uns segons');
        assert.equal(moment().add({d: 5}).fromNow(), 'en 5 dies', 'en 5 dies');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                         'avui a les 2:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),          'avui a les 2:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),           'avui a les 3:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),           'dem√† a les 2:00',  'tomorrow at the same time');
        assert.equal(moment(a).add({d: 1, h : -1}).calendar(),   'dem√† a la 1:00',   'tomorrow minus 1 hour');
        assert.equal(moment(a).subtract({h: 1}).calendar(),      'avui a la 1:00',      'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),      'ahir a les 2:00',    'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [a ' + ((m.hours() !== 1) ? 'les' : 'la') + '] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [a ' + ((m.hours() !== 1) ? 'les' : 'la') + '] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [a ' + ((m.hours() !== 1) ? 'les' : 'la') + '] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[el] dddd [passat a ' + ((m.hours() !== 1) ? 'les' : 'la') + '] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[el] dddd [passat a ' + ((m.hours() !== 1) ? 'les' : 'la') + '] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[el] dddd [passat a ' + ((m.hours() !== 1) ? 'les' : 'la') + '] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52a', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1a', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1a', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2a', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2a', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('cs');

    test('parse', function (assert) {
        var tests = 'leden led_√∫nor √∫no_b≈ôezen b≈ôe_duben dub_kvƒõten kvƒõ_ƒçerven ƒçvn_ƒçervenec ƒçvc_srpen srp_z√°≈ô√≠ z√°≈ô_≈ô√≠jen ≈ô√≠j_listopad lis_prosinec pro'.split('_'), i;
        function equalTest(input, mmm, monthIndex) {
            assert.equal(moment(input, mmm).month(), monthIndex, input + ' should be month ' + (monthIndex + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss',  'nedƒõle, √∫nor 14. 2010, 3:25:50'],
                ['ddd, h',                       'ne, 3'],
                ['M Mo MM MMMM MMM',             '2 2. 02 √∫nor √∫no'],
                ['YYYY YY',                      '2010 10'],
                ['D Do DD',                      '14 14. 14'],
                ['d do dddd ddd dd',             '0 0. nedƒõle ne ne'],
                ['DDD DDDo DDDD',                '45 45. 045'],
                ['w wo ww',                      '6 6. 06'],
                ['h hh',                         '3 03'],
                ['H HH',                         '15 15'],
                ['m mm',                         '25 25'],
                ['s ss',                         '50 50'],
                ['a A',                          'pm PM'],
                ['DDDo [den v roce]',            '45. den v roce'],
                ['LTS',                          '15:25:50'],
                ['L',                            '14.02.2010'],
                ['LL',                           '14. √∫nor 2010'],
                ['LLL',                          '14. √∫nor 2010 15:25'],
                ['LLLL',                         'nedƒõle 14. √∫nor 2010 15:25'],
                ['l',                            '14.2.2010'],
                ['ll',                           '14. √∫no 2010'],
                ['lll',                          '14. √∫no 2010 15:25'],
                ['llll',                         'ne 14. √∫no 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'leden led_√∫nor √∫no_b≈ôezen b≈ôe_duben dub_kvƒõten kvƒõ_ƒçerven ƒçvn_ƒçervenec ƒçvc_srpen srp_z√°≈ô√≠ z√°≈ô_≈ô√≠jen ≈ô√≠j_listopad lis_prosinec pro'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'nedƒõle ne ne_pondƒõl√≠ po po_√∫ter√Ω √∫t √∫t_st≈ôeda st st_ƒçtvrtek ƒçt ƒçt_p√°tek p√° p√°_sobota so so'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'p√°r sekund',  '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'minuta',        '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'minuta',        '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuty',      '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minut',     '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'hodina',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'hodina',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hodiny',     '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hodin',      '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hodin',     '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'den',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'den',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dny',         '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'den',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dn√≠',         '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dn√≠',        '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mƒõs√≠c',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mƒõs√≠c',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mƒõs√≠c',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mƒõs√≠ce',    '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mƒõs√≠ce',    '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mƒõs√≠ce',    '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mƒõs√≠c',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mƒõs√≠c≈Ø',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'rok',           '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 roky',        '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'rok',           '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 let',         '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'za p√°r sekund',  'prefix');
        assert.equal(moment(0).from(30000), 'p≈ôed p√°r sekundami', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'p≈ôed p√°r sekundami',  'now from now should display as in the past');
    });

    test('fromNow (future)', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'za p√°r sekund', 'in a few seconds');
        assert.equal(moment().add({m: 1}).fromNow(), 'za minutu', 'in a minute');
        assert.equal(moment().add({m: 3}).fromNow(), 'za 3 minuty', 'in 3 minutes');
        assert.equal(moment().add({m: 10}).fromNow(), 'za 10 minut', 'in 10 minutes');
        assert.equal(moment().add({h: 1}).fromNow(), 'za hodinu', 'in an hour');
        assert.equal(moment().add({h: 3}).fromNow(), 'za 3 hodiny', 'in 3 hours');
        assert.equal(moment().add({h: 10}).fromNow(), 'za 10 hodin', 'in 10 hours');
        assert.equal(moment().add({d: 1}).fromNow(), 'za den', 'in a day');
        assert.equal(moment().add({d: 3}).fromNow(), 'za 3 dny', 'in 3 days');
        assert.equal(moment().add({d: 10}).fromNow(), 'za 10 dn√≠', 'in 10 days');
        assert.equal(moment().add({M: 1}).fromNow(), 'za mƒõs√≠c', 'in a month');
        assert.equal(moment().add({M: 3}).fromNow(), 'za 3 mƒõs√≠ce', 'in 3 months');
        assert.equal(moment().add({M: 10}).fromNow(), 'za 10 mƒõs√≠c≈Ø', 'in 10 months');
        assert.equal(moment().add({y: 1}).fromNow(), 'za rok', 'in a year');
        assert.equal(moment().add({y: 3}).fromNow(), 'za 3 roky', 'in 3 years');
        assert.equal(moment().add({y: 10}).fromNow(), 'za 10 let', 'in 10 years');
    });

    test('fromNow (past)', function (assert) {
        assert.equal(moment().subtract({s: 30}).fromNow(), 'p≈ôed p√°r sekundami', 'a few seconds ago');
        assert.equal(moment().subtract({m: 1}).fromNow(), 'p≈ôed minutou', 'a minute ago');
        assert.equal(moment().subtract({m: 3}).fromNow(), 'p≈ôed 3 minutami', '3 minutes ago');
        assert.equal(moment().subtract({m: 10}).fromNow(), 'p≈ôed 10 minutami', '10 minutes ago');
        assert.equal(moment().subtract({h: 1}).fromNow(), 'p≈ôed hodinou', 'an hour ago');
        assert.equal(moment().subtract({h: 3}).fromNow(), 'p≈ôed 3 hodinami', '3 hours ago');
        assert.equal(moment().subtract({h: 10}).fromNow(), 'p≈ôed 10 hodinami', '10 hours ago');
        assert.equal(moment().subtract({d: 1}).fromNow(), 'p≈ôed dnem', 'a day ago');
        assert.equal(moment().subtract({d: 3}).fromNow(), 'p≈ôed 3 dny', '3 days ago');
        assert.equal(moment().subtract({d: 10}).fromNow(), 'p≈ôed 10 dny', '10 days ago');
        assert.equal(moment().subtract({M: 1}).fromNow(), 'p≈ôed mƒõs√≠cem', 'a month ago');
        assert.equal(moment().subtract({M: 3}).fromNow(), 'p≈ôed 3 mƒõs√≠ci', '3 months ago');
        assert.equal(moment().subtract({M: 10}).fromNow(), 'p≈ôed 10 mƒõs√≠ci', '10 months ago');
        assert.equal(moment().subtract({y: 1}).fromNow(), 'p≈ôed rokem', 'a year ago');
        assert.equal(moment().subtract({y: 3}).fromNow(), 'p≈ôed 3 lety', '3 years ago');
        assert.equal(moment().subtract({y: 10}).fromNow(), 'p≈ôed 10 lety', '10 years ago');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'dnes v 2:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'dnes v 2:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'dnes v 3:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'z√≠tra v 2:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'dnes v 1:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'vƒçera v 2:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m, nextDay;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            nextDay = '';
            switch (m.day()) {
            case 0:
                nextDay = 'v nedƒõli';
                break;
            case 1:
                nextDay = 'v pondƒõl√≠';
                break;
            case 2:
                nextDay = 'v √∫ter√Ω';
                break;
            case 3:
                nextDay = 've st≈ôedu';
                break;
            case 4:
                nextDay = 've ƒçtvrtek';
                break;
            case 5:
                nextDay = 'v p√°tek';
                break;
            case 6:
                nextDay = 'v sobotu';
                break;
            }
            assert.equal(m.calendar(),       m.format('[' + nextDay + '] [v] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[' + nextDay + '] [v] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[' + nextDay + '] [v] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m, lastDay;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            lastDay = '';
            switch (m.day()) {
            case 0:
                lastDay = 'minulou nedƒõli';
                break;
            case 1:
                lastDay = 'minul√© pondƒõl√≠';
                break;
            case 2:
                lastDay = 'minul√© √∫ter√Ω';
                break;
            case 3:
                lastDay = 'minulou st≈ôedu';
                break;
            case 4:
                lastDay = 'minul√Ω ƒçtvrtek';
                break;
            case 5:
                lastDay = 'minul√Ω p√°tek';
                break;
            case 6:
                lastDay = 'minulou sobotu';
                break;
            }
            assert.equal(m.calendar(),       m.format('[' + lastDay + '] [v] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[' + lastDay + '] [v] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[' + lastDay + '] [v] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('humanize duration', function (assert) {
        assert.equal(moment.duration(1, 'minutes').humanize(), 'minuta', 'a minute (future)');
        assert.equal(moment.duration(1, 'minutes').humanize(true), 'za minutu', 'in a minute');
        assert.equal(moment.duration(-1, 'minutes').humanize(), 'minuta', 'a minute (past)');
        assert.equal(moment.duration(-1, 'minutes').humanize(true), 'p≈ôed minutou', 'a minute ago');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('cv');

    test('parse', function (assert) {
        var tests = '–∫”ë—Ä–ª–∞—á –∫”ë—Ä_–Ω–∞—Ä”ë—Å –Ω–∞—Ä_–ø—É—à –ø—É—à_–∞–∫–∞ –∞–∫–∞_–º–∞–π –º–∞–π_“´”ó—Ä—Ç–º–µ “´”ó—Ä_—É—Ç”ë —É—Ç”ë_“´—É—Ä–ª–∞ “´—É—Ä_–∞–≤”ë–Ω –∞–≤–Ω_—é–ø–∞ —é–ø–∞_—á”≥–∫ —á”≥–∫_—Ä–∞—à—Ç–∞–≤ —Ä–∞—à'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      '–≤—ã—Ä—Å–∞—Ä–Ω–∏–∫—É–Ω, –Ω–∞—Ä”ë—Å 14-–º”ó—à 2010, 3:25:50 pm'],
                ['ddd, hA',                            '–≤—ã—Ä, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2-–º”ó—à 02 –Ω–∞—Ä”ë—Å –Ω–∞—Ä'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14-–º”ó—à 14'],
                ['d do dddd ddd dd',                   '0 0-–º”ó—à –≤—ã—Ä—Å–∞—Ä–Ω–∏–∫—É–Ω –≤—ã—Ä –≤—Ä'],
                ['DDD DDDo DDDD',                      '45 45-–º”ó—à 045'],
                ['w wo ww',                            '7 7-–º”ó—à 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['“™—É–ª”ë–Ω DDDo –∫—É–Ω”ó',                    '“™—É–ª”ë–Ω 45-–º”ó—à –∫—É–Ω”ó'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14-02-2010'],
                ['LL',                                 '2010 “´—É–ª—Ö–∏ –Ω–∞—Ä”ë—Å —É–π”ë—Ö”ó–Ω 14-–º”ó—à”ó'],
                ['LLL',                                '2010 “´—É–ª—Ö–∏ –Ω–∞—Ä”ë—Å —É–π”ë—Ö”ó–Ω 14-–º”ó—à”ó, 15:25'],
                ['LLLL',                               '–≤—ã—Ä—Å–∞—Ä–Ω–∏–∫—É–Ω, 2010 “´—É–ª—Ö–∏ –Ω–∞—Ä”ë—Å —É–π”ë—Ö”ó–Ω 14-–º”ó—à”ó, 15:25'],
                ['l',                                  '14-2-2010'],
                ['ll',                                 '2010 “´—É–ª—Ö–∏ –Ω–∞—Ä —É–π”ë—Ö”ó–Ω 14-–º”ó—à”ó'],
                ['lll',                                '2010 “´—É–ª—Ö–∏ –Ω–∞—Ä —É–π”ë—Ö”ó–Ω 14-–º”ó—à”ó, 15:25'],
                ['llll',                               '–≤—ã—Ä, 2010 “´—É–ª—Ö–∏ –Ω–∞—Ä —É–π”ë—Ö”ó–Ω 14-–º”ó—à”ó, 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-–º”ó—à', '1-–º”ó—à');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-–º”ó—à', '2-–º”ó—à');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-–º”ó—à', '3-–º”ó—à');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-–º”ó—à', '4-–º”ó—à');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-–º”ó—à', '5-–º”ó—à');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-–º”ó—à', '6-–º”ó—à');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-–º”ó—à', '7-–º”ó—à');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-–º”ó—à', '8-–º”ó—à');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-–º”ó—à', '9-–º”ó—à');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-–º”ó—à', '10-–º”ó—à');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-–º”ó—à', '11-–º”ó—à');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-–º”ó—à', '12-–º”ó—à');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-–º”ó—à', '13-–º”ó—à');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-–º”ó—à', '14-–º”ó—à');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-–º”ó—à', '15-–º”ó—à');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-–º”ó—à', '16-–º”ó—à');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-–º”ó—à', '17-–º”ó—à');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-–º”ó—à', '18-–º”ó—à');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-–º”ó—à', '19-–º”ó—à');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-–º”ó—à', '20-–º”ó—à');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-–º”ó—à', '21-–º”ó—à');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-–º”ó—à', '22-–º”ó—à');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-–º”ó—à', '23-–º”ó—à');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-–º”ó—à', '24-–º”ó—à');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-–º”ó—à', '25-–º”ó—à');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-–º”ó—à', '26-–º”ó—à');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-–º”ó—à', '27-–º”ó—à');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-–º”ó—à', '28-–º”ó—à');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-–º”ó—à', '29-–º”ó—à');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-–º”ó—à', '30-–º”ó—à');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-–º”ó—à', '31-–º”ó—à');
    });

    test('format month', function (assert) {
        var expected = '–∫”ë—Ä–ª–∞—á –∫”ë—Ä_–Ω–∞—Ä”ë—Å –Ω–∞—Ä_–ø—É—à –ø—É—à_–∞–∫–∞ –∞–∫–∞_–º–∞–π –º–∞–π_“´”ó—Ä—Ç–º–µ “´”ó—Ä_—É—Ç”ë —É—Ç”ë_“´—É—Ä–ª–∞ “´—É—Ä_–∞–≤”ë–Ω –∞–≤–Ω_—é–ø–∞ —é–ø–∞_—á”≥–∫ —á”≥–∫_—Ä–∞—à—Ç–∞–≤ —Ä–∞—à'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '–≤—ã—Ä—Å–∞—Ä–Ω–∏–∫—É–Ω –≤—ã—Ä –≤—Ä_—Ç—É–Ω—Ç–∏–∫—É–Ω —Ç—É–Ω —Ç–Ω_—ã—Ç–ª–∞—Ä–∏–∫—É–Ω —ã—Ç–ª —ã—Ç_—é–Ω–∫—É–Ω —é–Ω —é–Ω_–∫”ó“´–Ω–µ—Ä–Ω–∏–∫—É–Ω –∫”ó“´ –∫“´_—ç—Ä–Ω–µ–∫—É–Ω —ç—Ä–Ω —ç—Ä_—à”ë–º–∞—Ç–∫—É–Ω —à”ë–º —à–º'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '–ø”ó—Ä-–∏–∫ “´–µ–∫–∫—É–Ω—Ç', '44 sekunder = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '–ø”ó—Ä –º–∏–Ω—É—Ç',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '–ø”ó—Ä –º–∏–Ω—É—Ç',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 –º–∏–Ω—É—Ç',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 –º–∏–Ω—É—Ç',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '–ø”ó—Ä —Å–µ—Ö–µ—Ç',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '–ø”ó—Ä —Å–µ—Ö–µ—Ç',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 —Å–µ—Ö–µ—Ç',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 —Å–µ—Ö–µ—Ç',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 —Å–µ—Ö–µ—Ç',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '–ø”ó—Ä –∫—É–Ω',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '–ø”ó—Ä –∫—É–Ω',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 –∫—É–Ω',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '–ø”ó—Ä –∫—É–Ω',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 –∫—É–Ω',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 –∫—É–Ω',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '–ø”ó—Ä —É–π”ë—Ö',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '–ø”ó—Ä —É–π”ë—Ö',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '–ø”ó—Ä —É–π”ë—Ö',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 —É–π”ë—Ö',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 —É–π”ë—Ö',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 —É–π”ë—Ö',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '–ø”ó—Ä —É–π”ë—Ö',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 —É–π”ë—Ö',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '–ø”ó—Ä “´—É–ª',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 “´—É–ª',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '–ø”ó—Ä “´—É–ª',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 “´—É–ª',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '–ø”ó—Ä-–∏–∫ “´–µ–∫–∫—É–Ω—Ç—Ä–∞–Ω',  'prefix');
        assert.equal(moment(0).from(30000), '–ø”ó—Ä-–∏–∫ “´–µ–∫–∫—É–Ω—Ç –∫–∞—è–ª–ª–∞', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '–ø”ó—Ä-–∏–∫ “´–µ–∫–∫—É–Ω—Ç –∫–∞—è–ª–ª–∞',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '–ø”ó—Ä-–∏–∫ “´–µ–∫–∫—É–Ω—Ç—Ä–∞–Ω', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5 –∫—É–Ω—Ä–∞–Ω', 'in 5 days');
        assert.equal(moment().add({h: 2}).fromNow(), '2 —Å–µ—Ö–µ—Ç—Ä–µ–Ω', 'in 2 hours, the right suffix!');
        assert.equal(moment().add({y: 3}).fromNow(), '3 “´—É–ª—Ç–∞–Ω', 'in 3 years, the right suffix!');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);
        assert.equal(moment(a).calendar(),                   '–ü–∞—è–Ω 02:00 —Å–µ—Ö–µ—Ç—Ä–µ',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '–ü–∞—è–Ω 02:25 —Å–µ—Ö–µ—Ç—Ä–µ',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '–ü–∞—è–Ω 03:00 —Å–µ—Ö–µ—Ç—Ä–µ',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '–´—Ä–∞–Ω 02:00 —Å–µ—Ö–µ—Ç—Ä–µ',     'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '–ü–∞—è–Ω 01:00 —Å–µ—Ö–µ—Ç—Ä–µ',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '”ñ–Ω–µ—Ä 02:00 —Å–µ—Ö–µ—Ç—Ä–µ',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[“™–∏—Ç–µ—Å] dddd LT [—Å–µ—Ö–µ—Ç—Ä–µ]'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[“™–∏—Ç–µ—Å] dddd LT [—Å–µ—Ö–µ—Ç—Ä–µ]'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[“™–∏—Ç–µ—Å] dddd LT [—Å–µ—Ö–µ—Ç—Ä–µ]'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[–ò—Ä—Ç–Ω”ó] dddd LT [—Å–µ—Ö–µ—Ç—Ä–µ]'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[–ò—Ä—Ç–Ω”ó] dddd LT [—Å–µ—Ö–µ—Ç—Ä–µ]'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[–ò—Ä—Ç–Ω”ó] dddd LT [—Å–µ—Ö–µ—Ç—Ä–µ]'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    // Monday is the first day of the week.
    // The week that contains Jan 1st is the first week of the year.

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-–º”ó—à', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-–º”ó—à', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-–º”ó—à', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-–º”ó—à', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-–º”ó—à', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('cy');

    test('parse', function (assert) {
        var tests = 'Ionawr Ion_Chwefror Chwe_Mawrth Maw_Ebrill Ebr_Mai Mai_Mehefin Meh_Gorffennaf Gor_Awst Aws_Medi Med_Hydref Hyd_Tachwedd Tach_Rhagfyr Rhag'.split('_'),
            i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Dydd Sul, Chwefror 14eg 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Sul, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2il 02 Chwefror Chwe'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14eg 14'],
                ['d do dddd ddd dd',                   '0 0 Dydd Sul Sul Su'],
                ['DDD DDDo DDDD',                      '45 45ain 045'],
                ['w wo ww',                            '6 6ed 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45ain day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 Chwefror 2010'],
                ['LLL',                                '14 Chwefror 2010 15:25'],
                ['LLLL',                               'Dydd Sul, 14 Chwefror 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Chwe 2010'],
                ['lll',                                '14 Chwe 2010 15:25'],
                ['llll',                               'Sul, 14 Chwe 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1af', '1af');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2il', '2il');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3ydd', '3ydd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4ydd', '4ydd');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5ed', '5ed');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6ed', '6ed');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7ed', '7ed');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8fed', '8fed');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9fed', '9fed');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10fed', '10fed');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11eg', '11eg');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12fed', '12fed');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13eg', '13eg');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14eg', '14eg');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15fed', '15fed');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16eg', '16eg');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17eg', '17eg');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18fed', '18fed');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19eg', '19eg');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20fed', '20fed');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21ain', '21ain');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22ain', '22ain');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23ain', '23ain');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24ain', '24ain');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25ain', '25ain');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26ain', '26ain');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27ain', '27ain');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28ain', '28ain');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29ain', '29ain');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30ain', '30ain');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31ain', '31ain');
    });

    test('format month', function (assert) {
        var expected = 'Ionawr Ion_Chwefror Chwe_Mawrth Maw_Ebrill Ebr_Mai Mai_Mehefin Meh_Gorffennaf Gor_Awst Aws_Medi Med_Hydref Hyd_Tachwedd Tach_Rhagfyr Rhag'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Dydd Sul Sul Su_Dydd Llun Llun Ll_Dydd Mawrth Maw Ma_Dydd Mercher Mer Me_Dydd Iau Iau Ia_Dydd Gwener Gwe Gw_Dydd Sadwrn Sad Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'ychydig eiliadau', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'munud',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'munud',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 munud',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 munud', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'awr',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'awr',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 awr',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 awr',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 awr',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'diwrnod',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'diwrnod',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 diwrnod',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'diwrnod',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 diwrnod',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 diwrnod',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mis',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mis',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mis',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mis',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mis',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mis',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mis',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mis',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'blwyddyn',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 flynedd',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'blwyddyn',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 flynedd',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'mewn ychydig eiliadau', 'prefix');
        assert.equal(moment(0).from(30000), 'ychydig eiliadau yn √¥l', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'mewn ychydig eiliadau', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'mewn 5 diwrnod', 'in 5 days');
    });

    test('same day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Heddiw am 02:00',    'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Heddiw am 02:25',    'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Heddiw am 03:00',    'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Yfory am 02:00',         'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Heddiw am 01:00',    'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Ddoe am 02:00',           'yesterday at the same time');
    });

    test('same next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [am] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [am] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [am] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('same last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [diwethaf am] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [diwethaf am] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [diwethaf am] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('same all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52ain', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'), '1 01 1af', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '1 01 1af', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2il', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2il', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('da');

    test('parse', function (assert) {
        var tests = 'januar jan_februar feb_marts mar_april apr_maj maj_juni jun_juli jul_august aug_september sep_oktober okt_november nov_december dec'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd [den] Do MMMM YYYY, h:mm:ss a', 's√∏ndag den 14. februar 2010, 3:25:50 pm'],
                ['ddd hA',                             's√∏n 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. s√∏ndag s√∏n s√∏'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[den] DDDo [dag p√• √•ret]',           'den 45. dag p√• √•ret'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14. februar 2010'],
                ['LLL',                                '14. februar 2010 15:25'],
                ['LLLL',                               's√∏ndag d. 14. februar 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14. feb 2010'],
                ['lll',                                '14. feb 2010 15:25'],
                ['llll',                               's√∏n d. 14. feb 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'januar jan_februar feb_marts mar_april apr_maj maj_juni jun_juli jul_august aug_september sep_oktober okt_november nov_december dec'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 's√∏ndag s√∏n s√∏_mandag man ma_tirsdag tir ti_onsdag ons on_torsdag tor to_fredag fre fr_l√∏rdag l√∏r l√∏'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'f√• sekunder', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'et minut',    '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'et minut',    '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutter',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutter', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'en time',     '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'en time',     '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 timer',     '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 timer',     '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 timer',    '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'en dag',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'en dag',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dage',      '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'en dag',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dage',      '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dage',     '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'en m√•ned',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'en m√•ned',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'en m√•ned',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 m√•neder',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 m√•neder',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 m√•neder',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'en m√•ned',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 m√•neder',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'et √•r',       '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 √•r',        '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'et √•r',       '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 √•r',        '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'om f√• sekunder',  'prefix');
        assert.equal(moment(0).from(30000), 'f√• sekunder siden', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'f√• sekunder siden',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'om f√• sekunder', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'om 5 dage', 'in 5 days');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('de-at');

    test('parse', function (assert) {
        var tests = 'J√§nner J√§n._Februar Febr._M√§rz Mrz._April Apr._Mai Mai_Juni Jun._Juli Jul._August Aug._September Sept._Oktober Okt._November Nov._Dezember Dez.'.split('_'), i;

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a', 'Sonntag, 14. Februar 2010, 3:25:50 pm'],
                ['ddd, hA', 'So., 3PM'],
                ['M Mo MM MMMM MMM', '2 2. 02 Februar Febr.'],
                ['YYYY YY', '2010 10'],
                ['D Do DD', '14 14. 14'],
                ['d do dddd ddd dd', '0 0. Sonntag So. So'],
                ['DDD DDDo DDDD', '45 45. 045'],
                ['w wo ww', '6 6. 06'],
                ['h hh', '3 03'],
                ['H HH', '15 15'],
                ['m mm', '25 25'],
                ['s ss', '50 50'],
                ['a A', 'pm PM'],
                ['[the] DDDo [day of the year]', 'the 45. day of the year'],
                ['LTS', '15:25:50'],
                ['L', '14.02.2010'],
                ['LL', '14. Februar 2010'],
                ['LLL', '14. Februar 2010 15:25'],
                ['LLLL', 'Sonntag, 14. Februar 2010 15:25'],
                ['l', '14.2.2010'],
                ['ll', '14. Febr. 2010'],
                ['lll', '14. Febr. 2010 15:25'],
                ['llll', 'So., 14. Febr. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'J√§nner J√§n._Februar Febr._M√§rz Mrz._April Apr._Mai Mai_Juni Jun._Juli Jul._August Aug._September Sept._Oktober Okt._November Nov._Dezember Dez.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Sonntag So. So_Montag Mo. Mo_Dienstag Di. Di_Mittwoch Mi. Mi_Donnerstag Do. Do_Freitag Fr. Fr_Samstag Sa. Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true), 'ein paar Sekunden', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true), 'eine Minute', '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true), 'eine Minute', '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true), '2 Minuten', '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true), '44 Minuten', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true), 'eine Stunde', '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true), 'eine Stunde', '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true), '2 Stunden', '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true), '5 Stunden', '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true), '21 Stunden', '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true), 'ein Tag', '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true), 'ein Tag', '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true), '2 Tage', '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true), 'ein Tag', '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true), '5 Tage', '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true), '25 Tage', '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true), 'ein Monat', '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true), 'ein Monat', '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true), '2 Monate', '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true), '2 Monate', '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true), '3 Monate', '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true), 'ein Monat', '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true), '5 Monate', '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ein Jahr', '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Jahre', '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true), 'ein Jahr', '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true), '5 Jahre', '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'in ein paar Sekunden', 'prefix');
        assert.equal(moment(0).from(30000), 'vor ein paar Sekunden', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'in ein paar Sekunden', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'in 5 Tagen', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(), 'Heute um 02:00 Uhr', 'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(), 'Heute um 02:25 Uhr', 'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(), 'Heute um 03:00 Uhr', 'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(), 'Morgen um 02:00 Uhr', 'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(), 'Heute um 01:00 Uhr', 'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(), 'Gestern um 02:00 Uhr', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(), m.format('dddd [um] LT [Uhr]'), 'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format('dddd [um] LT [Uhr]'), 'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format('dddd [um] LT [Uhr]'), 'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(), m.format('[letzten] dddd [um] LT [Uhr]'), 'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format('[letzten] dddd [um] LT [Uhr]'), 'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format('[letzten] dddd [um] LT [Uhr]'), 'Today + ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '1 week ago');
        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), 'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '2 weeks ago');
        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), 'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(), 1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(), 1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(), 2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(), 1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(), 2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008, 0, 1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008, 0, 6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008, 0, 7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008, 0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008, 0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003, 0, 1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003, 0, 5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003, 0, 6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003, 0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003, 0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009, 0, 1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009, 0, 4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009, 0, 5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009, 0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009, 0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010, 0, 1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010, 0, 3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010, 0, 4]).week(), 1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010, 0, 10]).week(), 1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010, 0, 11]).week(), 2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011, 0, 1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011, 0, 2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011, 0, 3]).week(), 1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011, 0, 9]).week(), 1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011, 0, 10]).week(), 2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0, 1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).format('w ww wo'), '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).format('w ww wo'), '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).format('w ww wo'), '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '2 02 2.', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('de');

    test('parse', function (assert) {
        var tests = 'Januar Jan._Februar Febr._M√§rz Mrz._April Apr._Mai Mai_Juni Jun._Juli Jul._August Aug._September Sept._Oktober Okt._November Nov._Dezember Dez.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'Sonntag, 14. Februar 2010, 3:25:50 pm'],
                ['ddd, hA',                            'So., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 Februar Febr.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. Sonntag So. So'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14. Februar 2010'],
                ['LLL',                                '14. Februar 2010 15:25'],
                ['LLLL',                               'Sonntag, 14. Februar 2010 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14. Febr. 2010'],
                ['lll',                                '14. Febr. 2010 15:25'],
                ['llll',                               'So., 14. Febr. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'Januar Jan._Februar Febr._M√§rz Mrz._April Apr._Mai Mai_Juni Jun._Juli Jul._August Aug._September Sept._Oktober Okt._November Nov._Dezember Dez.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Sonntag So. So_Montag Mo. Mo_Dienstag Di. Di_Mittwoch Mi. Mi_Donnerstag Do. Do_Freitag Fr. Fr_Samstag Sa. Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'ein paar Sekunden',  '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'eine Minute',       '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'eine Minute',       '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 Minuten',          '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 Minuten',         '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'eine Stunde',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'eine Stunde',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 Stunden',          '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 Stunden',          '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 Stunden',         '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ein Tag',          '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ein Tag',          '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 Tage',            '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ein Tag',          '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 Tage',            '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 Tage',           '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ein Monat',        '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ein Monat',        '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ein Monat',        '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 Monate',          '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 Monate',          '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 Monate',          '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ein Monat',        '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 Monate',          '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ein Jahr',         '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Jahre',           '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'ein Jahr',         '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 Jahre',           '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'in ein paar Sekunden', 'prefix');
        assert.equal(moment(0).from(30000), 'vor ein paar Sekunden', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'in ein paar Sekunden', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'in 5 Tagen', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Heute um 02:00 Uhr',   'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Heute um 02:25 Uhr',   'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Heute um 03:00 Uhr',   'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Morgen um 02:00 Uhr',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Heute um 01:00 Uhr',   'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Gestern um 02:00 Uhr', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [um] LT [Uhr]'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [um] LT [Uhr]'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [um] LT [Uhr]'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[letzten] dddd [um] LT [Uhr]'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[letzten] dddd [um] LT [Uhr]'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[letzten] dddd [um] LT [Uhr]'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('el');

    test('parse', function (assert) {
        var i,
            tests = 'ŒôŒ±ŒΩŒøœÖŒ¨œÅŒπŒøœÇ ŒôŒ±ŒΩ_Œ¶ŒµŒ≤œÅŒøœÖŒ¨œÅŒπŒøœÇ Œ¶ŒµŒ≤_ŒúŒ¨œÅœÑŒπŒøœÇ ŒúŒ±œÅ_ŒëœÄœÅŒØŒªŒπŒøœÇ ŒëœÄœÅ_ŒúŒ¨ŒπŒøœÇ ŒúŒ±œä_ŒôŒøœçŒΩŒπŒøœÇ ŒôŒøœÖŒΩ_ŒôŒøœçŒªŒπŒøœÇ ŒôŒøœÖŒª_ŒëœçŒ≥ŒøœÖœÉœÑŒøœÇ ŒëœÖŒ≥_Œ£ŒµœÄœÑŒ≠ŒºŒ≤œÅŒπŒøœÇ Œ£ŒµœÄ_ŒüŒ∫œÑœéŒ≤œÅŒπŒøœÇ ŒüŒ∫œÑ_ŒùŒøŒ≠ŒºŒ≤œÅŒπŒøœÇ ŒùŒøŒµ_ŒîŒµŒ∫Œ≠ŒºŒ≤œÅŒπŒøœÇ ŒîŒµŒ∫'.split('_');

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('parse meridiem', function (assert) {
        var i,
            b = moment(),
            meridiemTests = [
                // h a patterns, expected hours, isValid
                ['10 œÄŒº',   10, true],
                ['10 ŒºŒº',   22, true],
                ['10 œÄ.Œº.', 10, true],
                ['10 Œº.Œº.', 22, true],
                ['10 œÄ',    10, true],
                ['10 Œº',    22, true],
                ['10 Œ†Œú',   10, true],
                ['10 ŒúŒú',   22, true],
                ['10 Œ†.Œú.', 10, true],
                ['10 Œú.Œú.', 22, true],
                ['10 Œ†',    10, true],
                ['10 Œú',    22, true],
                ['10 am',   10, false],
                ['10 pm',   10, false]
            ];

        // test that a formatted moment including meridiem string can be parsed back to the same moment
        assert.ok(b.isSame(moment(b.format('h:mm:ss a'), 'h:mm:ss a', 'el', true), 'seconds'), b.format('h:mm:ss a') + ' should be equal to ' + moment(b.format('h:mm:ss a'), 'h:mm:ss a', 'el', true).format('h:mm:ss a'));

        // test that a formatted moment having a meridiem string can be parsed with strict flag
        assert.ok(moment(b.format('h:mm:ss a'), 'h:mm:ss a', 'el', true).isValid(), b.format('h:mm:ss a') + ' should be parsed as valid');

        for (i = 0; i < meridiemTests.length; i++) {
            assert.equal(moment(meridiemTests[i][0], 'h a', 'el', true).hours(), meridiemTests[i][1], moment(meridiemTests[i][0], 'h a', 'el', true).hours() + ' should be ' + meridiemTests[i][1]);
            assert.ok(moment(meridiemTests[i][0], 'h a', 'el', true).isValid() === meridiemTests[i][2], meridiemTests[i][0] + ' ----> ' + meridiemTests[i][2]);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'ŒöœÖœÅŒπŒ±Œ∫ŒÆ, Œ¶ŒµŒ≤œÅŒøœÖŒ¨œÅŒπŒøœÇ 14Œ∑ 2010, 3:25:50 ŒºŒº'],
                ['dddd, D MMMM YYYY, h:mm:ss a',       'ŒöœÖœÅŒπŒ±Œ∫ŒÆ, 14 Œ¶ŒµŒ≤œÅŒøœÖŒ±œÅŒØŒøœÖ 2010, 3:25:50 ŒºŒº'],
                ['ddd, hA',                            'ŒöœÖœÅ, 3ŒúŒú'],
                ['dddd, MMMM YYYY',                    'ŒöœÖœÅŒπŒ±Œ∫ŒÆ, Œ¶ŒµŒ≤œÅŒøœÖŒ¨œÅŒπŒøœÇ 2010'],
                ['M Mo MM MMMM MMM',                   '2 2Œ∑ 02 Œ¶ŒµŒ≤œÅŒøœÖŒ¨œÅŒπŒøœÇ Œ¶ŒµŒ≤'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14Œ∑ 14'],
                ['d do dddd ddd dd',                   '0 0Œ∑ ŒöœÖœÅŒπŒ±Œ∫ŒÆ ŒöœÖœÅ ŒöœÖ'],
                ['DDD DDDo DDDD',                      '45 45Œ∑ 045'],
                ['w wo ww',                            '6 6Œ∑ 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'ŒºŒº ŒúŒú'],
                ['[the] DDDo [day of the year]',       'the 45Œ∑ day of the year'],
                ['LTS',                                '3:25:50 ŒúŒú'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 Œ¶ŒµŒ≤œÅŒøœÖŒ±œÅŒØŒøœÖ 2010'],
                ['LLL',                                '14 Œ¶ŒµŒ≤œÅŒøœÖŒ±œÅŒØŒøœÖ 2010 3:25 ŒúŒú'],
                ['LLLL',                               'ŒöœÖœÅŒπŒ±Œ∫ŒÆ, 14 Œ¶ŒµŒ≤œÅŒøœÖŒ±œÅŒØŒøœÖ 2010 3:25 ŒúŒú'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Œ¶ŒµŒ≤ 2010'],
                ['lll',                                '14 Œ¶ŒµŒ≤ 2010 3:25 ŒúŒú'],
                ['llll',                               'ŒöœÖœÅ, 14 Œ¶ŒµŒ≤ 2010 3:25 ŒúŒú']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1Œ∑', '1Œ∑');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2Œ∑', '2Œ∑');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3Œ∑', '3Œ∑');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4Œ∑', '4Œ∑');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5Œ∑', '5Œ∑');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6Œ∑', '6Œ∑');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7Œ∑', '7Œ∑');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8Œ∑', '8Œ∑');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9Œ∑', '9Œ∑');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10Œ∑', '10Œ∑');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11Œ∑', '11Œ∑');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12Œ∑', '12Œ∑');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13Œ∑', '13Œ∑');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14Œ∑', '14Œ∑');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15Œ∑', '15Œ∑');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16Œ∑', '16Œ∑');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17Œ∑', '17Œ∑');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18Œ∑', '18Œ∑');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19Œ∑', '19Œ∑');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20Œ∑', '20Œ∑');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21Œ∑', '21Œ∑');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22Œ∑', '22Œ∑');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23Œ∑', '23Œ∑');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24Œ∑', '24Œ∑');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25Œ∑', '25Œ∑');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26Œ∑', '26Œ∑');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27Œ∑', '27Œ∑');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28Œ∑', '28Œ∑');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29Œ∑', '29Œ∑');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30Œ∑', '30Œ∑');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31Œ∑', '31Œ∑');
    });

    test('format month', function (assert) {
        var i,
            expected = 'ŒôŒ±ŒΩŒøœÖŒ¨œÅŒπŒøœÇ ŒôŒ±ŒΩ_Œ¶ŒµŒ≤œÅŒøœÖŒ¨œÅŒπŒøœÇ Œ¶ŒµŒ≤_ŒúŒ¨œÅœÑŒπŒøœÇ ŒúŒ±œÅ_ŒëœÄœÅŒØŒªŒπŒøœÇ ŒëœÄœÅ_ŒúŒ¨ŒπŒøœÇ ŒúŒ±œä_ŒôŒøœçŒΩŒπŒøœÇ ŒôŒøœÖŒΩ_ŒôŒøœçŒªŒπŒøœÇ ŒôŒøœÖŒª_ŒëœçŒ≥ŒøœÖœÉœÑŒøœÇ ŒëœÖŒ≥_Œ£ŒµœÄœÑŒ≠ŒºŒ≤œÅŒπŒøœÇ Œ£ŒµœÄ_ŒüŒ∫œÑœéŒ≤œÅŒπŒøœÇ ŒüŒ∫œÑ_ŒùŒøŒ≠ŒºŒ≤œÅŒπŒøœÇ ŒùŒøŒµ_ŒîŒµŒ∫Œ≠ŒºŒ≤œÅŒπŒøœÇ ŒîŒµŒ∫'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var i,
            expected = 'ŒöœÖœÅŒπŒ±Œ∫ŒÆ ŒöœÖœÅ ŒöœÖ_ŒîŒµœÖœÑŒ≠œÅŒ± ŒîŒµœÖ ŒîŒµ_Œ§œÅŒØœÑŒ∑ Œ§œÅŒπ Œ§œÅ_Œ§ŒµœÑŒ¨œÅœÑŒ∑ Œ§ŒµœÑ Œ§Œµ_Œ†Œ≠ŒºœÄœÑŒ∑ Œ†ŒµŒº Œ†Œµ_Œ†Œ±œÅŒ±œÉŒ∫ŒµœÖŒÆ Œ†Œ±œÅ Œ†Œ±_Œ£Œ¨Œ≤Œ≤Œ±œÑŒø Œ£Œ±Œ≤ Œ£Œ±'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'ŒªŒØŒ≥Œ± Œ¥ŒµœÖœÑŒµœÅœåŒªŒµœÄœÑŒ±',   '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'Œ≠ŒΩŒ± ŒªŒµœÄœÑœå',           '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'Œ≠ŒΩŒ± ŒªŒµœÄœÑœå',           '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ŒªŒµœÄœÑŒ¨',             '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ŒªŒµœÄœÑŒ¨',            '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ŒºŒØŒ± œéœÅŒ±',             '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ŒºŒØŒ± œéœÅŒ±',             '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 œéœÅŒµœÇ',              '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 œéœÅŒµœÇ',              '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 œéœÅŒµœÇ',             '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ŒºŒØŒ± ŒºŒ≠œÅŒ±',            '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ŒºŒØŒ± ŒºŒ≠œÅŒ±',            '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ŒºŒ≠œÅŒµœÇ',             '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ŒºŒØŒ± ŒºŒ≠œÅŒ±',            '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ŒºŒ≠œÅŒµœÇ',             '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ŒºŒ≠œÅŒµœÇ',            '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'Œ≠ŒΩŒ±œÇ ŒºŒÆŒΩŒ±œÇ',          '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'Œ≠ŒΩŒ±œÇ ŒºŒÆŒΩŒ±œÇ',          '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'Œ≠ŒΩŒ±œÇ ŒºŒÆŒΩŒ±œÇ',          '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ŒºŒÆŒΩŒµœÇ',             '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ŒºŒÆŒΩŒµœÇ',             '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ŒºŒÆŒΩŒµœÇ',             '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'Œ≠ŒΩŒ±œÇ ŒºŒÆŒΩŒ±œÇ',          '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ŒºŒÆŒΩŒµœÇ',             '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'Œ≠ŒΩŒ±œÇ œáœÅœåŒΩŒøœÇ',         '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 œáœÅœåŒΩŒπŒ±',            '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'Œ≠ŒΩŒ±œÇ œáœÅœåŒΩŒøœÇ',         '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 œáœÅœåŒΩŒπŒ±',            '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'œÉŒµ ŒªŒØŒ≥Œ± Œ¥ŒµœÖœÑŒµœÅœåŒªŒµœÄœÑŒ±',  'prefix');
        assert.equal(moment(0).from(30000), 'ŒªŒØŒ≥Œ± Œ¥ŒµœÖœÑŒµœÅœåŒªŒµœÄœÑŒ± œÄœÅŒπŒΩ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'ŒªŒØŒ≥Œ± Œ¥ŒµœÖœÑŒµœÅœåŒªŒµœÄœÑŒ± œÄœÅŒπŒΩ',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'œÉŒµ ŒªŒØŒ≥Œ± Œ¥ŒµœÖœÑŒµœÅœåŒªŒµœÄœÑŒ±', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'œÉŒµ 5 ŒºŒ≠œÅŒµœÇ', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Œ£ŒÆŒºŒµœÅŒ± œÉœÑŒπœÇ 2:00 Œ†Œú',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Œ£ŒÆŒºŒµœÅŒ± œÉœÑŒπœÇ 2:25 Œ†Œú',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Œ£ŒÆŒºŒµœÅŒ± œÉœÑŒπœÇ 3:00 Œ†Œú',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'ŒëœçœÅŒπŒø œÉœÑŒπœÇ 2:00 Œ†Œú',      'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Œ£ŒÆŒºŒµœÅŒ± œÉœÑŒ∑ 1:00 Œ†Œú',        'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'ŒßŒ∏ŒµœÇ œÉœÑŒπœÇ 2:00 Œ†Œú',       'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [' + (m.hours() % 12 === 1 ? 'œÉœÑŒ∑' : 'œÉœÑŒπœÇ') + '] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [œÉœÑŒπœÇ] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [œÉœÑŒπœÇ] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m, dayString;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            dayString = m.day() === 6 ? '[œÑŒø œÄœÅŒøŒ∑Œ≥ŒøœçŒºŒµŒΩŒø Œ£Œ¨Œ≤Œ≤Œ±œÑŒø]' : '[œÑŒ∑ŒΩ œÄœÅŒøŒ∑Œ≥ŒøœçŒºŒµŒΩŒ∑] dddd';
            assert.equal(m.calendar(),       m.format(dayString + ' [' + (m.hours() % 12 === 1 ? 'œÉœÑŒ∑' : 'œÉœÑŒπœÇ') + '] LT'),  'Today - ' + i + ' days current time');
            m.hours(1).minutes(30).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(dayString + ' [œÉœÑŒ∑] LT'),  'Today - ' + i + ' days one o clock');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(dayString + ' [œÉœÑŒπœÇ] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(dayString + ' [œÉœÑŒπœÇ] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 52, 'Dec 31 2006 should be week 52');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 30]).week(), 52, 'Dec 30 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 52, 'Dec 29 2002 should be week 52');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 52, 'Dec 28 2008 should be week 52');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 52, 'Dec 27 2009 should be week 52');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  2]).week(), 53, 'Jan  2 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  9]).week(), 1, 'Jan  9 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(), 1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(), 2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 51, 'Dec 26 2010 should be week 51');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  8]).week(), 1, 'Jan  8 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(), 1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(), 2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52Œ∑', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'),   '1 01 1Œ∑', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1Œ∑', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'),   '2 02 2Œ∑', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2Œ∑', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('en-au');

    test('parse', function (assert) {
        var tests = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Sunday, February 14th 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Sun, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2nd 02 February Feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14th 14'],
                ['d do dddd ddd dd',                   '0 0th Sunday Sun Su'],
                ['DDD DDDo DDDD',                      '45 45th 045'],
                ['w wo ww',                            '6 6th 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45th day of the year'],
                ['LTS',                                '3:25:50 PM'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 February 2010'],
                ['LLL',                                '14 February 2010 3:25 PM'],
                ['LLLL',                               'Sunday, 14 February 2010 3:25 PM'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Feb 2010'],
                ['lll',                                '14 Feb 2010 3:25 PM'],
                ['llll',                               'Sun, 14 Feb 2010 3:25 PM']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1st', '1st');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2nd', '2nd');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3rd', '3rd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4th', '4th');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5th', '5th');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6th', '6th');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7th', '7th');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8th', '8th');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9th', '9th');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10th', '10th');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11th', '11th');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12th', '12th');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13th', '13th');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14th', '14th');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15th', '15th');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16th', '16th');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17th', '17th');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18th', '18th');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19th', '19th');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20th', '20th');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21st', '21st');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22nd', '22nd');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23rd', '23rd');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24th', '24th');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25th', '25th');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26th', '26th');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27th', '27th');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28th', '28th');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29th', '29th');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30th', '30th');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31st', '31st');
    });

    test('format month', function (assert) {
        var expected = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Sunday Sun Su_Monday Mon Mo_Tuesday Tue Tu_Wednesday Wed We_Thursday Thu Th_Friday Fri Fr_Saturday Sat Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'a few seconds', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'a minute',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'a minute',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutes',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutes',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'an hour',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'an hour',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hours',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hours',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hours',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'a day',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'a day',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 days',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'a day',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 days',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 days',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'a month',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'a month',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'a month',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 months',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 months',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 months',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'a month',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 months',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'a year',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 years',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'a year',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 years',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'in a few seconds',  'prefix');
        assert.equal(moment(0).from(30000), 'a few seconds ago', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'a few seconds ago',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'in a few seconds', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'in 5 days', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Today at 2:00 AM',      'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Today at 2:25 AM',      'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Today at 3:00 AM',      'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Tomorrow at 2:00 AM',   'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Today at 1:00 AM',      'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Yesterday at 2:00 AM',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52nd', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1st', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1st', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2nd', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2nd', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testStr;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testStr = moment(ordinalStr, 'YYYY MM Do').format('YYYY MM D');
            assert.equal(testStr, '2014 01 ' + i, 'lenient ordinal parsing ' + i);
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testStr;
        for (i = 1; i <= 31; ++i) {
            testStr = moment('2014 01 ' + i, 'YYYY MM Do').format('YYYY MM D');
            assert.equal(testStr, '2014 01 ' + i,
                    'lenient ordinal parsing of number ' + i);
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MMM Do');
            testMoment = moment(ordinalStr, 'YYYY MMM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('en-ca');

    test('parse', function (assert) {
        var i,
            tests = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_');

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Sunday, February 14th 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Sun, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2nd 02 February Feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14th 14'],
                ['d do dddd ddd dd',                   '0 0th Sunday Sun Su'],
                ['DDD DDDo DDDD',                      '45 45th 045'],
                ['w wo ww',                            '8 8th 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45th day of the year'],
                ['L',                                  '2010-02-14'],
                ['LTS',                                '3:25:50 PM'],
                ['LL',                                 '14 February, 2010'],
                ['LLL',                                '14 February, 2010 3:25 PM'],
                ['LLLL',                               'Sunday, 14 February, 2010 3:25 PM'],
                ['l',                                  '2010-2-14'],
                ['ll',                                 '14 Feb, 2010'],
                ['lll',                                '14 Feb, 2010 3:25 PM'],
                ['llll',                               'Sun, 14 Feb, 2010 3:25 PM']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1st', '1st');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2nd', '2nd');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3rd', '3rd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4th', '4th');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5th', '5th');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6th', '6th');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7th', '7th');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8th', '8th');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9th', '9th');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10th', '10th');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11th', '11th');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12th', '12th');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13th', '13th');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14th', '14th');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15th', '15th');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16th', '16th');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17th', '17th');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18th', '18th');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19th', '19th');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20th', '20th');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21st', '21st');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22nd', '22nd');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23rd', '23rd');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24th', '24th');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25th', '25th');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26th', '26th');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27th', '27th');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28th', '28th');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29th', '29th');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30th', '30th');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31st', '31st');
    });

    test('format month', function (assert) {
        var i,
            expected = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var i,
            expected = 'Sunday Sun Su_Monday Mon Mo_Tuesday Tue Tu_Wednesday Wed We_Thursday Thu Th_Friday Fri Fr_Saturday Sat Sa'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'a few seconds', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'a minute',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'a minute',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutes',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutes',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'an hour',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'an hour',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hours',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hours',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hours',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'a day',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'a day',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 days',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'a day',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 days',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 days',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'a month',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'a month',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'a month',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 months',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 months',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 months',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'a month',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 months',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'a year',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 years',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'a year',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 years',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'in a few seconds',  'prefix');
        assert.equal(moment(0).from(30000), 'a few seconds ago', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'a few seconds ago',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'in a few seconds', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'in 5 days', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Today at 2:00 AM',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Today at 2:25 AM',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Today at 3:00 AM',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Tomorrow at 2:00 AM',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Today at 1:00 AM',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Yesterday at 2:00 AM', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1st', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1st', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2nd', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2nd', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3rd', 'Jan 15 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('en-gb');

    test('parse', function (assert) {
        var tests = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Sunday, February 14th 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Sun, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2nd 02 February Feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14th 14'],
                ['d do dddd ddd dd',                   '0 0th Sunday Sun Su'],
                ['DDD DDDo DDDD',                      '45 45th 045'],
                ['w wo ww',                            '6 6th 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45th day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 February 2010'],
                ['LLL',                                '14 February 2010 15:25'],
                ['LLLL',                               'Sunday, 14 February 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Feb 2010'],
                ['lll',                                '14 Feb 2010 15:25'],
                ['llll',                               'Sun, 14 Feb 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1st', '1st');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2nd', '2nd');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3rd', '3rd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4th', '4th');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5th', '5th');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6th', '6th');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7th', '7th');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8th', '8th');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9th', '9th');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10th', '10th');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11th', '11th');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12th', '12th');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13th', '13th');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14th', '14th');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15th', '15th');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16th', '16th');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17th', '17th');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18th', '18th');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19th', '19th');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20th', '20th');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21st', '21st');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22nd', '22nd');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23rd', '23rd');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24th', '24th');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25th', '25th');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26th', '26th');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27th', '27th');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28th', '28th');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29th', '29th');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30th', '30th');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31st', '31st');
    });

    test('format month', function (assert) {
        var expected = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Sunday Sun Su_Monday Mon Mo_Tuesday Tue Tu_Wednesday Wed We_Thursday Thu Th_Friday Fri Fr_Saturday Sat Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'a few seconds', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'a minute',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'a minute',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutes',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutes',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'an hour',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'an hour',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hours',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hours',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hours',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'a day',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'a day',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 days',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'a day',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 days',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 days',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'a month',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'a month',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'a month',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 months',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 months',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 months',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'a month',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 months',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'a year',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 years',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'a year',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 years',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'in a few seconds',  'prefix');
        assert.equal(moment(0).from(30000), 'a few seconds ago', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'a few seconds ago',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'in a few seconds', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'in 5 days', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Today at 02:00',      'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Today at 02:25',      'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Today at 03:00',      'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Tomorrow at 02:00',   'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Today at 01:00',      'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Yesterday at 02:00',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52nd', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1st', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1st', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2nd', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2nd', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('en');

    test('parse', function (assert) {
        var i,
            tests = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_');

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Sunday, February 14th 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Sun, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2nd 02 February Feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14th 14'],
                ['d do dddd ddd dd',                   '0 0th Sunday Sun Su'],
                ['DDD DDDo DDDD',                      '45 45th 045'],
                ['w wo ww',                            '8 8th 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45th day of the year'],
                ['LTS',                                '3:25:50 PM'],
                ['L',                                  '02/14/2010'],
                ['LL',                                 'February 14, 2010'],
                ['LLL',                                'February 14, 2010 3:25 PM'],
                ['LLLL',                               'Sunday, February 14, 2010 3:25 PM'],
                ['l',                                  '2/14/2010'],
                ['ll',                                 'Feb 14, 2010'],
                ['lll',                                'Feb 14, 2010 3:25 PM'],
                ['llll',                               'Sun, Feb 14, 2010 3:25 PM']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1st', '1st');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2nd', '2nd');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3rd', '3rd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4th', '4th');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5th', '5th');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6th', '6th');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7th', '7th');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8th', '8th');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9th', '9th');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10th', '10th');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11th', '11th');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12th', '12th');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13th', '13th');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14th', '14th');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15th', '15th');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16th', '16th');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17th', '17th');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18th', '18th');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19th', '19th');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20th', '20th');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21st', '21st');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22nd', '22nd');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23rd', '23rd');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24th', '24th');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25th', '25th');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26th', '26th');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27th', '27th');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28th', '28th');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29th', '29th');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30th', '30th');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31st', '31st');
    });

    test('format month', function (assert) {
        var i,
            expected = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var i,
            expected = 'Sunday Sun Su_Monday Mon Mo_Tuesday Tue Tu_Wednesday Wed We_Thursday Thu Th_Friday Fri Fr_Saturday Sat Sa'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'a few seconds', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'a minute',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'a minute',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutes',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutes',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'an hour',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'an hour',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hours',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hours',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hours',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'a day',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'a day',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 days',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'a day',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 days',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 days',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'a month',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'a month',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'a month',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 months',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 months',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 months',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'a month',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 months',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'a year',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 years',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'a year',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 years',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'in a few seconds',  'prefix');
        assert.equal(moment(0).from(30000), 'a few seconds ago', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'a few seconds ago',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'in a few seconds', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'in 5 days', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Today at 2:00 AM',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Today at 2:25 AM',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Today at 3:00 AM',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Tomorrow at 2:00 AM',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Today at 1:00 AM',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Yesterday at 2:00 AM', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1st', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1st', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2nd', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2nd', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3rd', 'Jan 15 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('eo');

    test('parse', function (assert) {
        var tests = 'januaro jan_februaro feb_marto mar_aprilo apr_majo maj_junio jun_julio jul_a≈≠gusto a≈≠g_septembro sep_oktobro okt_novembro nov_decembro dec'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Dimanƒâo, februaro 14a 2010, 3:25:50 p.t.m.'],
                ['ddd, hA',                            'Dim, 3P.T.M.'],
                ['M Mo MM MMMM MMM',                   '2 2a 02 februaro feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14a 14'],
                ['d do dddd ddd dd',                   '0 0a Dimanƒâo Dim Di'],
                ['DDD DDDo DDDD',                      '45 45a 045'],
                ['w wo ww',                            '7 7a 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'p.t.m. P.T.M.'],
                ['[la] DDDo [tago] [de] [la] [jaro]',  'la 45a tago de la jaro'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '2010-02-14'],
                ['LL',                                 '14-an de februaro, 2010'],
                ['LLL',                                '14-an de februaro, 2010 15:25'],
                ['LLLL',                               'Dimanƒâo, la 14-an de februaro, 2010 15:25'],
                ['l',                                  '2010-2-14'],
                ['ll',                                 '14-an de feb, 2010'],
                ['lll',                                '14-an de feb, 2010 15:25'],
                ['llll',                               'Dim, la 14-an de feb, 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1a', '1a');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2a', '2a');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3a', '3a');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4a', '4a');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5a', '5a');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6a', '6a');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7a', '7a');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8a', '8a');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9a', '9a');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10a', '10a');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11a', '11a');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12a', '12a');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13a', '13a');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14a', '14a');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15a', '15a');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16a', '16a');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17a', '17a');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18a', '18a');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19a', '19a');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20a', '20a');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21a', '21a');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22a', '22a');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23a', '23a');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24a', '24a');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25a', '25a');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26a', '26a');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27a', '27a');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28a', '28a');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29a', '29a');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30a', '30a');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31a', '31a');
    });

    test('format month', function (assert) {
        var expected = 'januaro jan_februaro feb_marto mar_aprilo apr_majo maj_junio jun_julio jul_a≈≠gusto a≈≠g_septembro sep_oktobro okt_novembro nov_decembro dec'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Dimanƒâo Dim Di_Lundo Lun Lu_Mardo Mard Ma_Merkredo Merk Me_ƒ¥a≈≠do ƒ¥a≈≠ ƒ¥a_Vendredo Ven Ve_Sabato Sab Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'sekundoj', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'minuto',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'minuto',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutoj',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutoj',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'horo',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'horo',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 horoj',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 horoj',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 horoj',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'tago',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'tago',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 tagoj',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'tago',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 tagoj',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 tagoj',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'monato',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'monato',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'monato',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 monatoj',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 monatoj',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 monatoj',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'monato',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 monatoj',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'jaro',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 jaroj',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'jaro',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 jaroj',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'je sekundoj',  'je prefix');
        assert.equal(moment(0).from(30000), 'anta≈≠ sekundoj', 'anta≈≠ prefix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'anta≈≠ sekundoj',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'je sekundoj', 'je sekundoj');
        assert.equal(moment().add({d: 5}).fromNow(), 'je 5 tagoj', 'je 5 tagoj');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Hodia≈≠ je 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Hodia≈≠ je 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Hodia≈≠ je 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Morga≈≠ je 02:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Hodia≈≠ je 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Hiera≈≠ je 02:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [je] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [je] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [je] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[pasinta] dddd [je] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[pasinta] dddd [je] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[pasinta] dddd [je] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1a', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1a', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2a', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2a', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3a', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('es');

    test('parse', function (assert) {
        var tests = 'enero ene._febrero feb._marzo mar._abril abr._mayo may._junio jun._julio jul._agosto ago._septiembre sep._octubre oct._noviembre nov._diciembre dic.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Domingo, Febrero 14¬∫ 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Dom., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2¬∫ 02 Febrero Feb.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14¬∫ 14'],
                ['d do dddd ddd dd',                   '0 0¬∫ Domingo Dom. Do'],
                ['DDD DDDo DDDD',                      '45 45¬∫ 045'],
                ['w wo ww',                            '6 6¬∫ 06'],
                ['YYYY-MMM-DD',                        '2010-Feb-14'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45¬∫ day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 de Febrero de 2010'],
                ['LLL',                                '14 de Febrero de 2010 15:25'],
                ['LLLL',                               'Domingo, 14 de Febrero de 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 de Feb. de 2010'],
                ['lll',                                '14 de Feb. de 2010 15:25'],
                ['llll',                               'Dom., 14 de Feb. de 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1¬∫', '1¬∫');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2¬∫', '2¬∫');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3¬∫', '3¬∫');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4¬∫', '4¬∫');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5¬∫', '5¬∫');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6¬∫', '6¬∫');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7¬∫', '7¬∫');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8¬∫', '8¬∫');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9¬∫', '9¬∫');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10¬∫', '10¬∫');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11¬∫', '11¬∫');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12¬∫', '12¬∫');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13¬∫', '13¬∫');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14¬∫', '14¬∫');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15¬∫', '15¬∫');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16¬∫', '16¬∫');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17¬∫', '17¬∫');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18¬∫', '18¬∫');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19¬∫', '19¬∫');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20¬∫', '20¬∫');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21¬∫', '21¬∫');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22¬∫', '22¬∫');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23¬∫', '23¬∫');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24¬∫', '24¬∫');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25¬∫', '25¬∫');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26¬∫', '26¬∫');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27¬∫', '27¬∫');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28¬∫', '28¬∫');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29¬∫', '29¬∫');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30¬∫', '30¬∫');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31¬∫', '31¬∫');
    });

    test('format month', function (assert) {
        var expected = 'Enero Ene._Febrero Feb._Marzo Mar._Abril Abr._Mayo May._Junio Jun._Julio Jul._Agosto Ago._Septiembre Sep._Octubre Oct._Noviembre Nov._Diciembre Dic.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Domingo Dom. Do_Lunes Lun. Lu_Martes Mar. Ma_Mi√©rcoles Mi√©. Mi_Jueves Jue. Ju_Viernes Vie. Vi_S√°bado S√°b. S√°'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'unos segundos', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'un minuto',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'un minuto',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutos',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutos',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'una hora',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'una hora',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 horas',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 horas',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 horas',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'un d√≠a',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'un d√≠a',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 d√≠as',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'un d√≠a',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 d√≠as',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 d√≠as',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'un mes',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'un mes',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'un mes',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 meses',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 meses',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 meses',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'un mes',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 meses',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'un a√±o',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 a√±os',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'un a√±o',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 a√±os',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'en unos segundos',  'prefix');
        assert.equal(moment(0).from(30000), 'hace unos segundos', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'hace unos segundos',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'en unos segundos', 'en unos segundos');
        assert.equal(moment().add({d: 5}).fromNow(), 'en 5 d√≠as', 'en 5 d√≠as');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                         'hoy a las 2:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),          'hoy a las 2:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),           'hoy a las 3:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),           'ma√±ana a las 2:00',  'tomorrow at the same time');
        assert.equal(moment(a).add({d: 1, h : -1}).calendar(),   'ma√±ana a la 1:00',   'tomorrow minus 1 hour');
        assert.equal(moment(a).subtract({h: 1}).calendar(),      'hoy a la 1:00',      'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),      'ayer a las 2:00',    'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [a la' + ((m.hours() !== 1) ? 's' : '') + '] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [a la' + ((m.hours() !== 1) ? 's' : '') + '] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [a la' + ((m.hours() !== 1) ? 's' : '') + '] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[el] dddd [pasado a la' + ((m.hours() !== 1) ? 's' : '') + '] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[el] dddd [pasado a la' + ((m.hours() !== 1) ? 's' : '') + '] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[el] dddd [pasado a la' + ((m.hours() !== 1) ? 's' : '') + '] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52¬∫', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1¬∫', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1¬∫', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2¬∫', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2¬∫', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('et');

    test('parse', function (assert) {
        var tests = 'jaanuar jaan_veebruar veebr_m√§rts m√§rts_aprill apr_mai mai_juuni juuni_juuli juuli_august aug_september sept_oktoober okt_november nov_detsember dets'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' peaks olema kuu ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, H:mm:ss',      'p√ºhap√§ev, 14. veebruar 2010, 15:25:50'],
                ['ddd, h',                           'P, 3'],
                ['M Mo MM MMMM MMM',                 '2 2. 02 veebruar veebr'],
                ['YYYY YY',                          '2010 10'],
                ['D Do DD',                          '14 14. 14'],
                ['d do dddd ddd dd',                 '0 0. p√ºhap√§ev P P'],
                ['DDD DDDo DDDD',                    '45 45. 045'],
                ['w wo ww',                          '6 6. 06'],
                ['h hh',                             '3 03'],
                ['H HH',                             '15 15'],
                ['m mm',                             '25 25'],
                ['s ss',                             '50 50'],
                ['a A',                              'pm PM'],
                ['[aasta] DDDo [p√§ev]',              'aasta 45. p√§ev'],
                ['LTS',                              '15:25:50'],
                ['L',                                '14.02.2010'],
                ['LL',                               '14. veebruar 2010'],
                ['LLL',                              '14. veebruar 2010 15:25'],
                ['LLLL',                             'p√ºhap√§ev, 14. veebruar 2010 15:25'],
                ['l',                                '14.2.2010'],
                ['ll',                               '14. veebr 2010'],
                ['lll',                              '14. veebr 2010 15:25'],
                ['llll',                             'P, 14. veebr 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'jaanuar jaan_veebruar veebr_m√§rts m√§rts_aprill apr_mai mai_juuni juuni_juuli juuli_august aug_september sept_oktoober okt_november nov_detsember dets'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'p√ºhap√§ev P P_esmasp√§ev E E_teisip√§ev T T_kolmap√§ev K K_neljap√§ev N N_reede R R_laup√§ev L L'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'paar sekundit',  '44 seconds = paar sekundit');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '√ºks minut',      '45 seconds = √ºks minut');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '√ºks minut',      '89 seconds = √ºks minut');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutit',      '90 seconds = 2 minutit');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutit',     '44 minutes = 44 minutit');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '√ºks tund',       '45 minutes = tund aega');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '√ºks tund',       '89 minutes = √ºks tund');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 tundi',        '90 minutes = 2 tundi');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 tundi',        '5 hours = 5 tundi');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 tundi',       '21 hours = 21 tundi');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '√ºks p√§ev',       '22 hours = √ºks p√§ev');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '√ºks p√§ev',       '35 hours = √ºks p√§ev');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 p√§eva',        '36 hours = 2 p√§eva');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '√ºks p√§ev',       '1 day = √ºks p√§ev');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 p√§eva',        '5 days = 5 p√§eva');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 p√§eva',       '25 days = 25 p√§eva');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '√ºks kuu',        '26 days = √ºks kuu');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '√ºks kuu',        '30 days = √ºks kuu');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '√ºks kuu',        '43 days = √ºks kuu');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 kuud',         '46 days = 2 kuud');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 kuud',         '75 days = 2 kuud');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 kuud',         '76 days = 3 kuud');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '√ºks kuu',        '1 month = √ºks kuu');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 kuud',         '5 months = 5 kuud');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '√ºks aasta',      '345 days = √ºks aasta');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 aastat',       '548 days = 2 aastat');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '√ºks aasta',      '1 year = √ºks aasta');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 aastat',       '5 years = 5 aastat');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'm√µne sekundi p√§rast',  'prefix');
        assert.equal(moment(0).from(30000), 'm√µni sekund tagasi', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'm√µni sekund tagasi',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'm√µne sekundi p√§rast', 'in a few seconds');
        assert.equal(moment().subtract({s: 30}).fromNow(), 'm√µni sekund tagasi', 'a few seconds ago');

        assert.equal(moment().add({m: 1}).fromNow(), '√ºhe minuti p√§rast', 'in a minute');
        assert.equal(moment().subtract({m: 1}).fromNow(), '√ºks minut tagasi', 'a minute ago');

        assert.equal(moment().add({m: 5}).fromNow(), '5 minuti p√§rast', 'in 5 minutes');
        assert.equal(moment().subtract({m: 5}).fromNow(), '5 minutit tagasi', '5 minutes ago');

        assert.equal(moment().add({d: 1}).fromNow(), '√ºhe p√§eva p√§rast', 'in one day');
        assert.equal(moment().subtract({d: 1}).fromNow(), '√ºks p√§ev tagasi', 'one day ago');

        assert.equal(moment().add({d: 5}).fromNow(), '5 p√§eva p√§rast', 'in 5 days');
        assert.equal(moment().subtract({d: 5}).fromNow(), '5 p√§eva tagasi', '5 days ago');

        assert.equal(moment().add({M: 1}).fromNow(), 'kuu aja p√§rast', 'in a month');
        assert.equal(moment().subtract({M: 1}).fromNow(), 'kuu aega tagasi', 'a month ago');

        assert.equal(moment().add({M: 5}).fromNow(), '5 kuu p√§rast', 'in 5 months');
        assert.equal(moment().subtract({M: 5}).fromNow(), '5 kuud tagasi', '5 months ago');

        assert.equal(moment().add({y: 1}).fromNow(), '√ºhe aasta p√§rast', 'in a year');
        assert.equal(moment().subtract({y: 1}).fromNow(), 'aasta tagasi', 'a year ago');

        assert.equal(moment().add({y: 5}).fromNow(), '5 aasta p√§rast', 'in 5 years');
        assert.equal(moment().subtract({y: 5}).fromNow(), '5 aastat tagasi', '5 years ago');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'T√§na, 2:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'T√§na, 2:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'T√§na, 3:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Homme, 2:00',    'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'T√§na, 1:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Eile, 2:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[J√§rgmine] dddd LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[J√§rgmine] dddd LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[J√§rgmine] dddd LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[Eelmine] dddd LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[Eelmine] dddd LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[Eelmine] dddd LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 n√§dal tagasi');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  '1 n√§dala p√§rast');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 n√§dalat tagasi');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  '2 n√§dala p√§rast');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('eu');

    test('parse', function (assert) {
        var tests = 'urtarrila urt._otsaila ots._martxoa mar._apirila api._maiatza mai._ekaina eka._uztaila uzt._abuztua abu._iraila ira._urria urr._azaroa aza._abendua abe.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'igandea, otsaila 14. 2010, 3:25:50 pm'],
                ['ddd, hA',                            'ig., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 otsaila ots.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. igandea ig. ig'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '7 7. 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '2010-02-14'],
                ['LL',                                 '2010ko otsailaren 14a'],
                ['LLL',                                '2010ko otsailaren 14a 15:25'],
                ['LLLL',                               'igandea, 2010ko otsailaren 14a 15:25'],
                ['l',                                  '2010-2-14'],
                ['ll',                                 '2010ko ots. 14a'],
                ['lll',                                '2010ko ots. 14a 15:25'],
                ['llll',                               'ig., 2010ko ots. 14a 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'urtarrila urt._otsaila ots._martxoa mar._apirila api._maiatza mai._ekaina eka._uztaila uzt._abuztua abu._iraila ira._urria urr._azaroa aza._abendua abe.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'igandea ig. ig_astelehena al. al_asteartea ar. ar_asteazkena az. az_osteguna og. og_ostirala ol. ol_larunbata lr. lr'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'segundo batzuk', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'minutu bat',     '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'minutu bat',     '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutu',       '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutu',      '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ordu bat',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ordu bat',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ordu',         '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ordu',         '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ordu',        '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'egun bat',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'egun bat',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 egun',         '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'egun bat',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 egun',         '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 egun',        '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'hilabete bat',   '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'hilabete bat',   '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'hilabete bat',   '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 hilabete',     '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 hilabete',     '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 hilabete',     '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'hilabete bat',   '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 hilabete',     '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'urte bat',       '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 urte',         '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'urte bat',       '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 urte',         '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'segundo batzuk barru',  'prefix');
        assert.equal(moment(0).from(30000), 'duela segundo batzuk', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'duela segundo batzuk',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'segundo batzuk barru', 'in seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5 egun barru', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'gaur 02:00etan',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'gaur 02:25etan',  'now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'gaur 03:00etan',  'now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'bihar 02:00etan', 'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'gaur 01:00etan',  'now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'atzo 02:00etan',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd LT[etan]'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd LT[etan]'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd LT[etan]'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[aurreko] dddd LT[etan]'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[aurreko] dddd LT[etan]'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[aurreko] dddd LT[etan]'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('fa');

    test('parse', function (assert) {
        var tests = '⁄òÿßŸÜŸà€åŸá_ŸÅŸàÿ±€åŸá_ŸÖÿßÿ±ÿ≥_ÿ¢Ÿàÿ±€åŸÑ_ŸÖŸá_⁄òŸàÿ¶ŸÜ_⁄òŸàÿ¶€åŸá_ÿßŸàÿ™_ÿ≥Ÿæÿ™ÿßŸÖÿ®ÿ±_ÿß⁄©ÿ™ÿ®ÿ±_ŸÜŸàÿßŸÖÿ®ÿ±_ÿØÿ≥ÿßŸÖÿ®ÿ±'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1) + ' instead is month ' + moment(input, mmm).month());
        }
        for (i = 0; i < 12; i++) {
            equalTest(tests[i], 'MMM', i);
            equalTest(tests[i], 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      '€å⁄©\u200cÿ¥ŸÜÿ®Ÿáÿå ŸÅŸàÿ±€åŸá €±€¥ŸÖ €≤€∞€±€∞ÿå €≥:€≤€µ:€µ€∞ ÿ®ÿπÿØ ÿßÿ≤ ÿ∏Ÿáÿ±'],
                ['ddd, hA',                            '€å⁄©\u200cÿ¥ŸÜÿ®Ÿáÿå €≥ÿ®ÿπÿØ ÿßÿ≤ ÿ∏Ÿáÿ±'],
                ['M Mo MM MMMM MMM',                   '€≤ €≤ŸÖ €∞€≤ ŸÅŸàÿ±€åŸá ŸÅŸàÿ±€åŸá'],
                ['YYYY YY',                            '€≤€∞€±€∞ €±€∞'],
                ['D Do DD',                            '€±€¥ €±€¥ŸÖ €±€¥'],
                ['d do dddd ddd dd',                   '€∞ €∞ŸÖ €å⁄©\u200cÿ¥ŸÜÿ®Ÿá €å⁄©\u200cÿ¥ŸÜÿ®Ÿá €å'],
                ['DDD DDDo DDDD',                      '€¥€µ €¥€µŸÖ €∞€¥€µ'],
                ['w wo ww',                            '€∏ €∏ŸÖ €∞€∏'],
                ['h hh',                               '€≥ €∞€≥'],
                ['H HH',                               '€±€µ €±€µ'],
                ['m mm',                               '€≤€µ €≤€µ'],
                ['s ss',                               '€µ€∞ €µ€∞'],
                ['a A',                                'ÿ®ÿπÿØ ÿßÿ≤ ÿ∏Ÿáÿ± ÿ®ÿπÿØ ÿßÿ≤ ÿ∏Ÿáÿ±'],
                ['DDDo [ÿ±Ÿàÿ≤ ÿ≥ÿßŸÑ]',             '€¥€µŸÖ ÿ±Ÿàÿ≤ ÿ≥ÿßŸÑ'],
                ['LTS',                                '€±€µ:€≤€µ:€µ€∞'],
                ['L',                                  '€±€¥/€∞€≤/€≤€∞€±€∞'],
                ['LL',                                 '€±€¥ ŸÅŸàÿ±€åŸá €≤€∞€±€∞'],
                ['LLL',                                '€±€¥ ŸÅŸàÿ±€åŸá €≤€∞€±€∞ €±€µ:€≤€µ'],
                ['LLLL',                               '€å⁄©\u200cÿ¥ŸÜÿ®Ÿáÿå €±€¥ ŸÅŸàÿ±€åŸá €≤€∞€±€∞ €±€µ:€≤€µ'],
                ['l',                                  '€±€¥/€≤/€≤€∞€±€∞'],
                ['ll',                                 '€±€¥ ŸÅŸàÿ±€åŸá €≤€∞€±€∞'],
                ['lll',                                '€±€¥ ŸÅŸàÿ±€åŸá €≤€∞€±€∞ €±€µ:€≤€µ'],
                ['llll',                               '€å⁄©\u200cÿ¥ŸÜÿ®Ÿáÿå €±€¥ ŸÅŸàÿ±€åŸá €≤€∞€±€∞ €±€µ:€≤€µ']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '€±ŸÖ', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '€≤ŸÖ', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '€≥ŸÖ', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '€¥ŸÖ', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '€µŸÖ', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '€∂ŸÖ', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '€∑ŸÖ', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '€∏ŸÖ', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '€πŸÖ', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '€±€∞ŸÖ', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '€±€±ŸÖ', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '€±€≤ŸÖ', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '€±€≥ŸÖ', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '€±€¥ŸÖ', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '€±€µŸÖ', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '€±€∂ŸÖ', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '€±€∑ŸÖ', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '€±€∏ŸÖ', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '€±€πŸÖ', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '€≤€∞ŸÖ', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '€≤€±ŸÖ', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '€≤€≤ŸÖ', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '€≤€≥ŸÖ', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '€≤€¥ŸÖ', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '€≤€µŸÖ', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '€≤€∂ŸÖ', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '€≤€∑ŸÖ', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '€≤€∏ŸÖ', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '€≤€πŸÖ', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '€≥€∞ŸÖ', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '€≥€±ŸÖ', '31');
    });

    test('format month', function (assert) {
        var expected = '⁄òÿßŸÜŸà€åŸá ⁄òÿßŸÜŸà€åŸá_ŸÅŸàÿ±€åŸá ŸÅŸàÿ±€åŸá_ŸÖÿßÿ±ÿ≥ ŸÖÿßÿ±ÿ≥_ÿ¢Ÿàÿ±€åŸÑ ÿ¢Ÿàÿ±€åŸÑ_ŸÖŸá ŸÖŸá_⁄òŸàÿ¶ŸÜ ⁄òŸàÿ¶ŸÜ_⁄òŸàÿ¶€åŸá ⁄òŸàÿ¶€åŸá_ÿßŸàÿ™ ÿßŸàÿ™_ÿ≥Ÿæÿ™ÿßŸÖÿ®ÿ± ÿ≥Ÿæÿ™ÿßŸÖÿ®ÿ±_ÿß⁄©ÿ™ÿ®ÿ± ÿß⁄©ÿ™ÿ®ÿ±_ŸÜŸàÿßŸÖÿ®ÿ± ŸÜŸàÿßŸÖÿ®ÿ±_ÿØÿ≥ÿßŸÖÿ®ÿ± ÿØÿ≥ÿßŸÖÿ®ÿ±'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '€å⁄©\u200cÿ¥ŸÜÿ®Ÿá €å⁄©\u200cÿ¥ŸÜÿ®Ÿá €å_ÿØŸàÿ¥ŸÜÿ®Ÿá ÿØŸàÿ¥ŸÜÿ®Ÿá ÿØ_ÿ≥Ÿá\u200cÿ¥ŸÜÿ®Ÿá ÿ≥Ÿá\u200cÿ¥ŸÜÿ®Ÿá ÿ≥_⁄ÜŸáÿßÿ±ÿ¥ŸÜÿ®Ÿá ⁄ÜŸáÿßÿ±ÿ¥ŸÜÿ®Ÿá ⁄Ü_ŸæŸÜÿ¨\u200cÿ¥ŸÜÿ®Ÿá ŸæŸÜÿ¨\u200cÿ¥ŸÜÿ®Ÿá Ÿæ_ÿ¨ŸÖÿπŸá ÿ¨ŸÖÿπŸá ÿ¨_ÿ¥ŸÜÿ®Ÿá ÿ¥ŸÜÿ®Ÿá ÿ¥'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '⁄ÜŸÜÿØ€åŸÜ ÿ´ÿßŸÜ€åŸá', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '€å⁄© ÿØŸÇ€åŸÇŸá',       '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '€å⁄© ÿØŸÇ€åŸÇŸá',       '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '€≤ ÿØŸÇ€åŸÇŸá',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '€¥€¥ ÿØŸÇ€åŸÇŸá',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '€å⁄© ÿ≥ÿßÿπÿ™',     '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '€å⁄© ÿ≥ÿßÿπÿ™',     '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '€≤ ÿ≥ÿßÿπÿ™',      '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '€µ ÿ≥ÿßÿπÿ™',      '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '€≤€± ÿ≥ÿßÿπÿ™',     '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '€å⁄© ÿ±Ÿàÿ≤',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '€å⁄© ÿ±Ÿàÿ≤',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '€≤ ÿ±Ÿàÿ≤',       '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '€å⁄© ÿ±Ÿàÿ≤',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '€µ ÿ±Ÿàÿ≤',       '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '€≤€µ ÿ±Ÿàÿ≤',      '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '€å⁄© ŸÖÿßŸá',      '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '€å⁄© ŸÖÿßŸá',      '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '€å⁄© ŸÖÿßŸá',      '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '€≤ ŸÖÿßŸá',       '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '€≤ ŸÖÿßŸá',       '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '€≥ ŸÖÿßŸá',       '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '€å⁄© ŸÖÿßŸá',      '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '€µ ŸÖÿßŸá',       '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '€å⁄© ÿ≥ÿßŸÑ',      '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '€≤ ÿ≥ÿßŸÑ',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '€å⁄© ÿ≥ÿßŸÑ',      '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '€µ ÿ≥ÿßŸÑ',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'ÿØÿ± ⁄ÜŸÜÿØ€åŸÜ ÿ´ÿßŸÜ€åŸá', 'prefix');
        assert.equal(moment(0).from(30000), '⁄ÜŸÜÿØ€åŸÜ ÿ´ÿßŸÜ€åŸá Ÿæ€åÿ¥', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '⁄ÜŸÜÿØ€åŸÜ ÿ´ÿßŸÜ€åŸá Ÿæ€åÿ¥',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'ÿØÿ± ⁄ÜŸÜÿØ€åŸÜ ÿ´ÿßŸÜ€åŸá', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'ÿØÿ± €µ ÿ±Ÿàÿ≤', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'ÿßŸÖÿ±Ÿàÿ≤ ÿ≥ÿßÿπÿ™ €∞€≤:€∞€∞', 'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'ÿßŸÖÿ±Ÿàÿ≤ ÿ≥ÿßÿπÿ™ €∞€≤:€≤€µ', 'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'ÿßŸÖÿ±Ÿàÿ≤ ÿ≥ÿßÿπÿ™ €∞€≥:€∞€∞', 'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'ŸÅÿ±ÿØÿß ÿ≥ÿßÿπÿ™ €∞€≤:€∞€∞', 'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'ÿßŸÖÿ±Ÿàÿ≤ ÿ≥ÿßÿπÿ™ €∞€±:€∞€∞', 'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'ÿØ€åÿ±Ÿàÿ≤ ÿ≥ÿßÿπÿ™ €∞€≤:€∞€∞', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [ÿ≥ÿßÿπÿ™] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [ÿ≥ÿßÿπÿ™] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [ÿ≥ÿßÿπÿ™] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [Ÿæ€åÿ¥ ÿ≥ÿßÿπÿ™] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [Ÿæ€åÿ¥ ÿ≥ÿßÿπÿ™] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [Ÿæ€åÿ¥ ÿ≥ÿßÿπÿ™] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 31]).week(), 1, 'Dec 31 2011 should be week 1');
        assert.equal(moment([2012,  0,  6]).week(), 1, 'Jan  6 2012 should be week 1');
        assert.equal(moment([2012,  0,  7]).week(), 2, 'Jan  7 2012 should be week 2');
        assert.equal(moment([2012,  0, 13]).week(), 2, 'Jan 13 2012 should be week 2');
        assert.equal(moment([2012,  0, 14]).week(), 3, 'Jan 14 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 30]).week(), 1, 'Dec 30 2006 should be week 1');
        assert.equal(moment([2007,  0,  5]).week(), 1, 'Jan  5 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 2, 'Jan  6 2007 should be week 2');
        assert.equal(moment([2007,  0, 12]).week(), 2, 'Jan 12 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 3, 'Jan 13 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 1, 'Dec 29 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  4]).week(), 1, 'Jan  4 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 2, 'Jan  5 2008 should be week 2');
        assert.equal(moment([2008,  0, 11]).week(), 2, 'Jan 11 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 3, 'Jan 12 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 28]).week(), 1, 'Dec 28 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  3]).week(), 1, 'Jan  3 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 2, 'Jan  4 2003 should be week 2');
        assert.equal(moment([2003,  0, 10]).week(), 2, 'Jan 10 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 3, 'Jan 11 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 27]).week(), 1, 'Dec 27 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  2]).week(), 1, 'Jan  2 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 2, 'Jan  3 2009 should be week 2');
        assert.equal(moment([2009,  0,  9]).week(), 2, 'Jan  9 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 3, 'Jan 10 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 26]).week(), 1, 'Dec 26 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 2, 'Jan  2 2010 should be week 2');
        assert.equal(moment([2010,  0,  8]).week(), 2, 'Jan  8 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 3, 'Jan  9 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2011, 0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011, 0,  7]).week(), 1, 'Jan  7 2011 should be week 1');
        assert.equal(moment([2011, 0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011, 0, 14]).week(), 2, 'Jan 14 2011 should be week 2');
        assert.equal(moment([2011, 0, 15]).week(), 3, 'Jan 15 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 31]).format('w ww wo'), '€± €∞€± €±ŸÖ', 'Dec 31 2011 should be week 1');
        assert.equal(moment([2012,  0,  6]).format('w ww wo'), '€± €∞€± €±ŸÖ', 'Jan  6 2012 should be week 1');
        assert.equal(moment([2012,  0,  7]).format('w ww wo'), '€≤ €∞€≤ €≤ŸÖ', 'Jan  7 2012 should be week 2');
        assert.equal(moment([2012,  0, 13]).format('w ww wo'), '€≤ €∞€≤ €≤ŸÖ', 'Jan 13 2012 should be week 2');
        assert.equal(moment([2012,  0, 14]).format('w ww wo'), '€≥ €∞€≥ €≥ŸÖ', 'Jan 14 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('fi');

    test('parse', function (assert) {
        var tests = 'tammikuu tammi_helmikuu helmi_maaliskuu maalis_huhtikuu huhti_toukokuu touko_kes√§kuu kes√§_hein√§kuu hein√§_elokuu elo_syyskuu syys_lokakuu loka_marraskuu marras_joulukuu joulu'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'sunnuntai, helmikuu 14. 2010, 3:25:50 pm'],
                ['ddd, hA',                            'su, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 helmikuu helmi'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. sunnuntai su su'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[vuoden] DDDo [p√§iv√§]',              'vuoden 45. p√§iv√§'],
                ['LTS',                                '15.25.50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14. helmikuuta 2010'],
                ['LLL',                                '14. helmikuuta 2010, klo 15.25'],
                ['LLLL',                               'sunnuntai, 14. helmikuuta 2010, klo 15.25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14. helmi 2010'],
                ['lll',                                '14. helmi 2010, klo 15.25'],
                ['llll',                               'su, 14. helmi 2010, klo 15.25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1st');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2nd');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3rd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4th');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5th');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6th');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7th');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8th');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9th');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10th');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11th');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12th');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13th');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14th');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15th');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16th');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17th');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18th');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19th');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20th');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21st');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22nd');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23rd');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24th');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25th');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26th');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27th');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28th');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29th');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30th');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31st');
    });

    test('format month', function (assert) {
        var expected = 'tammikuu tammi_helmikuu helmi_maaliskuu maalis_huhtikuu huhti_toukokuu touko_kes√§kuu kes√§_hein√§kuu hein√§_elokuu elo_syyskuu syys_lokakuu loka_marraskuu marras_joulukuu joulu'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'sunnuntai su su_maanantai ma ma_tiistai ti ti_keskiviikko ke ke_torstai to to_perjantai pe pe_lauantai la la'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'muutama sekunti', '44 seconds = few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'minuutti',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'minuutti',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  'kaksi minuuttia',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuuttia',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'tunti',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'tunti',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  'kaksi tuntia',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   'viisi tuntia',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 tuntia',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'p√§iv√§',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'p√§iv√§',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  'kaksi p√§iv√§√§',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'p√§iv√§',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   'viisi p√§iv√§√§',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 p√§iv√§√§',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'kuukausi',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'kuukausi',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'kuukausi',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  'kaksi kuukautta',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  'kaksi kuukautta',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  'kolme kuukautta',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'kuukausi',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   'viisi kuukautta',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'vuosi',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), 'kaksi vuotta',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'vuosi',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   'viisi vuotta',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'muutaman sekunnin p√§√§st√§',  'prefix');
        assert.equal(moment(0).from(30000), 'muutama sekunti sitten', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'muutama sekunti sitten',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'muutaman sekunnin p√§√§st√§', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'viiden p√§iv√§n p√§√§st√§', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     't√§n√§√§n klo 02.00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      't√§n√§√§n klo 02.25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       't√§n√§√§n klo 03.00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'huomenna klo 02.00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  't√§n√§√§n klo 01.00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'eilen klo 02.00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [klo] LT'),  'today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [klo] LT'),  'today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [klo] LT'),  'today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[viime] dddd[na] [klo] LT'),  'today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[viime] dddd[na] [klo] LT'),  'today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[viime] dddd[na] [klo] LT'),  'today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  'yksi viikko sitten');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'yhden viikon p√§√§st√§');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  'kaksi viikkoa sitten');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'kaden viikon p√§√§st√§');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('fo');

    test('parse', function (assert) {
        var tests = 'januar jan_februar feb_mars mar_apr√≠l apr_mai mai_juni jun_juli jul_august aug_september sep_oktober okt_november nov_desember des'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd [tann] Do MMMM YYYY, h:mm:ss a', 'sunnudagur tann 14. februar 2010, 3:25:50 pm'],
                ['ddd hA',                             'sun 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. sunnudagur sun su'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[tann] DDDo [dagin √° √°rinum]',       'tann 45. dagin √° √°rinum'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 februar 2010'],
                ['LLL',                                '14 februar 2010 15:25'],
                ['LLLL',                               'sunnudagur 14. februar, 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 feb 2010'],
                ['lll',                                '14 feb 2010 15:25'],
                ['llll',                               'sun 14. feb, 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'januar jan_februar feb_mars mar_apr√≠l apr_mai mai_juni jun_juli jul_august aug_september sep_oktober okt_november nov_desember des'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'sunnudagur sun su_m√°nadagur m√°n m√°_t√Ωsdagur t√Ωs t√Ω_mikudagur mik mi_h√≥sdagur h√≥s h√≥_fr√≠ggjadagur fr√≠ fr_leygardagur ley le'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'f√° sekund', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ein minutt',    '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ein minutt',    '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuttir',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuttir', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ein t√≠mi',     '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ein t√≠mi',     '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 t√≠mar',     '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 t√≠mar',     '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 t√≠mar',    '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ein dagur',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ein dagur',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dagar',      '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ein dagur',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dagar',      '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dagar',     '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ein m√°na√∞i',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ein m√°na√∞i',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ein m√°na√∞i',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 m√°na√∞ir',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 m√°na√∞ir',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 m√°na√∞ir',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ein m√°na√∞i',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 m√°na√∞ir',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'eitt √°r',       '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 √°r',        '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'eitt √°r',       '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 √°r',        '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'um f√° sekund',  'prefix');
        assert.equal(moment(0).from(30000), 'f√° sekund s√≠√∞ani', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'f√° sekund s√≠√∞ani',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'um f√° sekund', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'um 5 dagar', 'in 5 days');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('fr-ca');

    test('parse', function (assert) {
        var i,
            tests = 'janvier janv._f√©vrier f√©vr._mars mars_avril avr._mai mai_juin juin_juillet juil._ao√ªt ao√ªt_septembre sept._octobre oct._novembre nov._d√©cembre d√©c.'.split('_');

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'dimanche, f√©vrier 14 2010, 3:25:50 pm'],
                ['ddd, hA',                            'dim., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2 02 f√©vrier f√©vr.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 dimanche dim. Di'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '8 8 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '2010-02-14'],
                ['LL',                                 '14 f√©vrier 2010'],
                ['LLL',                                '14 f√©vrier 2010 15:25'],
                ['LLLL',                               'dimanche 14 f√©vrier 2010 15:25'],
                ['l',                                  '2010-2-14'],
                ['ll',                                 '14 f√©vr. 2010'],
                ['lll',                                '14 f√©vr. 2010 15:25'],
                ['llll',                               'dim. 14 f√©vr. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1er', '1er');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var i,
            expected = 'janvier janv._f√©vrier f√©vr._mars mars_avril avr._mai mai_juin juin_juillet juil._ao√ªt ao√ªt_septembre sept._octobre oct._novembre nov._d√©cembre d√©c.'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var i,
            expected = 'dimanche dim. Di_lundi lun. Lu_mardi mar. Ma_mercredi mer. Me_jeudi jeu. Je_vendredi ven. Ve_samedi sam. Sa'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'quelques secondes', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'une minute',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'une minute',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutes',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutes', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'une heure',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'une heure',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 heures',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 heures',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 heures',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'un jour',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'un jour',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 jours',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'un jour',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 jours',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 jours',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'un mois',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'un mois',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'un mois',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mois',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mois',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mois',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'un mois',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mois',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'un an',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ans',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'un an',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ans',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'dans quelques secondes', 'prefix');
        assert.equal(moment(0).from(30000), 'il y a quelques secondes', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'dans quelques secondes', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'dans 5 jours', 'in 5 days');
    });

    test('same day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Aujourd\'hui √† 02:00',    'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Aujourd\'hui √† 02:25',    'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Aujourd\'hui √† 03:00',    'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Demain √† 02:00',         'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Aujourd\'hui √† 01:00',    'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Hier √† 02:00',           'yesterday at the same time');
    });

    test('same next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [√†] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [√†] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [√†] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('same last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [dernier √†] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [dernier √†] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [dernier √†] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('same all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1er', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1er', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3', 'Jan 15 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('fr');

    test('parse', function (assert) {
        var tests = 'janvier janv._f√©vrier f√©vr._mars mars_avril avr._mai mai_juin juin_juillet juil._ao√ªt ao√ªt_septembre sept._octobre oct._novembre nov._d√©cembre d√©c.'.split('_'),
            i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'dimanche, f√©vrier 14 2010, 3:25:50 pm'],
                ['ddd, hA',                            'dim., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2 02 f√©vrier f√©vr.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 dimanche dim. Di'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '6 6 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 f√©vrier 2010'],
                ['LLL',                                '14 f√©vrier 2010 15:25'],
                ['LLLL',                               'dimanche 14 f√©vrier 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 f√©vr. 2010'],
                ['lll',                                '14 f√©vr. 2010 15:25'],
                ['llll',                               'dim. 14 f√©vr. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1er', '1er');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = 'janvier janv._f√©vrier f√©vr._mars mars_avril avr._mai mai_juin juin_juillet juil._ao√ªt ao√ªt_septembre sept._octobre oct._novembre nov._d√©cembre d√©c.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'dimanche dim. Di_lundi lun. Lu_mardi mar. Ma_mercredi mer. Me_jeudi jeu. Je_vendredi ven. Ve_samedi sam. Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'quelques secondes', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'une minute',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'une minute',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutes',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutes', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'une heure',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'une heure',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 heures',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 heures',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 heures',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'un jour',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'un jour',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 jours',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'un jour',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 jours',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 jours',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'un mois',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'un mois',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'un mois',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mois',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mois',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mois',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'un mois',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mois',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'un an',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ans',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'un an',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ans',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'dans quelques secondes', 'prefix');
        assert.equal(moment(0).from(30000), 'il y a quelques secondes', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'dans quelques secondes', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'dans 5 jours', 'in 5 days');
    });

    test('same day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Aujourd\'hui √† 02:00',    'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Aujourd\'hui √† 02:25',    'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Aujourd\'hui √† 03:00',    'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Demain √† 02:00',         'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Aujourd\'hui √† 01:00',    'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Hier √† 02:00',           'yesterday at the same time');
    });

    test('same next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [√†] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [√†] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [√†] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('same last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [dernier √†] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [dernier √†] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [dernier √†] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('same all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'), '1 01 1er', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '1 01 1er', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('fy');

    test('parse', function (assert) {
        var tests = 'jannewaris jan._febrewaris feb._maart mrt._april apr._maaie mai._juny jun._july jul._augustus aug._septimber sep._oktober okt._novimber nov._desimber des.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, HH:mm:ss',       'snein, febrewaris 14de 2010, 15:25:50'],
                ['ddd, HH',                            'si., 15'],
                ['M Mo MM MMMM MMM',                   '2 2de 02 febrewaris feb.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14de 14'],
                ['d do dddd ddd dd',                   '0 0de snein si. Si'],
                ['DDD DDDo DDDD',                      '45 45ste 045'],
                ['w wo ww',                            '6 6de 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45ste day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14-02-2010'],
                ['LL',                                 '14 febrewaris 2010'],
                ['LLL',                                '14 febrewaris 2010 15:25'],
                ['LLLL',                               'snein 14 febrewaris 2010 15:25'],
                ['l',                                  '14-2-2010'],
                ['ll',                                 '14 feb. 2010'],
                ['lll',                                '14 feb. 2010 15:25'],
                ['llll',                               'si. 14 feb. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1ste', '1ste');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2de', '2de');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3de', '3de');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4de', '4de');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5de', '5de');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6de', '6de');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7de', '7de');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8ste', '8ste');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9de', '9de');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10de', '10de');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11de', '11de');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12de', '12de');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13de', '13de');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14de', '14de');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15de', '15de');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16de', '16de');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17de', '17de');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18de', '18de');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19de', '19de');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20ste', '20ste');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21ste', '21ste');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22ste', '22ste');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23ste', '23ste');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24ste', '24ste');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25ste', '25ste');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26ste', '26ste');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27ste', '27ste');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28ste', '28ste');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29ste', '29ste');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30ste', '30ste');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31ste', '31ste');
    });

    test('format month', function (assert) {
        var expected = 'jannewaris jan._febrewaris feb._maart mrt._april apr._maaie mai_juny jun._july jul._augustus aug._septimber sep._oktober okt._novimber nov._desimber des.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'snein si. Si_moandei mo. Mo_tiisdei ti. Ti_woansdei wo. Wo_tongersdei to. To_freed fr. Fr_sneon so. So'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'in pear sekonden', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ien min√∫t',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ien min√∫t',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuten',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuten',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ien oere',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ien oere',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 oeren',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 oeren',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 oeren',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ien dei',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ien dei',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dagen',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ien dei',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dagen',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dagen',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ien moanne',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ien moanne',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ien moanne',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 moannen',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 moannen',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 moannen',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ien moanne',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 moannen',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ien jier',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 jierren',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'ien jier',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 jierren',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'oer in pear sekonden',  'prefix');
        assert.equal(moment(0).from(30000), 'in pear sekonden lyn', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'in pear sekonden lyn',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'oer in pear sekonden', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'oer 5 dagen', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'hjoed om 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'hjoed om 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'hjoed om 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'moarn om 02:00',    'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'hjoed om 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'juster om 02:00',   'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[√¥fr√ªne] dddd [om] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[√¥fr√ªne] dddd [om] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[√¥fr√ªne] dddd [om] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('month abbreviation', function (assert) {
        assert.equal(moment([2012, 5, 23]).format('D-MMM-YYYY'), '23-jun-2012', 'format month abbreviation surrounded by dashes should not include a dot');
        assert.equal(moment([2012, 5, 23]).format('D MMM YYYY'), '23 jun. 2012', 'format month abbreviation not surrounded by dashes should include a dot');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52ste', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1ste', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1ste', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),    '2 02 2de', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),    '2 02 2de', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('gl');

    test('parse', function (assert) {
        var tests = 'Xaneiro Xan._Febreiro Feb._Marzo Mar._Abril Abr._Maio Mai._Xu√±o Xu√±._Xullo Xul._Agosto Ago._Setembro Set._Outubro Out._Novembro Nov._Decembro Dec.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Domingo, Febreiro 14¬∫ 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Dom., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2¬∫ 02 Febreiro Feb.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14¬∫ 14'],
                ['d do dddd ddd dd',                   '0 0¬∫ Domingo Dom. Do'],
                ['DDD DDDo DDDD',                      '45 45¬∫ 045'],
                ['w wo ww',                            '7 7¬∫ 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45¬∫ day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 Febreiro 2010'],
                ['LLL',                                '14 Febreiro 2010 15:25'],
                ['LLLL',                               'Domingo 14 Febreiro 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Feb. 2010'],
                ['lll',                                '14 Feb. 2010 15:25'],
                ['llll',                               'Dom. 14 Feb. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1¬∫', '1¬∫');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2¬∫', '2¬∫');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3¬∫', '3¬∫');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4¬∫', '4¬∫');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5¬∫', '5¬∫');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6¬∫', '6¬∫');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7¬∫', '7¬∫');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8¬∫', '8¬∫');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9¬∫', '9¬∫');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10¬∫', '10¬∫');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11¬∫', '11¬∫');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12¬∫', '12¬∫');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13¬∫', '13¬∫');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14¬∫', '14¬∫');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15¬∫', '15¬∫');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16¬∫', '16¬∫');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17¬∫', '17¬∫');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18¬∫', '18¬∫');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19¬∫', '19¬∫');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20¬∫', '20¬∫');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21¬∫', '21¬∫');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22¬∫', '22¬∫');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23¬∫', '23¬∫');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24¬∫', '24¬∫');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25¬∫', '25¬∫');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26¬∫', '26¬∫');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27¬∫', '27¬∫');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28¬∫', '28¬∫');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29¬∫', '29¬∫');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30¬∫', '30¬∫');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31¬∫', '31¬∫');
    });

    test('format month', function (assert) {
        var expected = 'Xaneiro Xan._Febreiro Feb._Marzo Mar._Abril Abr._Maio Mai._Xu√±o Xu√±._Xullo Xul._Agosto Ago._Setembro Set._Outubro Out._Novembro Nov._Decembro Dec.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Domingo Dom. Do_Luns Lun. Lu_Martes Mar. Ma_M√©rcores M√©r. M√©_Xoves Xov. Xo_Venres Ven. Ve_S√°bado S√°b. S√°'.split('_'),
        i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'uns segundos', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'un minuto',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'un minuto',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutos',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutos',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'unha hora',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'unha hora',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 horas',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 horas',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 horas',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'un d√≠a',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'un d√≠a',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 d√≠as',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'un d√≠a',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 d√≠as',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 d√≠as',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'un mes',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'un mes',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'un mes',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 meses',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 meses',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 meses',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'un mes',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 meses',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'un ano',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 anos',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'un ano',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 anos',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'nuns segundos',  'prefix');
        assert.equal(moment(0).from(30000), 'hai uns segundos', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'hai uns segundos',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'nuns segundos', 'en unos segundos');
        assert.equal(moment().add({d: 5}).fromNow(), 'en 5 d√≠as', 'en 5 d√≠as');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                         'hoxe √°s 2:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),          'hoxe √°s 2:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),           'hoxe √°s 3:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),           'ma√±√° √°s 2:00',  'tomorrow at the same time');
        assert.equal(moment(a).add({d: 1, h : -1}).calendar(),   'ma√±√° √° 1:00',   'tomorrow minus 1 hour');
        assert.equal(moment(a).subtract({h: 1}).calendar(),      'hoxe √° 1:00',      'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),      'onte √° 2:00',    'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [' + ((m.hours() !== 1) ? '√°s' : 'a') + '] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [' + ((m.hours() !== 1) ? '√°s' : 'a') + '] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [' + ((m.hours() !== 1) ? '√°s' : 'a') + '] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[o] dddd [pasado ' + ((m.hours() !== 1) ? '√°s' : 'a') + '] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[o] dddd [pasado ' + ((m.hours() !== 1) ? '√°s' : 'a') + '] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[o] dddd [pasado ' + ((m.hours() !== 1) ? '√°s' : 'a') + '] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('regression tests', function (assert) {
        var lastWeek = moment().subtract({d: 4}).hours(1);
        assert.equal(lastWeek.calendar(), lastWeek.format('[o] dddd [pasado a] LT'), '1 o\'clock bug');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1¬∫', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1¬∫', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2¬∫', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2¬∫', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3¬∫', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('he');

    test('parse', function (assert) {
        var tests = '◊ô◊†◊ï◊ê◊® ◊ô◊†◊ï◊≥_◊§◊ë◊®◊ï◊ê◊® ◊§◊ë◊®◊≥_◊û◊®◊• ◊û◊®◊•_◊ê◊§◊®◊ô◊ú ◊ê◊§◊®◊≥_◊û◊ê◊ô ◊û◊ê◊ô_◊ô◊ï◊†◊ô ◊ô◊ï◊†◊ô_◊ô◊ï◊ú◊ô ◊ô◊ï◊ú◊ô_◊ê◊ï◊í◊ï◊°◊ò ◊ê◊ï◊í◊≥_◊°◊§◊ò◊û◊ë◊® ◊°◊§◊ò◊≥_◊ê◊ï◊ß◊ò◊ï◊ë◊® ◊ê◊ï◊ß◊≥_◊†◊ï◊ë◊û◊ë◊® ◊†◊ï◊ë◊≥_◊ì◊¶◊û◊ë◊® ◊ì◊¶◊û◊≥'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      '◊®◊ê◊©◊ï◊ü, ◊§◊ë◊®◊ï◊ê◊® 14 2010, 3:25:50 pm'],
                ['ddd, hA',                            '◊ê◊≥, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2 02 ◊§◊ë◊®◊ï◊ê◊® ◊§◊ë◊®◊≥'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 ◊®◊ê◊©◊ï◊ü ◊ê◊≥ ◊ê'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '8 8 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 ◊ë◊§◊ë◊®◊ï◊ê◊® 2010'],
                ['LLL',                                '14 ◊ë◊§◊ë◊®◊ï◊ê◊® 2010 15:25'],
                ['LLLL',                               '◊®◊ê◊©◊ï◊ü, 14 ◊ë◊§◊ë◊®◊ï◊ê◊® 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 ◊§◊ë◊®◊≥ 2010'],
                ['lll',                                '14 ◊§◊ë◊®◊≥ 2010 15:25'],
                ['llll',                               '◊ê◊≥, 14 ◊§◊ë◊®◊≥ 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format month', function (assert) {
        var expected = '◊ô◊†◊ï◊ê◊® ◊ô◊†◊ï◊≥_◊§◊ë◊®◊ï◊ê◊® ◊§◊ë◊®◊≥_◊û◊®◊• ◊û◊®◊•_◊ê◊§◊®◊ô◊ú ◊ê◊§◊®◊≥_◊û◊ê◊ô ◊û◊ê◊ô_◊ô◊ï◊†◊ô ◊ô◊ï◊†◊ô_◊ô◊ï◊ú◊ô ◊ô◊ï◊ú◊ô_◊ê◊ï◊í◊ï◊°◊ò ◊ê◊ï◊í◊≥_◊°◊§◊ò◊û◊ë◊® ◊°◊§◊ò◊≥_◊ê◊ï◊ß◊ò◊ï◊ë◊® ◊ê◊ï◊ß◊≥_◊†◊ï◊ë◊û◊ë◊® ◊†◊ï◊ë◊≥_◊ì◊¶◊û◊ë◊® ◊ì◊¶◊û◊≥'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '◊®◊ê◊©◊ï◊ü ◊ê◊≥ ◊ê|◊©◊†◊ô ◊ë◊≥ ◊ë|◊©◊ú◊ô◊©◊ô ◊í◊≥ ◊í|◊®◊ë◊ô◊¢◊ô ◊ì◊≥ ◊ì|◊ó◊û◊ô◊©◊ô ◊î◊≥ ◊î|◊©◊ô◊©◊ô ◊ï◊≥ ◊ï|◊©◊ë◊™ ◊©◊≥ ◊©'.split('|'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '◊û◊°◊§◊® ◊©◊†◊ô◊ï◊™', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '◊ì◊ß◊î',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '◊ì◊ß◊î',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ◊ì◊ß◊ï◊™',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ◊ì◊ß◊ï◊™',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '◊©◊¢◊î',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '◊©◊¢◊î',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '◊©◊¢◊™◊ô◊ô◊ù',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ◊©◊¢◊ï◊™',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ◊©◊¢◊ï◊™',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '◊ô◊ï◊ù',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '◊ô◊ï◊ù',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '◊ô◊ï◊û◊ô◊ô◊ù',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '◊ô◊ï◊ù',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ◊ô◊û◊ô◊ù',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ◊ô◊û◊ô◊ù',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '◊ó◊ï◊ì◊©',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '◊ó◊ï◊ì◊©',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '◊ó◊ï◊ì◊©',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '◊ó◊ï◊ì◊©◊ô◊ô◊ù',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '◊ó◊ï◊ì◊©◊ô◊ô◊ù',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ◊ó◊ï◊ì◊©◊ô◊ù',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '◊ó◊ï◊ì◊©',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ◊ó◊ï◊ì◊©◊ô◊ù',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '◊©◊†◊î',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '◊©◊†◊™◊ô◊ô◊ù',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 3699}), true), '10 ◊©◊†◊ô◊ù',        '345 days = 10 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 7340}), true), '20 ◊©◊†◊î',       '548 days = 20 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '◊©◊†◊î',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ◊©◊†◊ô◊ù',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '◊ë◊¢◊ï◊ì ◊û◊°◊§◊® ◊©◊†◊ô◊ï◊™',  'prefix');
        assert.equal(moment(0).from(30000), '◊ú◊§◊†◊ô ◊û◊°◊§◊® ◊©◊†◊ô◊ï◊™', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '◊ú◊§◊†◊ô ◊û◊°◊§◊® ◊©◊†◊ô◊ï◊™',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '◊ë◊¢◊ï◊ì ◊û◊°◊§◊® ◊©◊†◊ô◊ï◊™', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '◊ë◊¢◊ï◊ì 5 ◊ô◊û◊ô◊ù', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '◊î◊ô◊ï◊ù ◊ë÷æ02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '◊î◊ô◊ï◊ù ◊ë÷æ02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '◊î◊ô◊ï◊ù ◊ë÷æ03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '◊û◊ó◊® ◊ë÷æ02:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '◊î◊ô◊ï◊ù ◊ë÷æ01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '◊ê◊™◊û◊ï◊ú ◊ë÷æ02:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [◊ë◊©◊¢◊î] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [◊ë◊©◊¢◊î] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [◊ë◊©◊¢◊î] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[◊ë◊ô◊ï◊ù] dddd [◊î◊ê◊ó◊®◊ï◊ü ◊ë◊©◊¢◊î] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[◊ë◊ô◊ï◊ù] dddd [◊î◊ê◊ó◊®◊ï◊ü ◊ë◊©◊¢◊î] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[◊ë◊ô◊ï◊ù] dddd [◊î◊ê◊ó◊®◊ï◊ü ◊ë◊©◊¢◊î] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3', 'Jan 15 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('hi');

    test('parse', function (assert) {
        var tests = '‡§ú‡§®‡§µ‡§∞‡•Ä ‡§ú‡§®._‡§´‡§º‡§∞‡§µ‡§∞‡•Ä ‡§´‡§º‡§∞._‡§Æ‡§æ‡§∞‡•ç‡§ö ‡§Æ‡§æ‡§∞‡•ç‡§ö_‡§Ö‡§™‡•ç‡§∞‡•à‡§≤ ‡§Ö‡§™‡•ç‡§∞‡•à._‡§Æ‡§à ‡§Æ‡§à_‡§ú‡•Ç‡§® ‡§ú‡•Ç‡§®_‡§ú‡•Å‡§≤‡§æ‡§à ‡§ú‡•Å‡§≤._‡§Ö‡§ó‡§∏‡•ç‡§§ ‡§Ö‡§ó._‡§∏‡§ø‡§§‡§Æ‡•ç‡§¨‡§∞ ‡§∏‡§ø‡§§._‡§Ö‡§ï‡•ç‡§ü‡•Ç‡§¨‡§∞ ‡§Ö‡§ï‡•ç‡§ü‡•Ç._‡§®‡§µ‡§Æ‡•ç‡§¨‡§∞ ‡§®‡§µ._‡§¶‡§ø‡§∏‡§Æ‡•ç‡§¨‡§∞ ‡§¶‡§ø‡§∏.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, a h:mm:ss ‡§¨‡§ú‡•á',  '‡§∞‡§µ‡§ø‡§µ‡§æ‡§∞, ‡•ß‡•™ ‡§´‡§º‡§∞‡§µ‡§∞‡•Ä ‡•®‡•¶‡•ß‡•¶, ‡§¶‡•ã‡§™‡§π‡§∞ ‡•©:‡•®‡•´:‡•´‡•¶ ‡§¨‡§ú‡•á'],
                ['ddd, a h ‡§¨‡§ú‡•á',                       '‡§∞‡§µ‡§ø, ‡§¶‡•ã‡§™‡§π‡§∞ ‡•© ‡§¨‡§ú‡•á'],
                ['M Mo MM MMMM MMM',                   '‡•® ‡•® ‡•¶‡•® ‡§´‡§º‡§∞‡§µ‡§∞‡•Ä ‡§´‡§º‡§∞.'],
                ['YYYY YY',                            '‡•®‡•¶‡•ß‡•¶ ‡•ß‡•¶'],
                ['D Do DD',                            '‡•ß‡•™ ‡•ß‡•™ ‡•ß‡•™'],
                ['d do dddd ddd dd',                   '‡•¶ ‡•¶ ‡§∞‡§µ‡§ø‡§µ‡§æ‡§∞ ‡§∞‡§µ‡§ø ‡§∞'],
                ['DDD DDDo DDDD',                      '‡•™‡•´ ‡•™‡•´ ‡•¶‡•™‡•´'],
                ['w wo ww',                            '‡•Æ ‡•Æ ‡•¶‡•Æ'],
                ['h hh',                               '‡•© ‡•¶‡•©'],
                ['H HH',                               '‡•ß‡•´ ‡•ß‡•´'],
                ['m mm',                               '‡•®‡•´ ‡•®‡•´'],
                ['s ss',                               '‡•´‡•¶ ‡•´‡•¶'],
                ['a A',                                '‡§¶‡•ã‡§™‡§π‡§∞ ‡§¶‡•ã‡§™‡§π‡§∞'],
                ['LTS',                                '‡§¶‡•ã‡§™‡§π‡§∞ ‡•©:‡•®‡•´:‡•´‡•¶ ‡§¨‡§ú‡•á'],
                ['L',                                  '‡•ß‡•™/‡•¶‡•®/‡•®‡•¶‡•ß‡•¶'],
                ['LL',                                 '‡•ß‡•™ ‡§´‡§º‡§∞‡§µ‡§∞‡•Ä ‡•®‡•¶‡•ß‡•¶'],
                ['LLL',                                '‡•ß‡•™ ‡§´‡§º‡§∞‡§µ‡§∞‡•Ä ‡•®‡•¶‡•ß‡•¶, ‡§¶‡•ã‡§™‡§π‡§∞ ‡•©:‡•®‡•´ ‡§¨‡§ú‡•á'],
                ['LLLL',                               '‡§∞‡§µ‡§ø‡§µ‡§æ‡§∞, ‡•ß‡•™ ‡§´‡§º‡§∞‡§µ‡§∞‡•Ä ‡•®‡•¶‡•ß‡•¶, ‡§¶‡•ã‡§™‡§π‡§∞ ‡•©:‡•®‡•´ ‡§¨‡§ú‡•á'],
                ['l',                                  '‡•ß‡•™/‡•®/‡•®‡•¶‡•ß‡•¶'],
                ['ll',                                 '‡•ß‡•™ ‡§´‡§º‡§∞. ‡•®‡•¶‡•ß‡•¶'],
                ['lll',                                '‡•ß‡•™ ‡§´‡§º‡§∞. ‡•®‡•¶‡•ß‡•¶, ‡§¶‡•ã‡§™‡§π‡§∞ ‡•©:‡•®‡•´ ‡§¨‡§ú‡•á'],
                ['llll',                               '‡§∞‡§µ‡§ø, ‡•ß‡•™ ‡§´‡§º‡§∞. ‡•®‡•¶‡•ß‡•¶, ‡§¶‡•ã‡§™‡§π‡§∞ ‡•©:‡•®‡•´ ‡§¨‡§ú‡•á']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '‡•ß', '‡•ß');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '‡•®', '‡•®');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '‡•©', '‡•©');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '‡•™', '‡•™');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '‡•´', '‡•´');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '‡•¨', '‡•¨');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '‡•≠', '‡•≠');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '‡•Æ', '‡•Æ');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '‡•Ø', '‡•Ø');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '‡•ß‡•¶', '‡•ß‡•¶');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '‡•ß‡•ß', '‡•ß‡•ß');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '‡•ß‡•®', '‡•ß‡•®');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '‡•ß‡•©', '‡•ß‡•©');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '‡•ß‡•™', '‡•ß‡•™');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '‡•ß‡•´', '‡•ß‡•´');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '‡•ß‡•¨', '‡•ß‡•¨');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '‡•ß‡•≠', '‡•ß‡•≠');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '‡•ß‡•Æ', '‡•ß‡•Æ');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '‡•ß‡•Ø', '‡•ß‡•Ø');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '‡•®‡•¶', '‡•®‡•¶');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '‡•®‡•ß', '‡•®‡•ß');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '‡•®‡•®', '‡•®‡•®');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '‡•®‡•©', '‡•®‡•©');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '‡•®‡•™', '‡•®‡•™');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '‡•®‡•´', '‡•®‡•´');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '‡•®‡•¨', '‡•®‡•¨');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '‡•®‡•≠', '‡•®‡•≠');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '‡•®‡•Æ', '‡•®‡•Æ');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '‡•®‡•Ø', '‡•®‡•Ø');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '‡•©‡•¶', '‡•©‡•¶');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '‡•©‡•ß', '‡•©‡•ß');
    });

    test('format month', function (assert) {
        var expected = '‡§ú‡§®‡§µ‡§∞‡•Ä ‡§ú‡§®._‡§´‡§º‡§∞‡§µ‡§∞‡•Ä ‡§´‡§º‡§∞._‡§Æ‡§æ‡§∞‡•ç‡§ö ‡§Æ‡§æ‡§∞‡•ç‡§ö_‡§Ö‡§™‡•ç‡§∞‡•à‡§≤ ‡§Ö‡§™‡•ç‡§∞‡•à._‡§Æ‡§à ‡§Æ‡§à_‡§ú‡•Ç‡§® ‡§ú‡•Ç‡§®_‡§ú‡•Å‡§≤‡§æ‡§à ‡§ú‡•Å‡§≤._‡§Ö‡§ó‡§∏‡•ç‡§§ ‡§Ö‡§ó._‡§∏‡§ø‡§§‡§Æ‡•ç‡§¨‡§∞ ‡§∏‡§ø‡§§._‡§Ö‡§ï‡•ç‡§ü‡•Ç‡§¨‡§∞ ‡§Ö‡§ï‡•ç‡§ü‡•Ç._‡§®‡§µ‡§Æ‡•ç‡§¨‡§∞ ‡§®‡§µ._‡§¶‡§ø‡§∏‡§Æ‡•ç‡§¨‡§∞ ‡§¶‡§ø‡§∏.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '‡§∞‡§µ‡§ø‡§µ‡§æ‡§∞ ‡§∞‡§µ‡§ø ‡§∞_‡§∏‡•ã‡§Æ‡§µ‡§æ‡§∞ ‡§∏‡•ã‡§Æ ‡§∏‡•ã_‡§Æ‡§Ç‡§ó‡§≤‡§µ‡§æ‡§∞ ‡§Æ‡§Ç‡§ó‡§≤ ‡§Æ‡§Ç_‡§¨‡•Å‡§ß‡§µ‡§æ‡§∞ ‡§¨‡•Å‡§ß ‡§¨‡•Å_‡§ó‡•Å‡§∞‡•Ç‡§µ‡§æ‡§∞ ‡§ó‡•Å‡§∞‡•Ç ‡§ó‡•Å_‡§∂‡•Å‡§ï‡•ç‡§∞‡§µ‡§æ‡§∞ ‡§∂‡•Å‡§ï‡•ç‡§∞ ‡§∂‡•Å_‡§∂‡§®‡§ø‡§µ‡§æ‡§∞ ‡§∂‡§®‡§ø ‡§∂'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '‡§ï‡•Å‡§õ ‡§π‡•Ä ‡§ï‡•ç‡§∑‡§£', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '‡§è‡§ï ‡§Æ‡§ø‡§®‡§ü',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '‡§è‡§ï ‡§Æ‡§ø‡§®‡§ü',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '‡•® ‡§Æ‡§ø‡§®‡§ü',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '‡•™‡•™ ‡§Æ‡§ø‡§®‡§ü',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '‡§è‡§ï ‡§ò‡§Ç‡§ü‡§æ',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '‡§è‡§ï ‡§ò‡§Ç‡§ü‡§æ',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '‡•® ‡§ò‡§Ç‡§ü‡•á',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '‡•´ ‡§ò‡§Ç‡§ü‡•á',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '‡•®‡•ß ‡§ò‡§Ç‡§ü‡•á',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '‡§è‡§ï ‡§¶‡§ø‡§®',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '‡§è‡§ï ‡§¶‡§ø‡§®',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '‡•® ‡§¶‡§ø‡§®',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '‡§è‡§ï ‡§¶‡§ø‡§®',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '‡•´ ‡§¶‡§ø‡§®',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '‡•®‡•´ ‡§¶‡§ø‡§®',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '‡§è‡§ï ‡§Æ‡§π‡•Ä‡§®‡•á',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '‡§è‡§ï ‡§Æ‡§π‡•Ä‡§®‡•á',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '‡§è‡§ï ‡§Æ‡§π‡•Ä‡§®‡•á',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '‡•® ‡§Æ‡§π‡•Ä‡§®‡•á',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '‡•® ‡§Æ‡§π‡•Ä‡§®‡•á',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '‡•© ‡§Æ‡§π‡•Ä‡§®‡•á',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '‡§è‡§ï ‡§Æ‡§π‡•Ä‡§®‡•á',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '‡•´ ‡§Æ‡§π‡•Ä‡§®‡•á',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '‡§è‡§ï ‡§µ‡§∞‡•ç‡§∑',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '‡•® ‡§µ‡§∞‡•ç‡§∑',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '‡§è‡§ï ‡§µ‡§∞‡•ç‡§∑',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '‡•´ ‡§µ‡§∞‡•ç‡§∑',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '‡§ï‡•Å‡§õ ‡§π‡•Ä ‡§ï‡•ç‡§∑‡§£ ‡§Æ‡•á‡§Ç',  'prefix');
        assert.equal(moment(0).from(30000), '‡§ï‡•Å‡§õ ‡§π‡•Ä ‡§ï‡•ç‡§∑‡§£ ‡§™‡§π‡§≤‡•á', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '‡§ï‡•Å‡§õ ‡§π‡•Ä ‡§ï‡•ç‡§∑‡§£ ‡§™‡§π‡§≤‡•á',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '‡§ï‡•Å‡§õ ‡§π‡•Ä ‡§ï‡•ç‡§∑‡§£ ‡§Æ‡•á‡§Ç', '‡§ï‡•Å‡§õ ‡§π‡•Ä ‡§ï‡•ç‡§∑‡§£ ‡§Æ‡•á‡§Ç');
        assert.equal(moment().add({d: 5}).fromNow(), '‡•´ ‡§¶‡§ø‡§® ‡§Æ‡•á‡§Ç', '‡•´ ‡§¶‡§ø‡§® ‡§Æ‡•á‡§Ç');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '‡§Ü‡§ú ‡§∞‡§æ‡§§ ‡•®:‡•¶‡•¶ ‡§¨‡§ú‡•á',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '‡§Ü‡§ú ‡§∞‡§æ‡§§ ‡•®:‡•®‡•´ ‡§¨‡§ú‡•á',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 3}).calendar(),       '‡§Ü‡§ú ‡§∏‡•Å‡§¨‡§π ‡•´:‡•¶‡•¶ ‡§¨‡§ú‡•á',     'Now plus 3 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '‡§ï‡§≤ ‡§∞‡§æ‡§§ ‡•®:‡•¶‡•¶ ‡§¨‡§ú‡•á',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '‡§Ü‡§ú ‡§∞‡§æ‡§§ ‡•ß:‡•¶‡•¶ ‡§¨‡§ú‡•á',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '‡§ï‡§≤ ‡§∞‡§æ‡§§ ‡•®:‡•¶‡•¶ ‡§¨‡§ú‡•á', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[‡§™‡§ø‡§õ‡§≤‡•á] dddd[,] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[‡§™‡§ø‡§õ‡§≤‡•á] dddd[,] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[‡§™‡§ø‡§õ‡§≤‡•á] dddd[,] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('meridiem invariant', function (assert) {
        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), '‡§∞‡§æ‡§§', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), '‡§∏‡•Å‡§¨‡§π', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), '‡§¶‡•ã‡§™‡§π‡§∞', 'during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), '‡§∂‡§æ‡§Æ', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), '‡§∂‡§æ‡§Æ', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('a'), '‡§∞‡§æ‡§§', 'night');

        assert.equal(moment([2011, 2, 23,  2, 30]).format('A'), '‡§∞‡§æ‡§§', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('A'), '‡§∏‡•Å‡§¨‡§π', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('A'), '‡§¶‡•ã‡§™‡§π‡§∞', ' during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('A'), '‡§∂‡§æ‡§Æ', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('A'), '‡§∂‡§æ‡§Æ', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('A'), '‡§∞‡§æ‡§§', 'night');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '‡•ß ‡•¶‡•ß ‡•ß', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '‡•ß ‡•¶‡•ß ‡•ß', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '‡•® ‡•¶‡•® ‡•®', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '‡•® ‡•¶‡•® ‡•®', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '‡•© ‡•¶‡•© ‡•©', 'Jan 15 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('meridiem', function (assert) {
        var h, m, t1, t2;
        for (h = 0; h < 24; ++h) {
            for (m = 0; m < 60; m += 15) {
                t1 = moment.utc([2000, 0, 1, h, m]);
                t2 = moment(t1.format('A h:mm'), 'A h:mm');
                assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                        'meridiem at ' + t1.format('HH:mm'));
            }
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('hr');

    test('parse', function (assert) {
        var tests = 'sijeƒçanj sij._veljaƒça velj._o≈æujak o≈æu._travanj tra._svibanj svi._lipanj lip._srpanj srp._kolovoz kol._rujan ruj._listopad lis._studeni stu._prosinac pro.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'nedjelja, 14. veljaƒça 2010, 3:25:50 pm'],
                ['ddd, hA',                            'ned., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 veljaƒça velj.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. nedjelja ned. ne'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '7 7. 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14. 02. 2010'],
                ['LL',                                 '14. veljaƒça 2010'],
                ['LLL',                                '14. veljaƒça 2010 15:25'],
                ['LLLL',                               'nedjelja, 14. veljaƒça 2010 15:25'],
                ['l',                                  '14. 2. 2010'],
                ['ll',                                 '14. velj. 2010'],
                ['lll',                                '14. velj. 2010 15:25'],
                ['llll',                               'ned., 14. velj. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'sijeƒçanj sij._veljaƒça velj._o≈æujak o≈æu._travanj tra._svibanj svi._lipanj lip._srpanj srp._kolovoz kol._rujan ruj._listopad lis._studeni stu._prosinac pro.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'nedjelja ned. ne_ponedjeljak pon. po_utorak uto. ut_srijeda sri. sr_ƒçetvrtak ƒçet. ƒçe_petak pet. pe_subota sub. su'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'par sekundi', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'jedna minuta',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'jedna minuta',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minute',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuta',     '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'jedan sat',      '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'jedan sat',      '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 sata',        '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 sati',         '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 sati',        '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'dan',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'dan',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dana',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'dan',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dana',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dana',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mjesec',     '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mjesec',     '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mjesec',     '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mjeseca',     '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mjeseca',     '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mjeseca',     '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mjesec',     '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mjeseci',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'godinu',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 godine',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'godinu',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 godina',        '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'za par sekundi',  'prefix');
        assert.equal(moment(0).from(30000), 'prije par sekundi', 'prefix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'prije par sekundi',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'za par sekundi', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'za 5 dana', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'danas u 2:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'danas u 2:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'danas u 3:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'sutra u 2:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'danas u 1:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'juƒçer u 2:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
                return '[u] [nedjelju] [u] LT';
            case 3:
                return '[u] [srijedu] [u] LT';
            case 6:
                return '[u] [subotu] [u] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[u] dddd [u] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
            case 3:
                return '[pro≈°lu] dddd [u] LT';
            case 6:
                return '[pro≈°le] [subote] [u] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[pro≈°li] dddd [u] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('hu');

    test('parse', function (assert) {
        var tests = 'janu√°r jan_febru√°r feb_m√°rcius m√°rc_√°prilis √°pr_m√°jus m√°j_j√∫nius j√∫n_j√∫lius j√∫l_augusztus aug_szeptember szept_okt√≥ber okt_november nov_december dec'.split('_'),
            i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, HH:mm:ss',      'vas√°rnap, febru√°r 14. 2010, 15:25:50'],
                ['ddd, HH',                            'vas, 15'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 febru√°r feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. vas√°rnap vas v'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '7 7. 07'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['[az √©v] DDDo [napja]',               'az √©v 45. napja'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '2010.02.14.'],
                ['LL',                                 '2010. febru√°r 14.'],
                ['LLL',                                '2010. febru√°r 14., 15:25'],
                ['LLLL',                               '2010. febru√°r 14., vas√°rnap 15:25'],
                ['l',                                  '2010.2.14.'],
                ['ll',                                 '2010. feb 14.'],
                ['lll',                                '2010. feb 14., 15:25'],
                ['llll',                               '2010. feb 14., vas 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  0,  0]).format('a'), 'de', 'am');
        assert.equal(moment([2011, 2, 23, 11, 59]).format('a'), 'de', 'am');
        assert.equal(moment([2011, 2, 23, 12,  0]).format('a'), 'du', 'pm');
        assert.equal(moment([2011, 2, 23, 23, 59]).format('a'), 'du', 'pm');

        assert.equal(moment([2011, 2, 23,  0,  0]).format('A'), 'DE', 'AM');
        assert.equal(moment([2011, 2, 23, 11, 59]).format('A'), 'DE', 'AM');
        assert.equal(moment([2011, 2, 23, 12,  0]).format('A'), 'DU', 'PM');
        assert.equal(moment([2011, 2, 23, 23, 59]).format('A'), 'DU', 'PM');
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'janu√°r jan_febru√°r feb_m√°rcius m√°rc_√°prilis √°pr_m√°jus m√°j_j√∫nius j√∫n_j√∫lius j√∫l_augusztus aug_szeptember szept_okt√≥ber okt_november nov_december dec'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'vas√°rnap vas_h√©tf≈ë h√©t_kedd kedd_szerda sze_cs√ºt√∂rt√∂k cs√ºt_p√©ntek p√©n_szombat szo'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'n√©h√°ny m√°sodperc', '44 m√°sodperc = n√©h√°ny m√°sodperc');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'egy perc',         '45 m√°sodperc = egy perc');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'egy perc',         '89 m√°sodperc = egy perc');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 perc',           '90 m√°sodperc = 2 perc');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 perc',          '44 perc = 44 perc');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'egy √≥ra',          '45 perc = egy √≥ra');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'egy √≥ra',          '89 perc = egy √≥ra');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 √≥ra',            '90 perc = 2 √≥ra');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 √≥ra',            '5 √≥ra = 5 √≥ra');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 √≥ra',           '21 √≥ra = 21 √≥ra');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'egy nap',          '22 √≥ra = egy nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'egy nap',          '35 √≥ra = egy nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 nap',            '36 √≥ra = 2 nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'egy nap',          '1 nap = egy nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 nap',            '5 nap = 5 nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 nap',           '25 nap = 25 nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'egy h√≥nap',        '26 nap = egy h√≥nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'egy h√≥nap',        '30 nap = egy h√≥nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'egy h√≥nap',        '45 nap = egy h√≥nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 h√≥nap',          '46 nap = 2 h√≥nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 h√≥nap',          '75 nap = 2 h√≥nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 h√≥nap',          '76 nap = 3 h√≥nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'egy h√≥nap',        '1 h√≥nap = egy h√≥nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 h√≥nap',          '5 h√≥nap = 5 h√≥nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'egy √©v',           '345 nap = egy √©v');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 √©v',             '548 nap = 2 √©v');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'egy √©v',           '1 √©v = egy √©v');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 √©v',             '5 √©v = 5 √©v');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'n√©h√°ny m√°sodperc m√∫lva',  'prefix');
        assert.equal(moment(0).from(30000), 'n√©h√°ny m√°sodperce', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'n√©h√°ny m√°sodperce',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'n√©h√°ny m√°sodperc m√∫lva', 'n√©h√°ny m√°sodperc m√∫lva');
        assert.equal(moment().add({d: 5}).fromNow(), '5 nap m√∫lva', '5 nap m√∫lva');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'ma 2:00-kor',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'ma 2:25-kor',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'ma 3:00-kor',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'holnap 2:00-kor', 'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'ma 1:00-kor',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'tegnap 2:00-kor', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m, days = 'vas√°rnap_h√©tf≈ën_kedden_szerd√°n_cs√ºt√∂rt√∂k√∂n_p√©nteken_szombaton'.split('_');
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[' + days[m.day()] + '] LT[-kor]'),  'today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[' + days[m.day()] + '] LT[-kor]'),  'today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[' + days[m.day()] + '] LT[-kor]'),  'today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m, days = 'vas√°rnap_h√©tf≈ën_kedden_szerd√°n_cs√ºt√∂rt√∂k√∂n_p√©nteken_szombaton'.split('_');

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[m√∫lt ' + days[m.day()] + '] LT[-kor]'),  'today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[m√∫lt ' + days[m.day()] + '] LT[-kor]'),  'today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[m√∫lt ' + days[m.day()] + '] LT[-kor]'),  'today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  'egy h√©te');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'egy h√©t m√∫lva');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 hete');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  '2 h√©t m√∫lva');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('hy-am');

    test('parse', function (assert) {
        var tests = '’∞’∏÷Ç’∂’æ’°÷Ä ’∞’∂’æ_÷É’•’ø÷Ä’æ’°÷Ä ÷É’ø÷Ä_’¥’°÷Ä’ø ’¥÷Ä’ø_’°’∫÷Ä’´’¨ ’°’∫÷Ä_’¥’°’µ’´’Ω ’¥’µ’Ω_’∞’∏÷Ç’∂’´’Ω ’∞’∂’Ω_’∞’∏÷Ç’¨’´’Ω ’∞’¨’Ω_÷Ö’£’∏’Ω’ø’∏’Ω ÷Ö’£’Ω_’Ω’•’∫’ø’•’¥’¢’•÷Ä ’Ω’∫’ø_’∞’∏’Ø’ø’•’¥’¢’•÷Ä ’∞’Ø’ø_’∂’∏’µ’•’¥’¢’•÷Ä ’∂’¥’¢_’§’•’Ø’ø’•’¥’¢’•÷Ä ’§’Ø’ø'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('parse exceptional case', function (assert) {
        assert.equal(moment('11 ’¥’°’µ’´’Ω’´ 1989', ['DD MMMM YYYY']).format('DD-MM-YYYY'), '11-05-1989');
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, HH:mm:ss',       '’Ø’´÷Ä’°’Ø’´, 14 ÷É’•’ø÷Ä’æ’°÷Ä’´ 2010, 15:25:50'],
                ['ddd, h A',                           '’Ø÷Ä’Ø, 3 ÷Å’•÷Ä’•’Ø’æ’°'],
                ['M Mo MM MMMM MMM',                   '2 2 02 ÷É’•’ø÷Ä’æ’°÷Ä ÷É’ø÷Ä'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 ’Ø’´÷Ä’°’Ø’´ ’Ø÷Ä’Ø ’Ø÷Ä’Ø'],
                ['DDD DDDo DDDD',                      '45 45-÷Ä’§ 045'],
                ['w wo ww',                            '7 7-÷Ä’§ 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                '÷Å’•÷Ä’•’Ø’æ’° ÷Å’•÷Ä’•’Ø’æ’°'],
                ['[’ø’°÷Ä’æ’°] DDDo [÷Ö÷Ä’®]',                 '’ø’°÷Ä’æ’° 45-÷Ä’§ ÷Ö÷Ä’®'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14 ÷É’•’ø÷Ä’æ’°÷Ä’´ 2010 ’©.'],
                ['LLL',                                '14 ÷É’•’ø÷Ä’æ’°÷Ä’´ 2010 ’©., 15:25'],
                ['LLLL',                               '’Ø’´÷Ä’°’Ø’´, 14 ÷É’•’ø÷Ä’æ’°÷Ä’´ 2010 ’©., 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14 ÷É’ø÷Ä 2010 ’©.'],
                ['lll',                                '14 ÷É’ø÷Ä 2010 ’©., 15:25'],
                ['llll',                               '’Ø÷Ä’Ø, 14 ÷É’ø÷Ä 2010 ’©., 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format meridiem', function (assert) {
        assert.equal(moment([2012, 11, 28, 0, 0]).format('A'), '’£’´’∑’•÷Ä’æ’°', 'night');
        assert.equal(moment([2012, 11, 28, 3, 59]).format('A'), '’£’´’∑’•÷Ä’æ’°', 'night');
        assert.equal(moment([2012, 11, 28, 4, 0]).format('A'), '’°’º’°’æ’∏’ø’æ’°', 'morning');
        assert.equal(moment([2012, 11, 28, 11, 59]).format('A'), '’°’º’°’æ’∏’ø’æ’°', 'morning');
        assert.equal(moment([2012, 11, 28, 12, 0]).format('A'), '÷Å’•÷Ä’•’Ø’æ’°', 'afternoon');
        assert.equal(moment([2012, 11, 28, 16, 59]).format('A'), '÷Å’•÷Ä’•’Ø’æ’°', 'afternoon');
        assert.equal(moment([2012, 11, 28, 17, 0]).format('A'), '’•÷Ä’•’Ø’∏’µ’°’∂', 'evening');
        assert.equal(moment([2012, 11, 28, 23, 59]).format('A'), '’•÷Ä’•’Ø’∏’µ’°’∂', 'evening');
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-’´’∂', '1-’´’∂');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-÷Ä’§', '2-÷Ä’§');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-÷Ä’§', '3-÷Ä’§');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-÷Ä’§', '4-÷Ä’§');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-÷Ä’§', '5-÷Ä’§');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-÷Ä’§', '6-÷Ä’§');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-÷Ä’§', '7-÷Ä’§');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-÷Ä’§', '8-÷Ä’§');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-÷Ä’§', '9-÷Ä’§');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-÷Ä’§', '10-÷Ä’§');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-÷Ä’§', '11-÷Ä’§');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-÷Ä’§', '12-÷Ä’§');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-÷Ä’§', '13-÷Ä’§');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-÷Ä’§', '14-÷Ä’§');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-÷Ä’§', '15-÷Ä’§');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-÷Ä’§', '16-÷Ä’§');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-÷Ä’§', '17-÷Ä’§');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-÷Ä’§', '18-÷Ä’§');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-÷Ä’§', '19-÷Ä’§');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-÷Ä’§', '20-÷Ä’§');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-÷Ä’§', '21-÷Ä’§');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-÷Ä’§', '22-÷Ä’§');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-÷Ä’§', '23-÷Ä’§');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-÷Ä’§', '24-÷Ä’§');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-÷Ä’§', '25-÷Ä’§');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-÷Ä’§', '26-÷Ä’§');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-÷Ä’§', '27-÷Ä’§');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-÷Ä’§', '28-÷Ä’§');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-÷Ä’§', '29-÷Ä’§');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-÷Ä’§', '30-÷Ä’§');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-÷Ä’§', '31-÷Ä’§');
    });

    test('format month', function (assert) {
        var expected = '’∞’∏÷Ç’∂’æ’°÷Ä ’∞’∂’æ_÷É’•’ø÷Ä’æ’°÷Ä ÷É’ø÷Ä_’¥’°÷Ä’ø ’¥÷Ä’ø_’°’∫÷Ä’´’¨ ’°’∫÷Ä_’¥’°’µ’´’Ω ’¥’µ’Ω_’∞’∏÷Ç’∂’´’Ω ’∞’∂’Ω_’∞’∏÷Ç’¨’´’Ω ’∞’¨’Ω_÷Ö’£’∏’Ω’ø’∏’Ω ÷Ö’£’Ω_’Ω’•’∫’ø’•’¥’¢’•÷Ä ’Ω’∫’ø_’∞’∏’Ø’ø’•’¥’¢’•÷Ä ’∞’Ø’ø_’∂’∏’µ’•’¥’¢’•÷Ä ’∂’¥’¢_’§’•’Ø’ø’•’¥’¢’•÷Ä ’§’Ø’ø'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format month case', function (assert) {
        var months = {
            'nominative': '’∞’∏÷Ç’∂’æ’°÷Ä_÷É’•’ø÷Ä’æ’°÷Ä_’¥’°÷Ä’ø_’°’∫÷Ä’´’¨_’¥’°’µ’´’Ω_’∞’∏÷Ç’∂’´’Ω_’∞’∏÷Ç’¨’´’Ω_÷Ö’£’∏’Ω’ø’∏’Ω_’Ω’•’∫’ø’•’¥’¢’•÷Ä_’∞’∏’Ø’ø’•’¥’¢’•÷Ä_’∂’∏’µ’•’¥’¢’•÷Ä_’§’•’Ø’ø’•’¥’¢’•÷Ä'.split('_'),
            'accusative': '’∞’∏÷Ç’∂’æ’°÷Ä’´_÷É’•’ø÷Ä’æ’°÷Ä’´_’¥’°÷Ä’ø’´_’°’∫÷Ä’´’¨’´_’¥’°’µ’´’Ω’´_’∞’∏÷Ç’∂’´’Ω’´_’∞’∏÷Ç’¨’´’Ω’´_÷Ö’£’∏’Ω’ø’∏’Ω’´_’Ω’•’∫’ø’•’¥’¢’•÷Ä’´_’∞’∏’Ø’ø’•’¥’¢’•÷Ä’´_’∂’∏’µ’•’¥’¢’•÷Ä’´_’§’•’Ø’ø’•’¥’¢’•÷Ä’´'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2011, i, 1]).format('D MMMM'), '1 ' + months.accusative[i], '1 ' + months.accusative[i]);
            assert.equal(moment([2011, i, 1]).format('MMMM'), months.nominative[i], '1 ' + months.nominative[i]);
        }
    });

    test('format month short case', function (assert) {
        var monthsShort = {
            'nominative': '’∞’∂’æ_÷É’ø÷Ä_’¥÷Ä’ø_’°’∫÷Ä_’¥’µ’Ω_’∞’∂’Ω_’∞’¨’Ω_÷Ö’£’Ω_’Ω’∫’ø_’∞’Ø’ø_’∂’¥’¢_’§’Ø’ø'.split('_'),
            'accusative': '’∞’∂’æ_÷É’ø÷Ä_’¥÷Ä’ø_’°’∫÷Ä_’¥’µ’Ω_’∞’∂’Ω_’∞’¨’Ω_÷Ö’£’Ω_’Ω’∫’ø_’∞’Ø’ø_’∂’¥’¢_’§’Ø’ø'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2011, i, 1]).format('D MMM'), '1 ' + monthsShort.accusative[i], '1 ' + monthsShort.accusative[i]);
            assert.equal(moment([2011, i, 1]).format('MMM'), monthsShort.nominative[i], '1 ' + monthsShort.nominative[i]);
        }
    });

    test('format month case with escaped symbols', function (assert) {
        var months = {
            'nominative': '’∞’∏÷Ç’∂’æ’°÷Ä_÷É’•’ø÷Ä’æ’°÷Ä_’¥’°÷Ä’ø_’°’∫÷Ä’´’¨_’¥’°’µ’´’Ω_’∞’∏÷Ç’∂’´’Ω_’∞’∏÷Ç’¨’´’Ω_÷Ö’£’∏’Ω’ø’∏’Ω_’Ω’•’∫’ø’•’¥’¢’•÷Ä_’∞’∏’Ø’ø’•’¥’¢’•÷Ä_’∂’∏’µ’•’¥’¢’•÷Ä_’§’•’Ø’ø’•’¥’¢’•÷Ä'.split('_'),
            'accusative': '’∞’∏÷Ç’∂’æ’°÷Ä’´_÷É’•’ø÷Ä’æ’°÷Ä’´_’¥’°÷Ä’ø’´_’°’∫÷Ä’´’¨’´_’¥’°’µ’´’Ω’´_’∞’∏÷Ç’∂’´’Ω’´_’∞’∏÷Ç’¨’´’Ω’´_÷Ö’£’∏’Ω’ø’∏’Ω’´_’Ω’•’∫’ø’•’¥’¢’•÷Ä’´_’∞’∏’Ø’ø’•’¥’¢’•÷Ä’´_’∂’∏’µ’•’¥’¢’•÷Ä’´_’§’•’Ø’ø’•’¥’¢’•÷Ä’´'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2013, i, 1]).format('D[] MMMM'), '1 ' + months.accusative[i], '1 ' + months.accusative[i]);
            assert.equal(moment([2013, i, 1]).format('[<i>]D[</i>] [<b>]MMMM[</b>]'), '<i>1</i> <b>' + months.accusative[i] + '</b>', '1 <b>' + months.accusative[i] + '</b>');
            assert.equal(moment([2013, i, 1]).format('D[-’´’∂ ÷Ö÷Ä’®] MMMM'), '1-’´’∂ ÷Ö÷Ä’® ' + months.accusative[i], '1-’´’∂ ÷Ö÷Ä’® ' + months.accusative[i]);
            assert.equal(moment([2013, i, 1]).format('D, MMMM'), '1, ' + months.nominative[i], '1, ' + months.nominative[i]);
        }
    });

    test('format month short case with escaped symbols', function (assert) {
        var monthsShort = {
            'nominative': '’∞’∂’æ_÷É’ø÷Ä_’¥÷Ä’ø_’°’∫÷Ä_’¥’µ’Ω_’∞’∂’Ω_’∞’¨’Ω_÷Ö’£’Ω_’Ω’∫’ø_’∞’Ø’ø_’∂’¥’¢_’§’Ø’ø'.split('_'),
            'accusative': '’∞’∂’æ_÷É’ø÷Ä_’¥÷Ä’ø_’°’∫÷Ä_’¥’µ’Ω_’∞’∂’Ω_’∞’¨’Ω_÷Ö’£’Ω_’Ω’∫’ø_’∞’Ø’ø_’∂’¥’¢_’§’Ø’ø'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2013, i, 1]).format('D[] MMM'), '1 ' + monthsShort.accusative[i], '1 ' + monthsShort.accusative[i]);
            assert.equal(moment([2013, i, 1]).format('[<i>]D[</i>] [<b>]MMM[</b>]'), '<i>1</i> <b>' + monthsShort.accusative[i] + '</b>', '1 <b>' + monthsShort.accusative[i] + '</b>');
            assert.equal(moment([2013, i, 1]).format('D[-’´’∂ ÷Ö÷Ä’®] MMM'), '1-’´’∂ ÷Ö÷Ä’® ' + monthsShort.accusative[i], '1-’´’∂ ÷Ö÷Ä’® ' + monthsShort.accusative[i]);
            assert.equal(moment([2013, i, 1]).format('D, MMM'), '1, ' + monthsShort.nominative[i], '1, ' + monthsShort.nominative[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '’Ø’´÷Ä’°’Ø’´ ’Ø÷Ä’Ø ’Ø÷Ä’Ø_’•÷Ä’Ø’∏÷Ç’∑’°’¢’©’´ ’•÷Ä’Ø ’•÷Ä’Ø_’•÷Ä’•÷Ñ’∑’°’¢’©’´ ’•÷Ä÷Ñ ’•÷Ä÷Ñ_’π’∏÷Ä’•÷Ñ’∑’°’¢’©’´ ’π÷Ä÷Ñ ’π÷Ä÷Ñ_’∞’´’∂’£’∑’°’¢’©’´ ’∞’∂’£ ’∞’∂’£_’∏÷Ç÷Ä’¢’°’© ’∏÷Ç÷Ä’¢ ’∏÷Ç÷Ä’¢_’∑’°’¢’°’© ’∑’¢’© ’∑’¢’©'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '’¥’´ ÷Ñ’°’∂’´ ’æ’°’µ÷Ä’Ø’µ’°’∂',    '44 seconds = seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '÷Ä’∏’∫’•',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '÷Ä’∏’∫’•',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ÷Ä’∏’∫’•',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ÷Ä’∏’∫’•', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '’™’°’¥',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '’™’°’¥',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ’™’°’¥',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ’™’°’¥',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ’™’°’¥',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '÷Ö÷Ä',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '÷Ö÷Ä',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ÷Ö÷Ä',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '÷Ö÷Ä',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ÷Ö÷Ä',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 11}), true),  '11 ÷Ö÷Ä',     '11 days = 11 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 21}), true),  '21 ÷Ö÷Ä',     '21 days = 21 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ÷Ö÷Ä',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '’°’¥’´’Ω',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '’°’¥’´’Ω',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '’°’¥’´’Ω',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ’°’¥’´’Ω',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ’°’¥’´’Ω',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ’°’¥’´’Ω',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '’°’¥’´’Ω',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ’°’¥’´’Ω',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '’ø’°÷Ä’´',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ’ø’°÷Ä’´',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '’ø’°÷Ä’´',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ’ø’°÷Ä’´',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '’¥’´ ÷Ñ’°’∂’´ ’æ’°’µ÷Ä’Ø’µ’°’∂ ’∞’•’ø’∏', 'prefix');
        assert.equal(moment(0).from(30000), '’¥’´ ÷Ñ’°’∂’´ ’æ’°’µ÷Ä’Ø’µ’°’∂ ’°’º’°’ª', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '’¥’´ ÷Ñ’°’∂’´ ’æ’°’µ÷Ä’Ø’µ’°’∂ ’∞’•’ø’∏', 'in seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5 ÷Ö÷Ä ’∞’•’ø’∏', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '’°’µ’Ω÷Ö÷Ä 02:00',   'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '’°’µ’Ω÷Ö÷Ä 02:25',   'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '’°’µ’Ω÷Ö÷Ä 03:00',   'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '’æ’°’≤’® 02:00',   'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '’°’µ’Ω÷Ö÷Ä 01:00',   'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '’•÷Ä’•’Ø 02:00',   'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        function makeFormat(d) {
            return 'dddd [÷Ö÷Ä’® ’™’°’¥’®] LT';
        }

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            return '[’°’∂÷Å’°’Æ] dddd [÷Ö÷Ä’® ’™’°’¥’®] LT';
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-’´’∂', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-’´’∂', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-÷Ä’§', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-÷Ä’§', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-÷Ä’§', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('id');

    test('parse', function (assert) {
        var tests = 'Januari Jan_Februari Feb_Maret Mar_April Apr_Mei Mei_Juni Jun_Juli Jul_Agustus Ags_September Sep_Oktober Okt_November Nov_Desember Des'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Minggu, Februari 14 2010, 3:25:50 sore'],
                ['ddd, hA',                            'Min, 3sore'],
                ['M Mo MM MMMM MMM',                   '2 2 02 Februari Feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 Minggu Min Mg'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '7 7 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'sore sore'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15.25.50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 Februari 2010'],
                ['LLL',                                '14 Februari 2010 pukul 15.25'],
                ['LLLL',                               'Minggu, 14 Februari 2010 pukul 15.25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Feb 2010'],
                ['lll',                                '14 Feb 2010 pukul 15.25'],
                ['llll',                               'Min, 14 Feb 2010 pukul 15.25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format month', function (assert) {
        var expected = 'Januari Jan_Februari Feb_Maret Mar_April Apr_Mei Mei_Juni Jun_Juli Jul_Agustus Ags_September Sep_Oktober Okt_November Nov_Desember Des'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Minggu Min Mg_Senin Sen Sn_Selasa Sel Sl_Rabu Rab Rb_Kamis Kam Km_Jumat Jum Jm_Sabtu Sab Sb'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'beberapa detik', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'semenit',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'semenit',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 menit',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 menit',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'sejam',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'sejam',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 jam',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 jam',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 jam',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'sehari',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'sehari',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 hari',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'sehari',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 hari',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 hari',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'sebulan',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'sebulan',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'sebulan',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 bulan',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 bulan',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 bulan',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'sebulan',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 bulan',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'setahun',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 tahun',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'setahun',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 tahun',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'dalam beberapa detik',  'prefix');
        assert.equal(moment(0).from(30000), 'beberapa detik yang lalu', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'beberapa detik yang lalu',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'dalam beberapa detik', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'dalam 5 hari', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Hari ini pukul 02.00', 'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Hari ini pukul 02.25', 'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Hari ini pukul 03.00', 'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Besok pukul 02.00',    'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Hari ini pukul 01.00', 'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Kemarin pukul 02.00',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [lalu pukul] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [lalu pukul] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [lalu pukul] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('meridiem invariant', function (assert) {
        var h, m, t1, t2;
        for (h = 0; h < 24; ++h) {
            for (m = 0; m < 60; m += 15) {
                t1 = moment.utc([2000, 0, 1, h, m]);
                t2 = moment(t1.format('A h:mm'), 'A h:mm');
                assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                        'meridiem at ' + t1.format('HH:mm'));
            }
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('is');

    test('parse', function (assert) {
        var tests = 'jan√∫ar jan_febr√∫ar feb_mars mar_apr√≠l apr_ma√≠ ma√≠_j√∫n√≠ j√∫n_j√∫l√≠ j√∫l_√°g√∫st √°g√∫_september sep_okt√≥ber okt_n√≥vember n√≥v_desember des'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'sunnudagur, 14. febr√∫ar 2010, 3:25:50 pm'],
                ['ddd, hA',                            'sun, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 febr√∫ar feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. sunnudagur sun Su'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14. febr√∫ar 2010'],
                ['LLL',                                '14. febr√∫ar 2010 kl. 15:25'],
                ['LLLL',                               'sunnudagur, 14. febr√∫ar 2010 kl. 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14. feb 2010'],
                ['lll',                                '14. feb 2010 kl. 15:25'],
                ['llll',                               'sun, 14. feb 2010 kl. 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'jan√∫ar jan_febr√∫ar feb_mars mar_apr√≠l apr_ma√≠ ma√≠_j√∫n√≠ j√∫n_j√∫l√≠ j√∫l_√°g√∫st √°g√∫_september sep_okt√≥ber okt_n√≥vember n√≥v_desember des'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'sunnudagur sun Su_m√°nudagur m√°n M√°_√æri√∞judagur √æri √ûr_mi√∞vikudagur mi√∞ Mi_fimmtudagur fim Fi_f√∂studagur f√∂s F√∂_laugardagur lau La'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'nokkrar sek√∫ndur', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'm√≠n√∫ta',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'm√≠n√∫ta',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 m√≠n√∫tur',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 m√≠n√∫tur',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 21}), true),  '21 m√≠n√∫ta',    '21 minutes = 21 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'klukkustund',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'klukkustund',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 klukkustundir',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 klukkustundir',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 klukkustund',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'dagur',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'dagur',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dagar',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'dagur',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dagar',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dagar',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 11}), true),  '11 dagar',       '11 days = 11 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 21}), true),  '21 dagur',       '21 days = 21 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'm√°nu√∞ur',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'm√°nu√∞ur',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'm√°nu√∞ur',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 m√°nu√∞ir',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 m√°nu√∞ir',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 m√°nu√∞ir',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'm√°nu√∞ur',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 m√°nu√∞ir',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '√°r',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 √°r',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '√°r',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 √°r',       '5 years = 5 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 21}), true),  '21 √°r',       '21 years = 21 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'eftir nokkrar sek√∫ndur',  'prefix');
        assert.equal(moment(0).from(30000), 'fyrir nokkrum sek√∫ndum s√≠√∞an', 'suffix');
        assert.equal(moment().subtract({m: 1}).fromNow(), 'fyrir m√≠n√∫tu s√≠√∞an', 'a minute ago');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'fyrir nokkrum sek√∫ndum s√≠√∞an',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'eftir nokkrar sek√∫ndur', 'in a few seconds');
        assert.equal(moment().add({m: 1}).fromNow(), 'eftir m√≠n√∫tu', 'in a minute');
        assert.equal(moment().add({d: 5}).fromNow(), 'eftir 5 daga', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '√≠ dag kl. 2:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '√≠ dag kl. 2:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '√≠ dag kl. 3:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '√° morgun kl. 2:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '√≠ dag kl. 1:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '√≠ g√¶r kl. 2:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[s√≠√∞asta] dddd [kl.] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[s√≠√∞asta] dddd [kl.] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[s√≠√∞asta] dddd [kl.] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),  '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),  '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),  '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),  '2 02 2.', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('it');

    test('parse', function (assert) {
        var tests = 'gennaio gen_febbraio feb_marzo mar_aprile apr_maggio mag_giugno giu_luglio lug_agosto ago_settembre set_ottobre ott_novembre nov_dicembre dic'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Domenica, febbraio 14¬∫ 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Dom, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2¬∫ 02 febbraio feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14¬∫ 14'],
                ['d do dddd ddd dd',                   '0 0¬∫ Domenica Dom D'],
                ['DDD DDDo DDDD',                      '45 45¬∫ 045'],
                ['w wo ww',                            '6 6¬∫ 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45¬∫ day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 febbraio 2010'],
                ['LLL',                                '14 febbraio 2010 15:25'],
                ['LLLL',                               'Domenica, 14 febbraio 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 feb 2010'],
                ['lll',                                '14 feb 2010 15:25'],
                ['llll',                               'Dom, 14 feb 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1¬∫', '1¬∫');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2¬∫', '2¬∫');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3¬∫', '3¬∫');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4¬∫', '4¬∫');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5¬∫', '5¬∫');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6¬∫', '6¬∫');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7¬∫', '7¬∫');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8¬∫', '8¬∫');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9¬∫', '9¬∫');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10¬∫', '10¬∫');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11¬∫', '11¬∫');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12¬∫', '12¬∫');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13¬∫', '13¬∫');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14¬∫', '14¬∫');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15¬∫', '15¬∫');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16¬∫', '16¬∫');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17¬∫', '17¬∫');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18¬∫', '18¬∫');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19¬∫', '19¬∫');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20¬∫', '20¬∫');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21¬∫', '21¬∫');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22¬∫', '22¬∫');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23¬∫', '23¬∫');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24¬∫', '24¬∫');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25¬∫', '25¬∫');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26¬∫', '26¬∫');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27¬∫', '27¬∫');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28¬∫', '28¬∫');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29¬∫', '29¬∫');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30¬∫', '30¬∫');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31¬∫', '31¬∫');
    });

    test('format month', function (assert) {
        var expected = 'gennaio gen_febbraio feb_marzo mar_aprile apr_maggio mag_giugno giu_luglio lug_agosto ago_settembre set_ottobre ott_novembre nov_dicembre dic'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Domenica Dom D_Luned√¨ Lun L_Marted√¨ Mar Ma_Mercoled√¨ Mer Me_Gioved√¨ Gio G_Venerd√¨ Ven V_Sabato Sab S'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'alcuni secondi', '44 seconds = seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'un minuto',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'un minuto',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuti',       '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuti',      '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'un\'ora',        '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'un\'ora',        '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ore',          '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ore',          '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ore',         '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'un giorno',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'un giorno',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 giorni',       '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'un giorno',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 giorni',       '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 giorni',      '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'un mese',        '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'un mese',        '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'un mese',        '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mesi',         '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mesi',         '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mesi',         '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'un mese',        '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mesi',         '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'un anno',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 anni',         '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'un anno',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 anni',         '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'in alcuni secondi', 'prefix');
        assert.equal(moment(0).from(30000), 'alcuni secondi fa', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'in alcuni secondi', 'in seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'tra 5 giorni', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Oggi alle 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Oggi alle 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Oggi alle 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Domani alle 02:00',   'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Oggi alle 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Ieri alle 02:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [alle] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [alle] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [alle] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m, weekday, datestring;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            // Different date string
            weekday = parseInt(m.format('d'), 10);
            datestring = (weekday === 0) ? '[la scorsa] dddd [alle] LT' : '[lo scorso] dddd [alle] LT';
            assert.equal(m.calendar(), m.format(datestring), 'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format(datestring), 'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format(datestring), 'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52¬∫', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),  '1 01 1¬∫', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),  '1 01 1¬∫', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),  '2 02 2¬∫', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),  '2 02 2¬∫', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('ja');

    test('parse', function (assert) {
        var tests = '1Êúà 1Êúà_2Êúà 2Êúà_3Êúà 3Êúà_4Êúà 4Êúà_5Êúà 5Êúà_6Êúà 6Êúà_7Êúà 7Êúà_8Êúà 8Êúà_9Êúà 9Êúà_10Êúà 10Êúà_11Êúà 11Êúà_12Êúà 12Êúà'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, a h:mm:ss',      'Êó•ÊõúÊó•, 2Êúà 14 2010, ÂçàÂæå 3:25:50'],
                ['ddd, Ah',                            'Êó•, ÂçàÂæå3'],
                ['M Mo MM MMMM MMM',                   '2 2 02 2Êúà 2Êúà'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 Êó•ÊõúÊó• Êó• Êó•'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '8 8 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'ÂçàÂæå ÂçàÂæå'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                'ÂçàÂæå3ÊôÇ25ÂàÜ50Áßí'],
                ['L',                                  '2010/02/14'],
                ['LL',                                 '2010Âπ¥2Êúà14Êó•'],
                ['LLL',                                '2010Âπ¥2Êúà14Êó•ÂçàÂæå3ÊôÇ25ÂàÜ'],
                ['LLLL',                               '2010Âπ¥2Êúà14Êó•ÂçàÂæå3ÊôÇ25ÂàÜ Êó•ÊõúÊó•'],
                ['l',                                  '2010/2/14'],
                ['ll',                                 '2010Âπ¥2Êúà14Êó•'],
                ['lll',                                '2010Âπ¥2Êúà14Êó•ÂçàÂæå3ÊôÇ25ÂàÜ'],
                ['llll',                               '2010Âπ¥2Êúà14Êó•ÂçàÂæå3ÊôÇ25ÂàÜ Êó•']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format month', function (assert) {
        var expected = '1Êúà 1Êúà_2Êúà 2Êúà_3Êúà 3Êúà_4Êúà 4Êúà_5Êúà 5Êúà_6Êúà 6Êúà_7Êúà 7Êúà_8Êúà 8Êúà_9Êúà 9Êúà_10Êúà 10Êúà_11Êúà 11Êúà_12Êúà 12Êúà'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Êó•ÊõúÊó• Êó• Êó•_ÊúàÊõúÊó• Êúà Êúà_ÁÅ´ÊõúÊó• ÁÅ´ ÁÅ´_Ê∞¥ÊõúÊó• Ê∞¥ Ê∞¥_Êú®ÊõúÊó• Êú® Êú®_ÈáëÊõúÊó• Èáë Èáë_ÂúüÊõúÊó• Âúü Âúü'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'Êï∞Áßí',   '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '1ÂàÜ', '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '1ÂàÜ', '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2ÂàÜ',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44ÂàÜ', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '1ÊôÇÈñì', '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '1ÊôÇÈñì', '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2ÊôÇÈñì',  '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5ÊôÇÈñì',  '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21ÊôÇÈñì', '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '1Êó•',   '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '1Êó•',   '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2Êó•',   '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '1Êó•',   '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5Êó•',   '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25Êó•',  '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '1„É∂Êúà', '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '1„É∂Êúà', '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '1„É∂Êúà', '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2„É∂Êúà',  '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2„É∂Êúà',  '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3„É∂Êúà',  '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '1„É∂Êúà', '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5„É∂Êúà',  '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '1Âπ¥',   '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2Âπ¥',   '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '1Âπ¥',   '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5Âπ¥',   '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'Êï∞ÁßíÂæå',  'prefix');
        assert.equal(moment(0).from(30000), 'Êï∞ÁßíÂâç', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'Êï∞ÁßíÂâç',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'Êï∞ÁßíÂæå', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5Êó•Âæå', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '‰ªäÊó• ÂçàÂâç2ÊôÇ0ÂàÜ',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '‰ªäÊó• ÂçàÂâç2ÊôÇ25ÂàÜ',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '‰ªäÊó• ÂçàÂâç3ÊôÇ0ÂàÜ',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'ÊòéÊó• ÂçàÂâç2ÊôÇ0ÂàÜ',     'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '‰ªäÊó• ÂçàÂâç1ÊôÇ0ÂàÜ',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Êò®Êó• ÂçàÂâç2ÊôÇ0ÂàÜ',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[Êù•ÈÄ±]dddd LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[Êù•ÈÄ±]dddd LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[Êù•ÈÄ±]dddd LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[ÂâçÈÄ±]dddd LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[ÂâçÈÄ±]dddd LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[ÂâçÈÄ±]dddd LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),      '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),      '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3', 'Jan 15 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('jv');


    test('parse', function (assert) {
        var tests = 'Januari Jan_Februari Feb_Maret Mar_April Apr_Mei Mei_Juni Jun_Juli Jul_Agustus Ags_September Sep_Oktober Okt_Nopember Nop_Desember Des'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Minggu, Februari 14 2010, 3:25:50 sonten'],
                ['ddd, hA',                            'Min, 3sonten'],
                ['M Mo MM MMMM MMM',                   '2 2 02 Februari Feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 Minggu Min Mg'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '7 7 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'sonten sonten'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15.25.50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 Februari 2010'],
                ['LLL',                                '14 Februari 2010 pukul 15.25'],
                ['LLLL',                               'Minggu, 14 Februari 2010 pukul 15.25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Feb 2010'],
                ['lll',                                '14 Feb 2010 pukul 15.25'],
                ['llll',                               'Min, 14 Feb 2010 pukul 15.25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format month', function (assert) {
        var expected = 'Januari Jan_Februari Feb_Maret Mar_April Apr_Mei Mei_Juni Jun_Juli Jul_Agustus Ags_September Sep_Oktober Okt_Nopember Nop_Desember Des'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Minggu Min Mg_Senen Sen Sn_Seloso Sel Sl_Rebu Reb Rb_Kemis Kem Km_Jemuwah Jem Jm_Septu Sep Sp'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'sawetawis detik', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'setunggal menit',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'setunggal menit',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 menit',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 menit',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'setunggal jam',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'setunggal jam',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 jam',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 jam',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 jam',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'sedinten',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'sedinten',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dinten',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'sedinten',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dinten',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dinten',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'sewulan',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'sewulan',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'sewulan',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 wulan',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 wulan',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 wulan',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'sewulan',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 wulan',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'setaun',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 taun',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'setaun',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 taun',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'wonten ing sawetawis detik',  'prefix');
        assert.equal(moment(0).from(30000), 'sawetawis detik ingkang kepengker', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'sawetawis detik ingkang kepengker',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'wonten ing sawetawis detik', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'wonten ing 5 dinten', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Dinten puniko pukul 02.00', 'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Dinten puniko pukul 02.25', 'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Dinten puniko pukul 03.00', 'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Mbenjang pukul 02.00',    'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Dinten puniko pukul 01.00', 'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Kala wingi pukul 02.00',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [kepengker pukul] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [kepengker pukul] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [kepengker pukul] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    // Monday is the first day of the week.
    // The week that contains Jan 1st is the first week of the year.

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('meridiem invariant', function (assert) {
        var h, m, t1, t2;
        for (h = 0; h < 24; ++h) {
            for (m = 0; m < 60; m += 15) {
                t1 = moment.utc([2000, 0, 1, h, m]);
                t2 = moment(t1.format('A h:mm'), 'A h:mm');
                assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                        'meridiem at ' + t1.format('HH:mm'));
            }
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('ka');

    test('parse', function (assert) {
        var i,
            tests = '·Éò·Éê·Éú·Éï·Éê·É†·Éò ·Éò·Éê·Éú_·Éó·Éî·Éë·Éî·É†·Éï·Éê·Éö·Éò ·Éó·Éî·Éë_·Éõ·Éê·É†·É¢·Éò ·Éõ·Éê·É†_·Éê·Éû·É†·Éò·Éö·Éò ·Éê·Éû·É†_·Éõ·Éê·Éò·É°·Éò ·Éõ·Éê·Éò_·Éò·Éï·Éú·Éò·É°·Éò ·Éò·Éï·Éú_·Éò·Éï·Éö·Éò·É°·Éò ·Éò·Éï·Éö_·Éê·Éí·Éï·Éò·É°·É¢·Éù ·Éê·Éí·Éï_·É°·Éî·É•·É¢·Éî·Éõ·Éë·Éî·É†·Éò ·É°·Éî·É•_·Éù·É•·É¢·Éù·Éõ·Éë·Éî·É†·Éò ·Éù·É•·É¢_·Éú·Éù·Éî·Éõ·Éë·Éî·É†·Éò ·Éú·Éù·Éî_·Éì·Éî·Éô·Éî·Éõ·Éë·Éî·É†·Éò ·Éì·Éî·Éô'.split('_');

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éó·Éï·Éî ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a', '·Éô·Éï·Éò·É†·Éê, ·Éó·Éî·Éë·Éî·É†·Éï·Éê·Éö·Éò ·Éõ·Éî-14 2010, 3:25:50 pm'],
                ['ddd, hA',                       '·Éô·Éï·Éò, 3PM'],
                ['M Mo MM MMMM MMM',              '2 ·Éõ·Éî-2 02 ·Éó·Éî·Éë·Éî·É†·Éï·Éê·Éö·Éò ·Éó·Éî·Éë'],
                ['YYYY YY',                       '2010 10'],
                ['D Do DD',                       '14 ·Éõ·Éî-14 14'],
                ['d do dddd ddd dd',              '0 0 ·Éô·Éï·Éò·É†·Éê ·Éô·Éï·Éò ·Éô·Éï'],
                ['DDD DDDo DDDD',                 '45 45-·Éî 045'],
                ['w wo ww',                       '7 ·Éõ·Éî-7 07'],
                ['h hh',                          '3 03'],
                ['H HH',                          '15 15'],
                ['m mm',                          '25 25'],
                ['s ss',                          '50 50'],
                ['a A',                           'pm PM'],
                ['·É¨·Éö·Éò·É° DDDo ·Éì·É¶·Éî',                 '·É¨·Éö·Éò·É° 45-·Éî ·Éì·É¶·Éî'],
                ['LTS',                           '3:25:50 PM'],
                ['L',                             '14/02/2010'],
                ['LL',                            '14 ·Éó·Éî·Éë·Éî·É†·Éï·Éê·Éö·Éò 2010'],
                ['LLL',                           '14 ·Éó·Éî·Éë·Éî·É†·Éï·Éê·Éö·Éò 2010 3:25 PM'],
                ['LLLL',                          '·Éô·Éï·Éò·É†·Éê, 14 ·Éó·Éî·Éë·Éî·É†·Éï·Éê·Éö·Éò 2010 3:25 PM'],
                ['l',                             '14/2/2010'],
                ['ll',                            '14 ·Éó·Éî·Éë 2010'],
                ['lll',                           '14 ·Éó·Éî·Éë 2010 3:25 PM'],
                ['llll',                          '·Éô·Éï·Éò, 14 ·Éó·Éî·Éë 2010 3:25 PM']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'),  '1-·Éö·Éò',  '1-·Éö·Éò');
        assert.equal(moment([2011, 0, 2]).format('DDDo'),  '·Éõ·Éî-2',  '·Éõ·Éî-2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'),  '·Éõ·Éî-3',  '·Éõ·Éî-3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'),  '·Éõ·Éî-4',  '·Éõ·Éî-4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'),  '·Éõ·Éî-5',  '·Éõ·Éî-5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'),  '·Éõ·Éî-6',  '·Éõ·Éî-6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'),  '·Éõ·Éî-7',  '·Éõ·Éî-7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'),  '·Éõ·Éî-8',  '·Éõ·Éî-8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'),  '·Éõ·Éî-9',  '·Éõ·Éî-9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '·Éõ·Éî-10', '·Éõ·Éî-10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '·Éõ·Éî-11', '·Éõ·Éî-11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '·Éõ·Éî-12', '·Éõ·Éî-12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '·Éõ·Éî-13', '·Éõ·Éî-13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '·Éõ·Éî-14', '·Éõ·Éî-14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '·Éõ·Éî-15', '·Éõ·Éî-15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '·Éõ·Éî-16', '·Éõ·Éî-16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '·Éõ·Éî-17', '·Éõ·Éî-17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '·Éõ·Éî-18', '·Éõ·Éî-18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '·Éõ·Éî-19', '·Éõ·Éî-19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '·Éõ·Éî-20', '·Éõ·Éî-20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-·Éî', '21-·Éî');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-·Éî', '22-·Éî');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-·Éî', '23-·Éî');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-·Éî', '24-·Éî');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-·Éî', '25-·Éî');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-·Éî', '26-·Éî');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-·Éî', '27-·Éî');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-·Éî', '28-·Éî');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-·Éî', '29-·Éî');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-·Éî', '30-·Éî');

        assert.equal(moment('2011 40', 'YYYY DDD').format('DDDo'),  '·Éõ·Éî-40',  '·Éõ·Éî-40');
        assert.equal(moment('2011 50', 'YYYY DDD').format('DDDo'),  '50-·Éî',   '50-·Éî');
        assert.equal(moment('2011 60', 'YYYY DDD').format('DDDo'),  '·Éõ·Éî-60',  '·Éõ·Éî-60');
        assert.equal(moment('2011 100', 'YYYY DDD').format('DDDo'), '·Éõ·Éî-100', '·Éõ·Éî-100');
        assert.equal(moment('2011 101', 'YYYY DDD').format('DDDo'), '101-·Éî',  '101-·Éî');
    });

    test('format month', function (assert) {
        var i,
            expected = '·Éò·Éê·Éú·Éï·Éê·É†·Éò ·Éò·Éê·Éú_·Éó·Éî·Éë·Éî·É†·Éï·Éê·Éö·Éò ·Éó·Éî·Éë_·Éõ·Éê·É†·É¢·Éò ·Éõ·Éê·É†_·Éê·Éû·É†·Éò·Éö·Éò ·Éê·Éû·É†_·Éõ·Éê·Éò·É°·Éò ·Éõ·Éê·Éò_·Éò·Éï·Éú·Éò·É°·Éò ·Éò·Éï·Éú_·Éò·Éï·Éö·Éò·É°·Éò ·Éò·Éï·Éö_·Éê·Éí·Éï·Éò·É°·É¢·Éù ·Éê·Éí·Éï_·É°·Éî·É•·É¢·Éî·Éõ·Éë·Éî·É†·Éò ·É°·Éî·É•_·Éù·É•·É¢·Éù·Éõ·Éë·Éî·É†·Éò ·Éù·É•·É¢_·Éú·Éù·Éî·Éõ·Éë·Éî·É†·Éò ·Éú·Éù·Éî_·Éì·Éî·Éô·Éî·Éõ·Éë·Éî·É†·Éò ·Éì·Éî·Éô'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var i,
            expected = '·Éô·Éï·Éò·É†·Éê ·Éô·Éï·Éò ·Éô·Éï_·Éù·É†·É®·Éê·Éë·Éê·Éó·Éò ·Éù·É†·É® ·Éù·É†_·É°·Éê·Éõ·É®·Éê·Éë·Éê·Éó·Éò ·É°·Éê·Éõ ·É°·Éê_·Éù·Éó·ÉÆ·É®·Éê·Éë·Éê·Éó·Éò ·Éù·Éó·ÉÆ ·Éù·Éó_·ÉÆ·É£·Éó·É®·Éê·Éë·Éê·Éó·Éò ·ÉÆ·É£·Éó ·ÉÆ·É£_·Éû·Éê·É†·Éê·É°·Éô·Éî·Éï·Éò ·Éû·Éê·É† ·Éû·Éê_·É®·Éê·Éë·Éê·Éó·Éò ·É®·Éê·Éë ·É®·Éê'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}),  true), '·É†·Éê·Éõ·Éì·Éî·Éú·Éò·Éõ·Éî ·É¨·Éê·Éõ·Éò', '44 ·É¨·Éê·Éõ·Éò  = ·É†·Éê·Éõ·Éì·Éî·Éú·Éò·Éõ·Éî ·É¨·Éê·Éõ·Éò');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}),  true), '·É¨·É£·Éó·Éò',           '45 ·É¨·Éê·Éõ·Éò  = ·É¨·É£·Éó·Éò');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}),  true), '·É¨·É£·Éó·Éò',           '89 ·É¨·Éê·Éõ·Éò  = ·É¨·É£·Éó·Éò');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}),  true), '2 ·É¨·É£·Éó·Éò',         '90 ·É¨·Éê·Éõ·Éò  = 2 ·É¨·É£·Éó·Éò');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}),  true), '44 ·É¨·É£·Éó·Éò',        '44 ·É¨·Éê·Éõ·Éò  = 44 ·É¨·É£·Éó·Éò');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}),  true), '·É°·Éê·Éê·Éó·Éò',          '45 ·É¨·Éê·Éõ·Éò  = ·É°·Éê·Éê·Éó·Éò');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}),  true), '·É°·Éê·Éê·Éó·Éò',          '89 ·É¨·Éê·Éõ·Éò  = ·É°·Éê·Éê·Éó·Éò');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}),  true), '2 ·É°·Éê·Éê·Éó·Éò',        '90 ·É¨·Éê·Éõ·Éò  = 2 ·É°·Éê·Éê·Éó·Éò');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}),   true), '5 ·É°·Éê·Éê·Éó·Éò',        '5 ·É°·Éê·Éê·Éó·Éò  = 5 ·É°·Éê·Éê·Éó·Éò');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}),  true), '21 ·É°·Éê·Éê·Éó·Éò',       '21 ·É°·Éê·Éê·Éó·Éò = 21 ·É°·Éê·Éê·Éó·Éò');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}),  true), '·Éì·É¶·Éî',            '22 ·É°·Éê·Éê·Éó·Éò = ·Éì·É¶·Éî');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}),  true), '·Éì·É¶·Éî',            '35 ·É°·Éê·Éê·Éó·Éò = ·Éì·É¶·Éî');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}),  true), '2 ·Éì·É¶·Éî',          '36 ·É°·Éê·Éê·Éó·Éò = 2 ·Éì·É¶·Éî');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}),   true), '·Éì·É¶·Éî',            '1 ·Éì·É¶·Éî    = ·Éì·É¶·Éî');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}),   true), '5 ·Éì·É¶·Éî',          '5 ·Éì·É¶·Éî    = 5 ·Éì·É¶·Éî');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}),  true), '25 ·Éì·É¶·Éî',         '25 ·Éì·É¶·Éî   = 25 ·Éì·É¶·Éî');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}),  true), '·Éó·Éï·Éî',            '26 ·Éì·É¶·Éî   = ·Éó·Éï·Éî');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}),  true), '·Éó·Éï·Éî',            '30 ·Éì·É¶·Éî   = ·Éó·Éï·Éî');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}),  true), '·Éó·Éï·Éî',            '45 ·Éì·É¶·Éî   = ·Éó·Éï·Éî');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}),  true), '2 ·Éó·Éï·Éî',          '46 ·Éì·É¶·Éî   = 2 ·Éó·Éï·Éî');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}),  true), '2 ·Éó·Éï·Éî',          '75 ·Éì·É¶·Éî   = 2 ·Éó·Éï·Éî');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}),  true), '3 ·Éó·Éï·Éî',          '76 ·Éì·É¶·Éî   = 3 ·Éó·Éï·Éî');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}),   true), '·Éó·Éï·Éî',            '1 ·Éó·Éï·Éî    = ·Éó·Éï·Éî');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}),   true), '5 ·Éó·Éï·Éî',          '5 ·Éó·Éï·Éî    = 5 ·Éó·Éï·Éî');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '·É¨·Éî·Éö·Éò',           '345 ·Éì·É¶·Éî  = ·É¨·Éî·Éö·Éò');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ·É¨·Éî·Éö·Éò',         '548 ·Éì·É¶·Éî  = 2 ·É¨·Éî·Éö·Éò');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}),   true), '·É¨·Éî·Éö·Éò',           '1 ·É¨·Éî·Éö·Éò   = ·É¨·Éî·Éö·Éò');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}),   true), '5 ·É¨·Éî·Éö·Éò',         '5 ·É¨·Éî·Éö·Éò   = 5 ·É¨·Éî·Éö·Éò');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '·É†·Éê·Éõ·Éì·Éî·Éú·Éò·Éõ·Éî ·É¨·Éê·Éõ·É®·Éò',     '·É®·Éò ·É°·É£·É§·Éò·É•·É°·Éò');
        assert.equal(moment(0).from(30000), '·É†·Éê·Éõ·Éì·Éî·Éú·Éò·Éõ·Éî ·É¨·Éê·Éõ·Éò·É° ·É¨·Éò·Éú', '·É¨·Éò·Éú ·É°·É£·É§·Éò·É•·É°·Éò');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '·É†·Éê·Éõ·Éì·Éî·Éú·Éò·Éõ·Éî ·É¨·Éê·Éõ·Éò·É° ·É¨·Éò·Éú', '·É£·Éú·Éì·Éê ·Éê·É©·Éï·Éî·Éú·Éù·É° ·É†·Éù·Éí·Éù·É†·É™ ·É¨·Éê·É†·É°·É£·Éö·Éò');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '·É†·Éê·Éõ·Éì·Éî·Éú·Éò·Éõ·Éî ·É¨·Éê·Éõ·É®·Éò', '·É†·Éê·Éõ·Éì·Éî·Éú·Éò·Éõ·Éî ·É¨·Éê·Éõ·É®·Éò');
        assert.equal(moment().add({d: 5}).fromNow(), '5 ·Éì·É¶·Éî·É®·Éò', '5 ·Éì·É¶·Éî·É®·Éò');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '·Éì·É¶·Éî·É° 2:00 AM-·Éñ·Éî',  '·Éì·É¶·Éî·É° ·Éê·Éõ·Éê·Éï·Éî ·Éì·É†·Éù·É°');
        assert.equal(moment(a).add({m: 25}).calendar(),      '·Éì·É¶·Éî·É° 2:25 AM-·Éñ·Éî',  '·Éê·ÉÆ·Éö·Éê·Éú·Éì·Éî·Éö ·Éì·É†·Éù·É° ·Éì·Éê·Éõ·Éê·É¢·Éî·Éë·É£·Éö·Éò 25 ·É¨·É£·Éó·Éò');
        assert.equal(moment(a).add({h: 1}).calendar(),       '·Éì·É¶·Éî·É° 3:00 AM-·Éñ·Éî',  '·Éê·ÉÆ·Éö·Éê·Éú·Éì·Éî·Éö ·Éì·É†·Éù·É° ·Éì·Éê·Éõ·Éê·É¢·Éî·Éë·É£·Éö·Éò 1 ·É°·Éê·Éê·Éó·Éò');
        assert.equal(moment(a).add({d: 1}).calendar(),       '·ÉÆ·Éï·Éê·Éö 2:00 AM-·Éñ·Éî',  '·ÉÆ·Éï·Éê·Éö ·Éê·Éõ·Éê·Éï·Éî ·Éì·É†·Éù·É°');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '·Éì·É¶·Éî·É° 1:00 AM-·Éñ·Éî',  '·Éê·ÉÆ·Éö·Éê·Éú·Éì·Éî·Éö ·Éì·É†·Éù·É° ·Éí·Éê·Éõ·Éù·Éô·Éö·Éî·Éë·É£·Éö·Éò 1 ·É°·Éê·Éê·Éó·Éò');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '·Éí·É£·É®·Éò·Éú 2:00 AM-·Éñ·Éî', '·Éí·É£·É®·Éò·Éú ·Éê·Éõ·Éê·Éï·Éî ·Éì·É†·Éù·É°');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[·É®·Éî·Éõ·Éì·Éî·Éí] dddd LT[-·Éñ·Éî]'),  '·Éì·É¶·Éî·É° + ' + i + ' ·Éì·É¶·Éî ·Éê·ÉÆ·Éö·Éê·Éú·Éì·Éî·Éö ·Éì·É†·Éù·É°');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[·É®·Éî·Éõ·Éì·Éî·Éí] dddd LT[-·Éñ·Éî]'),  '·Éì·É¶·Éî·É° + ' + i + ' ·Éì·É¶·Éî ·Éì·É¶·Éò·É° ·Éì·Éê·É°·Éê·É¨·Éß·Éò·É°·É®·Éò');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[·É®·Éî·Éõ·Éì·Éî·Éí] dddd LT[-·Éñ·Éî]'),  '·Éì·É¶·Éî·É° + ' + i + ' ·Éì·É¶·Éî ·Éì·É¶·Éò·É° ·Éì·Éê·É°·Éê·É°·É†·É£·Éö·É°');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[·É¨·Éò·Éú·Éê] dddd LT[-·Éñ·Éî]'),  '·Éì·É¶·Éî·É° - ' + i + ' ·Éì·É¶·Éî ·Éê·ÉÆ·Éö·Éê·Éú·Éì·Éî·Éö ·Éì·É†·Éù·É°');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[·É¨·Éò·Éú·Éê] dddd LT[-·Éñ·Éî]'),  '·Éì·É¶·Éî·É° - ' + i + ' ·Éì·É¶·Éî ·Éì·É¶·Éò·É° ·Éì·Éê·É°·Éê·É¨·Éß·Éò·É°·É®·Éò');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[·É¨·Éò·Éú·Éê] dddd LT[-·Éñ·Éî]'),  '·Éì·É¶·Éî·É° - ' + i + ' ·Éì·É¶·Éî ·Éì·É¶·Éò·É° ·Éì·Éê·É°·Éê·É°·É†·É£·Éö·É°');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 ·Éô·Éï·Éò·É†·Éò·É° ·É¨·Éò·Éú');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  '1 ·Éô·Éï·Éò·É†·Éê·É®·Éò');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 ·Éô·Éï·Éò·É†·Éò·É° ·É¨·Éò·Éú');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  '2 ·Éô·Éï·Éò·É†·Éê·É®·Éò');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, '·Éì·Éî·Éô 26 2011 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, '·Éò·Éê·Éú  1 2012 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, '·Éò·Éê·Éú  2 2012 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, '·Éò·Éê·Éú  8 2012 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, '·Éò·Éê·Éú  9 2012 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, '·Éò·Éê·Éú  1 2007 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, '·Éò·Éê·Éú  7 2007 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, '·Éò·Éê·Éú  8 2007 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, '·Éò·Éê·Éú 14 2007 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, '·Éò·Éê·Éú 15 2007 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, '·Éì·Éî·Éô 31 2007 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, '·Éò·Éê·Éú  1 2008 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, '·Éò·Éê·Éú  6 2008 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, '·Éò·Éê·Éú  7 2008 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, '·Éò·Éê·Éú 13 2008 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, '·Éò·Éê·Éú 14 2008 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, '·Éì·Éî·Éô 30 2002 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, '·Éò·Éê·Éú  1 2003 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, '·Éò·Éê·Éú  5 2003 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, '·Éò·Éê·Éú  6 2003 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, '·Éò·Éê·Éú 12 2003 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, '·Éò·Éê·Éú 13 2003 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, '·Éì·Éî·Éô 29 2008 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, '·Éò·Éê·Éú  1 2009 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, '·Éò·Éê·Éú  4 2009 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, '·Éò·Éê·Éú  5 2009 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, '·Éò·Éê·Éú 11 2009 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, '·Éò·Éê·Éú 12 2009 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, '·Éì·Éî·Éô 28 2009 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, '·Éò·Éê·Éú  1 2010 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, '·Éò·Éê·Éú  3 2010 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, '·Éò·Éê·Éú  4 2010 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, '·Éò·Éê·Éú 10 2010 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, '·Éò·Éê·Éú 11 2010 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, '·Éì·Éî·Éô 27 2010 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, '·Éò·Éê·Éú  1 2011 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, '·Éò·Éê·Éú  2 2011 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, '·Éò·Éê·Éú  3 2011 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, '·Éò·Éê·Éú  9 2011 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, '·Éò·Éê·Éú 10 2011 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-·Éö·Éò', '·Éì·Éî·Éô 26 2011 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-·Éö·Éò', '·Éò·Éê·Éú  1 2012 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 ·Éõ·Éî-2', '·Éò·Éê·Éú  2 2012 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 ·Éõ·Éî-2', '·Éò·Éê·Éú  8 2012 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 ·Éõ·Éî-3', '·Éò·Éê·Éú  9 2012 ·É£·Éú·Éì·Éê ·Éò·Éß·Éù·É° ·Éô·Éï·Éò·É†·Éê 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('km');

    test('parse', function (assert) {
        var tests = '·ûò·ûÄ·ûö·û∂ ·ûò·ûÄ·ûö·û∂_·ûÄ·ûª·ûò·üí·ûó·üà ·ûÄ·ûª·ûò·üí·ûó·üà_·ûò·û∑·ûì·û∂ ·ûò·û∑·ûì·û∂_·ûò·üÅ·ûü·û∂ ·ûò·üÅ·ûü·û∂_·ûß·ûü·ûó·û∂ ·ûß·ûü·ûó·û∂_·ûò·û∑·ûê·ûª·ûì·û∂ ·ûò·û∑·ûê·ûª·ûì·û∂_·ûÄ·ûÄ·üí·ûÄ·ûä·û∂ ·ûÄ·ûÄ·üí·ûÄ·ûä·û∂_·ûü·û∏·û†·û∂ ·ûü·û∏·û†·û∂_·ûÄ·ûâ·üí·ûâ·û∂ ·ûÄ·ûâ·üí·ûâ·û∂_·ûè·ûª·ûõ·û∂ ·ûè·ûª·ûõ·û∂_·ûú·û∑·ûÖ·üí·ûÜ·û∑·ûÄ·û∂ ·ûú·û∑·ûÖ·üí·ûÜ·û∑·ûÄ·û∂_·ûí·üí·ûì·ûº ·ûí·üí·ûì·ûº'.split('_'),
            i;

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a', '·û¢·û∂·ûë·û∑·ûè·üí·ûô, ·ûÄ·ûª·ûò·üí·ûó·üà 14 2010, 3:25:50 pm'],
                ['ddd, hA', '·û¢·û∂·ûë·û∑·ûè·üí·ûô, 3PM'],
                ['M Mo MM MMMM MMM', '2 2 02 ·ûÄ·ûª·ûò·üí·ûó·üà ·ûÄ·ûª·ûò·üí·ûó·üà'],
                ['YYYY YY', '2010 10'],
                ['D Do DD', '14 14 14'],
                ['d do dddd ddd dd', '0 0 ·û¢·û∂·ûë·û∑·ûè·üí·ûô ·û¢·û∂·ûë·û∑·ûè·üí·ûô ·û¢·û∂·ûë·û∑·ûè·üí·ûô'],
                ['DDD DDDo DDDD', '45 45 045'],
                ['w wo ww', '6 6 06'],
                ['h hh', '3 03'],
                ['H HH', '15 15'],
                ['m mm', '25 25'],
                ['s ss', '50 50'],
                ['a A', 'pm PM'],
                ['[the] DDDo [day of the year]', 'the 45 day of the year'],
                ['LTS', '15:25:50'],
                ['L', '14/02/2010'],
                ['LL', '14 ·ûÄ·ûª·ûò·üí·ûó·üà 2010'],
                ['LLL', '14 ·ûÄ·ûª·ûò·üí·ûó·üà 2010 15:25'],
                ['LLLL', '·û¢·û∂·ûë·û∑·ûè·üí·ûô, 14 ·ûÄ·ûª·ûò·üí·ûó·üà 2010 15:25'],
                ['l', '14/2/2010'],
                ['ll', '14 ·ûÄ·ûª·ûò·üí·ûó·üà 2010'],
                ['lll', '14 ·ûÄ·ûª·ûò·üí·ûó·üà 2010 15:25'],
                ['llll', '·û¢·û∂·ûë·û∑·ûè·üí·ûô, 14 ·ûÄ·ûª·ûò·üí·ûó·üà 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1st');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2nd');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3rd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4th');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5th');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6th');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7th');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8th');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9th');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10th');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11th');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12th');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13th');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14th');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15th');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16th');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17th');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18th');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19th');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20th');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21st');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22nd');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23rd');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24th');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25th');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26th');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27th');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28th');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29th');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30th');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31st');
    });

    test('format month', function (assert) {
        var expected = '·ûò·ûÄ·ûö·û∂ ·ûò·ûÄ·ûö·û∂_·ûÄ·ûª·ûò·üí·ûó·üà ·ûÄ·ûª·ûò·üí·ûó·üà_·ûò·û∑·ûì·û∂ ·ûò·û∑·ûì·û∂_·ûò·üÅ·ûü·û∂ ·ûò·üÅ·ûü·û∂_·ûß·ûü·ûó·û∂ ·ûß·ûü·ûó·û∂_·ûò·û∑·ûê·ûª·ûì·û∂ ·ûò·û∑·ûê·ûª·ûì·û∂_·ûÄ·ûÄ·üí·ûÄ·ûä·û∂ ·ûÄ·ûÄ·üí·ûÄ·ûä·û∂_·ûü·û∏·û†·û∂ ·ûü·û∏·û†·û∂_·ûÄ·ûâ·üí·ûâ·û∂ ·ûÄ·ûâ·üí·ûâ·û∂_·ûè·ûª·ûõ·û∂ ·ûè·ûª·ûõ·û∂_·ûú·û∑·ûÖ·üí·ûÜ·û∑·ûÄ·û∂ ·ûú·û∑·ûÖ·üí·ûÜ·û∑·ûÄ·û∂_·ûí·üí·ûì·ûº ·ûí·üí·ûì·ûº'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '·û¢·û∂·ûë·û∑·ûè·üí·ûô ·û¢·û∂·ûë·û∑·ûè·üí·ûô ·û¢·û∂·ûë·û∑·ûè·üí·ûô_·ûÖ·üê·ûì·üí·ûë ·ûÖ·üê·ûì·üí·ûë ·ûÖ·üê·ûì·üí·ûë_·û¢·ûÑ·üí·ûÇ·û∂·ûö ·û¢·ûÑ·üí·ûÇ·û∂·ûö ·û¢·ûÑ·üí·ûÇ·û∂·ûö_·ûñ·ûª·ûí ·ûñ·ûª·ûí ·ûñ·ûª·ûí_·ûñ·üí·ûö·û†·ûü·üí·ûî·ûè·û∑·üç ·ûñ·üí·ûö·û†·ûü·üí·ûî·ûè·û∑·üç ·ûñ·üí·ûö·û†·ûü·üí·ûî·ûè·û∑·üç_·ûü·ûª·ûÄ·üí·ûö ·ûü·ûª·ûÄ·üí·ûö ·ûü·ûª·ûÄ·üí·ûö_·ûü·üÖ·ûö·üç ·ûü·üÖ·ûö·üç ·ûü·üÖ·ûö·üç'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true), '·ûî·üâ·ûª·ûì·üí·ûò·û∂·ûì·ûú·û∑·ûì·û∂·ûë·û∏', '44 seconds = ·ûî·üâ·ûª·ûì·üí·ûò·û∂·ûì·ûú·û∑·ûì·û∂·ûë·û∏');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true), '·ûò·ûΩ·ûô·ûì·û∂·ûë·û∏', '45 seconds = ·ûò·ûΩ·ûô·ûì·û∂·ûë·û∏');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true), '·ûò·ûΩ·ûô·ûì·û∂·ûë·û∏', '89 seconds = ·ûò·ûΩ·ûô·ûì·û∂·ûë·û∏');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true), '2 ·ûì·û∂·ûë·û∏', '90 seconds = 2 ·ûì·û∂·ûë·û∏');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true), '44 ·ûì·û∂·ûë·û∏', '44 minutes = 44 ·ûì·û∂·ûë·û∏');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true), '·ûò·ûΩ·ûô·ûò·üâ·üÑ·ûÑ', '45 minutes = ·ûò·ûΩ·ûô·ûò·üâ·üÑ·ûÑ');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true), '·ûò·ûΩ·ûô·ûò·üâ·üÑ·ûÑ', '89 minutes = ·ûò·ûΩ·ûô·ûò·üâ·üÑ·ûÑ');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true), '2 ·ûò·üâ·üÑ·ûÑ', '90 minutes = 2 ·ûò·üâ·üÑ·ûÑ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true), '5 ·ûò·üâ·üÑ·ûÑ', '5 hours = 5 ·ûò·üâ·üÑ·ûÑ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true), '21 ·ûò·üâ·üÑ·ûÑ', '21 hours = 21 ·ûò·üâ·üÑ·ûÑ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true), '·ûò·ûΩ·ûô·ûê·üí·ûÑ·üÉ', '22 hours = ·ûò·ûΩ·ûô·ûê·üí·ûÑ·üÉ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true), '·ûò·ûΩ·ûô·ûê·üí·ûÑ·üÉ', '35 hours = ·ûò·ûΩ·ûô·ûê·üí·ûÑ·üÉ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true), '2 ·ûê·üí·ûÑ·üÉ', '36 hours = 2 ·ûê·üí·ûÑ·üÉ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true), '·ûò·ûΩ·ûô·ûê·üí·ûÑ·üÉ', '1 day = ·ûò·ûΩ·ûô·ûê·üí·ûÑ·üÉ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true), '5 ·ûê·üí·ûÑ·üÉ', '5 days = 5 ·ûê·üí·ûÑ·üÉ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true), '25 ·ûê·üí·ûÑ·üÉ', '25 days = 25 ·ûê·üí·ûÑ·üÉ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true), '·ûò·ûΩ·ûô·ûÅ·üÇ', '26 days = ·ûò·ûΩ·ûô·ûÅ·üÇ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true), '·ûò·ûΩ·ûô·ûÅ·üÇ', '30 days = ·ûò·ûΩ·ûô·ûÅ·üÇ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true), '·ûò·ûΩ·ûô·ûÅ·üÇ', '43 days = ·ûò·ûΩ·ûô·ûÅ·üÇ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true), '2 ·ûÅ·üÇ', '46 days = 2 ·ûÅ·üÇ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true), '2 ·ûÅ·üÇ', '75 days = 2 ·ûÅ·üÇ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true), '3 ·ûÅ·üÇ', '76 days = 3 ·ûÅ·üÇ');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true), '·ûò·ûΩ·ûô·ûÅ·üÇ', '1 month = ·ûò·ûΩ·ûô·ûÅ·üÇ');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true), '5 ·ûÅ·üÇ', '5 months = 5 ·ûÅ·üÇ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '·ûò·ûΩ·ûô·ûÜ·üí·ûì·û∂·üÜ', '345 days = ·ûò·ûΩ·ûô·ûÜ·üí·ûì·û∂·üÜ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ·ûÜ·üí·ûì·û∂·üÜ', '548 days = 2 ·ûÜ·üí·ûì·û∂·üÜ');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true), '·ûò·ûΩ·ûô·ûÜ·üí·ûì·û∂·üÜ', '1 year = ·ûò·ûΩ·ûô·ûÜ·üí·ûì·û∂·üÜ');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true), '5 ·ûÜ·üí·ûì·û∂·üÜ', '5 years = 5 ·ûÜ·üí·ûì·û∂·üÜ');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '·ûî·üâ·ûª·ûì·üí·ûò·û∂·ûì·ûú·û∑·ûì·û∂·ûë·û∏·ûë·üÄ·ûè', 'prefix');
        assert.equal(moment(0).from(30000), '·ûî·üâ·ûª·ûì·üí·ûò·û∂·ûì·ûú·û∑·ûì·û∂·ûë·û∏·ûò·ûª·ûì', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '·ûî·üâ·ûª·ûì·üí·ûò·û∂·ûì·ûú·û∑·ûì·û∂·ûë·û∏·ûò·ûª·ûì', 'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({
            s: 30
        }).fromNow(), '·ûî·üâ·ûª·ûì·üí·ûò·û∂·ûì·ûú·û∑·ûì·û∂·ûë·û∏·ûë·üÄ·ûè', 'in a few seconds');
        assert.equal(moment().add({
            d: 5
        }).fromNow(), '5 ·ûê·üí·ûÑ·üÉ·ûë·üÄ·ûè', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(), '·ûê·üí·ûÑ·üÉ·ûì·üà ·ûò·üâ·üÑ·ûÑ 02:00', 'today at the same time');
        assert.equal(moment(a).add({
            m: 25
        }).calendar(), '·ûê·üí·ûÑ·üÉ·ûì·üà ·ûò·üâ·üÑ·ûÑ 02:25', 'Now plus 25 min');
        assert.equal(moment(a).add({
            h: 1
        }).calendar(), '·ûê·üí·ûÑ·üÉ·ûì·üà ·ûò·üâ·üÑ·ûÑ 03:00', 'Now plus 1 hour');
        assert.equal(moment(a).add({
            d: 1
        }).calendar(), '·ûü·üí·û¢·üÇ·ûÄ ·ûò·üâ·üÑ·ûÑ 02:00', 'tomorrow at the same time');
        assert.equal(moment(a).subtract({
            h: 1
        }).calendar(), '·ûê·üí·ûÑ·üÉ·ûì·üà ·ûò·üâ·üÑ·ûÑ 01:00', 'Now minus 1 hour');
        assert.equal(moment(a).subtract({
            d: 1
        }).calendar(), '·ûò·üí·ûü·û∑·ûõ·ûò·û∑·ûâ ·ûò·üâ·üÑ·ûÑ 02:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({
                d: i
            });
            assert.equal(m.calendar(), m.format('dddd [·ûò·üâ·üÑ·ûÑ] LT'), 'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format('dddd [·ûò·üâ·üÑ·ûÑ] LT'), 'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format('dddd [·ûò·üâ·üÑ·ûÑ] LT'), 'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({
                d: i
            });
            assert.equal(m.calendar(), m.format('dddd [·ûü·ûî·üí·ûè·û∂·û†·üç·ûò·ûª·ûì] [·ûò·üâ·üÑ·ûÑ] LT'), 'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format('dddd [·ûü·ûî·üí·ûè·û∂·û†·üç·ûò·ûª·ûì] [·ûò·üâ·üÑ·ûÑ] LT'), 'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format('dddd [·ûü·ûî·üí·ûè·û∂·û†·üç·ûò·ûª·ûì] [·ûò·üâ·üÑ·ûÑ] LT'), 'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({
                w: 1
            }),
            weeksFromNow = moment().add({
                w: 1
            });

        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '1 week ago');
        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), 'in 1 week');

        weeksAgo = moment().subtract({
            w: 2
        });
        weeksFromNow = moment().add({
            w: 2
        });

        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '2 weeks ago');
        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), 'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(), 1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(), 1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(), 2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(), 1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(), 2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008, 0, 1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008, 0, 6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008, 0, 7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008, 0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008, 0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003, 0, 1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003, 0, 5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003, 0, 6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003, 0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003, 0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009, 0, 1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009, 0, 4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009, 0, 5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009, 0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009, 0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010, 0, 1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010, 0, 3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010, 0, 4]).week(), 1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010, 0, 10]).week(), 1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010, 0, 11]).week(), 2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011, 0, 1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011, 0, 2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011, 0, 3]).week(), 1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011, 0, 9]).week(), 1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011, 0, 10]).week(), 2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0, 1]).format('w ww wo'), '52 52 52', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).format('w ww wo'), '1 01 1', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).format('w ww wo'), '1 01 1', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).format('w ww wo'), '2 02 2', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '2 02 2', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('ko');

    test('parse', function (assert) {
        var tests = '1Ïõî 1Ïõî_2Ïõî 2Ïõî_3Ïõî 3Ïõî_4Ïõî 4Ïõî_5Ïõî 5Ïõî_6Ïõî 6Ïõî_7Ïõî 7Ïõî_8Ïõî 8Ïõî_9Ïõî 9Ïõî_10Ïõî 10Ïõî_11Ïõî 11Ïõî_12Ïõî 12Ïõî'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('parse meridiem', function (assert) {
        var elements = [{
            expression : '1981ÎÖÑ 9Ïõî 8Ïùº Ïò§ÌõÑ 2Ïãú 30Î∂Ñ',
            inputFormat : 'YYYY[ÎÖÑ] M[Ïõî] D[Ïùº] A h[Ïãú] m[Î∂Ñ]',
            outputFormat : 'A',
            expected : 'Ïò§ÌõÑ'
        }, {
            expression : '1981ÎÖÑ 9Ïõî 8Ïùº Ïò§Ï†Ñ 2Ïãú 30Î∂Ñ',
            inputFormat : 'YYYY[ÎÖÑ] M[Ïõî] D[Ïùº] A h[Ïãú] m[Î∂Ñ]',
            outputFormat : 'A hÏãú',
            expected : 'Ïò§Ï†Ñ 2Ïãú'
        }, {
            expression : '14Ïãú 30Î∂Ñ',
            inputFormat : 'H[Ïãú] m[Î∂Ñ]',
            outputFormat : 'A',
            expected : 'Ïò§ÌõÑ'
        }, {
            expression : 'Ïò§ÌõÑ 4Ïãú',
            inputFormat : 'A h[Ïãú]',
            outputFormat : 'H',
            expected : '16'
        }], i, l, it, actual;


        for (i = 0, l = elements.length; i < l; ++i) {
            it = elements[i];
            actual = moment(it.expression, it.inputFormat).format(it.outputFormat);

            assert.equal(
                actual,
                it.expected,
                '\'' + it.outputFormat + '\' of \'' + it.expression + '\' must be \'' + it.expected + '\' but was \'' + actual + '\'.'
            );
        }
    });

    test('format', function (assert) {
        var a = [
                ['YYYYÎÖÑ MMMM Do dddd a h:mm:ss',      '2010ÎÖÑ 2Ïõî 14Ïùº ÏùºÏöîÏùº Ïò§ÌõÑ 3:25:50'],
                ['ddd A h',                            'Ïùº Ïò§ÌõÑ 3'],
                ['M Mo MM MMMM MMM',                   '2 2Ïùº 02 2Ïõî 2Ïõî'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14Ïùº 14'],
                ['d do dddd ddd dd',                   '0 0Ïùº ÏùºÏöîÏùº Ïùº Ïùº'],
                ['DDD DDDo DDDD',                      '45 45Ïùº 045'],
                ['w wo ww',                            '8 8Ïùº 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'Ïò§ÌõÑ Ïò§ÌõÑ'],
                ['ÏùºÎÖÑ Ï§ë DDDoÏß∏ ÎêòÎäî ÎÇ†',                 'ÏùºÎÖÑ Ï§ë 45ÏùºÏß∏ ÎêòÎäî ÎÇ†'],
                ['LTS',                                'Ïò§ÌõÑ 3Ïãú 25Î∂Ñ 50Ï¥à'],
                ['L',                                  '2010.02.14'],
                ['LL',                                 '2010ÎÖÑ 2Ïõî 14Ïùº'],
                ['LLL',                                '2010ÎÖÑ 2Ïõî 14Ïùº Ïò§ÌõÑ 3Ïãú 25Î∂Ñ'],
                ['LLLL',                               '2010ÎÖÑ 2Ïõî 14Ïùº ÏùºÏöîÏùº Ïò§ÌõÑ 3Ïãú 25Î∂Ñ'],
                ['l',                                  '2010.2.14'],
                ['ll',                                 '2010ÎÖÑ 2Ïõî 14Ïùº'],
                ['lll',                                '2010ÎÖÑ 2Ïõî 14Ïùº Ïò§ÌõÑ 3Ïãú 25Î∂Ñ'],
                ['llll',                               '2010ÎÖÑ 2Ïõî 14Ïùº Ïùº Ïò§ÌõÑ 3Ïãú 25Î∂Ñ']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1Ïùº', '1Ïùº');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2Ïùº', '2Ïùº');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3Ïùº', '3Ïùº');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4Ïùº', '4Ïùº');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5Ïùº', '5Ïùº');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6Ïùº', '6Ïùº');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7Ïùº', '7Ïùº');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8Ïùº', '8Ïùº');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9Ïùº', '9Ïùº');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10Ïùº', '10Ïùº');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11Ïùº', '11Ïùº');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12Ïùº', '12Ïùº');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13Ïùº', '13Ïùº');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14Ïùº', '14Ïùº');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15Ïùº', '15Ïùº');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16Ïùº', '16Ïùº');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17Ïùº', '17Ïùº');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18Ïùº', '18Ïùº');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19Ïùº', '19Ïùº');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20Ïùº', '20Ïùº');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21Ïùº', '21Ïùº');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22Ïùº', '22Ïùº');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23Ïùº', '23Ïùº');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24Ïùº', '24Ïùº');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25Ïùº', '25Ïùº');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26Ïùº', '26Ïùº');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27Ïùº', '27Ïùº');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28Ïùº', '28Ïùº');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29Ïùº', '29Ïùº');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30Ïùº', '30Ïùº');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31Ïùº', '31Ïùº');
    });

    test('format month', function (assert) {
        var expected = '1Ïõî 1Ïõî_2Ïõî 2Ïõî_3Ïõî 3Ïõî_4Ïõî 4Ïõî_5Ïõî 5Ïõî_6Ïõî 6Ïõî_7Ïõî 7Ïõî_8Ïõî 8Ïõî_9Ïõî 9Ïõî_10Ïõî 10Ïõî_11Ïõî 11Ïõî_12Ïõî 12Ïõî'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'ÏùºÏöîÏùº Ïùº Ïùº_ÏõîÏöîÏùº Ïõî Ïõî_ÌôîÏöîÏùº Ìôî Ìôî_ÏàòÏöîÏùº Ïàò Ïàò_Î™©ÏöîÏùº Î™© Î™©_Í∏àÏöîÏùº Í∏à Í∏à_ÌÜ†ÏöîÏùº ÌÜ† ÌÜ†'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'Î™áÏ¥à', '44Ï¥à = Î™áÏ¥à');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ÏùºÎ∂Ñ',      '45Ï¥à = ÏùºÎ∂Ñ');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ÏùºÎ∂Ñ',      '89Ï¥à = ÏùºÎ∂Ñ');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2Î∂Ñ',     '90Ï¥à = 2Î∂Ñ');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44Î∂Ñ',    '44Î∂Ñ = 44Î∂Ñ');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ÌïúÏãúÍ∞Ñ',       '45Î∂Ñ = ÌïúÏãúÍ∞Ñ');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ÌïúÏãúÍ∞Ñ',       '89Î∂Ñ = ÌïúÏãúÍ∞Ñ');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2ÏãúÍ∞Ñ',       '90Î∂Ñ = 2ÏãúÍ∞Ñ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5ÏãúÍ∞Ñ',       '5ÏãúÍ∞Ñ = 5ÏãúÍ∞Ñ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21ÏãúÍ∞Ñ',      '21ÏãúÍ∞Ñ = 21ÏãúÍ∞Ñ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ÌïòÎ£®',         '22ÏãúÍ∞Ñ = ÌïòÎ£®');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ÌïòÎ£®',         '35ÏãúÍ∞Ñ = ÌïòÎ£®');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2Ïùº',        '36ÏãúÍ∞Ñ = 2Ïùº');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ÌïòÎ£®',         'ÌïòÎ£® = ÌïòÎ£®');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5Ïùº',        '5Ïùº = 5Ïùº');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25Ïùº',       '25Ïùº = 25Ïùº');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ÌïúÎã¨',       '26Ïùº = ÌïúÎã¨');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ÌïúÎã¨',       '30Ïùº = ÌïúÎã¨');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ÌïúÎã¨',       '45Ïùº = ÌïúÎã¨');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2Îã¨',      '46Ïùº = 2Îã¨');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2Îã¨',      '75Ïùº = 2Îã¨');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3Îã¨',      '76Ïùº = 3Îã¨');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ÌïúÎã¨',       '1Îã¨ = ÌïúÎã¨');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5Îã¨',      '5Îã¨ = 5Îã¨');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ÏùºÎÖÑ',        '345Ïùº = ÏùºÎÖÑ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2ÎÖÑ',       '548Ïùº = 2ÎÖÑ');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'ÏùºÎÖÑ',        'ÏùºÎÖÑ = ÏùºÎÖÑ');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5ÎÖÑ',       '5ÎÖÑ = 5ÎÖÑ');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'Î™áÏ¥à ÌõÑ',  'prefix');
        assert.equal(moment(0).from(30000), 'Î™áÏ¥à Ï†Ñ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'Î™áÏ¥à Ï†Ñ',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'Î™áÏ¥à ÌõÑ', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5Ïùº ÌõÑ', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Ïò§Îäò Ïò§Ï†Ñ 2Ïãú 0Î∂Ñ',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Ïò§Îäò Ïò§Ï†Ñ 2Ïãú 25Î∂Ñ',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Ïò§Îäò Ïò§Ï†Ñ 3Ïãú 0Î∂Ñ',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'ÎÇ¥Ïùº Ïò§Ï†Ñ 2Ïãú 0Î∂Ñ',     'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Ïò§Îäò Ïò§Ï†Ñ 1Ïãú 0Î∂Ñ',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Ïñ¥Ï†ú Ïò§Ï†Ñ 2Ïãú 0Î∂Ñ',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('ÏßÄÎÇúÏ£º dddd LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('ÏßÄÎÇúÏ£º dddd LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('ÏßÄÎÇúÏ£º dddd LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1Ïùº', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1Ïùº', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2Ïùº', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2Ïùº', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3Ïùº', 'Jan 15 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('lb');

    test('parse', function (assert) {
        var tests = 'Januar Jan._Februar Febr._M√§erz Mrz._Abr√´ll Abr._Mee Mee_Juni Jun._Juli Jul._August Aug._September Sept._Oktober Okt._November Nov._Dezember Dez.'.split('_'), i;

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, HH:mm:ss', 'Sonndeg, 14. Februar 2010, 15:25:50'],
                ['ddd, HH:mm', 'So., 15:25'],
                ['M Mo MM MMMM MMM', '2 2. 02 Februar Febr.'],
                ['YYYY YY', '2010 10'],
                ['D Do DD', '14 14. 14'],
                ['d do dddd ddd dd', '0 0. Sonndeg So. So'],
                ['DDD DDDo DDDD', '45 45. 045'],
                ['w wo ww', '6 6. 06'],
                ['h hh', '3 03'],
                ['H HH', '15 15'],
                ['m mm', '25 25'],
                ['s ss', '50 50'],
                ['a A', 'pm PM'],
                ['[the] DDDo [day of the year]', 'the 45. day of the year'],
                ['LTS', '15:25:50 Auer'],
                ['L', '14.02.2010'],
                ['LL', '14. Februar 2010'],
                ['LLL', '14. Februar 2010 15:25 Auer'],
                ['LLLL', 'Sonndeg, 14. Februar 2010 15:25 Auer'],
                ['l', '14.2.2010'],
                ['ll', '14. Febr. 2010'],
                ['lll', '14. Febr. 2010 15:25 Auer'],
                ['llll', 'So., 14. Febr. 2010 15:25 Auer']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format month', function (assert) {
        var expected = 'Januar Jan._Februar Febr._M√§erz Mrz._Abr√´ll Abr._Mee Mee_Juni Jun._Juli Jul._August Aug._September Sept._Oktober Okt._November Nov._Dezember Dez.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Sonndeg So. So_M√©indeg M√©. M√©_D√´nschdeg D√´. D√´_M√´ttwoch M√´. M√´_Donneschdeg Do. Do_Freideg Fr. Fr_Samschdeg Sa. Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true), 'e puer Sekonnen', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true), 'eng Minutt', '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true), 'eng Minutt', '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true), '2 Minutten', '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true), '44 Minutten', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true), 'eng Stonn', '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true), 'eng Stonn', '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true), '2 Stonnen', '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true), '5 Stonnen', '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true), '21 Stonnen', '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true), 'een Dag', '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true), 'een Dag', '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true), '2 Deeg', '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true), 'een Dag', '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true), '5 Deeg', '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true), '25 Deeg', '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true), 'ee Mount', '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true), 'ee Mount', '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true), 'ee Mount', '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true), '2 M√©int', '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true), '2 M√©int', '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true), '3 M√©int', '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true), 'ee Mount', '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true), '5 M√©int', '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ee Joer', '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Joer', '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true), 'ee Joer', '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true), '5 Joer', '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'an e puer Sekonnen', 'prefix');
        assert.equal(moment(0).from(30000), 'virun e puer Sekonnen', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'an e puer Sekonnen', 'in a few seconds');
        assert.equal(moment().add({d: 1}).fromNow(), 'an engem Dag', 'in one day');
        assert.equal(moment().add({d: 2}).fromNow(), 'an 2 Deeg', 'in 2 days');
        assert.equal(moment().add({d: 3}).fromNow(), 'an 3 Deeg', 'in 3 days');
        assert.equal(moment().add({d: 4}).fromNow(), 'a 4 Deeg', 'in 4 days');
        assert.equal(moment().add({d: 5}).fromNow(), 'a 5 Deeg', 'in 5 days');
        assert.equal(moment().add({d: 6}).fromNow(), 'a 6 Deeg', 'in 6 days');
        assert.equal(moment().add({d: 7}).fromNow(), 'a 7 Deeg', 'in 7 days');
        assert.equal(moment().add({d: 8}).fromNow(), 'an 8 Deeg', 'in 8 days');
        assert.equal(moment().add({d: 9}).fromNow(), 'an 9 Deeg', 'in 9 days');
        assert.equal(moment().add({d: 10}).fromNow(), 'an 10 Deeg', 'in 10 days');
        assert.equal(moment().add({y: 100}).fromNow(), 'an 100 Joer', 'in 100 years');
        assert.equal(moment().add({y: 400}).fromNow(), 'a 400 Joer', 'in 400 years');
    });

    test('calendar last week', function (assert) {
        var i, m, weekday, datestring;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});

            // Different date string for 'D√´nschdeg' (Tuesday) and 'Donneschdeg' (Thursday)
            weekday = parseInt(m.format('d'), 10);
            datestring = (weekday === 2 || weekday === 4 ? '[Leschten] dddd [um] LT' : '[Leschte] dddd [um] LT');

            assert.equal(m.calendar(), m.format(datestring), 'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format(datestring), 'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format(datestring), 'Today + ' + i + ' days end of day');
        }
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('lt');

    test('parse', function (assert) {
        var tests = 'sausio sau_vasario vas_kovo kov_baland≈æio bal_gegu≈æƒós geg_bir≈æelio bir_liepos lie_rugpj≈´ƒçio rgp_rugsƒójo rgs_spalio spa_lapkriƒçio lap_gruod≈æio grd'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'sekmadienis, 14-oji vasario 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Sek, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2-oji 02 vasario vas'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14-oji 14'],
                ['d do dddd ddd dd',                   '0 0-oji sekmadienis Sek S'],
                ['DDD DDDo DDDD',                      '45 45-oji 045'],
                ['w wo ww',                            '6 6-oji 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['DDDo [met≈≥ diena]',                  '45-oji met≈≥ diena'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '2010-02-14'],
                ['LL',                                 '2010 m. vasario 14 d.'],
                ['LLL',                                '2010 m. vasario 14 d., 15:25 val.'],
                ['LLLL',                               '2010 m. vasario 14 d., sekmadienis, 15:25 val.'],
                ['l',                                  '2010-02-14'],
                ['ll',                                 '2010 m. vasario 14 d.'],
                ['lll',                                '2010 m. vasario 14 d., 15:25 val.'],
                ['llll',                               '2010 m. vasario 14 d., Sek, 15:25 val.']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-oji', '1-oji');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-oji', '2-oji');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-oji', '3-oji');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-oji', '4-oji');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-oji', '5-oji');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-oji', '6-oji');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-oji', '7-oji');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-oji', '8-oji');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-oji', '9-oji');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-oji', '10-oji');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-oji', '11-oji');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-oji', '12-oji');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-oji', '13-oji');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-oji', '14-oji');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-oji', '15-oji');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-oji', '16-oji');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-oji', '17-oji');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-oji', '18-oji');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-oji', '19-oji');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-oji', '20-oji');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-oji', '21-oji');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-oji', '22-oji');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-oji', '23-oji');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-oji', '24-oji');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-oji', '25-oji');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-oji', '26-oji');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-oji', '27-oji');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-oji', '28-oji');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-oji', '29-oji');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-oji', '30-oji');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-oji', '31-oji');
    });

    test('format month', function (assert) {
        var expected = 'sausio sau_vasario vas_kovo kov_baland≈æio bal_gegu≈æƒós geg_bir≈æelio bir_liepos lie_rugpj≈´ƒçio rgp_rugsƒójo rgs_spalio spa_lapkriƒçio lap_gruod≈æio grd'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'sekmadienis Sek S_pirmadienis Pir P_antradienis Ant A_treƒçiadienis Tre T_ketvirtadienis Ket K_penktadienis Pen Pn_≈°e≈°tadienis ≈†e≈° ≈†'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('format week on US calendar', function (assert) {
        // Tests, whether the weekday names are correct, even if the week does not start on Monday
        moment.locale('lt', {week: {dow: 0, doy: 6}});
        var expected = 'sekmadienis Sek S_pirmadienis Pir P_antradienis Ant A_treƒçiadienis Tre T_ketvirtadienis Ket K_penktadienis Pen Pn_≈°e≈°tadienis ≈†e≈° ≈†'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
        moment.locale('lt', {week: {dow: 1, doy: 4}});
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'kelios sekundƒós', '44 seconds = seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'minutƒó',          '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'minutƒó',          '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutƒós',       '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 10}), true),  '10 minuƒçi≈≥',       '10 minutes = 10 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 11}), true),  '11 minuƒçi≈≥',       '11 minutes = 11 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 19}), true),  '19 minuƒçi≈≥',       '19 minutes = 19 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 20}), true),  '20 minuƒçi≈≥',       '20 minutes = 20 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutƒós',      '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'valanda',         '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'valanda',         '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 valandos',      '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 valandos',      '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 10}), true),  '10 valand≈≥',      '10 hours = 10 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 valandos',     '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'diena',           '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'diena',           '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dienos',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'diena',           '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dienos',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 10}), true),  '10 dien≈≥',        '10 days = 10 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dienos',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mƒónuo',           '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mƒónuo',           '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mƒónuo',           '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mƒónesiai',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mƒónesiai',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mƒónesiai',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mƒónuo',           '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mƒónesiai',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 10}), true),  '10 mƒónesi≈≥',      '10 months = 10 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'metai',           '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 metai',         '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'metai',           '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 metai',         '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'po keli≈≥ sekund≈æi≈≥',  'prefix');
        assert.equal(moment(0).from(30000), 'prie≈° kelias sekundes', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'prie≈° kelias sekundes',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'po keli≈≥ sekund≈æi≈≥', 'in seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'po 5 dien≈≥', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '≈†iandien 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '≈†iandien 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '≈†iandien 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Rytoj 02:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '≈†iandien 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Vakar 02:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[PraƒójusƒØ] dddd LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[PraƒójusƒØ] dddd LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[PraƒójusƒØ] dddd LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52-oji', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),  '1 01 1-oji', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),  '1 01 1-oji', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),  '2 02 2-oji', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),  '2 02 2-oji', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('lv');

    test('parse', function (assert) {
        var tests = 'janvƒÅris jan_februƒÅris feb_marts mar_aprƒ´lis apr_maijs mai_j≈´nijs j≈´n_j≈´lijs j≈´l_augusts aug_septembris sep_oktobris okt_novembris nov_decembris dec'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'svƒìtdiena, 14. februƒÅris 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Sv, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 februƒÅris feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. svƒìtdiena Sv Sv'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010.'],
                ['LL',                                 '2010. gada 14. februƒÅris'],
                ['LLL',                                '2010. gada 14. februƒÅris, 15:25'],
                ['LLLL',                               '2010. gada 14. februƒÅris, svƒìtdiena, 15:25'],
                ['l',                                  '14.2.2010.'],
                ['ll',                                 '2010. gada 14. feb'],
                ['lll',                                '2010. gada 14. feb, 15:25'],
                ['llll',                               '2010. gada 14. feb, Sv, 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'janvƒÅris jan_februƒÅris feb_marts mar_aprƒ´lis apr_maijs mai_j≈´nijs j≈´n_j≈´lijs j≈´l_augusts aug_septembris sep_oktobris okt_novembris nov_decembris dec'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'svƒìtdiena Sv Sv_pirmdiena P P_otrdiena O O_tre≈°diena T T_ceturtdiena C C_piektdiena Pk Pk_sestdiena S S'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    // Includes testing the cases of withoutSuffix = true and false.
    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),   'da≈æas sekundes',       '44 seconds = seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), false),  'pirms da≈æƒÅm sekundƒìm', '44 seconds with suffix = seconds ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),   'min≈´te',               '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), false),  'pirms min≈´tes',        '45 seconds with suffix = a minute ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),   'min≈´te',               '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: -89}), false), 'pƒìc min≈´tes',          '89 seconds with suffix/prefix = in a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),   '2 min≈´tes',            '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), false),  'pirms 2 min≈´tƒìm',      '90 seconds with suffix = 2 minutes ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),   '44 min≈´tes',           '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), false),  'pirms 44 min≈´tƒìm',     '44 minutes with suffix = 44 minutes ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),   'stunda',               '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), false),  'pirms stundas',        '45 minutes with suffix = an hour ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),   'stunda',               '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),   '2 stundas',            '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: -90}), false), 'pƒìc 2 stundƒÅm',        '90 minutes with suffix = in 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),    '5 stundas',            '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), false),   'pirms 5 stundƒÅm',      '5 hours with suffix = 5 hours ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),   '21 stunda',            '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), false),  'pirms 21 stundas',     '21 hours with suffix = 21 hours ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),   'diena',                '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), false),  'pirms dienas',         '22 hours with suffix = a day ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),   'diena',                '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),   '2 dienas',             '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), false),  'pirms 2 dienƒÅm',       '36 hours with suffix = 2 days ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),    'diena',                '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),    '5 dienas',             '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), false),   'pirms 5 dienƒÅm',       '5 days with suffix = 5 days ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),   '25 dienas',            '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), false),  'pirms 25 dienƒÅm',      '25 days with suffix = 25 days ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),   'mƒìnesis',              '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), false),  'pirms mƒìne≈°a',         '26 days with suffix = a month ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),   'mƒìnesis',              '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),   'mƒìnesis',              '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),   '2 mƒìne≈°i',             '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), false),  'pirms 2 mƒìne≈°iem',     '46 days with suffix = 2 months ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),   '2 mƒìne≈°i',             '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),   '3 mƒìne≈°i',             '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), false),  'pirms 3 mƒìne≈°iem',     '76 days with suffix = 3 months ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),    'mƒìnesis',              '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),    '5 mƒìne≈°i',             '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), false),   'pirms 5 mƒìne≈°iem',     '5 months with suffix = 5 months ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true),  'gads',                 '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), false), 'pirms gada',           '345 days with suffix = a year ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true),  '2 gadi',               '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), false), 'pirms 2 gadiem',       '548 days with suffix = 2 years ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),    'gads',                 '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),    '5 gadi',               '5 years = 5 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), false),   'pirms 5 gadiem',       '5 years with suffix = 5 years ago');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'pƒìc da≈æƒÅm sekundƒìm',  'prefix');
        assert.equal(moment(0).from(30000), 'pirms da≈æƒÅm sekundƒìm', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'pirms da≈æƒÅm sekundƒìm',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'pƒìc da≈æƒÅm sekundƒìm', 'in seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'pƒìc 5 dienƒÅm', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '≈†odien pulksten 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '≈†odien pulksten 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '≈†odien pulksten 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Rƒ´t pulksten 02:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '≈†odien pulksten 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Vakar pulksten 02:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [pulksten] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [pulksten] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [pulksten] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[PagƒÅju≈°ƒÅ] dddd [pulksten] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[PagƒÅju≈°ƒÅ] dddd [pulksten] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[PagƒÅju≈°ƒÅ] dddd [pulksten] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),  '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),  '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),  '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),  '2 02 2.', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('me');

    test('parse', function (assert) {
        var tests = 'januar jan._februar feb._mart mar._april apr._maj maj_jun jun_jul jul_avgust avg._septembar sep._oktobar okt._novembar nov._decembar dec.'.split('_'),
            i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'nedjelja, 14. februar 2010, 3:25:50 pm'],
                ['ddd, hA',                            'ned., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. nedjelja ned. ne'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '7 7. 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14. 02. 2010'],
                ['LL',                                 '14. februar 2010'],
                ['LLL',                                '14. februar 2010 15:25'],
                ['LLLL',                               'nedjelja, 14. februar 2010 15:25'],
                ['l',                                  '14. 2. 2010'],
                ['ll',                                 '14. feb. 2010'],
                ['lll',                                '14. feb. 2010 15:25'],
                ['llll',                               'ned., 14. feb. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'januar jan._februar feb._mart mar._april apr._maj maj_jun jun_jul jul_avgust avg._septembar sep._oktobar okt._novembar nov._decembar dec.'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'nedjelja ned. ne_ponedjeljak pon. po_utorak uto. ut_srijeda sri. sr_ƒçetvrtak ƒçet. ƒçe_petak pet. pe_subota sub. su'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'nekoliko sekundi', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'jedan minut',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'jedan minut',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuta',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuta',     '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'jedan sat',      '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'jedan sat',      '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 sata',        '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 sati',         '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 sati',        '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'dan',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'dan',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dana',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'dan',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dana',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dana',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mjesec',     '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mjesec',     '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mjesec',     '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mjeseca',     '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mjeseca',     '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mjeseca',     '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mjesec',     '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mjeseci',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'godinu',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 godine',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'godinu',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 godina',        '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'za nekoliko sekundi',  'prefix');
        assert.equal(moment(0).from(30000), 'prije nekoliko sekundi', 'prefix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'prije nekoliko sekundi',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'za nekoliko sekundi', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'za 5 dana', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'danas u 2:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'danas u 2:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'danas u 3:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'sjutra u 2:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'danas u 1:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'juƒçe u 2:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
                return '[u] [nedjelju] [u] LT';
            case 3:
                return '[u] [srijedu] [u] LT';
            case 6:
                return '[u] [subotu] [u] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[u] dddd [u] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            var lastWeekDay = [
                    '[pro≈°le] [nedjelje] [u] LT',
                    '[pro≈°log] [ponedjeljka] [u] LT',
                    '[pro≈°log] [utorka] [u] LT',
                    '[pro≈°le] [srijede] [u] LT',
                    '[pro≈°log] [ƒçetvrtka] [u] LT',
                    '[pro≈°log] [petka] [u] LT',
                    '[pro≈°le] [subote] [u] LT'
                ];

            return lastWeekDay[d.day()];
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    // Monday is the first day of the week.
    // The week that contains Jan 1st is the first week of the year.

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('mk');

    test('parse', function (assert) {
        var tests = '—ò–∞–Ω—É–∞—Ä–∏ —ò–∞–Ω_—Ñ–µ–≤—Ä—É–∞—Ä–∏ —Ñ–µ–≤_–º–∞—Ä—Ç –º–∞—Ä_–∞–ø—Ä–∏–ª –∞–ø—Ä_–º–∞—ò –º–∞—ò_—ò—É–Ω–∏ —ò—É–Ω_—ò—É–ª–∏ —ò—É–ª_–∞–≤–≥—É—Å—Ç –∞–≤–≥_—Å–µ–ø—Ç–µ–º–≤—Ä–∏ —Å–µ–ø_–æ–∫—Ç–æ–º–≤—Ä–∏ –æ–∫—Ç_–Ω–æ–µ–º–≤—Ä–∏ –Ω–æ–µ_–¥–µ–∫–µ–º–≤—Ä–∏ –¥–µ–∫'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, H:mm:ss',        '–Ω–µ–¥–µ–ª–∞, —Ñ–µ–≤—Ä—É–∞—Ä–∏ 14-—Ç–∏ 2010, 15:25:50'],
                ['ddd, hA',                            '–Ω–µ–¥, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2-—Ä–∏ 02 —Ñ–µ–≤—Ä—É–∞—Ä–∏ —Ñ–µ–≤'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14-—Ç–∏ 14'],
                ['d do dddd ddd dd',                   '0 0-–µ–≤ –Ω–µ–¥–µ–ª–∞ –Ω–µ–¥ –Ωe'],
                ['DDD DDDo DDDD',                      '45 45-—Ç–∏ 045'],
                ['w wo ww',                            '7 7-–º–∏ 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45-—Ç–∏ day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14 —Ñ–µ–≤—Ä—É–∞—Ä–∏ 2010'],
                ['LLL',                                '14 —Ñ–µ–≤—Ä—É–∞—Ä–∏ 2010 15:25'],
                ['LLLL',                               '–Ω–µ–¥–µ–ª–∞, 14 —Ñ–µ–≤—Ä—É–∞—Ä–∏ 2010 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14 —Ñ–µ–≤ 2010'],
                ['lll',                                '14 —Ñ–µ–≤ 2010 15:25'],
                ['llll',                               '–Ω–µ–¥, 14 —Ñ–µ–≤ 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-–≤–∏', '1-–≤–∏');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-—Ä–∏', '2-—Ä–∏');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-—Ç–∏', '3-—Ç–∏');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-—Ç–∏', '4-—Ç–∏');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-—Ç–∏', '5-—Ç–∏');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-—Ç–∏', '6-—Ç–∏');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-–º–∏', '7-–º–∏');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-–º–∏', '8-–º–∏');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-—Ç–∏', '9-—Ç–∏');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-—Ç–∏', '10-—Ç–∏');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-—Ç–∏', '11-—Ç–∏');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-—Ç–∏', '12-—Ç–∏');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-—Ç–∏', '13-—Ç–∏');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-—Ç–∏', '14-—Ç–∏');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-—Ç–∏', '15-—Ç–∏');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-—Ç–∏', '16-—Ç–∏');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-—Ç–∏', '17-—Ç–∏');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-—Ç–∏', '18-—Ç–∏');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-—Ç–∏', '19-—Ç–∏');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-—Ç–∏', '20-—Ç–∏');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-–≤–∏', '21-–≤–∏');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-—Ä–∏', '22-—Ä–∏');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-—Ç–∏', '23-—Ç–∏');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-—Ç–∏', '24-—Ç–∏');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-—Ç–∏', '25-—Ç–∏');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-—Ç–∏', '26-—Ç–∏');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-–º–∏', '27-–º–∏');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-–º–∏', '28-–º–∏');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-—Ç–∏', '29-—Ç–∏');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-—Ç–∏', '30-—Ç–∏');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-–≤–∏', '31-–≤–∏');
    });

    test('format month', function (assert) {
        var expected = '—ò–∞–Ω—É–∞—Ä–∏ —ò–∞–Ω_—Ñ–µ–≤—Ä—É–∞—Ä–∏ —Ñ–µ–≤_–º–∞—Ä—Ç –º–∞—Ä_–∞–ø—Ä–∏–ª –∞–ø—Ä_–º–∞—ò –º–∞—ò_—ò—É–Ω–∏ —ò—É–Ω_—ò—É–ª–∏ —ò—É–ª_–∞–≤–≥—É—Å—Ç –∞–≤–≥_—Å–µ–ø—Ç–µ–º–≤—Ä–∏ —Å–µ–ø_–æ–∫—Ç–æ–º–≤—Ä–∏ –æ–∫—Ç_–Ω–æ–µ–º–≤—Ä–∏ –Ω–æ–µ_–¥–µ–∫–µ–º–≤—Ä–∏ –¥–µ–∫'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '–Ω–µ–¥–µ–ª–∞ –Ω–µ–¥ –Ωe_–ø–æ–Ω–µ–¥–µ–ª–Ω–∏–∫ –ø–æ–Ω –øo_–≤—Ç–æ—Ä–Ω–∏–∫ –≤—Ç–æ –≤—Ç_—Å—Ä–µ–¥–∞ —Å—Ä–µ —Å—Ä_—á–µ—Ç–≤—Ä—Ç–æ–∫ —á–µ—Ç —á–µ_–ø–µ—Ç–æ–∫ –ø–µ—Ç –ø–µ_—Å–∞–±–æ—Ç–∞ —Å–∞–± —Åa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '–Ω–µ–∫–æ–ª–∫—É —Å–µ–∫—É–Ω–¥–∏', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '–º–∏–Ω—É—Ç–∞',          '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '–º–∏–Ω—É—Ç–∞',          '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 –º–∏–Ω—É—Ç–∏',        '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 –º–∏–Ω—É—Ç–∏',       '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '—á–∞—Å',             '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '—á–∞—Å',             '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 —á–∞—Å–∞',          '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 —á–∞—Å–∞',          '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 —á–∞—Å–∞',         '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '–¥–µ–Ω',             '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '–¥–µ–Ω',             '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 –¥–µ–Ω–∞',          '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '–¥–µ–Ω',             '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 –¥–µ–Ω–∞',          '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 –¥–µ–Ω–∞',         '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '–º–µ—Å–µ—Ü',           '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '–º–µ—Å–µ—Ü',           '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '–º–µ—Å–µ—Ü',           '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 –º–µ—Å–µ—Ü–∏',        '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 –º–µ—Å–µ—Ü–∏',        '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 –º–µ—Å–µ—Ü–∏',        '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '–º–µ—Å–µ—Ü',           '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 –º–µ—Å–µ—Ü–∏',        '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '–≥–æ–¥–∏–Ω–∞',          '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 –≥–æ–¥–∏–Ω–∏',        '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '–≥–æ–¥–∏–Ω–∞',          '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 –≥–æ–¥–∏–Ω–∏',        '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '–ø–æ—Å–ª–µ –Ω–µ–∫–æ–ª–∫—É —Å–µ–∫—É–Ω–¥–∏',  'prefix');
        assert.equal(moment(0).from(30000), '–ø—Ä–µ–¥ –Ω–µ–∫–æ–ª–∫—É —Å–µ–∫—É–Ω–¥–∏', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '–ø—Ä–µ–¥ –Ω–µ–∫–æ–ª–∫—É —Å–µ–∫—É–Ω–¥–∏',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '–ø–æ—Å–ª–µ –Ω–µ–∫–æ–ª–∫—É —Å–µ–∫—É–Ω–¥–∏', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '–ø–æ—Å–ª–µ 5 –¥–µ–Ω–∞', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '–î–µ–Ω–µ—Å –≤–æ 2:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '–î–µ–Ω–µ—Å –≤–æ 2:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '–î–µ–Ω–µ—Å –≤–æ 3:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '–£—Ç—Ä–µ –≤–æ 2:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '–î–µ–Ω–µ—Å –≤–æ 1:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '–í—á–µ—Ä–∞ –≤–æ 2:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [–≤–æ] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [–≤–æ] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [–≤–æ] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
            case 3:
            case 6:
                return '[–í–æ –∏–∑–º–∏–Ω–∞—Ç–∞—Ç–∞] dddd [–≤–æ] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[–í–æ –∏–∑–º–∏–Ω–∞—Ç–∏–æ—Ç] dddd [–≤–æ] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-–≤–∏', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-–≤–∏', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-—Ä–∏', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-—Ä–∏', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-—Ç–∏', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('ml');

    test('parse', function (assert) {
        var tests = '‡¥ú‡¥®‡µÅ‡¥µ‡¥∞‡¥ø ‡¥ú‡¥®‡µÅ._‡¥´‡µÜ‡¥¨‡µç‡¥∞‡µÅ‡¥µ‡¥∞‡¥ø ‡¥´‡µÜ‡¥¨‡µç‡¥∞‡µÅ._‡¥Æ‡¥æ‡µº‡¥ö‡µç‡¥ö‡µç ‡¥Æ‡¥æ‡µº._‡¥è‡¥™‡µç‡¥∞‡¥ø‡µΩ ‡¥è‡¥™‡µç‡¥∞‡¥ø._‡¥Æ‡µá‡¥Ø‡µç ‡¥Æ‡µá‡¥Ø‡µç_‡¥ú‡µÇ‡µ∫ ‡¥ú‡µÇ‡µ∫_‡¥ú‡µÇ‡¥≤‡µà ‡¥ú‡µÇ‡¥≤‡µà._‡¥ì‡¥ó‡¥∏‡µç‡¥±‡µç‡¥±‡µç ‡¥ì‡¥ó._‡¥∏‡µÜ‡¥™‡µç‡¥±‡µç‡¥±‡¥Ç‡¥¨‡µº ‡¥∏‡µÜ‡¥™‡µç‡¥±‡µç‡¥±._‡¥í‡¥ï‡µç‡¥ü‡µã‡¥¨‡µº ‡¥í‡¥ï‡µç‡¥ü‡µã._‡¥®‡¥µ‡¥Ç‡¥¨‡µº ‡¥®‡¥µ‡¥Ç._‡¥°‡¥ø‡¥∏‡¥Ç‡¥¨‡µº ‡¥°‡¥ø‡¥∏‡¥Ç.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, a h:mm:ss -‡¥®‡µÅ',  '‡¥û‡¥æ‡¥Ø‡¥±‡¥æ‡¥¥‡µç‡¥ö, 14 ‡¥´‡µÜ‡¥¨‡µç‡¥∞‡µÅ‡¥µ‡¥∞‡¥ø 2010, ‡¥â‡¥ö‡µç‡¥ö ‡¥ï‡¥¥‡¥ø‡¥û‡µç‡¥û‡µç 3:25:50 -‡¥®‡µÅ'],
                ['ddd, a h -‡¥®‡µÅ',                       '‡¥û‡¥æ‡¥Ø‡µº, ‡¥â‡¥ö‡µç‡¥ö ‡¥ï‡¥¥‡¥ø‡¥û‡µç‡¥û‡µç 3 -‡¥®‡µÅ'],
                ['M Mo MM MMMM MMM',                   '2 2 02 ‡¥´‡µÜ‡¥¨‡µç‡¥∞‡µÅ‡¥µ‡¥∞‡¥ø ‡¥´‡µÜ‡¥¨‡µç‡¥∞‡µÅ.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 ‡¥û‡¥æ‡¥Ø‡¥±‡¥æ‡¥¥‡µç‡¥ö ‡¥û‡¥æ‡¥Ø‡µº ‡¥û‡¥æ'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '8 8 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                '‡¥â‡¥ö‡µç‡¥ö ‡¥ï‡¥¥‡¥ø‡¥û‡µç‡¥û‡µç ‡¥â‡¥ö‡µç‡¥ö ‡¥ï‡¥¥‡¥ø‡¥û‡µç‡¥û‡µç'],
                ['LTS',                                '‡¥â‡¥ö‡µç‡¥ö ‡¥ï‡¥¥‡¥ø‡¥û‡µç‡¥û‡µç 3:25:50 -‡¥®‡µÅ'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 ‡¥´‡µÜ‡¥¨‡µç‡¥∞‡µÅ‡¥µ‡¥∞‡¥ø 2010'],
                ['LLL',                                '14 ‡¥´‡µÜ‡¥¨‡µç‡¥∞‡µÅ‡¥µ‡¥∞‡¥ø 2010, ‡¥â‡¥ö‡µç‡¥ö ‡¥ï‡¥¥‡¥ø‡¥û‡µç‡¥û‡µç 3:25 -‡¥®‡µÅ'],
                ['LLLL',                               '‡¥û‡¥æ‡¥Ø‡¥±‡¥æ‡¥¥‡µç‡¥ö, 14 ‡¥´‡µÜ‡¥¨‡µç‡¥∞‡µÅ‡¥µ‡¥∞‡¥ø 2010, ‡¥â‡¥ö‡µç‡¥ö ‡¥ï‡¥¥‡¥ø‡¥û‡µç‡¥û‡µç 3:25 -‡¥®‡µÅ'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 ‡¥´‡µÜ‡¥¨‡µç‡¥∞‡µÅ. 2010'],
                ['lll',                                '14 ‡¥´‡µÜ‡¥¨‡µç‡¥∞‡µÅ. 2010, ‡¥â‡¥ö‡µç‡¥ö ‡¥ï‡¥¥‡¥ø‡¥û‡µç‡¥û‡µç 3:25 -‡¥®‡µÅ'],
                ['llll',                               '‡¥û‡¥æ‡¥Ø‡µº, 14 ‡¥´‡µÜ‡¥¨‡µç‡¥∞‡µÅ. 2010, ‡¥â‡¥ö‡µç‡¥ö ‡¥ï‡¥¥‡¥ø‡¥û‡µç‡¥û‡µç 3:25 -‡¥®‡µÅ']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = '‡¥ú‡¥®‡µÅ‡¥µ‡¥∞‡¥ø ‡¥ú‡¥®‡µÅ._‡¥´‡µÜ‡¥¨‡µç‡¥∞‡µÅ‡¥µ‡¥∞‡¥ø ‡¥´‡µÜ‡¥¨‡µç‡¥∞‡µÅ._‡¥Æ‡¥æ‡µº‡¥ö‡µç‡¥ö‡µç ‡¥Æ‡¥æ‡µº._‡¥è‡¥™‡µç‡¥∞‡¥ø‡µΩ ‡¥è‡¥™‡µç‡¥∞‡¥ø._‡¥Æ‡µá‡¥Ø‡µç ‡¥Æ‡µá‡¥Ø‡µç_‡¥ú‡µÇ‡µ∫ ‡¥ú‡µÇ‡µ∫_‡¥ú‡µÇ‡¥≤‡µà ‡¥ú‡µÇ‡¥≤‡µà._‡¥ì‡¥ó‡¥∏‡µç‡¥±‡µç‡¥±‡µç ‡¥ì‡¥ó._‡¥∏‡µÜ‡¥™‡µç‡¥±‡µç‡¥±‡¥Ç‡¥¨‡µº ‡¥∏‡µÜ‡¥™‡µç‡¥±‡µç‡¥±._‡¥í‡¥ï‡µç‡¥ü‡µã‡¥¨‡µº ‡¥í‡¥ï‡µç‡¥ü‡µã._‡¥®‡¥µ‡¥Ç‡¥¨‡µº ‡¥®‡¥µ‡¥Ç._‡¥°‡¥ø‡¥∏‡¥Ç‡¥¨‡µº ‡¥°‡¥ø‡¥∏‡¥Ç.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '‡¥û‡¥æ‡¥Ø‡¥±‡¥æ‡¥¥‡µç‡¥ö ‡¥û‡¥æ‡¥Ø‡µº ‡¥û‡¥æ_‡¥§‡¥ø‡¥ô‡µç‡¥ï‡¥≥‡¥æ‡¥¥‡µç‡¥ö ‡¥§‡¥ø‡¥ô‡µç‡¥ï‡µæ ‡¥§‡¥ø_‡¥ö‡µä‡¥µ‡µç‡¥µ‡¥æ‡¥¥‡µç‡¥ö ‡¥ö‡µä‡¥µ‡µç‡¥µ ‡¥ö‡µä_‡¥¨‡µÅ‡¥ß‡¥®‡¥æ‡¥¥‡µç‡¥ö ‡¥¨‡µÅ‡¥ß‡µª ‡¥¨‡µÅ_‡¥µ‡µç‡¥Ø‡¥æ‡¥¥‡¥æ‡¥¥‡µç‡¥ö ‡¥µ‡µç‡¥Ø‡¥æ‡¥¥‡¥Ç ‡¥µ‡µç‡¥Ø‡¥æ_‡¥µ‡µÜ‡¥≥‡µç‡¥≥‡¥ø‡¥Ø‡¥æ‡¥¥‡µç‡¥ö ‡¥µ‡µÜ‡¥≥‡µç‡¥≥‡¥ø ‡¥µ‡µÜ_‡¥∂‡¥®‡¥ø‡¥Ø‡¥æ‡¥¥‡µç‡¥ö ‡¥∂‡¥®‡¥ø ‡¥∂'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '‡¥Ö‡µΩ‡¥™ ‡¥®‡¥ø‡¥Æ‡¥ø‡¥∑‡¥ô‡µç‡¥ô‡µæ', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '‡¥í‡¥∞‡µÅ ‡¥Æ‡¥ø‡¥®‡¥ø‡¥±‡µç‡¥±‡µç',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '‡¥í‡¥∞‡µÅ ‡¥Æ‡¥ø‡¥®‡¥ø‡¥±‡µç‡¥±‡µç',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ‡¥Æ‡¥ø‡¥®‡¥ø‡¥±‡µç‡¥±‡µç',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ‡¥Æ‡¥ø‡¥®‡¥ø‡¥±‡µç‡¥±‡µç',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '‡¥í‡¥∞‡µÅ ‡¥Æ‡¥£‡¥ø‡¥ï‡µç‡¥ï‡µÇ‡µº',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '‡¥í‡¥∞‡µÅ ‡¥Æ‡¥£‡¥ø‡¥ï‡µç‡¥ï‡µÇ‡µº',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ‡¥Æ‡¥£‡¥ø‡¥ï‡µç‡¥ï‡µÇ‡µº',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ‡¥Æ‡¥£‡¥ø‡¥ï‡µç‡¥ï‡µÇ‡µº',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ‡¥Æ‡¥£‡¥ø‡¥ï‡µç‡¥ï‡µÇ‡µº',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '‡¥í‡¥∞‡µÅ ‡¥¶‡¥ø‡¥µ‡¥∏‡¥Ç',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '‡¥í‡¥∞‡µÅ ‡¥¶‡¥ø‡¥µ‡¥∏‡¥Ç',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ‡¥¶‡¥ø‡¥µ‡¥∏‡¥Ç',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '‡¥í‡¥∞‡µÅ ‡¥¶‡¥ø‡¥µ‡¥∏‡¥Ç',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ‡¥¶‡¥ø‡¥µ‡¥∏‡¥Ç',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ‡¥¶‡¥ø‡¥µ‡¥∏‡¥Ç',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '‡¥í‡¥∞‡µÅ ‡¥Æ‡¥æ‡¥∏‡¥Ç',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '‡¥í‡¥∞‡µÅ ‡¥Æ‡¥æ‡¥∏‡¥Ç',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '‡¥í‡¥∞‡µÅ ‡¥Æ‡¥æ‡¥∏‡¥Ç',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ‡¥Æ‡¥æ‡¥∏‡¥Ç',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ‡¥Æ‡¥æ‡¥∏‡¥Ç',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ‡¥Æ‡¥æ‡¥∏‡¥Ç',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '‡¥í‡¥∞‡µÅ ‡¥Æ‡¥æ‡¥∏‡¥Ç',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ‡¥Æ‡¥æ‡¥∏‡¥Ç',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '‡¥í‡¥∞‡µÅ ‡¥µ‡µº‡¥∑‡¥Ç',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ‡¥µ‡µº‡¥∑‡¥Ç',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '‡¥í‡¥∞‡µÅ ‡¥µ‡µº‡¥∑‡¥Ç',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ‡¥µ‡µº‡¥∑‡¥Ç',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '‡¥Ö‡µΩ‡¥™ ‡¥®‡¥ø‡¥Æ‡¥ø‡¥∑‡¥ô‡µç‡¥ô‡µæ ‡¥ï‡¥¥‡¥ø‡¥û‡µç‡¥û‡µç',  'prefix');
        assert.equal(moment(0).from(30000), '‡¥Ö‡µΩ‡¥™ ‡¥®‡¥ø‡¥Æ‡¥ø‡¥∑‡¥ô‡µç‡¥ô‡µæ ‡¥Æ‡µÅ‡µª‡¥™‡µç', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '‡¥Ö‡µΩ‡¥™ ‡¥®‡¥ø‡¥Æ‡¥ø‡¥∑‡¥ô‡µç‡¥ô‡µæ ‡¥Æ‡µÅ‡µª‡¥™‡µç',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '‡¥Ö‡µΩ‡¥™ ‡¥®‡¥ø‡¥Æ‡¥ø‡¥∑‡¥ô‡µç‡¥ô‡µæ ‡¥ï‡¥¥‡¥ø‡¥û‡µç‡¥û‡µç', '‡¥Ö‡µΩ‡¥™ ‡¥®‡¥ø‡¥Æ‡¥ø‡¥∑‡¥ô‡µç‡¥ô‡µæ ‡¥ï‡¥¥‡¥ø‡¥û‡µç‡¥û‡µç');
        assert.equal(moment().add({d: 5}).fromNow(), '5 ‡¥¶‡¥ø‡¥µ‡¥∏‡¥Ç ‡¥ï‡¥¥‡¥ø‡¥û‡µç‡¥û‡µç', '5 ‡¥¶‡¥ø‡¥µ‡¥∏‡¥Ç ‡¥ï‡¥¥‡¥ø‡¥û‡µç‡¥û‡µç');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '‡¥á‡¥®‡µç‡¥®‡µç ‡¥∞‡¥æ‡¥§‡µç‡¥∞‡¥ø 2:00 -‡¥®‡µÅ',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '‡¥á‡¥®‡µç‡¥®‡µç ‡¥∞‡¥æ‡¥§‡µç‡¥∞‡¥ø 2:25 -‡¥®‡µÅ',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 3}).calendar(),       '‡¥á‡¥®‡µç‡¥®‡µç ‡¥∞‡¥æ‡¥µ‡¥ø‡¥≤‡µÜ 5:00 -‡¥®‡µÅ',     'Now plus 3 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '‡¥®‡¥æ‡¥≥‡µÜ ‡¥∞‡¥æ‡¥§‡µç‡¥∞‡¥ø 2:00 -‡¥®‡µÅ',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '‡¥á‡¥®‡µç‡¥®‡µç ‡¥∞‡¥æ‡¥§‡µç‡¥∞‡¥ø 1:00 -‡¥®‡µÅ',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '‡¥á‡¥®‡µç‡¥®‡¥≤‡µÜ ‡¥∞‡¥æ‡¥§‡µç‡¥∞‡¥ø 2:00 -‡¥®‡µÅ', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[‡¥ï‡¥¥‡¥ø‡¥û‡µç‡¥û] dddd[,] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[‡¥ï‡¥¥‡¥ø‡¥û‡µç‡¥û] dddd[,] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[‡¥ï‡¥¥‡¥ø‡¥û‡µç‡¥û] dddd[,] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), '‡¥∞‡¥æ‡¥§‡µç‡¥∞‡¥ø', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), '‡¥∞‡¥æ‡¥µ‡¥ø‡¥≤‡µÜ', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), '‡¥â‡¥ö‡µç‡¥ö ‡¥ï‡¥¥‡¥ø‡¥û‡µç‡¥û‡µç', 'during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), '‡¥µ‡µà‡¥ï‡µÅ‡¥®‡µç‡¥®‡µá‡¥∞‡¥Ç', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), '‡¥µ‡µà‡¥ï‡µÅ‡¥®‡µç‡¥®‡µá‡¥∞‡¥Ç', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('a'), '‡¥∞‡¥æ‡¥§‡µç‡¥∞‡¥ø', 'night');

        assert.equal(moment([2011, 2, 23,  2, 30]).format('A'), '‡¥∞‡¥æ‡¥§‡µç‡¥∞‡¥ø', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('A'), '‡¥∞‡¥æ‡¥µ‡¥ø‡¥≤‡µÜ', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('A'), '‡¥â‡¥ö‡µç‡¥ö ‡¥ï‡¥¥‡¥ø‡¥û‡µç‡¥û‡µç', ' during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('A'), '‡¥µ‡µà‡¥ï‡µÅ‡¥®‡µç‡¥®‡µá‡¥∞‡¥Ç', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('A'), '‡¥µ‡µà‡¥ï‡µÅ‡¥®‡µç‡¥®‡µá‡¥∞‡¥Ç', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('A'), '‡¥∞‡¥æ‡¥§‡µç‡¥∞‡¥ø', 'night');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3', 'Jan 15 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('mr');

    test('parse', function (assert) {
        var tests = '‡§ú‡§æ‡§®‡•á‡§µ‡§æ‡§∞‡•Ä ‡§ú‡§æ‡§®‡•á._‡§´‡•á‡§¨‡•ç‡§∞‡•Å‡§µ‡§æ‡§∞‡•Ä ‡§´‡•á‡§¨‡•ç‡§∞‡•Å._‡§Æ‡§æ‡§∞‡•ç‡§ö ‡§Æ‡§æ‡§∞‡•ç‡§ö._‡§è‡§™‡•ç‡§∞‡§ø‡§≤ ‡§è‡§™‡•ç‡§∞‡§ø._‡§Æ‡•á ‡§Æ‡•á._‡§ú‡•Ç‡§® ‡§ú‡•Ç‡§®._‡§ú‡•Å‡§≤‡•à ‡§ú‡•Å‡§≤‡•à._‡§ë‡§ó‡§∏‡•ç‡§ü ‡§ë‡§ó._‡§∏‡§™‡•ç‡§ü‡•á‡§Ç‡§¨‡§∞ ‡§∏‡§™‡•ç‡§ü‡•á‡§Ç._‡§ë‡§ï‡•ç‡§ü‡•ã‡§¨‡§∞ ‡§ë‡§ï‡•ç‡§ü‡•ã._‡§®‡•ã‡§µ‡•ç‡§π‡•á‡§Ç‡§¨‡§∞ ‡§®‡•ã‡§µ‡•ç‡§π‡•á‡§Ç._‡§°‡§ø‡§∏‡•á‡§Ç‡§¨‡§∞ ‡§°‡§ø‡§∏‡•á‡§Ç.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, a h:mm:ss ‡§µ‡§æ‡§ú‡§§‡§æ', '‡§∞‡§µ‡§ø‡§µ‡§æ‡§∞, ‡•ß‡•™ ‡§´‡•á‡§¨‡•ç‡§∞‡•Å‡§µ‡§æ‡§∞‡•Ä ‡•®‡•¶‡•ß‡•¶, ‡§¶‡•Å‡§™‡§æ‡§∞‡•Ä ‡•©:‡•®‡•´:‡•´‡•¶ ‡§µ‡§æ‡§ú‡§§‡§æ'],
                ['ddd, a h ‡§µ‡§æ‡§ú‡§§‡§æ',                       '‡§∞‡§µ‡§ø, ‡§¶‡•Å‡§™‡§æ‡§∞‡•Ä ‡•© ‡§µ‡§æ‡§ú‡§§‡§æ'],
                ['M Mo MM MMMM MMM',                   '‡•® ‡•® ‡•¶‡•® ‡§´‡•á‡§¨‡•ç‡§∞‡•Å‡§µ‡§æ‡§∞‡•Ä ‡§´‡•á‡§¨‡•ç‡§∞‡•Å.'],
                ['YYYY YY',                            '‡•®‡•¶‡•ß‡•¶ ‡•ß‡•¶'],
                ['D Do DD',                            '‡•ß‡•™ ‡•ß‡•™ ‡•ß‡•™'],
                ['d do dddd ddd dd',                   '‡•¶ ‡•¶ ‡§∞‡§µ‡§ø‡§µ‡§æ‡§∞ ‡§∞‡§µ‡§ø ‡§∞'],
                ['DDD DDDo DDDD',                      '‡•™‡•´ ‡•™‡•´ ‡•¶‡•™‡•´'],
                ['w wo ww',                            '‡•Æ ‡•Æ ‡•¶‡•Æ'],
                ['h hh',                               '‡•© ‡•¶‡•©'],
                ['H HH',                               '‡•ß‡•´ ‡•ß‡•´'],
                ['m mm',                               '‡•®‡•´ ‡•®‡•´'],
                ['s ss',                               '‡•´‡•¶ ‡•´‡•¶'],
                ['a A',                                '‡§¶‡•Å‡§™‡§æ‡§∞‡•Ä ‡§¶‡•Å‡§™‡§æ‡§∞‡•Ä'],
                ['LTS',                                '‡§¶‡•Å‡§™‡§æ‡§∞‡•Ä ‡•©:‡•®‡•´:‡•´‡•¶ ‡§µ‡§æ‡§ú‡§§‡§æ'],
                ['L',                                  '‡•ß‡•™/‡•¶‡•®/‡•®‡•¶‡•ß‡•¶'],
                ['LL',                                 '‡•ß‡•™ ‡§´‡•á‡§¨‡•ç‡§∞‡•Å‡§µ‡§æ‡§∞‡•Ä ‡•®‡•¶‡•ß‡•¶'],
                ['LLL',                                '‡•ß‡•™ ‡§´‡•á‡§¨‡•ç‡§∞‡•Å‡§µ‡§æ‡§∞‡•Ä ‡•®‡•¶‡•ß‡•¶, ‡§¶‡•Å‡§™‡§æ‡§∞‡•Ä ‡•©:‡•®‡•´ ‡§µ‡§æ‡§ú‡§§‡§æ'],
                ['LLLL',                               '‡§∞‡§µ‡§ø‡§µ‡§æ‡§∞, ‡•ß‡•™ ‡§´‡•á‡§¨‡•ç‡§∞‡•Å‡§µ‡§æ‡§∞‡•Ä ‡•®‡•¶‡•ß‡•¶, ‡§¶‡•Å‡§™‡§æ‡§∞‡•Ä ‡•©:‡•®‡•´ ‡§µ‡§æ‡§ú‡§§‡§æ'],
                ['l',                                  '‡•ß‡•™/‡•®/‡•®‡•¶‡•ß‡•¶'],
                ['ll',                                 '‡•ß‡•™ ‡§´‡•á‡§¨‡•ç‡§∞‡•Å. ‡•®‡•¶‡•ß‡•¶'],
                ['lll',                                '‡•ß‡•™ ‡§´‡•á‡§¨‡•ç‡§∞‡•Å. ‡•®‡•¶‡•ß‡•¶, ‡§¶‡•Å‡§™‡§æ‡§∞‡•Ä ‡•©:‡•®‡•´ ‡§µ‡§æ‡§ú‡§§‡§æ'],
                ['llll',                               '‡§∞‡§µ‡§ø, ‡•ß‡•™ ‡§´‡•á‡§¨‡•ç‡§∞‡•Å. ‡•®‡•¶‡•ß‡•¶, ‡§¶‡•Å‡§™‡§æ‡§∞‡•Ä ‡•©:‡•®‡•´ ‡§µ‡§æ‡§ú‡§§‡§æ']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '‡•ß', '‡•ß');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '‡•®', '‡•®');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '‡•©', '‡•©');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '‡•™', '‡•™');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '‡•´', '‡•´');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '‡•¨', '‡•¨');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '‡•≠', '‡•≠');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '‡•Æ', '‡•Æ');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '‡•Ø', '‡•Ø');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '‡•ß‡•¶', '‡•ß‡•¶');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '‡•ß‡•ß', '‡•ß‡•ß');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '‡•ß‡•®', '‡•ß‡•®');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '‡•ß‡•©', '‡•ß‡•©');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '‡•ß‡•™', '‡•ß‡•™');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '‡•ß‡•´', '‡•ß‡•´');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '‡•ß‡•¨', '‡•ß‡•¨');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '‡•ß‡•≠', '‡•ß‡•≠');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '‡•ß‡•Æ', '‡•ß‡•Æ');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '‡•ß‡•Ø', '‡•ß‡•Ø');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '‡•®‡•¶', '‡•®‡•¶');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '‡•®‡•ß', '‡•®‡•ß');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '‡•®‡•®', '‡•®‡•®');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '‡•®‡•©', '‡•®‡•©');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '‡•®‡•™', '‡•®‡•™');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '‡•®‡•´', '‡•®‡•´');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '‡•®‡•¨', '‡•®‡•¨');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '‡•®‡•≠', '‡•®‡•≠');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '‡•®‡•Æ', '‡•®‡•Æ');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '‡•®‡•Ø', '‡•®‡•Ø');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '‡•©‡•¶', '‡•©‡•¶');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '‡•©‡•ß', '‡•©‡•ß');
    });

    test('format month', function (assert) {
        var expected = '‡§ú‡§æ‡§®‡•á‡§µ‡§æ‡§∞‡•Ä ‡§ú‡§æ‡§®‡•á._‡§´‡•á‡§¨‡•ç‡§∞‡•Å‡§µ‡§æ‡§∞‡•Ä ‡§´‡•á‡§¨‡•ç‡§∞‡•Å._‡§Æ‡§æ‡§∞‡•ç‡§ö ‡§Æ‡§æ‡§∞‡•ç‡§ö._‡§è‡§™‡•ç‡§∞‡§ø‡§≤ ‡§è‡§™‡•ç‡§∞‡§ø._‡§Æ‡•á ‡§Æ‡•á._‡§ú‡•Ç‡§® ‡§ú‡•Ç‡§®._‡§ú‡•Å‡§≤‡•à ‡§ú‡•Å‡§≤‡•à._‡§ë‡§ó‡§∏‡•ç‡§ü ‡§ë‡§ó._‡§∏‡§™‡•ç‡§ü‡•á‡§Ç‡§¨‡§∞ ‡§∏‡§™‡•ç‡§ü‡•á‡§Ç._‡§ë‡§ï‡•ç‡§ü‡•ã‡§¨‡§∞ ‡§ë‡§ï‡•ç‡§ü‡•ã._‡§®‡•ã‡§µ‡•ç‡§π‡•á‡§Ç‡§¨‡§∞ ‡§®‡•ã‡§µ‡•ç‡§π‡•á‡§Ç._‡§°‡§ø‡§∏‡•á‡§Ç‡§¨‡§∞ ‡§°‡§ø‡§∏‡•á‡§Ç.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '‡§∞‡§µ‡§ø‡§µ‡§æ‡§∞ ‡§∞‡§µ‡§ø ‡§∞_‡§∏‡•ã‡§Æ‡§µ‡§æ‡§∞ ‡§∏‡•ã‡§Æ ‡§∏‡•ã_‡§Æ‡§Ç‡§ó‡§≥‡§µ‡§æ‡§∞ ‡§Æ‡§Ç‡§ó‡§≥ ‡§Æ‡§Ç_‡§¨‡•Å‡§ß‡§µ‡§æ‡§∞ ‡§¨‡•Å‡§ß ‡§¨‡•Å_‡§ó‡•Å‡§∞‡•Ç‡§µ‡§æ‡§∞ ‡§ó‡•Å‡§∞‡•Ç ‡§ó‡•Å_‡§∂‡•Å‡§ï‡•ç‡§∞‡§µ‡§æ‡§∞ ‡§∂‡•Å‡§ï‡•ç‡§∞ ‡§∂‡•Å_‡§∂‡§®‡§ø‡§µ‡§æ‡§∞ ‡§∂‡§®‡§ø ‡§∂'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '‡§∏‡•á‡§ï‡§Ç‡§¶', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '‡§è‡§ï ‡§Æ‡§ø‡§®‡§ø‡§ü',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '‡§è‡§ï ‡§Æ‡§ø‡§®‡§ø‡§ü',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '‡•® ‡§Æ‡§ø‡§®‡§ø‡§ü‡•á',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true), '‡•™‡•™ ‡§Æ‡§ø‡§®‡§ø‡§ü‡•á', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '‡§è‡§ï ‡§§‡§æ‡§∏',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '‡§è‡§ï ‡§§‡§æ‡§∏',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '‡•® ‡§§‡§æ‡§∏',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '‡•´ ‡§§‡§æ‡§∏',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '‡•®‡•ß ‡§§‡§æ‡§∏',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '‡§è‡§ï ‡§¶‡§ø‡§µ‡§∏',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '‡§è‡§ï ‡§¶‡§ø‡§µ‡§∏',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '‡•® ‡§¶‡§ø‡§µ‡§∏',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '‡§è‡§ï ‡§¶‡§ø‡§µ‡§∏',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '‡•´ ‡§¶‡§ø‡§µ‡§∏',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '‡•®‡•´ ‡§¶‡§ø‡§µ‡§∏',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true), '‡§è‡§ï ‡§Æ‡§π‡§ø‡§®‡§æ', '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true), '‡§è‡§ï ‡§Æ‡§π‡§ø‡§®‡§æ', '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true), '‡§è‡§ï ‡§Æ‡§π‡§ø‡§®‡§æ', '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true), '‡•® ‡§Æ‡§π‡§ø‡§®‡•á', '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true), '‡•® ‡§Æ‡§π‡§ø‡§®‡•á', '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true), '‡•© ‡§Æ‡§π‡§ø‡§®‡•á', '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true), '‡§è‡§ï ‡§Æ‡§π‡§ø‡§®‡§æ', '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true), '‡•´ ‡§Æ‡§π‡§ø‡§®‡•á', '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '‡§è‡§ï ‡§µ‡§∞‡•ç‡§∑',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '‡•® ‡§µ‡§∞‡•ç‡§∑‡•á',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '‡§è‡§ï ‡§µ‡§∞‡•ç‡§∑',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true), '‡•´ ‡§µ‡§∞‡•ç‡§∑‡•á', '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '‡§∏‡•á‡§ï‡§Ç‡§¶ ‡§®‡§Ç‡§§‡§∞', 'prefix');
        assert.equal(moment(0).from(30000), '‡§∏‡•á‡§ï‡§Ç‡§¶ ‡§™‡•Ç‡§∞‡•ç‡§µ‡•Ä', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '‡§∏‡•á‡§ï‡§Ç‡§¶ ‡§™‡•Ç‡§∞‡•ç‡§µ‡•Ä',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '‡§∏‡•á‡§ï‡§Ç‡§¶ ‡§®‡§Ç‡§§‡§∞', '‡§∏‡•á‡§ï‡§Ç‡§¶ ‡§®‡§Ç‡§§‡§∞');
        assert.equal(moment().add({d: 5}).fromNow(), '‡•´ ‡§¶‡§ø‡§µ‡§∏ ‡§®‡§Ç‡§§‡§∞', '‡•´ ‡§¶‡§ø‡§µ‡§∏ ‡§®‡§Ç‡§§‡§∞');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '‡§Ü‡§ú ‡§∞‡§æ‡§§‡•ç‡§∞‡•Ä ‡•®:‡•¶‡•¶ ‡§µ‡§æ‡§ú‡§§‡§æ',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '‡§Ü‡§ú ‡§∞‡§æ‡§§‡•ç‡§∞‡•Ä ‡•®:‡•®‡•´ ‡§µ‡§æ‡§ú‡§§‡§æ',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 3}).calendar(),       '‡§Ü‡§ú ‡§∏‡§ï‡§æ‡§≥‡•Ä ‡•´:‡•¶‡•¶ ‡§µ‡§æ‡§ú‡§§‡§æ',     'Now plus 3 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '‡§â‡§¶‡•ç‡§Ø‡§æ ‡§∞‡§æ‡§§‡•ç‡§∞‡•Ä ‡•®:‡•¶‡•¶ ‡§µ‡§æ‡§ú‡§§‡§æ',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '‡§Ü‡§ú ‡§∞‡§æ‡§§‡•ç‡§∞‡•Ä ‡•ß:‡•¶‡•¶ ‡§µ‡§æ‡§ú‡§§‡§æ',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '‡§ï‡§æ‡§≤ ‡§∞‡§æ‡§§‡•ç‡§∞‡•Ä ‡•®:‡•¶‡•¶ ‡§µ‡§æ‡§ú‡§§‡§æ', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(), m.format('[‡§Æ‡§æ‡§ó‡•Ä‡§≤] dddd[,] LT'), 'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format('[‡§Æ‡§æ‡§ó‡•Ä‡§≤] dddd[,] LT'), 'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format('[‡§Æ‡§æ‡§ó‡•Ä‡§≤] dddd[,] LT'), 'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), '‡§∞‡§æ‡§§‡•ç‡§∞‡•Ä', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), '‡§∏‡§ï‡§æ‡§≥‡•Ä', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), '‡§¶‡•Å‡§™‡§æ‡§∞‡•Ä', 'during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), '‡§∏‡§æ‡§Ø‡§Ç‡§ï‡§æ‡§≥‡•Ä', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), '‡§∏‡§æ‡§Ø‡§Ç‡§ï‡§æ‡§≥‡•Ä', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('a'), '‡§∞‡§æ‡§§‡•ç‡§∞‡•Ä', 'night');

        assert.equal(moment([2011, 2, 23,  2, 30]).format('A'), '‡§∞‡§æ‡§§‡•ç‡§∞‡•Ä', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('A'), '‡§∏‡§ï‡§æ‡§≥‡•Ä', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('A'), '‡§¶‡•Å‡§™‡§æ‡§∞‡•Ä', ' during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('A'), '‡§∏‡§æ‡§Ø‡§Ç‡§ï‡§æ‡§≥‡•Ä', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('A'), '‡§∏‡§æ‡§Ø‡§Ç‡§ï‡§æ‡§≥‡•Ä', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('A'), '‡§∞‡§æ‡§§‡•ç‡§∞‡•Ä', 'night');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '‡•ß ‡•¶‡•ß ‡•ß', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '‡•ß ‡•¶‡•ß ‡•ß', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '‡•® ‡•¶‡•® ‡•®', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '‡•® ‡•¶‡•® ‡•®', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '‡•© ‡•¶‡•© ‡•©', 'Jan 15 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('meridiem invariant', function (assert) {
        var h, m, t1, t2;
        for (h = 0; h < 24; ++h) {
            for (m = 0; m < 60; m += 15) {
                t1 = moment.utc([2000, 0, 1, h, m]);
                t2 = moment(t1.format('A h:mm'), 'A h:mm');
                assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                        'meridiem at ' + t1.format('HH:mm'));
            }
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('ms-my');

    test('parse', function (assert) {
        var i,
            tests = 'Januari Jan_Februari Feb_Mac Mac_April Apr_Mei Mei_Jun Jun_Julai Jul_Ogos Ogs_September Sep_Oktober Okt_November Nov_Disember Dis'.split('_');

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' sepatutnya bulan ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Ahad, Februari 14 2010, 3:25:50 petang'],
                ['ddd, hA',                            'Ahd, 3petang'],
                ['M Mo MM MMMM MMM',                   '2 2 02 Februari Feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 Ahad Ahd Ah'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '7 7 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'petang petang'],
                ['[hari] [ke] DDDo [tahun] ini', 'hari ke 45 tahun ini'],
                ['LTS',                                '15.25.50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 Februari 2010'],
                ['LLL',                                '14 Februari 2010 pukul 15.25'],
                ['LLLL',                               'Ahad, 14 Februari 2010 pukul 15.25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Feb 2010'],
                ['lll',                                '14 Feb 2010 pukul 15.25'],
                ['llll',                               'Ahd, 14 Feb 2010 pukul 15.25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var i,
            expected = 'Januari Jan_Februari Feb_Mac Mac_April Apr_Mei Mei_Jun Jun_Julai Jul_Ogos Ogs_September Sep_Oktober Okt_November Nov_Disember Dis'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var i,
            expected = 'Ahad Ahd Ah_Isnin Isn Is_Selasa Sel Sl_Rabu Rab Rb_Khamis Kha Km_Jumaat Jum Jm_Sabtu Sab Sb'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'beberapa saat', '44 saat = beberapa saat');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'seminit',      '45 saat = seminit');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'seminit',      '89 saat = seminit');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minit',     '90 saat = 2 minit');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minit',    '44 minit = 44 minit');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'sejam',       '45 minit = sejam');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'sejam',       '89 minit = sejam');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 jam',       '90 minit = 2 jam');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 jam',       '5 jam = 5 jam');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 jam',      '21 jam = 21 jam');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'sehari',         '22 jam = sehari');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'sehari',         '35 jam = sehari');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 hari',        '36 jam = 2 hari');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'sehari',         '1 hari = sehari');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 hari',        '5 hari = 5 hari');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 hari',       '25 hari = 25 hari');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'sebulan',       '26 hari = sebulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'sebulan',       '30 hari = sebulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'sebulan',       '45 hari = sebulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 bulan',      '46 hari = 2 bulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 bulan',      '75 hari = 2 bulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 bulan',      '76 hari = 3 bulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'sebulan',       '1 bulan = sebulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 bulan',      '5 bulan = 5 bulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'setahun',        '345 hari = setahun');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 tahun',       '548 hari = 2 tahun');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'setahun',        '1 tahun = setahun');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 tahun',       '5 tahun = 5 tahun');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'dalam beberapa saat',  'prefix');
        assert.equal(moment(0).from(30000), 'beberapa saat yang lepas', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'beberapa saat yang lepas',  'waktu sekarang dari sekarang sepatutnya menunjukkan sebagai telah lepas');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'dalam beberapa saat', 'dalam beberapa saat');
        assert.equal(moment().add({d: 5}).fromNow(), 'dalam 5 hari', 'dalam 5 hari');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Hari ini pukul 02.00',     'hari ini pada waktu yang sama');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Hari ini pukul 02.25',     'Sekarang tambah 25 minit');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Hari ini pukul 03.00',     'Sekarang tambah 1 jam');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Esok pukul 02.00',  'esok pada waktu yang sama');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Hari ini pukul 01.00',     'Sekarang tolak 1 jam');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Kelmarin pukul 02.00', 'kelmarin pada waktu yang sama');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Hari ini + ' + i + ' hari waktu sekarang');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Hari ini + ' + i + ' hari permulaan hari');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Hari ini + ' + i + ' hari tamat hari');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [lepas] [pukul] LT'),  'Hari ini - ' + i + ' hari waktu sekarang');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [lepas] [pukul] LT'),  'Hari ini - ' + i + ' hari permulaan hari');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [lepas] [pukul] LT'),  'Hari ini - ' + i + ' hari tamat hari');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 minggu lepas');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'dalam 1 minggu');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 minggu lepas');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'dalam 2 minggu');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 sepatutnya minggu 1');
        assert.equal(moment([2012, 0,  7]).week(), 2, 'Jan  7 2012 sepatutnya minggu 2');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 sepatutnya minggu 2');
        assert.equal(moment([2012, 0, 14]).week(), 3, 'Jan 14 2012 sepatutnya minggu 3');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 sepatutnya minggu 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 53, 'Dec 31 2006 sepatutnya minggu 53');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 sepatutnya minggu 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 sepatutnya minggu 1');
        assert.equal(moment([2007,  0,  7]).week(), 1, 'Jan  7 2007 sepatutnya minggu 1');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 sepatutnya minggu 2');
        assert.equal(moment([2007,  0, 14]).week(), 2, 'Jan 14 2007 sepatutnya minggu 2');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 30]).week(), 52, 'Dec 30 2007 sepatutnya minggu 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 sepatutnya minggu 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 sepatutnya minggu 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 sepatutnya minggu 1');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 sepatutnya minggu 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 sepatutnya minggu 2');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 52, 'Dec 29 2002 sepatutnya minggu 52');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 sepatutnya minggu 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 sepatutnya minggu 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 sepatutnya minggu 1');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 sepatutnya minggu 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 sepatutnya minggu 2');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 52, 'Dec 28 2008 sepatutnya minggu 52');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 sepatutnya minggu 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 sepatutnya minggu 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 sepatutnya minggu 1');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 sepatutnya minggu 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 sepatutnya minggu 2');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 52, 'Dec 27 2009 sepatutnya minggu 52');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 sepatutnya minggu 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 sepatutnya minggu 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 sepatutnya minggu 1');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 sepatutnya minggu 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 sepatutnya minggu 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 52, 'Dec 26 2010 sepatutnya minggu 52');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 sepatutnya minggu 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 sepatutnya minggu 1');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 sepatutnya minggu 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 sepatutnya minggu 2');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 sepatutnya minggu 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '2 02 2', 'Jan  7 2012 sepatutnya minggu 2');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 sepatutnya minggu 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '3 03 3', 'Jan 14 2012 sepatutnya minggu 3');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3', 'Jan 15 2012 sepatutnya minggu 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('meridiem invariant', function (assert) {
        var h, m, t1, t2;
        for (h = 0; h < 24; ++h) {
            for (m = 0; m < 60; m += 15) {
                t1 = moment.utc([2000, 0, 1, h, m]);
                t2 = moment(t1.format('A h:mm'), 'A h:mm');
                assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                        'meridiem at ' + t1.format('HH:mm'));
            }
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('my');

    test('parse', function (assert) {
        var tests = '·Äá·Äî·Ä∫·Äî·Äù·Ä´·Äõ·ÄÆ ·Äá·Äî·Ä∫_·Äñ·Ä±·Äñ·Ä±·Ä¨·Ä∫·Äù·Ä´·Äõ·ÄÆ ·Äñ·Ä±_·Äô·Äê·Ä∫ ·Äô·Äê·Ä∫_·Äß·Äï·Äº·ÄÆ ·Äï·Äº·ÄÆ_·Äô·Ä± ·Äô·Ä±_·Äá·ÄΩ·Äî·Ä∫ ·Äá·ÄΩ·Äî·Ä∫_·Äá·Ä∞·Äú·Ä≠·ÄØ·ÄÑ·Ä∫ ·Äú·Ä≠·ÄØ·ÄÑ·Ä∫_·Äû·Äº·ÄÇ·ÄØ·Äê·Ä∫ ·Äû·Äº_·ÄÖ·ÄÄ·Ä∫·Äê·ÄÑ·Ä∫·Äò·Ä¨ ·ÄÖ·ÄÄ·Ä∫_·Ä°·Ä±·Ä¨·ÄÄ·Ä∫·Äê·Ä≠·ÄØ·Äò·Ä¨ ·Ä°·Ä±·Ä¨·ÄÄ·Ä∫_·Äî·Ä≠·ÄØ·Äù·ÄÑ·Ä∫·Äò·Ä¨ ·Äî·Ä≠·ÄØ_·Äí·ÄÆ·Äá·ÄÑ·Ä∫·Äò·Ä¨ ·Äí·ÄÆ'.split('_'),
            i;

        function equalTest (input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a', '·Äê·Äî·ÄÑ·Ä∫·Äπ·ÄÇ·Äî·ÄΩ·Ä±, ·Äñ·Ä±·Äñ·Ä±·Ä¨·Ä∫·Äù·Ä´·Äõ·ÄÆ ·ÅÅ·ÅÑ ·ÅÇ·ÅÄ·ÅÅ·ÅÄ, ·ÅÉ:·ÅÇ·ÅÖ:·ÅÖ·ÅÄ pm'],
                ['ddd, hA', '·Äî·ÄΩ·Ä±, ·ÅÉPM'],
                ['M Mo MM MMMM MMM', '·ÅÇ ·ÅÇ ·ÅÄ·ÅÇ ·Äñ·Ä±·Äñ·Ä±·Ä¨·Ä∫·Äù·Ä´·Äõ·ÄÆ ·Äñ·Ä±'],
                ['YYYY YY', '·ÅÇ·ÅÄ·ÅÅ·ÅÄ ·ÅÅ·ÅÄ'],
                ['D Do DD', '·ÅÅ·ÅÑ ·ÅÅ·ÅÑ ·ÅÅ·ÅÑ'],
                ['d do dddd ddd dd', '·ÅÄ ·ÅÄ ·Äê·Äî·ÄÑ·Ä∫·Äπ·ÄÇ·Äî·ÄΩ·Ä± ·Äî·ÄΩ·Ä± ·Äî·ÄΩ·Ä±'],
                ['DDD DDDo DDDD', '·ÅÑ·ÅÖ ·ÅÑ·ÅÖ ·ÅÄ·ÅÑ·ÅÖ'],
                ['w wo ww', '·ÅÜ ·ÅÜ ·ÅÄ·ÅÜ'],
                ['h hh', '·ÅÉ ·ÅÄ·ÅÉ'],
                ['H HH', '·ÅÅ·ÅÖ ·ÅÅ·ÅÖ'],
                ['m mm', '·ÅÇ·ÅÖ ·ÅÇ·ÅÖ'],
                ['s ss', '·ÅÖ·ÅÄ ·ÅÖ·ÅÄ'],
                ['a A', 'pm PM'],
                ['[·Äî·Äæ·ÄÖ·Ä∫·Åè] DDDo [·Äõ·ÄÄ·Ä∫·Äô·Äº·Ä±·Ä¨·ÄÄ·Ä∫]', '·Äî·Äæ·ÄÖ·Ä∫·Åè ·ÅÑ·ÅÖ ·Äõ·ÄÄ·Ä∫·Äô·Äº·Ä±·Ä¨·ÄÄ·Ä∫'],
                ['LTS', '·ÅÅ·ÅÖ:·ÅÇ·ÅÖ:·ÅÖ·ÅÄ'],
                ['L', '·ÅÅ·ÅÑ/·ÅÄ·ÅÇ/·ÅÇ·ÅÄ·ÅÅ·ÅÄ'],
                ['LL', '·ÅÅ·ÅÑ ·Äñ·Ä±·Äñ·Ä±·Ä¨·Ä∫·Äù·Ä´·Äõ·ÄÆ ·ÅÇ·ÅÄ·ÅÅ·ÅÄ'],
                ['LLL', '·ÅÅ·ÅÑ ·Äñ·Ä±·Äñ·Ä±·Ä¨·Ä∫·Äù·Ä´·Äõ·ÄÆ ·ÅÇ·ÅÄ·ÅÅ·ÅÄ ·ÅÅ·ÅÖ:·ÅÇ·ÅÖ'],
                ['LLLL', '·Äê·Äî·ÄÑ·Ä∫·Äπ·ÄÇ·Äî·ÄΩ·Ä± ·ÅÅ·ÅÑ ·Äñ·Ä±·Äñ·Ä±·Ä¨·Ä∫·Äù·Ä´·Äõ·ÄÆ ·ÅÇ·ÅÄ·ÅÅ·ÅÄ ·ÅÅ·ÅÖ:·ÅÇ·ÅÖ'],
                ['l', '·ÅÅ·ÅÑ/·ÅÇ/·ÅÇ·ÅÄ·ÅÅ·ÅÄ'],
                ['ll', '·ÅÅ·ÅÑ ·Äñ·Ä± ·ÅÇ·ÅÄ·ÅÅ·ÅÄ'],
                ['lll', '·ÅÅ·ÅÑ ·Äñ·Ä± ·ÅÇ·ÅÄ·ÅÅ·ÅÄ ·ÅÅ·ÅÖ:·ÅÇ·ÅÖ'],
                ['llll', '·Äî·ÄΩ·Ä± ·ÅÅ·ÅÑ ·Äñ·Ä± ·ÅÇ·ÅÄ·ÅÅ·ÅÄ ·ÅÅ·ÅÖ:·ÅÇ·ÅÖ']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '·ÅÅ', '·ÅÅ');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '·ÅÇ', '·ÅÇ');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '·ÅÉ', '·ÅÉ');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '·ÅÑ', '·ÅÑ');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '·ÅÖ', '·ÅÖ');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '·ÅÜ', '·ÅÜ');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '·Åá', '·Åá');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '·Åà', '·Åà');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '·Åâ', '·Åâ');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '·ÅÅ·ÅÄ', '·ÅÅ·ÅÄ');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '·ÅÅ·ÅÅ', '·ÅÅ·ÅÅ');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '·ÅÅ·ÅÇ', '·ÅÅ·ÅÇ');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '·ÅÅ·ÅÉ', '·ÅÅ·ÅÉ');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '·ÅÅ·ÅÑ', '·ÅÅ·ÅÑ');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '·ÅÅ·ÅÖ', '·ÅÅ·ÅÖ');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '·ÅÅ·ÅÜ', '·ÅÅ·ÅÜ');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '·ÅÅ·Åá', '·ÅÅ·Åá');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '·ÅÅ·Åà', '·ÅÅ·Åà');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '·ÅÅ·Åâ', '·ÅÅ·Åâ');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '·ÅÇ·ÅÄ', '·ÅÇ·ÅÄ');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '·ÅÇ·ÅÅ', '·ÅÇ·ÅÅ');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '·ÅÇ·ÅÇ', '·ÅÇ·ÅÇ');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '·ÅÇ·ÅÉ', '·ÅÇ·ÅÉ');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '·ÅÇ·ÅÑ', '·ÅÇ·ÅÑ');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '·ÅÇ·ÅÖ', '·ÅÇ·ÅÖ');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '·ÅÇ·ÅÜ', '·ÅÇ·ÅÜ');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '·ÅÇ·Åá', '·ÅÇ·Åá');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '·ÅÇ·Åà', '·ÅÇ·Åà');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '·ÅÇ·Åâ', '·ÅÇ·Åâ');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '·ÅÉ·ÅÄ', '·ÅÉ·ÅÄ');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '·ÅÉ·ÅÅ', '·ÅÉ·ÅÅ');
    });

    test('format month', function (assert) {
        var expected = '·Äá·Äî·Ä∫·Äî·Äù·Ä´·Äõ·ÄÆ ·Äá·Äî·Ä∫_·Äñ·Ä±·Äñ·Ä±·Ä¨·Ä∫·Äù·Ä´·Äõ·ÄÆ ·Äñ·Ä±_·Äô·Äê·Ä∫ ·Äô·Äê·Ä∫_·Äß·Äï·Äº·ÄÆ ·Äï·Äº·ÄÆ_·Äô·Ä± ·Äô·Ä±_·Äá·ÄΩ·Äî·Ä∫ ·Äá·ÄΩ·Äî·Ä∫_·Äá·Ä∞·Äú·Ä≠·ÄØ·ÄÑ·Ä∫ ·Äú·Ä≠·ÄØ·ÄÑ·Ä∫_·Äû·Äº·ÄÇ·ÄØ·Äê·Ä∫ ·Äû·Äº_·ÄÖ·ÄÄ·Ä∫·Äê·ÄÑ·Ä∫·Äò·Ä¨ ·ÄÖ·ÄÄ·Ä∫_·Ä°·Ä±·Ä¨·ÄÄ·Ä∫·Äê·Ä≠·ÄØ·Äò·Ä¨ ·Ä°·Ä±·Ä¨·ÄÄ·Ä∫_·Äî·Ä≠·ÄØ·Äù·ÄÑ·Ä∫·Äò·Ä¨ ·Äî·Ä≠·ÄØ_·Äí·ÄÆ·Äá·ÄÑ·Ä∫·Äò·Ä¨ ·Äí·ÄÆ'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '·Äê·Äî·ÄÑ·Ä∫·Äπ·ÄÇ·Äî·ÄΩ·Ä± ·Äî·ÄΩ·Ä± ·Äî·ÄΩ·Ä±_·Äê·Äî·ÄÑ·Ä∫·Äπ·Äú·Ä¨ ·Äú·Ä¨ ·Äú·Ä¨_·Ä°·ÄÑ·Ä∫·Äπ·ÄÇ·Ä´ ·ÄÇ·Ä´ ·ÄÇ·Ä´_·Äó·ÄØ·Äí·Äπ·Äì·Äü·Ä∞·Ä∏ ·Äü·Ä∞·Ä∏ ·Äü·Ä∞·Ä∏_·ÄÄ·Äº·Ä¨·Äû·Äï·Äê·Ä±·Ä∏ ·ÄÄ·Äº·Ä¨ ·ÄÄ·Äº·Ä¨_·Äû·Ä±·Ä¨·ÄÄ·Äº·Ä¨ ·Äû·Ä±·Ä¨ ·Äû·Ä±·Ä¨_·ÄÖ·Äî·Ä± ·Äî·Ä± ·Äî·Ä±'.split('_'),
            i;

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({
            s: 44
        }), true), '·ÄÖ·ÄÄ·Äπ·ÄÄ·Äî·Ä∫.·Ä°·Äî·Ää·Ä∫·Ä∏·ÄÑ·Äö·Ä∫', '·ÅÑ·ÅÑ ·ÄÖ·ÄÄ·Äπ·ÄÄ·Äî·Ä∫. = ·ÄÖ·ÄÄ·Äπ·ÄÄ·Äî·Ä∫.·Ä°·Äî·Ää·Ä∫·Ä∏·ÄÑ·Äö·Ä∫');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            s: 45
        }), true), '·Äê·ÄÖ·Ä∫·Äô·Ä≠·Äî·ÄÖ·Ä∫', '·ÅÑ·ÅÖ ·ÄÖ·ÄÄ·Äπ·ÄÄ·Äî·Ä∫. = ·Äê·ÄÖ·Ä∫·Äô·Ä≠·Äî·ÄÖ·Ä∫');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            s: 89
        }), true), '·Äê·ÄÖ·Ä∫·Äô·Ä≠·Äî·ÄÖ·Ä∫', '·Åà·Åâ ·ÄÖ·ÄÄ·Äπ·ÄÄ·Äî·Ä∫. = ·Äê·ÄÖ·Ä∫·Äô·Ä≠·Äî·ÄÖ·Ä∫');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            s: 90
        }), true), '·ÅÇ ·Äô·Ä≠·Äî·ÄÖ·Ä∫', '·Åâ·ÅÄ ·ÄÖ·ÄÄ·Äπ·ÄÄ·Äî·Ä∫. =  ·ÅÇ ·Äô·Ä≠·Äî·ÄÖ·Ä∫');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            m: 44
        }), true), '·ÅÑ·ÅÑ ·Äô·Ä≠·Äî·ÄÖ·Ä∫', '·ÅÑ·ÅÑ ·Äô·Ä≠·Äî·ÄÖ·Ä∫ = ·ÅÑ·ÅÑ ·Äô·Ä≠·Äî·ÄÖ·Ä∫');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            m: 45
        }), true), '·Äê·ÄÖ·Ä∫·Äî·Ä¨·Äõ·ÄÆ', '·ÅÑ·ÅÖ ·Äô·Ä≠·Äî·ÄÖ·Ä∫ = ·ÅÅ ·Äî·Ä¨·Äõ·ÄÆ');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            m: 89
        }), true), '·Äê·ÄÖ·Ä∫·Äî·Ä¨·Äõ·ÄÆ', '·Åà·Åâ ·Äô·Ä≠·Äî·ÄÖ·Ä∫ = ·Äê·ÄÖ·Ä∫·Äî·Ä¨·Äõ·ÄÆ');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            m: 90
        }), true), '·ÅÇ ·Äî·Ä¨·Äõ·ÄÆ', '·Äô·Ä≠·Äî·ÄÖ·Ä∫ ·Åâ·ÅÄ= ·ÅÇ ·Äî·Ä¨·Äõ·ÄÆ');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            h: 5
        }), true), '·ÅÖ ·Äî·Ä¨·Äõ·ÄÆ', '·ÅÖ ·Äî·Ä¨·Äõ·ÄÆ= ·ÅÖ ·Äî·Ä¨·Äõ·ÄÆ');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            h: 21
        }), true), '·ÅÇ·ÅÅ ·Äî·Ä¨·Äõ·ÄÆ', '·ÅÇ·ÅÅ ·Äî·Ä¨·Äõ·ÄÆ =·ÅÇ·ÅÅ ·Äî·Ä¨·Äõ·ÄÆ');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            h: 22
        }), true), '·Äê·ÄÖ·Ä∫·Äõ·ÄÄ·Ä∫', '·ÅÇ·ÅÇ ·Äî·Ä¨·Äõ·ÄÆ =·Äê·ÄÖ·Ä∫·Äõ·ÄÄ·Ä∫');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            h: 35
        }), true), '·Äê·ÄÖ·Ä∫·Äõ·ÄÄ·Ä∫', '·ÅÉ·ÅÖ ·Äî·Ä¨·Äõ·ÄÆ =·Äê·ÄÖ·Ä∫·Äõ·ÄÄ·Ä∫');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            h: 36
        }), true), '·ÅÇ ·Äõ·ÄÄ·Ä∫', '·ÅÉ·ÅÜ ·Äî·Ä¨·Äõ·ÄÆ = ·ÅÇ ·Äõ·ÄÄ·Ä∫');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 1
        }), true), '·Äê·ÄÖ·Ä∫·Äõ·ÄÄ·Ä∫', '·ÅÅ ·Äõ·ÄÄ·Ä∫= ·Äê·ÄÖ·Ä∫·Äõ·ÄÄ·Ä∫');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 5
        }), true), '·ÅÖ ·Äõ·ÄÄ·Ä∫', '·ÅÖ ·Äõ·ÄÄ·Ä∫ = ·ÅÖ ·Äõ·ÄÄ·Ä∫');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 25
        }), true), '·ÅÇ·ÅÖ ·Äõ·ÄÄ·Ä∫', '·ÅÇ·ÅÖ ·Äõ·ÄÄ·Ä∫= ·ÅÇ·ÅÖ ·Äõ·ÄÄ·Ä∫');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 26
        }), true), '·Äê·ÄÖ·Ä∫·Äú', '·ÅÇ·ÅÜ ·Äõ·ÄÄ·Ä∫ = ·Äê·ÄÖ·Ä∫·Äú');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 30
        }), true), '·Äê·ÄÖ·Ä∫·Äú', '·Äõ·ÄÄ·Ä∫ ·ÅÉ·ÅÄ = ·Äê·ÄÖ·Ä∫·Äú');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 43
        }), true), '·Äê·ÄÖ·Ä∫·Äú', '·ÅÑ·ÅÉ ·Äõ·ÄÄ·Ä∫ = ·Äê·ÄÖ·Ä∫·Äú');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 46
        }), true), '·ÅÇ ·Äú', '·ÅÑ·ÅÜ ·Äõ·ÄÄ·Ä∫ = ·ÅÇ ·Äú');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 74
        }), true), '·ÅÇ ·Äú', '·Åá·ÅÖ ·Äõ·ÄÄ·Ä∫= ·ÅÇ ·Äú');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 76
        }), true), '·ÅÉ ·Äú', '·Åá·ÅÜ ·Äõ·ÄÄ·Ä∫ = ·ÅÉ ·Äú');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            M: 1
        }), true), '·Äê·ÄÖ·Ä∫·Äú', '·ÅÅ ·Äú = ·Äê·ÄÖ·Ä∫·Äú');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            M: 5
        }), true), '·ÅÖ ·Äú', '·ÅÖ ·Äú = ·ÅÖ ·Äú');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 345
        }), true), '·Äê·ÄÖ·Ä∫·Äî·Äæ·ÄÖ·Ä∫', '·ÅÉ·ÅÑ·ÅÖ ·Äõ·ÄÄ·Ä∫ = ·Äê·ÄÖ·Ä∫·Äî·Äæ·ÄÖ·Ä∫');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 548
        }), true), '·ÅÇ ·Äî·Äæ·ÄÖ·Ä∫', '·ÅÖ·ÅÑ·Åà ·Äõ·ÄÄ·Ä∫ = ·ÅÇ ·Äî·Äæ·ÄÖ·Ä∫');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            y: 1
        }), true), '·Äê·ÄÖ·Ä∫·Äî·Äæ·ÄÖ·Ä∫', '·ÅÅ ·Äî·Äæ·ÄÖ·Ä∫ = ·Äê·ÄÖ·Ä∫·Äî·Äæ·ÄÖ·Ä∫');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            y: 5
        }), true), '·ÅÖ ·Äî·Äæ·ÄÖ·Ä∫', '·ÅÖ ·Äî·Äæ·ÄÖ·Ä∫ = ·ÅÖ ·Äî·Äæ·ÄÖ·Ä∫');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '·Äú·Ä¨·Äô·Ää·Ä∫·Ä∑ ·ÄÖ·ÄÄ·Äπ·ÄÄ·Äî·Ä∫.·Ä°·Äî·Ää·Ä∫·Ä∏·ÄÑ·Äö·Ä∫ ·Äô·Äæ·Ä¨', 'prefix');
        assert.equal(moment(0).from(30000), '·Äú·ÄΩ·Äî·Ä∫·ÄÅ·Ä≤·Ä∑·Äû·Ä±·Ä¨ ·ÄÖ·ÄÄ·Äπ·ÄÄ·Äî·Ä∫.·Ä°·Äî·Ää·Ä∫·Ä∏·ÄÑ·Äö·Ä∫ ·ÄÄ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '·Äú·ÄΩ·Äî·Ä∫·ÄÅ·Ä≤·Ä∑·Äû·Ä±·Ä¨ ·ÄÖ·ÄÄ·Äπ·ÄÄ·Äî·Ä∫.·Ä°·Äî·Ää·Ä∫·Ä∏·ÄÑ·Äö·Ä∫ ·ÄÄ', '·Äö·ÄÅ·ÄØ·Äô·Äæ·ÄÖ·Äï·Äº·ÄÆ·Ä∏ ·Ä°·Äê·Ä≠·Äê·Ä∫·Äê·ÄΩ·ÄÑ·Ä∫·Äñ·Ä±·Ä¨·Ä∫·Äï·Äº·Äû·Äú·Ä≠·ÄØ·Äñ·Ä±·Ä¨·Ä∫·Äï·Äº·Äô·Ää·Ä∫');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({
            s: 30
        }).fromNow(), '·Äú·Ä¨·Äô·Ää·Ä∫·Ä∑ ·ÄÖ·ÄÄ·Äπ·ÄÄ·Äî·Ä∫.·Ä°·Äî·Ää·Ä∫·Ä∏·ÄÑ·Äö·Ä∫ ·Äô·Äæ·Ä¨', '·Äú·Ä¨·Äô·Ää·Ä∫·Ä∑ ·ÄÖ·ÄÄ·Äπ·ÄÄ·Äî·Ä∫.·Ä°·Äî·Ää·Ä∫·Ä∏·ÄÑ·Äö·Ä∫ ·Äô·Äæ·Ä¨');
        assert.equal(moment().add({
            d: 5
        }).fromNow(), '·Äú·Ä¨·Äô·Ää·Ä∫·Ä∑ ·ÅÖ ·Äõ·ÄÄ·Ä∫ ·Äô·Äæ·Ä¨', '·Äú·Ä¨·Äô·Ää·Ä∫·Ä∑ ·ÅÖ ·Äõ·ÄÄ·Ä∫ ·Äô·Äæ·Ä¨');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(), '·Äö·Äî·Ä±. ·ÅÄ·ÅÇ:·ÅÄ·ÅÄ ·Äô·Äæ·Ä¨', '·Äö·Äî·Ä±. ·Äí·ÄÆ·Ä°·ÄÅ·Äª·Ä≠·Äî·Ä∫');
        assert.equal(moment(a).add({
            m: 25
        }).calendar(), '·Äö·Äî·Ä±. ·ÅÄ·ÅÇ:·ÅÇ·ÅÖ ·Äô·Äæ·Ä¨', '·Äö·ÄÅ·ÄØ·Äô·Äæ ·ÅÇ·ÅÖ ·Äô·Ä≠·Äî·ÄÖ·Ä∫·Äï·Ä±·Ä´·ÄÑ·Ä∫·Ä∏·Äë·Ää·Ä∫·Ä∑');
        assert.equal(moment(a).add({
            h: 1
        }).calendar(), '·Äö·Äî·Ä±. ·ÅÄ·ÅÉ:·ÅÄ·ÅÄ ·Äô·Äæ·Ä¨', '·Äö·ÄÅ·ÄØ·Äô·Äæ ·ÅÅ ·Äî·Ä¨·Äõ·ÄÆ·Äï·Ä±·Ä´·ÄÑ·Ä∫·Ä∏·Äë·Ää·Ä∫·Ä∑');
        assert.equal(moment(a).add({
            d: 1
        }).calendar(), '·Äô·Äî·ÄÄ·Ä∫·Äñ·Äº·Äî·Ä∫ ·ÅÄ·ÅÇ:·ÅÄ·ÅÄ ·Äô·Äæ·Ä¨', '·Äô·Äî·ÄÄ·Ä∫·Äñ·Äº·Äî·Ä∫ ·Äí·ÄÆ·Ä°·ÄÅ·Äª·Ä≠·Äî·Ä∫');
        assert.equal(moment(a).subtract({
            h: 1
        }).calendar(), '·Äö·Äî·Ä±. ·ÅÄ·ÅÅ:·ÅÄ·ÅÄ ·Äô·Äæ·Ä¨', '·Äö·ÄÅ·ÄØ·Äô·Äæ ·ÅÅ ·Äî·Ä¨·Äõ·ÄÆ·Äî·Äæ·ÄØ·Äê·Ä∫');
        assert.equal(moment(a).subtract({
            d: 1
        }).calendar(), '·Äô·Äî·Ä±.·ÄÄ ·ÅÄ·ÅÇ:·ÅÄ·ÅÄ ·Äô·Äæ·Ä¨', '·Äô·Äî·Ä±.·ÄÄ ·Äí·ÄÆ·Ä°·ÄÅ·Äª·Ä≠·Äî·Ä∫');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({
                d: i
            });
            assert.equal(m.calendar(), m.format('dddd LT [·Äô·Äæ·Ä¨]'), 'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format('dddd LT [·Äô·Äæ·Ä¨]'), 'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format('dddd LT [·Äô·Äæ·Ä¨]'), 'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({
                d: i
            });
            assert.equal(m.calendar(), m.format('[·Äï·Äº·ÄÆ·Ä∏·ÄÅ·Ä≤·Ä∑·Äû·Ä±·Ä¨] dddd LT [·Äô·Äæ·Ä¨]'), 'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format('[·Äï·Äº·ÄÆ·Ä∏·ÄÅ·Ä≤·Ä∑·Äû·Ä±·Ä¨] dddd LT [·Äô·Äæ·Ä¨]'), 'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format('[·Äï·Äº·ÄÆ·Ä∏·ÄÅ·Ä≤·Ä∑·Äû·Ä±·Ä¨] dddd LT [·Äô·Äæ·Ä¨]'), 'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({
                w: 1
            }),
            weeksFromNow = moment().add({
                w: 1
            });

        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '·Äú·ÄΩ·Äî·Ä∫·ÄÅ·Ä≤·Ä∑·Äû·Ä±·Ä¨ ·ÅÅ ·Äï·Äê·Ä∫·ÄÄ');
        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), '·ÅÅ ·Äï·Äê·Ä∫·Ä°·Äê·ÄΩ·ÄÑ·Ä∫·Ä∏');

        weeksAgo = moment().subtract({
            w: 2
        });
        weeksFromNow = moment().add({
            w: 2
        });

        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '·ÅÇ ·Äï·Äê·Ä∫ ·Ä°·Äõ·ÄÑ·Ä∫·ÄÄ');
        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), '·ÅÇ ·Äï·Äê·Ä∫ ·Ä°·Äê·ÄΩ·ÄÑ·Ä∫·Ä∏');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(), 1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(), 1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(), 2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(), 1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(), 2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008, 0, 1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008, 0, 6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008, 0, 7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008, 0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008, 0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003, 0, 1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003, 0, 5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003, 0, 6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003, 0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003, 0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009, 0, 1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009, 0, 4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009, 0, 5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009, 0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009, 0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010, 0, 1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010, 0, 3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010, 0, 4]).week(), 1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010, 0, 10]).week(), 1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010, 0, 11]).week(), 2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011, 0, 1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011, 0, 2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011, 0, 3]).week(), 1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011, 0, 9]).week(), 1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011, 0, 10]).week(), 2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0, 1]).format('w ww wo'), '·ÅÖ·ÅÇ ·ÅÖ·ÅÇ ·ÅÖ·ÅÇ', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).format('w ww wo'), '·ÅÅ ·ÅÄ·ÅÅ ·ÅÅ', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).format('w ww wo'), '·ÅÅ ·ÅÄ·ÅÅ ·ÅÅ', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).format('w ww wo'), '·ÅÇ ·ÅÄ·ÅÇ ·ÅÇ', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '·ÅÇ ·ÅÄ·ÅÇ ·ÅÇ', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('nb');

    test('parse', function (assert) {
        var tests = 'januar jan_februar feb_mars mar_april apr_mai mai_juni jun_juli jul_august aug_september sep_oktober okt_november nov_desember des'.split('_'),
            i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      's√∏ndag, februar 14. 2010, 3:25:50 pm'],
                ['ddd, hA',                            's√∏n, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. s√∏ndag s√∏n s√∏'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[den] DDDo [dagen i √•ret]',          'den 45. dagen i √•ret'],
                ['LTS',                                '15.25.50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14. februar 2010'],
                ['LLL',                                '14. februar 2010 kl. 15.25'],
                ['LLLL',                               's√∏ndag 14. februar 2010 kl. 15.25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14. feb 2010'],
                ['lll',                                '14. feb 2010 kl. 15.25'],
                ['llll',                               's√∏n 14. feb 2010 kl. 15.25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'januar jan_februar feb_mars mar_april apr_mai mai_juni jun_juli jul_august aug_september sep_oktober okt_november nov_desember des'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 's√∏ndag s√∏n s√∏_mandag man ma_tirsdag tirs ti_onsdag ons on_torsdag tors to_fredag fre fr_l√∏rdag l√∏r l√∏'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'noen sekunder', '44 sekunder = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ett minutt',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ett minutt',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutter',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutter',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'en time',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'en time',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 timer',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 timer',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 timer',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'en dag',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'en dag',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dager',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'en dag',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dager',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dager',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'en m√•ned',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'en m√•ned',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'en m√•ned',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 m√•neder',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 m√•neder',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 m√•neder',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'en m√•ned',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 m√•neder',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ett √•r',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 √•r',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'ett √•r',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 √•r',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'om noen sekunder',  'prefix');
        assert.equal(moment(0).from(30000), 'for noen sekunder siden', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'for noen sekunder siden',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'om noen sekunder', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'om 5 dager', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'i dag kl. 2.00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'i dag kl. 2.25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'i dag kl. 3.00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'i morgen kl. 2.00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'i dag kl. 1.00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'i g√•r kl. 2.00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[forrige] dddd [kl.] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[forrige] dddd [kl.] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[forrige] dddd [kl.] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),  '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),  '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),  '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),  '2 02 2.', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('ne');

    test('parse', function (assert) {
        var tests = '‡§ú‡§®‡§µ‡§∞‡•Ä ‡§ú‡§®._‡§´‡•á‡§¨‡•ç‡§∞‡•Å‡§µ‡§∞‡•Ä ‡§´‡•á‡§¨‡•ç‡§∞‡•Å._‡§Æ‡§æ‡§∞‡•ç‡§ö ‡§Æ‡§æ‡§∞‡•ç‡§ö_‡§Ö‡§™‡•ç‡§∞‡§ø‡§≤ ‡§Ö‡§™‡•ç‡§∞‡§ø._‡§Æ‡§à ‡§Æ‡§à_‡§ú‡•Å‡§® ‡§ú‡•Å‡§®_‡§ú‡•Å‡§≤‡§æ‡§à ‡§ú‡•Å‡§≤‡§æ‡§à._‡§Ö‡§ó‡§∑‡•ç‡§ü ‡§Ö‡§ó._‡§∏‡•á‡§™‡•ç‡§ü‡•á‡§Æ‡•ç‡§¨‡§∞ ‡§∏‡•á‡§™‡•ç‡§ü._‡§Ö‡§ï‡•ç‡§ü‡•ã‡§¨‡§∞ ‡§Ö‡§ï‡•ç‡§ü‡•ã._‡§®‡•ã‡§≠‡•á‡§Æ‡•ç‡§¨‡§∞ ‡§®‡•ã‡§≠‡•á._‡§°‡§ø‡§∏‡•á‡§Æ‡•ç‡§¨‡§∞ ‡§°‡§ø‡§∏‡•á.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, a‡§ï‡•ã h:mm:ss ‡§¨‡§ú‡•á',       '‡§Ü‡§á‡§§‡§¨‡§æ‡§∞, ‡•ß‡•™ ‡§´‡•á‡§¨‡•ç‡§∞‡•Å‡§µ‡§∞‡•Ä ‡•®‡•¶‡•ß‡•¶, ‡§¨‡•á‡§≤‡•Å‡§ï‡§æ‡§ï‡•ã ‡•©:‡•®‡•´:‡•´‡•¶ ‡§¨‡§ú‡•á'],
                ['ddd, a‡§ï‡•ã h ‡§¨‡§ú‡•á',                                                      '‡§Ü‡§á‡§§., ‡§¨‡•á‡§≤‡•Å‡§ï‡§æ‡§ï‡•ã ‡•© ‡§¨‡§ú‡•á'],
                ['M Mo MM MMMM MMM',                   '‡•® ‡•® ‡•¶‡•® ‡§´‡•á‡§¨‡•ç‡§∞‡•Å‡§µ‡§∞‡•Ä ‡§´‡•á‡§¨‡•ç‡§∞‡•Å.'],
                ['YYYY YY',                            '‡•®‡•¶‡•ß‡•¶ ‡•ß‡•¶'],
                ['D Do DD',                            '‡•ß‡•™ ‡•ß‡•™ ‡•ß‡•™'],
                ['d do dddd ddd dd',                   '‡•¶ ‡•¶ ‡§Ü‡§á‡§§‡§¨‡§æ‡§∞ ‡§Ü‡§á‡§§. ‡§Ü‡§á.'],
                ['DDD DDDo DDDD',                      '‡•™‡•´ ‡•™‡•´ ‡•¶‡•™‡•´'],
                ['w wo ww',                            '‡•≠ ‡•≠ ‡•¶‡•≠'],
                ['h hh',                               '‡•© ‡•¶‡•©'],
                ['H HH',                               '‡•ß‡•´ ‡•ß‡•´'],
                ['m mm',                               '‡•®‡•´ ‡•®‡•´'],
                ['s ss',                               '‡•´‡•¶ ‡•´‡•¶'],
                ['a A',                                '‡§¨‡•á‡§≤‡•Å‡§ï‡§æ ‡§¨‡•á‡§≤‡•Å‡§ï‡§æ'],
                ['LTS',                                '‡§¨‡•á‡§≤‡•Å‡§ï‡§æ‡§ï‡•ã ‡•©:‡•®‡•´:‡•´‡•¶ ‡§¨‡§ú‡•á'],
                ['L',                                  '‡•ß‡•™/‡•¶‡•®/‡•®‡•¶‡•ß‡•¶'],
                ['LL',                                 '‡•ß‡•™ ‡§´‡•á‡§¨‡•ç‡§∞‡•Å‡§µ‡§∞‡•Ä ‡•®‡•¶‡•ß‡•¶'],
                ['LLL',                                '‡•ß‡•™ ‡§´‡•á‡§¨‡•ç‡§∞‡•Å‡§µ‡§∞‡•Ä ‡•®‡•¶‡•ß‡•¶, ‡§¨‡•á‡§≤‡•Å‡§ï‡§æ‡§ï‡•ã ‡•©:‡•®‡•´ ‡§¨‡§ú‡•á'],
                ['LLLL',                               '‡§Ü‡§á‡§§‡§¨‡§æ‡§∞, ‡•ß‡•™ ‡§´‡•á‡§¨‡•ç‡§∞‡•Å‡§µ‡§∞‡•Ä ‡•®‡•¶‡•ß‡•¶, ‡§¨‡•á‡§≤‡•Å‡§ï‡§æ‡§ï‡•ã ‡•©:‡•®‡•´ ‡§¨‡§ú‡•á'],
                ['l',                                  '‡•ß‡•™/‡•®/‡•®‡•¶‡•ß‡•¶'],
                ['ll',                                 '‡•ß‡•™ ‡§´‡•á‡§¨‡•ç‡§∞‡•Å. ‡•®‡•¶‡•ß‡•¶'],
                ['lll',                                '‡•ß‡•™ ‡§´‡•á‡§¨‡•ç‡§∞‡•Å. ‡•®‡•¶‡•ß‡•¶, ‡§¨‡•á‡§≤‡•Å‡§ï‡§æ‡§ï‡•ã ‡•©:‡•®‡•´ ‡§¨‡§ú‡•á'],
                ['llll',                               '‡§Ü‡§á‡§§., ‡•ß‡•™ ‡§´‡•á‡§¨‡•ç‡§∞‡•Å. ‡•®‡•¶‡•ß‡•¶, ‡§¨‡•á‡§≤‡•Å‡§ï‡§æ‡§ï‡•ã ‡•©:‡•®‡•´ ‡§¨‡§ú‡•á']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '‡•ß', '‡•ß');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '‡•®', '‡•®');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '‡•©', '‡•©');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '‡•™', '‡•™');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '‡•´', '‡•´');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '‡•¨', '‡•¨');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '‡•≠', '‡•≠');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '‡•Æ', '‡•Æ');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '‡•Ø', '‡•Ø');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '‡•ß‡•¶', '‡•ß‡•¶');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '‡•ß‡•ß', '‡•ß‡•ß');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '‡•ß‡•®', '‡•ß‡•®');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '‡•ß‡•©', '‡•ß‡•©');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '‡•ß‡•™', '‡•ß‡•™');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '‡•ß‡•´', '‡•ß‡•´');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '‡•ß‡•¨', '‡•ß‡•¨');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '‡•ß‡•≠', '‡•ß‡•≠');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '‡•ß‡•Æ', '‡•ß‡•Æ');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '‡•ß‡•Ø', '‡•ß‡•Ø');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '‡•®‡•¶', '‡•®‡•¶');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '‡•®‡•ß', '‡•®‡•ß');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '‡•®‡•®', '‡•®‡•®');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '‡•®‡•©', '‡•®‡•©');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '‡•®‡•™', '‡•®‡•™');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '‡•®‡•´', '‡•®‡•´');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '‡•®‡•¨', '‡•®‡•¨');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '‡•®‡•≠', '‡•®‡•≠');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '‡•®‡•Æ', '‡•®‡•Æ');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '‡•®‡•Ø', '‡•®‡•Ø');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '‡•©‡•¶', '‡•©‡•¶');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '‡•©‡•ß', '‡•©‡•ß');
    });

    test('format month', function (assert) {
        var expected = '‡§ú‡§®‡§µ‡§∞‡•Ä ‡§ú‡§®._‡§´‡•á‡§¨‡•ç‡§∞‡•Å‡§µ‡§∞‡•Ä ‡§´‡•á‡§¨‡•ç‡§∞‡•Å._‡§Æ‡§æ‡§∞‡•ç‡§ö ‡§Æ‡§æ‡§∞‡•ç‡§ö_‡§Ö‡§™‡•ç‡§∞‡§ø‡§≤ ‡§Ö‡§™‡•ç‡§∞‡§ø._‡§Æ‡§à ‡§Æ‡§à_‡§ú‡•Å‡§® ‡§ú‡•Å‡§®_‡§ú‡•Å‡§≤‡§æ‡§à ‡§ú‡•Å‡§≤‡§æ‡§à._‡§Ö‡§ó‡§∑‡•ç‡§ü ‡§Ö‡§ó._‡§∏‡•á‡§™‡•ç‡§ü‡•á‡§Æ‡•ç‡§¨‡§∞ ‡§∏‡•á‡§™‡•ç‡§ü._‡§Ö‡§ï‡•ç‡§ü‡•ã‡§¨‡§∞ ‡§Ö‡§ï‡•ç‡§ü‡•ã._‡§®‡•ã‡§≠‡•á‡§Æ‡•ç‡§¨‡§∞ ‡§®‡•ã‡§≠‡•á._‡§°‡§ø‡§∏‡•á‡§Æ‡•ç‡§¨‡§∞ ‡§°‡§ø‡§∏‡•á.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '‡§Ü‡§á‡§§‡§¨‡§æ‡§∞ ‡§Ü‡§á‡§§. ‡§Ü‡§á._‡§∏‡•ã‡§Æ‡§¨‡§æ‡§∞ ‡§∏‡•ã‡§Æ. ‡§∏‡•ã._‡§Æ‡§ô‡•ç‡§ó‡§≤‡§¨‡§æ‡§∞ ‡§Æ‡§ô‡•ç‡§ó‡§≤. ‡§Æ‡§ô‡•ç_‡§¨‡•Å‡§ß‡§¨‡§æ‡§∞ ‡§¨‡•Å‡§ß. ‡§¨‡•Å._‡§¨‡§ø‡§π‡§ø‡§¨‡§æ‡§∞ ‡§¨‡§ø‡§π‡§ø. ‡§¨‡§ø._‡§∂‡•Å‡§ï‡•ç‡§∞‡§¨‡§æ‡§∞ ‡§∂‡•Å‡§ï‡•ç‡§∞. ‡§∂‡•Å._‡§∂‡§®‡§ø‡§¨‡§æ‡§∞ ‡§∂‡§®‡§ø. ‡§∂.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '‡§ï‡•á‡§π‡•Ä ‡§∏‡§Æ‡§Ø', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '‡§è‡§ï ‡§Æ‡§ø‡§®‡•á‡§ü',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '‡§è‡§ï ‡§Æ‡§ø‡§®‡•á‡§ü',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '‡•® ‡§Æ‡§ø‡§®‡•á‡§ü',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '‡•™‡•™ ‡§Æ‡§ø‡§®‡•á‡§ü',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '‡§è‡§ï ‡§ò‡§£‡•ç‡§ü‡§æ',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '‡§è‡§ï ‡§ò‡§£‡•ç‡§ü‡§æ',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '‡•® ‡§ò‡§£‡•ç‡§ü‡§æ',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '‡•´ ‡§ò‡§£‡•ç‡§ü‡§æ',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '‡•®‡•ß ‡§ò‡§£‡•ç‡§ü‡§æ',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '‡§è‡§ï ‡§¶‡§ø‡§®',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '‡§è‡§ï ‡§¶‡§ø‡§®',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '‡•® ‡§¶‡§ø‡§®',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '‡§è‡§ï ‡§¶‡§ø‡§®',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '‡•´ ‡§¶‡§ø‡§®',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '‡•®‡•´ ‡§¶‡§ø‡§®',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '‡§è‡§ï ‡§Æ‡§π‡§ø‡§®‡§æ',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '‡§è‡§ï ‡§Æ‡§π‡§ø‡§®‡§æ',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '‡§è‡§ï ‡§Æ‡§π‡§ø‡§®‡§æ',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '‡•® ‡§Æ‡§π‡§ø‡§®‡§æ',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '‡•® ‡§Æ‡§π‡§ø‡§®‡§æ',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '‡•© ‡§Æ‡§π‡§ø‡§®‡§æ',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '‡§è‡§ï ‡§Æ‡§π‡§ø‡§®‡§æ',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '‡•´ ‡§Æ‡§π‡§ø‡§®‡§æ',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '‡§è‡§ï ‡§¨‡§∞‡•ç‡§∑',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '‡•® ‡§¨‡§∞‡•ç‡§∑',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '‡§è‡§ï ‡§¨‡§∞‡•ç‡§∑',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '‡•´ ‡§¨‡§∞‡•ç‡§∑',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '‡§ï‡•á‡§π‡•Ä ‡§∏‡§Æ‡§Ø‡§Æ‡§æ',  'prefix');
        assert.equal(moment(0).from(30000), '‡§ï‡•á‡§π‡•Ä ‡§∏‡§Æ‡§Ø ‡§Ö‡§ó‡§æ‡§°‡•Ä', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '‡§ï‡•á‡§π‡•Ä ‡§∏‡§Æ‡§Ø ‡§Ö‡§ó‡§æ‡§°‡•Ä',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '‡§ï‡•á‡§π‡•Ä ‡§∏‡§Æ‡§Ø‡§Æ‡§æ', '‡§ï‡•á‡§π‡•Ä ‡§∏‡§Æ‡§Ø‡§Æ‡§æ');
        assert.equal(moment().add({d: 5}).fromNow(), '‡•´ ‡§¶‡§ø‡§®‡§Æ‡§æ', '‡•´ ‡§¶‡§ø‡§®‡§Æ‡§æ');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '‡§Ü‡§ú ‡§∞‡§æ‡§§‡•Ä‡§ï‡•ã ‡•®:‡•¶‡•¶ ‡§¨‡§ú‡•á',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '‡§Ü‡§ú ‡§∞‡§æ‡§§‡•Ä‡§ï‡•ã ‡•®:‡•®‡•´ ‡§¨‡§ú‡•á',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '‡§Ü‡§ú ‡§¨‡§ø‡§π‡§æ‡§®‡§ï‡•ã ‡•©:‡•¶‡•¶ ‡§¨‡§ú‡•á',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '‡§≠‡•ã‡§≤‡•Ä ‡§∞‡§æ‡§§‡•Ä‡§ï‡•ã ‡•®:‡•¶‡•¶ ‡§¨‡§ú‡•á',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '‡§Ü‡§ú ‡§∞‡§æ‡§§‡•Ä‡§ï‡•ã ‡•ß:‡•¶‡•¶ ‡§¨‡§ú‡•á',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '‡§π‡§ø‡§ú‡•ã ‡§∞‡§æ‡§§‡•Ä‡§ï‡•ã ‡•®:‡•¶‡•¶ ‡§¨‡§ú‡•á', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[‡§Ü‡§â‡§Å‡§¶‡•ã] dddd[,] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[‡§Ü‡§â‡§Å‡§¶‡•ã] dddd[,] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[‡§Ü‡§â‡§Å‡§¶‡•ã] dddd[,] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[‡§ó‡§è‡§ï‡•ã] dddd[,] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[‡§ó‡§è‡§ï‡•ã] dddd[,] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[‡§ó‡§è‡§ï‡•ã] dddd[,] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), '‡§∞‡§æ‡§§‡•Ä', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), '‡§¨‡§ø‡§π‡§æ‡§®', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), '‡§¶‡§ø‡§â‡§Å‡§∏‡•ã', 'during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), '‡§¨‡•á‡§≤‡•Å‡§ï‡§æ', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), '‡§∏‡§æ‡§Å‡§ù', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('a'), '‡§∞‡§æ‡§§‡•Ä', 'night');

        assert.equal(moment([2011, 2, 23,  2, 30]).format('A'), '‡§∞‡§æ‡§§‡•Ä', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('A'), '‡§¨‡§ø‡§π‡§æ‡§®', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('A'), '‡§¶‡§ø‡§â‡§Å‡§∏‡•ã', 'during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('A'), '‡§¨‡•á‡§≤‡•Å‡§ï‡§æ', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('A'), '‡§∏‡§æ‡§Å‡§ù', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('A'), '‡§∞‡§æ‡§§‡•Ä', 'night');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '‡•ß ‡•¶‡•ß ‡•ß', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '‡•ß ‡•¶‡•ß ‡•ß', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '‡•® ‡•¶‡•® ‡•®', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '‡•® ‡•¶‡•® ‡•®', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '‡•© ‡•¶‡•© ‡•©', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('meridiem invariant', function (assert) {
        var h, m, t1, t2;
        for (h = 0; h < 24; ++h) {
            for (m = 0; m < 60; m += 15) {
                t1 = moment.utc([2000, 0, 1, h, m]);
                t2 = moment(t1.format('A h:mm'), 'A h:mm');
                assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                        'meridiem at ' + t1.format('HH:mm'));
            }
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('nl');

    test('parse', function (assert) {
        var tests = 'januari jan._februari feb._maart mrt._april apr._mei mei._juni jun._juli jul._augustus aug._september sep._oktober okt._november nov._december dec.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, HH:mm:ss',       'zondag, februari 14de 2010, 15:25:50'],
                ['ddd, HH',                            'zo., 15'],
                ['M Mo MM MMMM MMM',                   '2 2de 02 februari feb.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14de 14'],
                ['d do dddd ddd dd',                   '0 0de zondag zo. Zo'],
                ['DDD DDDo DDDD',                      '45 45ste 045'],
                ['w wo ww',                            '6 6de 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45ste day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14-02-2010'],
                ['LL',                                 '14 februari 2010'],
                ['LLL',                                '14 februari 2010 15:25'],
                ['LLLL',                               'zondag 14 februari 2010 15:25'],
                ['l',                                  '14-2-2010'],
                ['ll',                                 '14 feb. 2010'],
                ['lll',                                '14 feb. 2010 15:25'],
                ['llll',                               'zo. 14 feb. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1ste', '1ste');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2de', '2de');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3de', '3de');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4de', '4de');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5de', '5de');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6de', '6de');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7de', '7de');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8ste', '8ste');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9de', '9de');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10de', '10de');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11de', '11de');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12de', '12de');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13de', '13de');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14de', '14de');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15de', '15de');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16de', '16de');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17de', '17de');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18de', '18de');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19de', '19de');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20ste', '20ste');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21ste', '21ste');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22ste', '22ste');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23ste', '23ste');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24ste', '24ste');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25ste', '25ste');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26ste', '26ste');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27ste', '27ste');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28ste', '28ste');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29ste', '29ste');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30ste', '30ste');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31ste', '31ste');
    });

    test('format month', function (assert) {
        var expected = 'januari jan._februari feb._maart mrt._april apr._mei mei_juni jun._juli jul._augustus aug._september sep._oktober okt._november nov._december dec.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'zondag zo. Zo_maandag ma. Ma_dinsdag di. Di_woensdag wo. Wo_donderdag do. Do_vrijdag vr. Vr_zaterdag za. Za'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'een paar seconden', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '√©√©n minuut',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '√©√©n minuut',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuten',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuten',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '√©√©n uur',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '√©√©n uur',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 uur',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 uur',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 uur',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '√©√©n dag',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '√©√©n dag',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dagen',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '√©√©n dag',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dagen',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dagen',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '√©√©n maand',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '√©√©n maand',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '√©√©n maand',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 maanden',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 maanden',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 maanden',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '√©√©n maand',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 maanden',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '√©√©n jaar',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 jaar',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '√©√©n jaar',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 jaar',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'over een paar seconden',  'prefix');
        assert.equal(moment(0).from(30000), 'een paar seconden geleden', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'een paar seconden geleden',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'over een paar seconden', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'over 5 dagen', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'vandaag om 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'vandaag om 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'vandaag om 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'morgen om 02:00',    'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'vandaag om 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'gisteren om 02:00',   'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[afgelopen] dddd [om] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[afgelopen] dddd [om] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[afgelopen] dddd [om] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('month abbreviation', function (assert) {
        assert.equal(moment([2012, 5, 23]).format('D-MMM-YYYY'), '23-jun-2012', 'format month abbreviation surrounded by dashes should not include a dot');
        assert.equal(moment([2012, 5, 23]).format('D MMM YYYY'), '23 jun. 2012', 'format month abbreviation not surrounded by dashes should include a dot');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52ste', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1ste', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1ste', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),    '2 02 2de', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),    '2 02 2de', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('nn');

    test('parse', function (assert) {
        var tests = 'januar jan_februar feb_mars mar_april apr_mai mai_juni jun_juli jul_august aug_september sep_oktober okt_november nov_desember des'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'sundag, februar 14. 2010, 3:25:50 pm'],
                ['ddd, hA',                            'sun, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. sundag sun su'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14 februar 2010'],
                ['LLL',                                '14 februar 2010 15:25'],
                ['LLLL',                               'sundag 14 februar 2010 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14 feb 2010'],
                ['lll',                                '14 feb 2010 15:25'],
                ['llll',                               'sun 14 feb 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'januar jan_februar feb_mars mar_april apr_mai mai_juni jun_juli jul_august aug_september sep_oktober okt_november nov_desember des'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'sundag sun su_m√•ndag m√•n m√•_tysdag tys ty_onsdag ons on_torsdag tor to_fredag fre fr_laurdag lau l√∏'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'nokre sekund', '44 sekunder = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'eit minutt',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'eit minutt',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutt',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutt',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ein time',     '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ein time',     '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 timar',      '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 timar',      '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 timar',     '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ein dag',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ein dag',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dagar',      '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ein dag',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dagar',      '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dagar',     '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ein m√•nad',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ein m√•nad',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ein m√•nad',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 m√•nader',    '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 m√•nader',    '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 m√•nader',    '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ein m√•nad',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 m√•nader',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'eit √•r',       '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 √•r',         '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'eit √•r',       '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 √•r',         '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'om nokre sekund',  'prefix');
        assert.equal(moment(0).from(30000), 'for nokre sekund sidan', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'for nokre sekund sidan',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'om nokre sekund', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'om 5 dagar', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'I dag klokka 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'I dag klokka 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'I dag klokka 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'I morgon klokka 02:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'I dag klokka 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'I g√•r klokka 02:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [klokka] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [klokka] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [klokka] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[F√∏reg√•ande] dddd [klokka] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[F√∏reg√•ande] dddd [klokka] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[F√∏reg√•ande] dddd [klokka] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('pl');

    test('parse', function (assert) {
        var tests = 'stycze≈Ñ stycznia sty_luty lutego lut_marzec marca mar_kwiecie≈Ñ kwietnia kwi_maj maja maj_czerwiec czerwca cze_lipiec lipca lip_sierpie≈Ñ sierpnia sie_wrzesie≈Ñ wrze≈õnia wrz_pa≈∫dziernik pa≈∫dziernika pa≈∫_listopad listopada lis_grudzie≈Ñ grudnia gru'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][2], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][2], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][2].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][2].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('parse strict', function (assert) {
        var tests = 'stycze≈Ñ stycznia sty_luty lutego lut_marzec marca mar_kwiecie≈Ñ kwietnia kwi_maj maja maj_czerwiec czerwca cze_lipiec lipca lip_sierpie≈Ñ sierpnia sie_wrzesie≈Ñ wrze≈õnia wrz_pa≈∫dziernik pa≈∫dziernika pa≈∫_listopad listopada lis_grudzie≈Ñ grudnia gru'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm, true).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][2], 'MMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][2].toLocaleLowerCase(), 'MMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][2].toLocaleUpperCase(), 'MMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'niedziela, luty 14. 2010, 3:25:50 pm'],
                ['ddd, hA',                            'nie, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 luty lut'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. niedziela nie N'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14 lutego 2010'],
                ['LLL',                                '14 lutego 2010 15:25'],
                ['LLLL',                               'niedziela, 14 lutego 2010 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14 lut 2010'],
                ['lll',                                '14 lut 2010 15:25'],
                ['llll',                               'nie, 14 lut 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'stycze≈Ñ sty_luty lut_marzec mar_kwiecie≈Ñ kwi_maj maj_czerwiec cze_lipiec lip_sierpie≈Ñ sie_wrzesie≈Ñ wrz_pa≈∫dziernik pa≈∫_listopad lis_grudzie≈Ñ gru'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'niedziela nie N_poniedzia≈Çek pon Pn_wtorek wt Wt_≈õroda ≈õr ≈ör_czwartek czw Cz_piƒÖtek pt Pt_sobota sb So'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'kilka sekund',  '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'minuta',        '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'minuta',        '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuty',      '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuty',     '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'godzina',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'godzina',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 godziny',     '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 godzin',      '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 godzin',     '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '1 dzie≈Ñ',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '1 dzie≈Ñ',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dni',         '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '1 dzie≈Ñ',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dni',         '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dni',        '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'miesiƒÖc',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'miesiƒÖc',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'miesiƒÖc',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 miesiƒÖce',    '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 miesiƒÖce',    '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 miesiƒÖce',    '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'miesiƒÖc',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 miesiƒôcy',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'rok',           '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 lata',        '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'rok',           '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 lat',         '5 years = 5 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 112}), true), '112 lat',       '112 years = 112 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 122}), true), '122 lata',      '122 years = 122 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 213}), true), '213 lat',       '213 years = 213 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 223}), true), '223 lata',      '223 years = 223 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'za kilka sekund',  'prefix');
        assert.equal(moment(0).from(30000), 'kilka sekund temu', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'kilka sekund temu',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'za kilka sekund', 'in a few seconds');
        assert.equal(moment().add({h: 1}).fromNow(), 'za godzinƒô', 'in an hour');
        assert.equal(moment().add({d: 5}).fromNow(), 'za 5 dni', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Dzi≈õ o 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Dzi≈õ o 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Dzi≈õ o 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Jutro o 02:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Dzi≈õ o 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Wczoraj o 02:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[W] dddd [o] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[W] dddd [o] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[W] dddd [o] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
                return '[W zesz≈ÇƒÖ niedzielƒô o] LT';
            case 3:
                return '[W zesz≈ÇƒÖ ≈õrodƒô o] LT';
            case 6:
                return '[W zesz≈ÇƒÖ sobotƒô o] LT';
            default:
                return '[W zesz≈Çy] dddd [o] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(), m.format(makeFormat(m)), 'Today - ' + i + ' days current time');

            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format(makeFormat(m)), 'Today - ' + i + ' days beginning of day');

            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format(makeFormat(m)), 'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('pt-br');

    test('parse', function (assert) {
        var tests = 'janeiro jan_fevereiro fev_mar√ßo mar_abril abr_maio mai_junho jun_julho jul_agosto ago_setembro set_outubro out_novembro nov_dezembro dez'.split('_'), i;

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Domingo, Fevereiro 14¬∫ 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Dom, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2¬∫ 02 Fevereiro Fev'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14¬∫ 14'],
                ['d do dddd ddd',                      '0 0¬∫ Domingo Dom'],
                ['DDD DDDo DDDD',                      '45 45¬∫ 045'],
                ['w wo ww',                            '8 8¬∫ 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45¬∫ day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 de Fevereiro de 2010'],
                ['LLL',                                '14 de Fevereiro de 2010 √†s 15:25'],
                ['LLLL',                               'Domingo, 14 de Fevereiro de 2010 √†s 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 de Fev de 2010'],
                ['lll',                                '14 de Fev de 2010 √†s 15:25'],
                ['llll',                               'Dom, 14 de Fev de 2010 √†s 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1¬∫', '1¬∫');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2¬∫', '2¬∫');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3¬∫', '3¬∫');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4¬∫', '4¬∫');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5¬∫', '5¬∫');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6¬∫', '6¬∫');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7¬∫', '7¬∫');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8¬∫', '8¬∫');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9¬∫', '9¬∫');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10¬∫', '10¬∫');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11¬∫', '11¬∫');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12¬∫', '12¬∫');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13¬∫', '13¬∫');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14¬∫', '14¬∫');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15¬∫', '15¬∫');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16¬∫', '16¬∫');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17¬∫', '17¬∫');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18¬∫', '18¬∫');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19¬∫', '19¬∫');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20¬∫', '20¬∫');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21¬∫', '21¬∫');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22¬∫', '22¬∫');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23¬∫', '23¬∫');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24¬∫', '24¬∫');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25¬∫', '25¬∫');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26¬∫', '26¬∫');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27¬∫', '27¬∫');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28¬∫', '28¬∫');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29¬∫', '29¬∫');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30¬∫', '30¬∫');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31¬∫', '31¬∫');
    });

    test('format month', function (assert) {
        var expected = 'Janeiro Jan_Fevereiro Fev_Mar√ßo Mar_Abril Abr_Maio Mai_Junho Jun_Julho Jul_Agosto Ago_Setembro Set_Outubro Out_Novembro Nov_Dezembro Dez'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Domingo Dom_Segunda-Feira Seg_Ter√ßa-Feira Ter_Quarta-Feira Qua_Quinta-Feira Qui_Sexta-Feira Sex_S√°bado S√°b'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'segundos',    '44 seconds = seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'um minuto',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'um minuto',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutos',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutos', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'uma hora',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'uma hora',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 horas',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 horas',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 horas',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'um dia',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'um dia',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dias',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'um dia',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dias',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dias',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'um m√™s',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'um m√™s',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'um m√™s',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 meses',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 meses',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 meses',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'um m√™s',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 meses',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'um ano',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 anos',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'um ano',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 anos',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'em segundos', 'prefix');
        assert.equal(moment(0).from(30000), 'segundos atr√°s', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'em segundos', 'in seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'em 5 dias', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Hoje √†s 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Hoje √†s 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Hoje √†s 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Amanh√£ √†s 02:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Hoje √†s 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Ontem √†s 02:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [√†s] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [√†s] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [√†s] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format((m.day() === 0 || m.day() === 6) ? '[√öltimo] dddd [√†s] LT' : '[√öltima] dddd [√†s] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format((m.day() === 0 || m.day() === 6) ? '[√öltimo] dddd [√†s] LT' : '[√öltima] dddd [√†s] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format((m.day() === 0 || m.day() === 6) ? '[√öltimo] dddd [√†s] LT' : '[√öltima] dddd [√†s] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1¬∫', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1¬∫', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2¬∫', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2¬∫', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3¬∫', 'Jan 15 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('pt');

    test('parse', function (assert) {
        var tests = 'Janeiro Jan_Fevereiro Fev_Mar√ßo Mar_Abril Abr_Maio Mai_Junho Jun_Julho Jul_Agosto Ago_Setembro Set_Outubro Out_Novembro Nov_Dezembro Dez'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Domingo, Fevereiro 14¬∫ 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Dom, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2¬∫ 02 Fevereiro Fev'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14¬∫ 14'],
                ['d do dddd ddd',                      '0 0¬∫ Domingo Dom'],
                ['DDD DDDo DDDD',                      '45 45¬∫ 045'],
                ['w wo ww',                            '6 6¬∫ 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45¬∫ day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 de Fevereiro de 2010'],
                ['LLL',                                '14 de Fevereiro de 2010 15:25'],
                ['LLLL',                               'Domingo, 14 de Fevereiro de 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 de Fev de 2010'],
                ['lll',                                '14 de Fev de 2010 15:25'],
                ['llll',                               'Dom, 14 de Fev de 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1¬∫', '1¬∫');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2¬∫', '2¬∫');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3¬∫', '3¬∫');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4¬∫', '4¬∫');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5¬∫', '5¬∫');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6¬∫', '6¬∫');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7¬∫', '7¬∫');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8¬∫', '8¬∫');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9¬∫', '9¬∫');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10¬∫', '10¬∫');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11¬∫', '11¬∫');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12¬∫', '12¬∫');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13¬∫', '13¬∫');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14¬∫', '14¬∫');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15¬∫', '15¬∫');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16¬∫', '16¬∫');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17¬∫', '17¬∫');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18¬∫', '18¬∫');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19¬∫', '19¬∫');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20¬∫', '20¬∫');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21¬∫', '21¬∫');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22¬∫', '22¬∫');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23¬∫', '23¬∫');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24¬∫', '24¬∫');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25¬∫', '25¬∫');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26¬∫', '26¬∫');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27¬∫', '27¬∫');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28¬∫', '28¬∫');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29¬∫', '29¬∫');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30¬∫', '30¬∫');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31¬∫', '31¬∫');
    });

    test('format month', function (assert) {
        var expected = 'Janeiro Jan_Fevereiro Fev_Mar√ßo Mar_Abril Abr_Maio Mai_Junho Jun_Julho Jul_Agosto Ago_Setembro Set_Outubro Out_Novembro Nov_Dezembro Dez'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Domingo Dom Dom_Segunda-Feira Seg 2¬™_Ter√ßa-Feira Ter 3¬™_Quarta-Feira Qua 4¬™_Quinta-Feira Qui 5¬™_Sexta-Feira Sex 6¬™_S√°bado S√°b S√°b'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'segundos',    '44 seconds = seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'um minuto',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'um minuto',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutos',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutos', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'uma hora',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'uma hora',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 horas',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 horas',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 horas',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'um dia',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'um dia',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dias',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'um dia',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dias',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dias',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'um m√™s',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'um m√™s',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'um m√™s',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 meses',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 meses',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 meses',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'um m√™s',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 meses',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'um ano',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 anos',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'um ano',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 anos',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'em segundos', 'prefix');
        assert.equal(moment(0).from(30000), 'h√° segundos', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'em segundos', 'in seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'em 5 dias', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Hoje √†s 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Hoje √†s 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Hoje √†s 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Amanh√£ √†s 02:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Hoje √†s 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Ontem √†s 02:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [√†s] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [√†s] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [√†s] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format((m.day() === 0 || m.day() === 6) ? '[√öltimo] dddd [√†s] LT' : '[√öltima] dddd [√†s] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format((m.day() === 0 || m.day() === 6) ? '[√öltimo] dddd [√†s] LT' : '[√öltima] dddd [√†s] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format((m.day() === 0 || m.day() === 6) ? '[√öltimo] dddd [√†s] LT' : '[√öltima] dddd [√†s] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52¬∫', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),  '1 01 1¬∫', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),  '1 01 1¬∫', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),  '2 02 2¬∫', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),  '2 02 2¬∫', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('ro');

    test('parse', function (assert) {
        var tests = 'ianuarie ian._februarie febr._martie mart._aprilie apr._mai mai_iunie iun._iulie iul._august aug._septembrie sept._octombrie oct._noiembrie nov._decembrie dec.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss A',  'duminicƒÉ, februarie 14 2010, 3:25:50 PM'],
                ['ddd, hA',                        'Dum, 3PM'],
                ['M Mo MM MMMM MMM',               '2 2 02 februarie febr.'],
                ['YYYY YY',                        '2010 10'],
                ['D Do DD',                        '14 14 14'],
                ['d do dddd ddd dd',               '0 0 duminicƒÉ Dum Du'],
                ['DDD DDDo DDDD',                  '45 45 045'],
                ['w wo ww',                        '7 7 07'],
                ['h hh',                           '3 03'],
                ['H HH',                           '15 15'],
                ['m mm',                           '25 25'],
                ['s ss',                           '50 50'],
                ['a A',                            'pm PM'],
                ['[a] DDDo[a zi a anului]',        'a 45a zi a anului'],
                ['LTS',                            '15:25:50'],
                ['L',                              '14.02.2010'],
                ['LL',                             '14 februarie 2010'],
                ['LLL',                            '14 februarie 2010 15:25'],
                ['LLLL',                           'duminicƒÉ, 14 februarie 2010 15:25'],
                ['l',                              '14.2.2010'],
                ['ll',                             '14 febr. 2010'],
                ['lll',                            '14 febr. 2010 15:25'],
                ['llll',                           'Dum, 14 febr. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = 'ianuarie ian._februarie febr._martie mart._aprilie apr._mai mai_iunie iun._iulie iul._august aug._septembrie sept._octombrie oct._noiembrie nov._decembrie dec.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'duminicƒÉ Dum Du_luni Lun Lu_mar»õi Mar Ma_miercuri Mie Mi_joi Joi Jo_vineri Vin Vi_s√¢mbƒÉtƒÉ S√¢m S√¢'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'c√¢teva secunde', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'un minut',       '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'un minut',       '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minute',       '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 de minute',   '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'o orƒÉ',          '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'o orƒÉ',          '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ore',          '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ore',          '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 de ore',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'o zi',           '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'o zi',           '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 zile',         '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'o zi',           '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 zile',         '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 de zile',     '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'o lunƒÉ',         '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'o lunƒÉ',         '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'o lunƒÉ',         '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 luni',         '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 luni',         '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 luni',         '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'o lunƒÉ',         '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 luni',         '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'un an',          '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ani',          '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'un an',          '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ani',          '5 years = 5 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 19}), true),   '19 ani',        '19 years = 19 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 20}), true),   '20 de ani',     '20 years = 20 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 100}), true),   '100 de ani',   '100 years = 100 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 101}), true),   '101 ani',      '101 years = 101 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 119}), true),   '119 ani',      '119 years = 119 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 120}), true),   '120 de ani',   '120 years = 120 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 219}), true),   '219 ani',      '219 years = 219 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 220}), true),   '220 de ani',   '220 years = 220 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'peste c√¢teva secunde',   'prefix');
        assert.equal(moment(0).from(30000), 'c√¢teva secunde √Æn urmƒÉ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'c√¢teva secunde √Æn urmƒÉ',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'peste c√¢teva secunde', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'peste 5 zile', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'azi la 2:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'azi la 2:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'azi la 3:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'm√¢ine la 2:00',   'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'azi la 1:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'ieri la 2:00',    'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [la] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [la] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [la] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[fosta] dddd [la] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[fosta] dddd [la] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[fosta] dddd [la] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('ru');

    test('parse', function (assert) {
        var tests = '—è–Ω–≤–∞—Ä—å —è–Ω–≤_—Ñ–µ–≤—Ä–∞–ª—å —Ñ–µ–≤_–º–∞—Ä—Ç –º–∞—Ä—Ç_–∞–ø—Ä–µ–ª—å –∞–ø—Ä_–º–∞–π –º–∞–π_–∏—é–Ω—å –∏—é–Ω—å_–∏—é–ª—å –∏—é–ª—å_–∞–≤–≥—É—Å—Ç –∞–≤–≥_—Å–µ–Ω—Ç—è–±—Ä—å —Å–µ–Ω_–æ–∫—Ç—è–±—Ä—å –æ–∫—Ç_–Ω–æ—è–±—Ä—å –Ω–æ—è_–¥–µ–∫–∞–±—Ä—å –¥–µ–∫'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('parse exceptional case', function (assert) {
        assert.equal(moment('11 –º–∞—è 1989', ['DD MMMM YYYY']).format('DD-MM-YYYY'), '11-05-1989');
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, HH:mm:ss',       '–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ, 14-–≥–æ —Ñ–µ–≤—Ä–∞–ª—è 2010, 15:25:50'],
                ['ddd, h A',                           '–≤—Å, 3 –¥–Ω—è'],
                ['M Mo MM MMMM MMM',                   '2 2-–π 02 —Ñ–µ–≤—Ä–∞–ª—å —Ñ–µ–≤'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14-–≥–æ 14'],
                ['d do dddd ddd dd',                   '0 0-–π –≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ –≤—Å –≤—Å'],
                ['DDD DDDo DDDD',                      '45 45-–π 045'],
                ['w wo ww',                            '7 7-—è 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                '–¥–Ω—è –¥–Ω—è'],
                ['DDDo [–¥–µ–Ω—å –≥–æ–¥–∞]',                   '45-–π –¥–µ–Ω—å –≥–æ–¥–∞'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14 —Ñ–µ–≤—Ä–∞–ª—è 2010 –≥.'],
                ['LLL',                                '14 —Ñ–µ–≤—Ä–∞–ª—è 2010 –≥., 15:25'],
                ['LLLL',                               '–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ, 14 —Ñ–µ–≤—Ä–∞–ª—è 2010 –≥., 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14 —Ñ–µ–≤ 2010 –≥.'],
                ['lll',                                '14 —Ñ–µ–≤ 2010 –≥., 15:25'],
                ['llll',                               '–≤—Å, 14 —Ñ–µ–≤ 2010 –≥., 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format meridiem', function (assert) {
        assert.equal(moment([2012, 11, 28, 0, 0]).format('A'), '–Ω–æ—á–∏', 'night');
        assert.equal(moment([2012, 11, 28, 3, 59]).format('A'), '–Ω–æ—á–∏', 'night');
        assert.equal(moment([2012, 11, 28, 4, 0]).format('A'), '—É—Ç—Ä–∞', 'morning');
        assert.equal(moment([2012, 11, 28, 11, 59]).format('A'), '—É—Ç—Ä–∞', 'morning');
        assert.equal(moment([2012, 11, 28, 12, 0]).format('A'), '–¥–Ω—è', 'afternoon');
        assert.equal(moment([2012, 11, 28, 16, 59]).format('A'), '–¥–Ω—è', 'afternoon');
        assert.equal(moment([2012, 11, 28, 17, 0]).format('A'), '–≤–µ—á–µ—Ä–∞', 'evening');
        assert.equal(moment([2012, 11, 28, 23, 59]).format('A'), '–≤–µ—á–µ—Ä–∞', 'evening');
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-–π', '1-–π');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-–π', '2-–π');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-–π', '3-–π');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-–π', '4-–π');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-–π', '5-–π');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-–π', '6-–π');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-–π', '7-–π');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-–π', '8-–π');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-–π', '9-–π');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-–π', '10-–π');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-–π', '11-–π');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-–π', '12-–π');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-–π', '13-–π');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-–π', '14-–π');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-–π', '15-–π');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-–π', '16-–π');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-–π', '17-–π');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-–π', '18-–π');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-–π', '19-–π');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-–π', '20-–π');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-–π', '21-–π');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-–π', '22-–π');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-–π', '23-–π');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-–π', '24-–π');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-–π', '25-–π');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-–π', '26-–π');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-–π', '27-–π');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-–π', '28-–π');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-–π', '29-–π');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-–π', '30-–π');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-–π', '31-–π');
    });

    test('format month', function (assert) {
        var expected = '—è–Ω–≤–∞—Ä—å —è–Ω–≤_—Ñ–µ–≤—Ä–∞–ª—å —Ñ–µ–≤_–º–∞—Ä—Ç –º–∞—Ä—Ç_–∞–ø—Ä–µ–ª—å –∞–ø—Ä_–º–∞–π –º–∞–π_–∏—é–Ω—å –∏—é–Ω—å_–∏—é–ª—å –∏—é–ª—å_–∞–≤–≥—É—Å—Ç –∞–≤–≥_—Å–µ–Ω—Ç—è–±—Ä—å —Å–µ–Ω_–æ–∫—Ç—è–±—Ä—å –æ–∫—Ç_–Ω–æ—è–±—Ä—å –Ω–æ—è_–¥–µ–∫–∞–±—Ä—å –¥–µ–∫'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format month case', function (assert) {
        var months = {
            'nominative': '—è–Ω–≤–∞—Ä—å_—Ñ–µ–≤—Ä–∞–ª—å_–º–∞—Ä—Ç_–∞–ø—Ä–µ–ª—å_–º–∞–π_–∏—é–Ω—å_–∏—é–ª—å_–∞–≤–≥—É—Å—Ç_—Å–µ–Ω—Ç—è–±—Ä—å_–æ–∫—Ç—è–±—Ä—å_–Ω–æ—è–±—Ä—å_–¥–µ–∫–∞–±—Ä—å'.split('_'),
            'accusative': '—è–Ω–≤–∞—Ä—è_—Ñ–µ–≤—Ä–∞–ª—è_–º–∞—Ä—Ç–∞_–∞–ø—Ä–µ–ª—è_–º–∞—è_–∏—é–Ω—è_–∏—é–ª—è_–∞–≤–≥—É—Å—Ç–∞_—Å–µ–Ω—Ç—è–±—Ä—è_–æ–∫—Ç—è–±—Ä—è_–Ω–æ—è–±—Ä—è_–¥–µ–∫–∞–±—Ä—è'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2011, i, 1]).format('D MMMM'), '1 ' + months.accusative[i], '1 ' + months.accusative[i]);
            assert.equal(moment([2011, i, 1]).format('MMMM'), months.nominative[i], '1 ' + months.nominative[i]);
        }
    });

    test('format month short case', function (assert) {
        var monthsShort = {
            'nominative': '—è–Ω–≤_—Ñ–µ–≤_–º–∞—Ä—Ç_–∞–ø—Ä_–º–∞–π_–∏—é–Ω—å_–∏—é–ª—å_–∞–≤–≥_—Å–µ–Ω_–æ–∫—Ç_–Ω–æ—è_–¥–µ–∫'.split('_'),
            'accusative': '—è–Ω–≤_—Ñ–µ–≤_–º–∞—Ä_–∞–ø—Ä_–º–∞—è_–∏—é–Ω—è_–∏—é–ª—è_–∞–≤–≥_—Å–µ–Ω_–æ–∫—Ç_–Ω–æ—è_–¥–µ–∫'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2011, i, 1]).format('D MMM'), '1 ' + monthsShort.accusative[i], '1 ' + monthsShort.accusative[i]);
            assert.equal(moment([2011, i, 1]).format('MMM'), monthsShort.nominative[i], '1 ' + monthsShort.nominative[i]);
        }
    });

    test('format month case with escaped symbols', function (assert) {
        var months = {
            'nominative': '—è–Ω–≤–∞—Ä—å_—Ñ–µ–≤—Ä–∞–ª—å_–º–∞—Ä—Ç_–∞–ø—Ä–µ–ª—å_–º–∞–π_–∏—é–Ω—å_–∏—é–ª—å_–∞–≤–≥—É—Å—Ç_—Å–µ–Ω—Ç—è–±—Ä—å_–æ–∫—Ç—è–±—Ä—å_–Ω–æ—è–±—Ä—å_–¥–µ–∫–∞–±—Ä—å'.split('_'),
            'accusative': '—è–Ω–≤–∞—Ä—è_—Ñ–µ–≤—Ä–∞–ª—è_–º–∞—Ä—Ç–∞_–∞–ø—Ä–µ–ª—è_–º–∞—è_–∏—é–Ω—è_–∏—é–ª—è_–∞–≤–≥—É—Å—Ç–∞_—Å–µ–Ω—Ç—è–±—Ä—è_–æ–∫—Ç—è–±—Ä—è_–Ω–æ—è–±—Ä—è_–¥–µ–∫–∞–±—Ä—è'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2013, i, 1]).format('D[] MMMM'), '1 ' + months.accusative[i], '1 ' + months.accusative[i]);
            assert.equal(moment([2013, i, 1]).format('[<i>]D[</i>] [<b>]MMMM[</b>]'), '<i>1</i> <b>' + months.accusative[i] + '</b>', '1 <b>' + months.accusative[i] + '</b>');
            assert.equal(moment([2013, i, 1]).format('D[-–π –¥–µ–Ω—å] MMMM'), '1-–π –¥–µ–Ω—å ' + months.accusative[i], '1-–π –¥–µ–Ω—å ' + months.accusative[i]);
            assert.equal(moment([2013, i, 1]).format('D, MMMM'), '1, ' + months.nominative[i], '1, ' + months.nominative[i]);
        }
    });

    test('format month short case with escaped symbols', function (assert) {
        var monthsShort = {
            'nominative': '—è–Ω–≤_—Ñ–µ–≤_–º–∞—Ä—Ç_–∞–ø—Ä_–º–∞–π_–∏—é–Ω—å_–∏—é–ª—å_–∞–≤–≥_—Å–µ–Ω_–æ–∫—Ç_–Ω–æ—è_–¥–µ–∫'.split('_'),
            'accusative': '—è–Ω–≤_—Ñ–µ–≤_–º–∞—Ä_–∞–ø—Ä_–º–∞—è_–∏—é–Ω—è_–∏—é–ª—è_–∞–≤–≥_—Å–µ–Ω_–æ–∫—Ç_–Ω–æ—è_–¥–µ–∫'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2013, i, 1]).format('D[] MMM'), '1 ' + monthsShort.accusative[i], '1 ' + monthsShort.accusative[i]);
            assert.equal(moment([2013, i, 1]).format('[<i>]D[</i>] [<b>]MMM[</b>]'), '<i>1</i> <b>' + monthsShort.accusative[i] + '</b>', '1 <b>' + monthsShort.accusative[i] + '</b>');
            assert.equal(moment([2013, i, 1]).format('D[-–π –¥–µ–Ω—å] MMM'), '1-–π –¥–µ–Ω—å ' + monthsShort.accusative[i], '1-–π –¥–µ–Ω—å ' + monthsShort.accusative[i]);
            assert.equal(moment([2013, i, 1]).format('D, MMM'), '1, ' + monthsShort.nominative[i], '1, ' + monthsShort.nominative[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ –≤—Å –≤—Å_–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫ –ø–Ω –ø–Ω_–≤—Ç–æ—Ä–Ω–∏–∫ –≤—Ç –≤—Ç_—Å—Ä–µ–¥–∞ —Å—Ä —Å—Ä_—á–µ—Ç–≤–µ—Ä–≥ —á—Ç —á—Ç_–ø—è—Ç–Ω–∏—Ü–∞ –ø—Ç –ø—Ç_—Å—É–±–±–æ—Ç–∞ —Å–± —Å–±'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '–Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥',    '44 seconds = seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '–º–∏–Ω—É—Ç–∞',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '–º–∏–Ω—É—Ç–∞',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 –º–∏–Ω—É—Ç—ã',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 31}), true),  '31 –º–∏–Ω—É—Ç–∞',  '31 minutes = 31 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 –º–∏–Ω—É—Ç—ã', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '—á–∞—Å',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '—á–∞—Å',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 —á–∞—Å–∞',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 —á–∞—Å–æ–≤',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 —á–∞—Å',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '–¥–µ–Ω—å',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '–¥–µ–Ω—å',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 –¥–Ω—è',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '–¥–µ–Ω—å',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 –¥–Ω–µ–π',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 11}), true),  '11 –¥–Ω–µ–π',     '11 days = 11 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 21}), true),  '21 –¥–µ–Ω—å',     '21 days = 21 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 –¥–Ω–µ–π',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '–º–µ—Å—è—Ü',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '–º–µ—Å—è—Ü',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '–º–µ—Å—è—Ü',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 –º–µ—Å—è—Ü–∞',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 –º–µ—Å—è—Ü–∞',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 –º–µ—Å—è—Ü–∞',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '–º–µ—Å—è—Ü',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 –º–µ—Å—è—Ü–µ–≤',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '–≥–æ–¥',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 –≥–æ–¥–∞',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '–≥–æ–¥',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 –ª–µ—Ç',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '—á–µ—Ä–µ–∑ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥', 'prefix');
        assert.equal(moment(0).from(30000), '–Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥ –Ω–∞–∑–∞–¥', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '—á–µ—Ä–µ–∑ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥', 'in seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '—á–µ—Ä–µ–∑ 5 –¥–Ω–µ–π', 'in 5 days');
        assert.equal(moment().add({m: 31}).fromNow(), '—á–µ—Ä–µ–∑ 31 –º–∏–Ω—É—Ç—É', 'in 31 minutes = in 31 minutes');
        assert.equal(moment().subtract({m: 31}).fromNow(), '31 –º–∏–Ω—É—Ç—É –Ω–∞–∑–∞–¥', '31 minutes ago = 31 minutes ago');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '–°–µ–≥–æ–¥–Ω—è –≤ 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '–°–µ–≥–æ–¥–Ω—è –≤ 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '–°–µ–≥–æ–¥–Ω—è –≤ 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '–ó–∞–≤—Ç—Ä–∞ –≤ 02:00',      'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '–°–µ–≥–æ–¥–Ω—è –≤ 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '–í—á–µ—Ä–∞ –≤ 02:00',       'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        function makeFormat(d) {
            return d.day() === 2 ? '[–í–æ] dddd [–≤] LT' : '[–í] dddd [–≤] LT';
        }

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m, now;

        function makeFormatLast(d) {
            switch (d.day()) {
            case 0:
                return '[–í –ø—Ä–æ—à–ª–æ–µ] dddd [–≤] LT';
            case 1:
            case 2:
            case 4:
                return '[–í –ø—Ä–æ—à–ª—ã–π] dddd [–≤] LT';
            case 3:
            case 5:
            case 6:
                return '[–í –ø—Ä–æ—à–ª—É—é] dddd [–≤] LT';
            }
        }

        function makeFormatThis(d) {
            switch (d.day()) {
            case 2:
                return '[–í–æ] dddd [–≤] LT';
            case 0:
            case 1:
            case 3:
            case 4:
            case 5:
            case 6:
                return '[–í] dddd [–≤] LT';
            }
        }

        now = moment().startOf('week');
        for (i = 2; i < 7; i++) {
            m = moment(now).subtract({d: i});
            assert.equal(m.calendar(now),       m.format(makeFormatLast(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(now),       m.format(makeFormatLast(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(now),       m.format(makeFormatLast(m)),  'Today - ' + i + ' days end of day');
        }

        now = moment().endOf('week');
        for (i = 2; i < 7; i++) {
            m = moment(now).subtract({d: i});
            assert.equal(m.calendar(now),       m.format(makeFormatThis(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(now),       m.format(makeFormatThis(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(now),       m.format(makeFormatThis(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-—è', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-—è', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-—è', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-—è', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-—è', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('si');

    /*jshint -W100*/
    test('parse', function (assert) {
        var tests = '‡∂¢‡∂±‡∑Ä‡∑è‡∂ª‡∑í ‡∂¢‡∂±_‡∂¥‡∑ô‡∂∂‡∂ª‡∑Ä‡∑è‡∂ª‡∑í ‡∂¥‡∑ô‡∂∂_‡∂∏‡∑è‡∂ª‡∑ä‡∂≠‡∑î ‡∂∏‡∑è‡∂ª‡∑ä_‡∂Ö‡∂¥‡∑ä‚Äç‡∂ª‡∑ö‡∂Ω‡∑ä ‡∂Ö‡∂¥‡∑ä_‡∂∏‡∑ê‡∂∫‡∑í ‡∂∏‡∑ê‡∂∫‡∑í_‡∂¢‡∑ñ‡∂±‡∑í ‡∂¢‡∑ñ‡∂±‡∑í_‡∂¢‡∑ñ‡∂Ω‡∑í ‡∂¢‡∑ñ‡∂Ω‡∑í_‡∂Ö‡∂ú‡∑ù‡∑É‡∑ä‡∂≠‡∑î ‡∂Ö‡∂ú‡∑ù_‡∑É‡∑ê‡∂¥‡∑ä‡∂≠‡∑ê‡∂∏‡∑ä‡∂∂‡∂ª‡∑ä ‡∑É‡∑ê‡∂¥‡∑ä_‡∂î‡∂ö‡∑ä‡∂≠‡∑ù‡∂∂‡∂ª‡∑ä ‡∂î‡∂ö‡∑ä_‡∂±‡∑ú‡∑Ä‡∑ê‡∂∏‡∑ä‡∂∂‡∂ª‡∑ä ‡∂±‡∑ú‡∑Ä‡∑ê_‡∂Ø‡∑ô‡∑É‡∑ê‡∂∏‡∑ä‡∂∂‡∂ª‡∑ä ‡∂Ø‡∑ô‡∑É‡∑ê'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['YYYY MMMM Do dddd, a h:mm:ss',       '2010 ‡∂¥‡∑ô‡∂∂‡∂ª‡∑Ä‡∑è‡∂ª‡∑í 14 ‡∑Ä‡∑ê‡∂±‡∑í ‡∂â‡∂ª‡∑í‡∂Ø‡∑è, ‡∂¥.‡∑Ä. 3:25:50'],
                ['YYYY MMMM Do dddd, a h:mm:ss',       '2010 ‡∂¥‡∑ô‡∂∂‡∂ª‡∑Ä‡∑è‡∂ª‡∑í 14 ‡∑Ä‡∑ê‡∂±‡∑í ‡∂â‡∂ª‡∑í‡∂Ø‡∑è, ‡∂¥.‡∑Ä. 3:25:50'],
                ['ddd, A h',                            '‡∂â‡∂ª‡∑í, ‡∂¥‡∑É‡∑ä ‡∑Ä‡∂ª‡∑î 3'],
                ['M Mo MM MMMM MMM',                   '2 2 ‡∑Ä‡∑ê‡∂±‡∑í 02 ‡∂¥‡∑ô‡∂∂‡∂ª‡∑Ä‡∑è‡∂ª‡∑í ‡∂¥‡∑ô‡∂∂'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 ‡∑Ä‡∑ê‡∂±‡∑í 14'],
                ['d do dddd ddd dd',                   '0 0 ‡∑Ä‡∑ê‡∂±‡∑í ‡∂â‡∂ª‡∑í‡∂Ø‡∑è ‡∂â‡∂ª‡∑í ‡∂â'],
                ['DDD DDDo DDDD',                      '45 45 ‡∑Ä‡∑ê‡∂±‡∑í 045'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                '‡∂¥.‡∑Ä. ‡∂¥‡∑É‡∑ä ‡∑Ä‡∂ª‡∑î'],
                ['[‡∑Ä‡∑É‡∂ª‡∑ö] DDDo [‡∂Ø‡∑í‡∂±‡∂∫]',                      '‡∑Ä‡∑É‡∂ª‡∑ö 45 ‡∑Ä‡∑ê‡∂±‡∑í ‡∂Ø‡∑í‡∂±‡∂∫'],
                ['LTS',                                '‡∂¥.‡∑Ä. 3:25:50'],
                ['LT',                                 '‡∂¥.‡∑Ä. 3:25'],
                ['L',                                  '2010/02/14'],
                ['LL',                                 '2010 ‡∂¥‡∑ô‡∂∂‡∂ª‡∑Ä‡∑è‡∂ª‡∑í 14'],
                ['LLL',                                '2010 ‡∂¥‡∑ô‡∂∂‡∂ª‡∑Ä‡∑è‡∂ª‡∑í 14, ‡∂¥.‡∑Ä. 3:25'],
                ['LLLL',                               '2010 ‡∂¥‡∑ô‡∂∂‡∂ª‡∑Ä‡∑è‡∂ª‡∑í 14 ‡∑Ä‡∑ê‡∂±‡∑í ‡∂â‡∂ª‡∑í‡∂Ø‡∑è, ‡∂¥.‡∑Ä. 3:25:50'],
                ['l',                                  '2010/2/14'],
                ['ll',                                 '2010 ‡∂¥‡∑ô‡∂∂ 14'],
                ['lll',                                '2010 ‡∂¥‡∑ô‡∂∂ 14, ‡∂¥.‡∑Ä. 3:25'],
                ['llll',                               '2010 ‡∂¥‡∑ô‡∂∂ 14 ‡∑Ä‡∑ê‡∂±‡∑í ‡∂â‡∂ª‡∑í, ‡∂¥.‡∑Ä. 3:25:50']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1 ‡∑Ä‡∑ê‡∂±‡∑í', '1 ‡∑Ä‡∑ê‡∂±‡∑í');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2 ‡∑Ä‡∑ê‡∂±‡∑í', '2 ‡∑Ä‡∑ê‡∂±‡∑í');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3 ‡∑Ä‡∑ê‡∂±‡∑í', '3 ‡∑Ä‡∑ê‡∂±‡∑í');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4 ‡∑Ä‡∑ê‡∂±‡∑í', '4 ‡∑Ä‡∑ê‡∂±‡∑í');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5 ‡∑Ä‡∑ê‡∂±‡∑í', '5 ‡∑Ä‡∑ê‡∂±‡∑í');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6 ‡∑Ä‡∑ê‡∂±‡∑í', '6 ‡∑Ä‡∑ê‡∂±‡∑í');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7 ‡∑Ä‡∑ê‡∂±‡∑í', '7 ‡∑Ä‡∑ê‡∂±‡∑í');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8 ‡∑Ä‡∑ê‡∂±‡∑í', '8 ‡∑Ä‡∑ê‡∂±‡∑í');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9 ‡∑Ä‡∑ê‡∂±‡∑í', '9 ‡∑Ä‡∑ê‡∂±‡∑í');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10 ‡∑Ä‡∑ê‡∂±‡∑í', '10 ‡∑Ä‡∑ê‡∂±‡∑í');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11 ‡∑Ä‡∑ê‡∂±‡∑í', '11 ‡∑Ä‡∑ê‡∂±‡∑í');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12 ‡∑Ä‡∑ê‡∂±‡∑í', '12 ‡∑Ä‡∑ê‡∂±‡∑í');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13 ‡∑Ä‡∑ê‡∂±‡∑í', '13 ‡∑Ä‡∑ê‡∂±‡∑í');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14 ‡∑Ä‡∑ê‡∂±‡∑í', '14 ‡∑Ä‡∑ê‡∂±‡∑í');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15 ‡∑Ä‡∑ê‡∂±‡∑í', '15 ‡∑Ä‡∑ê‡∂±‡∑í');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16 ‡∑Ä‡∑ê‡∂±‡∑í', '16 ‡∑Ä‡∑ê‡∂±‡∑í');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17 ‡∑Ä‡∑ê‡∂±‡∑í', '17 ‡∑Ä‡∑ê‡∂±‡∑í');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18 ‡∑Ä‡∑ê‡∂±‡∑í', '18 ‡∑Ä‡∑ê‡∂±‡∑í');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19 ‡∑Ä‡∑ê‡∂±‡∑í', '19 ‡∑Ä‡∑ê‡∂±‡∑í');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20 ‡∑Ä‡∑ê‡∂±‡∑í', '20 ‡∑Ä‡∑ê‡∂±‡∑í');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21 ‡∑Ä‡∑ê‡∂±‡∑í', '21 ‡∑Ä‡∑ê‡∂±‡∑í');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22 ‡∑Ä‡∑ê‡∂±‡∑í', '22 ‡∑Ä‡∑ê‡∂±‡∑í');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23 ‡∑Ä‡∑ê‡∂±‡∑í', '23 ‡∑Ä‡∑ê‡∂±‡∑í');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24 ‡∑Ä‡∑ê‡∂±‡∑í', '24 ‡∑Ä‡∑ê‡∂±‡∑í');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25 ‡∑Ä‡∑ê‡∂±‡∑í', '25 ‡∑Ä‡∑ê‡∂±‡∑í');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26 ‡∑Ä‡∑ê‡∂±‡∑í', '26 ‡∑Ä‡∑ê‡∂±‡∑í');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27 ‡∑Ä‡∑ê‡∂±‡∑í', '27 ‡∑Ä‡∑ê‡∂±‡∑í');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28 ‡∑Ä‡∑ê‡∂±‡∑í', '28 ‡∑Ä‡∑ê‡∂±‡∑í');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29 ‡∑Ä‡∑ê‡∂±‡∑í', '29 ‡∑Ä‡∑ê‡∂±‡∑í');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30 ‡∑Ä‡∑ê‡∂±‡∑í', '30 ‡∑Ä‡∑ê‡∂±‡∑í');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31 ‡∑Ä‡∑ê‡∂±‡∑í', '31 ‡∑Ä‡∑ê‡∂±‡∑í');
    });

    test('format month', function (assert) {
        var expected = '‡∂¢‡∂±‡∑Ä‡∑è‡∂ª‡∑í ‡∂¢‡∂±_‡∂¥‡∑ô‡∂∂‡∂ª‡∑Ä‡∑è‡∂ª‡∑í ‡∂¥‡∑ô‡∂∂_‡∂∏‡∑è‡∂ª‡∑ä‡∂≠‡∑î ‡∂∏‡∑è‡∂ª‡∑ä_‡∂Ö‡∂¥‡∑ä‚Äç‡∂ª‡∑ö‡∂Ω‡∑ä ‡∂Ö‡∂¥‡∑ä_‡∂∏‡∑ê‡∂∫‡∑í ‡∂∏‡∑ê‡∂∫‡∑í_‡∂¢‡∑ñ‡∂±‡∑í ‡∂¢‡∑ñ‡∂±‡∑í_‡∂¢‡∑ñ‡∂Ω‡∑í ‡∂¢‡∑ñ‡∂Ω‡∑í_‡∂Ö‡∂ú‡∑ù‡∑É‡∑ä‡∂≠‡∑î ‡∂Ö‡∂ú‡∑ù_‡∑É‡∑ê‡∂¥‡∑ä‡∂≠‡∑ê‡∂∏‡∑ä‡∂∂‡∂ª‡∑ä ‡∑É‡∑ê‡∂¥‡∑ä_‡∂î‡∂ö‡∑ä‡∂≠‡∑ù‡∂∂‡∂ª‡∑ä ‡∂î‡∂ö‡∑ä_‡∂±‡∑ú‡∑Ä‡∑ê‡∂∏‡∑ä‡∂∂‡∂ª‡∑ä ‡∂±‡∑ú‡∑Ä‡∑ê_‡∂Ø‡∑ô‡∑É‡∑ê‡∂∏‡∑ä‡∂∂‡∂ª‡∑ä ‡∂Ø‡∑ô‡∑É‡∑ê'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '‡∂â‡∂ª‡∑í‡∂Ø‡∑è ‡∂â‡∂ª‡∑í ‡∂â_‡∑É‡∂≥‡∑î‡∂Ø‡∑è ‡∑É‡∂≥‡∑î ‡∑É_‡∂Ö‡∂ü‡∑Ñ‡∂ª‡∑î‡∑Ä‡∑è‡∂Ø‡∑è ‡∂Ö‡∂ü ‡∂Ö_‡∂∂‡∂Ø‡∑è‡∂Ø‡∑è ‡∂∂‡∂Ø‡∑è ‡∂∂_‡∂∂‡∑ä‚Äç‡∂ª‡∑Ñ‡∑É‡∑ä‡∂¥‡∂≠‡∑í‡∂±‡∑ä‡∂Ø‡∑è ‡∂∂‡∑ä‚Äç‡∂ª‡∑Ñ ‡∂∂‡∑ä‚Äç‡∂ª_‡∑É‡∑í‡∂ö‡∑î‡∂ª‡∑è‡∂Ø‡∑è ‡∑É‡∑í‡∂ö‡∑î ‡∑É‡∑í_‡∑É‡∑ô‡∂±‡∑É‡∑î‡∂ª‡∑è‡∂Ø‡∑è ‡∑É‡∑ô‡∂± ‡∑É‡∑ô'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '‡∂≠‡∂≠‡∑ä‡∂¥‡∂ª ‡∂ö‡∑í‡∑Ñ‡∑í‡∂¥‡∂∫', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '‡∂∏‡∑í‡∂±‡∑í‡∂≠‡∑ä‡∂≠‡∑î‡∑Ä',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '‡∂∏‡∑í‡∂±‡∑í‡∂≠‡∑ä‡∂≠‡∑î‡∑Ä',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '‡∂∏‡∑í‡∂±‡∑í‡∂≠‡∑ä‡∂≠‡∑î 2',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '‡∂∏‡∑í‡∂±‡∑í‡∂≠‡∑ä‡∂≠‡∑î 44',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '‡∂¥‡∑ê‡∂∫',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '‡∂¥‡∑ê‡∂∫',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '‡∂¥‡∑ê‡∂∫ 2',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '‡∂¥‡∑ê‡∂∫ 5',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '‡∂¥‡∑ê‡∂∫ 21',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '‡∂Ø‡∑í‡∂±‡∂∫',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '‡∂Ø‡∑í‡∂±‡∂∫',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '‡∂Ø‡∑í‡∂± 2',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '‡∂Ø‡∑í‡∂±‡∂∫',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '‡∂Ø‡∑í‡∂± 5',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '‡∂Ø‡∑í‡∂± 25',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '‡∂∏‡∑è‡∑É‡∂∫',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '‡∂∏‡∑è‡∑É‡∂∫',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '‡∂∏‡∑è‡∑É‡∂∫',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '‡∂∏‡∑è‡∑É 2',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '‡∂∏‡∑è‡∑É 2',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '‡∂∏‡∑è‡∑É 3',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '‡∂∏‡∑è‡∑É‡∂∫',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '‡∂∏‡∑è‡∑É 5',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '‡∑Ä‡∑É‡∂ª',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '‡∑Ä‡∑É‡∂ª 2',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '‡∑Ä‡∑É‡∂ª',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '‡∑Ä‡∑É‡∂ª 5',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '‡∂≠‡∂≠‡∑ä‡∂¥‡∂ª ‡∂ö‡∑í‡∑Ñ‡∑í‡∂¥‡∂∫‡∂ö‡∑í‡∂±‡∑ä',  'prefix');
        assert.equal(moment(0).from(30000), '‡∂≠‡∂≠‡∑ä‡∂¥‡∂ª ‡∂ö‡∑í‡∑Ñ‡∑í‡∂¥‡∂∫‡∂ö‡∂ß ‡∂¥‡∑ô‡∂ª', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '‡∂≠‡∂≠‡∑ä‡∂¥‡∂ª ‡∂ö‡∑í‡∑Ñ‡∑í‡∂¥‡∂∫‡∂ö‡∂ß ‡∂¥‡∑ô‡∂ª',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '‡∂≠‡∂≠‡∑ä‡∂¥‡∂ª ‡∂ö‡∑í‡∑Ñ‡∑í‡∂¥‡∂∫‡∂ö‡∑í‡∂±‡∑ä', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '‡∂Ø‡∑í‡∂± 5‡∂ö‡∑í‡∂±‡∑ä', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   '‡∂Ö‡∂Ø ‡∂¥‡∑ô.‡∑Ä. 2:00‡∂ß',      'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '‡∂Ö‡∂Ø ‡∂¥‡∑ô.‡∑Ä. 2:25‡∂ß',      'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '‡∂Ö‡∂Ø ‡∂¥‡∑ô.‡∑Ä. 3:00‡∂ß',      'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '‡∑Ñ‡∑ô‡∂ß ‡∂¥‡∑ô.‡∑Ä. 2:00‡∂ß',   'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '‡∂Ö‡∂Ø ‡∂¥‡∑ô.‡∑Ä. 1:00‡∂ß',      'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '‡∂ä‡∂∫‡∑ö ‡∂¥‡∑ô.‡∑Ä. 2:00‡∂ß',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd LT[‡∂ß]'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd LT[‡∂ß]'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd LT[‡∂ß]'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[‡∂¥‡∑É‡∑î‡∂ú‡∑í‡∂∫] dddd LT[‡∂ß]'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[‡∂¥‡∑É‡∑î‡∂ú‡∑í‡∂∫] dddd LT[‡∂ß]'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[‡∂¥‡∑É‡∑î‡∂ú‡∑í‡∂∫] dddd LT[‡∂ß]'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('sk');

    test('parse', function (assert) {
        var tests = 'janu√°r jan._febru√°r feb._marec mar._apr√≠l apr._m√°j m√°j_j√∫n j√∫n._j√∫l j√∫l._august aug._september sep._okt√≥ber okt._november nov._december dec.'.split('_'), i;
        function equalTest(input, mmm, monthIndex) {
            assert.equal(moment(input, mmm).month(), monthIndex, input + ' should be month ' + (monthIndex + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss',  'nedeƒæa, febru√°r 14. 2010, 3:25:50'],
                ['ddd, h',                       'ne, 3'],
                ['M Mo MM MMMM MMM',             '2 2. 02 febru√°r feb'],
                ['YYYY YY',                      '2010 10'],
                ['D Do DD',                      '14 14. 14'],
                ['d do dddd ddd dd',             '0 0. nedeƒæa ne ne'],
                ['DDD DDDo DDDD',                '45 45. 045'],
                ['w wo ww',                      '6 6. 06'],
                ['h hh',                         '3 03'],
                ['H HH',                         '15 15'],
                ['m mm',                         '25 25'],
                ['s ss',                         '50 50'],
                ['a A',                          'pm PM'],
                ['DDDo [de≈à v roku]',            '45. de≈à v roku'],
                ['LTS',                          '15:25:50'],
                ['L',                            '14.02.2010'],
                ['LL',                           '14. febru√°r 2010'],
                ['LLL',                          '14. febru√°r 2010 15:25'],
                ['LLLL',                         'nedeƒæa 14. febru√°r 2010 15:25'],
                ['l',                            '14.2.2010'],
                ['ll',                           '14. feb 2010'],
                ['lll',                          '14. feb 2010 15:25'],
                ['llll',                         'ne 14. feb 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'janu√°r jan_febru√°r feb_marec mar_apr√≠l apr_m√°j m√°j_j√∫n j√∫n_j√∫l j√∫l_august aug_september sep_okt√≥ber okt_november nov_december dec'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'nedeƒæa ne ne_pondelok po po_utorok ut ut_streda st st_≈°tvrtok ≈°t ≈°t_piatok pi pi_sobota so so'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'p√°r sek√∫nd',  '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'min√∫ta',        '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'min√∫ta',        '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 min√∫ty',      '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 min√∫t',     '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'hodina',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'hodina',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hodiny',     '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hod√≠n',      '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hod√≠n',     '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'de≈à',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'de≈à',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dni',         '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'de≈à',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dn√≠',         '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dn√≠',        '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mesiac',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mesiac',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mesiac',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mesiace',    '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mesiace',    '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mesiace',    '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mesiac',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mesiacov',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'rok',           '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 roky',        '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'rok',           '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 rokov',         '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'za p√°r sek√∫nd',  'prefix');
        assert.equal(moment(0).from(30000), 'pred p√°r sekundami', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'pred p√°r sekundami',  'now from now should display as in the past');
    });

    test('fromNow (future)', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'za p√°r sek√∫nd', 'in a few seconds');
        assert.equal(moment().add({m: 1}).fromNow(), 'za min√∫tu', 'in a minute');
        assert.equal(moment().add({m: 3}).fromNow(), 'za 3 min√∫ty', 'in 3 minutes');
        assert.equal(moment().add({m: 10}).fromNow(), 'za 10 min√∫t', 'in 10 minutes');
        assert.equal(moment().add({h: 1}).fromNow(), 'za hodinu', 'in an hour');
        assert.equal(moment().add({h: 3}).fromNow(), 'za 3 hodiny', 'in 3 hours');
        assert.equal(moment().add({h: 10}).fromNow(), 'za 10 hod√≠n', 'in 10 hours');
        assert.equal(moment().add({d: 1}).fromNow(), 'za de≈à', 'in a day');
        assert.equal(moment().add({d: 3}).fromNow(), 'za 3 dni', 'in 3 days');
        assert.equal(moment().add({d: 10}).fromNow(), 'za 10 dn√≠', 'in 10 days');
        assert.equal(moment().add({M: 1}).fromNow(), 'za mesiac', 'in a month');
        assert.equal(moment().add({M: 3}).fromNow(), 'za 3 mesiace', 'in 3 months');
        assert.equal(moment().add({M: 10}).fromNow(), 'za 10 mesiacov', 'in 10 months');
        assert.equal(moment().add({y: 1}).fromNow(), 'za rok', 'in a year');
        assert.equal(moment().add({y: 3}).fromNow(), 'za 3 roky', 'in 3 years');
        assert.equal(moment().add({y: 10}).fromNow(), 'za 10 rokov', 'in 10 years');
    });

    test('fromNow (past)', function (assert) {
        assert.equal(moment().subtract({s: 30}).fromNow(), 'pred p√°r sekundami', 'a few seconds ago');
        assert.equal(moment().subtract({m: 1}).fromNow(), 'pred min√∫tou', 'a minute ago');
        assert.equal(moment().subtract({m: 3}).fromNow(), 'pred 3 min√∫tami', '3 minutes ago');
        assert.equal(moment().subtract({m: 10}).fromNow(), 'pred 10 min√∫tami', '10 minutes ago');
        assert.equal(moment().subtract({h: 1}).fromNow(), 'pred hodinou', 'an hour ago');
        assert.equal(moment().subtract({h: 3}).fromNow(), 'pred 3 hodinami', '3 hours ago');
        assert.equal(moment().subtract({h: 10}).fromNow(), 'pred 10 hodinami', '10 hours ago');
        assert.equal(moment().subtract({d: 1}).fromNow(), 'pred d≈àom', 'a day ago');
        assert.equal(moment().subtract({d: 3}).fromNow(), 'pred 3 d≈àami', '3 days ago');
        assert.equal(moment().subtract({d: 10}).fromNow(), 'pred 10 d≈àami', '10 days ago');
        assert.equal(moment().subtract({M: 1}).fromNow(), 'pred mesiacom', 'a month ago');
        assert.equal(moment().subtract({M: 3}).fromNow(), 'pred 3 mesiacmi', '3 months ago');
        assert.equal(moment().subtract({M: 10}).fromNow(), 'pred 10 mesiacmi', '10 months ago');
        assert.equal(moment().subtract({y: 1}).fromNow(), 'pred rokom', 'a year ago');
        assert.equal(moment().subtract({y: 3}).fromNow(), 'pred 3 rokmi', '3 years ago');
        assert.equal(moment().subtract({y: 10}).fromNow(), 'pred 10 rokmi', '10 years ago');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'dnes o 2:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'dnes o 2:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'dnes o 3:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'zajtra o 2:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'dnes o 1:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'vƒçera o 2:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m, nextDay;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            nextDay = '';
            switch (m.day()) {
            case 0:
                nextDay = 'v nedeƒæu';
                break;
            case 1:
                nextDay = 'v pondelok';
                break;
            case 2:
                nextDay = 'v utorok';
                break;
            case 3:
                nextDay = 'v stredu';
                break;
            case 4:
                nextDay = 'vo ≈°tvrtok';
                break;
            case 5:
                nextDay = 'v piatok';
                break;
            case 6:
                nextDay = 'v sobotu';
                break;
            }
            assert.equal(m.calendar(),       m.format('[' + nextDay + '] [o] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[' + nextDay + '] [o] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[' + nextDay + '] [o] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m, lastDay;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            lastDay = '';
            switch (m.day()) {
            case 0:
                lastDay = 'minul√∫ nedeƒæu';
                break;
            case 1:
                lastDay = 'minul√Ω pondelok';
                break;
            case 2:
                lastDay = 'minul√Ω utorok';
                break;
            case 3:
                lastDay = 'minul√∫ stredu';
                break;
            case 4:
                lastDay = 'minul√Ω ≈°tvrtok';
                break;
            case 5:
                lastDay = 'minul√Ω piatok';
                break;
            case 6:
                lastDay = 'minul√∫ sobotu';
                break;
            }
            assert.equal(m.calendar(),       m.format('[' + lastDay + '] [o] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[' + lastDay + '] [o] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[' + lastDay + '] [o] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('humanize duration', function (assert) {
        assert.equal(moment.duration(1, 'minutes').humanize(), 'min√∫ta', 'a minute (future)');
        assert.equal(moment.duration(1, 'minutes').humanize(true), 'za min√∫tu', 'in a minute');
        assert.equal(moment.duration(-1, 'minutes').humanize(), 'min√∫ta', 'a minute (past)');
        assert.equal(moment.duration(-1, 'minutes').humanize(true), 'pred min√∫tou', 'a minute ago');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('sl');

    test('parse', function (assert) {
        var tests = 'januar jan._februar feb._marec mar._april apr._maj maj_junij jun._julij jul._avgust avg._september sep._oktober okt._november nov._december dec.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'nedelja, 14. februar 2010, 3:25:50 pm'],
                ['ddd, hA',                            'ned., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. nedelja ned. ne'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '7 7. 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14. 02. 2010'],
                ['LL',                                 '14. februar 2010'],
                ['LLL',                                '14. februar 2010 15:25'],
                ['LLLL',                               'nedelja, 14. februar 2010 15:25'],
                ['l',                                  '14. 2. 2010'],
                ['ll',                                 '14. feb. 2010'],
                ['lll',                                '14. feb. 2010 15:25'],
                ['llll',                               'ned., 14. feb. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'januar jan._februar feb._marec mar._april apr._maj maj._junij jun._julij jul._avgust avg._september sep._oktober okt._november nov._december dec.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'nedelja ned. ne_ponedeljek pon. po_torek tor. to_sreda sre. sr_ƒçetrtek ƒçet. ƒçe_petek pet. pe_sobota sob. so'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'nekaj sekund', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ena minuta',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ena minuta',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuti',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minut',     '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ena ura',      '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ena ura',      '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 uri',        '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ur',         '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ur',        '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'en dan',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'en dan',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dni',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'en dan',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dni',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dni',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'en mesec',     '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'en mesec',     '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'en mesec',     '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 meseca',     '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 meseca',     '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mesece',     '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'en mesec',     '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mesecev',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'eno leto',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 leti',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'eno leto',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 let',        '5 years = 5 years');

        assert.equal(start.from(moment([2007, 1, 28]).add({m: 1}), true),  'ena minuta', 'a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 2}), true),  '2 minuti',   '2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 3}), true),  '3 minute',   '3 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 4}), true),  '4 minute',   '4 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 5}), true),  '5 minut',    '5 minutes');

        assert.equal(start.from(moment([2007, 1, 28]).add({h: 1}), true),  'ena ura', 'an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 2}), true),  '2 uri',   '2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 3}), true),  '3 ure',   '3 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 4}), true),  '4 ure',   '4 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),  '5 ur',    '5 hours');

        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),  'en dan', 'a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 2}), true),  '2 dni',  '2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 3}), true),  '3 dni',  '3 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 4}), true),  '4 dni',  '4 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),  '5 dni',  '5 days');

        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),  'en mesec',  'a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 2}), true),  '2 meseca',  '2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 3}), true),  '3 mesece',  '3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 4}), true),  '4 mesece',  '4 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),  '5 mesecev', '5 months');

        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),  'eno leto', 'a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 2}), true),  '2 leti',   '2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 3}), true),  '3 leta',   '3 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 4}), true),  '4 leta',   '4 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),  '5 let',    '5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'ƒçez nekaj sekund',  'prefix');
        assert.equal(moment(0).from(30000), 'pred nekaj sekundami', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'pred nekaj sekundami',  'now from now should display as in the past');
    });

    test('fromNow (future)', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'ƒçez nekaj sekund', 'in a few seconds');
        assert.equal(moment().add({m: 1}).fromNow(),  'ƒçez eno minuto', 'in a minute');
        assert.equal(moment().add({m: 2}).fromNow(),  'ƒçez 2 minuti',   'in 2 minutes');
        assert.equal(moment().add({m: 3}).fromNow(),  'ƒçez 3 minute',   'in 3 minutes');
        assert.equal(moment().add({m: 4}).fromNow(),  'ƒçez 4 minute',   'in 4 minutes');
        assert.equal(moment().add({m: 5}).fromNow(),  'ƒçez 5 minut',    'in 5 minutes');

        assert.equal(moment().add({h: 1}).fromNow(),  'ƒçez eno uro', 'in an hour');
        assert.equal(moment().add({h: 2}).fromNow(),  'ƒçez 2 uri',   'in 2 hours');
        assert.equal(moment().add({h: 3}).fromNow(),  'ƒçez 3 ure',   'in 3 hours');
        assert.equal(moment().add({h: 4}).fromNow(),  'ƒçez 4 ure',   'in 4 hours');
        assert.equal(moment().add({h: 5}).fromNow(),  'ƒçez 5 ur',    'in 5 hours');

        assert.equal(moment().add({d: 1}).fromNow(),  'ƒçez en dan', 'in a day');
        assert.equal(moment().add({d: 2}).fromNow(),  'ƒçez 2 dni',  'in 2 days');
        assert.equal(moment().add({d: 3}).fromNow(),  'ƒçez 3 dni',  'in 3 days');
        assert.equal(moment().add({d: 4}).fromNow(),  'ƒçez 4 dni',  'in 4 days');
        assert.equal(moment().add({d: 5}).fromNow(),  'ƒçez 5 dni',  'in 5 days');

        assert.equal(moment().add({M: 1}).fromNow(),  'ƒçez en mesec',  'in a month');
        assert.equal(moment().add({M: 2}).fromNow(),  'ƒçez 2 meseca',  'in 2 months');
        assert.equal(moment().add({M: 3}).fromNow(),  'ƒçez 3 mesece',  'in 3 months');
        assert.equal(moment().add({M: 4}).fromNow(),  'ƒçez 4 mesece',  'in 4 months');
        assert.equal(moment().add({M: 5}).fromNow(),  'ƒçez 5 mesecev', 'in 5 months');

        assert.equal(moment().add({y: 1}).fromNow(),  'ƒçez eno leto', 'in a year');
        assert.equal(moment().add({y: 2}).fromNow(),  'ƒçez 2 leti',   'in 2 years');
        assert.equal(moment().add({y: 3}).fromNow(),  'ƒçez 3 leta',   'in 3 years');
        assert.equal(moment().add({y: 4}).fromNow(),  'ƒçez 4 leta',   'in 4 years');
        assert.equal(moment().add({y: 5}).fromNow(),  'ƒçez 5 let',    'in 5 years');

        assert.equal(moment().subtract({s: 30}).fromNow(), 'pred nekaj sekundami', 'a few seconds ago');

        assert.equal(moment().subtract({m: 1}).fromNow(),  'pred eno minuto', 'a minute ago');
        assert.equal(moment().subtract({m: 2}).fromNow(),  'pred 2 minutama', '2 minutes ago');
        assert.equal(moment().subtract({m: 3}).fromNow(),  'pred 3 minutami', '3 minutes ago');
        assert.equal(moment().subtract({m: 4}).fromNow(),  'pred 4 minutami', '4 minutes ago');
        assert.equal(moment().subtract({m: 5}).fromNow(),  'pred 5 minutami', '5 minutes ago');

        assert.equal(moment().subtract({h: 1}).fromNow(),  'pred eno uro', 'an hour ago');
        assert.equal(moment().subtract({h: 2}).fromNow(),  'pred 2 urama', '2 hours ago');
        assert.equal(moment().subtract({h: 3}).fromNow(),  'pred 3 urami', '3 hours ago');
        assert.equal(moment().subtract({h: 4}).fromNow(),  'pred 4 urami', '4 hours ago');
        assert.equal(moment().subtract({h: 5}).fromNow(),  'pred 5 urami', '5 hours ago');

        assert.equal(moment().subtract({d: 1}).fromNow(),  'pred enim dnem', 'a day ago');
        assert.equal(moment().subtract({d: 2}).fromNow(),  'pred 2 dnevoma', '2 days ago');
        assert.equal(moment().subtract({d: 3}).fromNow(),  'pred 3 dnevi',   '3 days ago');
        assert.equal(moment().subtract({d: 4}).fromNow(),  'pred 4 dnevi',   '4 days ago');
        assert.equal(moment().subtract({d: 5}).fromNow(),  'pred 5 dnevi',   '5 days ago');

        assert.equal(moment().subtract({M: 1}).fromNow(),  'pred enim mesecem', 'a month ago');
        assert.equal(moment().subtract({M: 2}).fromNow(),  'pred 2 mesecema',   '2 months ago');
        assert.equal(moment().subtract({M: 3}).fromNow(),  'pred 3 meseci',     '3 months ago');
        assert.equal(moment().subtract({M: 4}).fromNow(),  'pred 4 meseci',     '4 months ago');
        assert.equal(moment().subtract({M: 5}).fromNow(),  'pred 5 meseci',     '5 months ago');

        assert.equal(moment().subtract({y: 1}).fromNow(),  'pred enim letom', 'a year ago');
        assert.equal(moment().subtract({y: 2}).fromNow(),  'pred 2 letoma',   '2 years ago');
        assert.equal(moment().subtract({y: 3}).fromNow(),  'pred 3 leti',     '3 years ago');
        assert.equal(moment().subtract({y: 4}).fromNow(),  'pred 4 leti',     '4 years ago');
        assert.equal(moment().subtract({y: 5}).fromNow(),  'pred 5 leti',     '5 years ago');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'danes ob 2:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'danes ob 2:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'danes ob 3:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'jutri ob 2:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'danes ob 1:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'vƒçeraj ob 2:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
                return '[v] [nedeljo] [ob] LT';
            case 3:
                return '[v] [sredo] [ob] LT';
            case 6:
                return '[v] [soboto] [ob] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[v] dddd [ob] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
                return '[prej≈°njo] [nedeljo] [ob] LT';
            case 3:
                return '[prej≈°njo] [sredo] [ob] LT';
            case 6:
                return '[prej≈°njo] [soboto] [ob] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[prej≈°nji] dddd [ob] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('sq');

    test('parse', function (assert) {
        var i,
            tests = 'Janar Jan_Shkurt Shk_Mars Mar_Prill Pri_Maj Maj_Qershor Qer_Korrik Kor_Gusht Gus_Shtator Sht_Tetor Tet_N√´ntor N√´n_Dhjetor Dhj'.split('_');

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, HH:mm:ss',       'E Diel, Shkurt 14. 2010, 15:25:50'],
                ['ddd, HH',                            'Die, 15'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 Shkurt Shk'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. E Diel Die D'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'MD MD'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 Shkurt 2010'],
                ['LLL',                                '14 Shkurt 2010 15:25'],
                ['LLLL',                               'E Diel, 14 Shkurt 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Shk 2010'],
                ['lll',                                '14 Shk 2010 15:25'],
                ['llll',                               'Die, 14 Shk 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  0, 0]).format('A'), 'PD', 'before dawn');
        assert.equal(moment([2011, 2, 23, 12, 0]).format('A'), 'MD', 'noon');
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var i,
            expected = 'Janar Jan_Shkurt Shk_Mars Mar_Prill Pri_Maj Maj_Qershor Qer_Korrik Kor_Gusht Gus_Shtator Sht_Tetor Tet_N√´ntor N√´n_Dhjetor Dhj'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var i,
            expected = 'E Diel Die D_E H√´n√´ H√´n H_E Mart√´ Mar Ma_E M√´rkur√´ M√´r M√´_E Enjte Enj E_E Premte Pre P_E Shtun√´ Sht Sh'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'disa sekonda', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'nj√´ minut√´',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'nj√´ minut√´',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuta',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuta',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'nj√´ or√´',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'nj√´ or√´',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 or√´',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 or√´',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 or√´',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'nj√´ dit√´',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'nj√´ dit√´',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dit√´',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'nj√´ dit√´',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dit√´',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dit√´',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'nj√´ muaj',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'nj√´ muaj',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'nj√´ muaj',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 muaj',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 muaj',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 muaj',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'nj√´ muaj',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 muaj',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'nj√´ vit',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 vite',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'nj√´ vit',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 vite',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'n√´ disa sekonda',  'prefix');
        assert.equal(moment(0).from(30000), 'disa sekonda m√´ par√´', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'disa sekonda m√´ par√´',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'n√´ disa sekonda', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'n√´ 5 dit√´', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Sot n√´ 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Sot n√´ 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Sot n√´ 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Nes√´r n√´ 02:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Sot n√´ 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Dje n√´ 02:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [n√´] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [n√´] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [n√´] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [e kaluar n√´] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [e kaluar n√´] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [e kaluar n√´] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('sr-cyrl');

    test('parse', function (assert) {
        var tests = '—ò–∞–Ω—É–∞—Ä —ò–∞–Ω._—Ñ–µ–±—Ä—É–∞—Ä —Ñ–µ–±._–º–∞—Ä—Ç –º–∞—Ä._–∞–ø—Ä–∏–ª –∞–ø—Ä._–º–∞—ò –º–∞—ò_—ò—É–Ω —ò—É–Ω_—ò—É–ª —ò—É–ª_–∞–≤–≥—É—Å—Ç –∞–≤–≥._—Å–µ–ø—Ç–µ–º–±–∞—Ä —Å–µ–ø._–æ–∫—Ç–æ–±–∞—Ä –æ–∫—Ç._–Ω–æ–≤–µ–º–±–∞—Ä –Ω–æ–≤._–¥–µ—Ü–µ–º–±–∞—Ä –¥–µ—Ü.'.split('_'),
            i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      '–Ω–µ–¥–µ—ô–∞, 14. —Ñ–µ–±—Ä—É–∞—Ä 2010, 3:25:50 pm'],
                ['ddd, hA',                            '–Ω–µ–¥., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 —Ñ–µ–±—Ä—É–∞—Ä —Ñ–µ–±.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. –Ω–µ–¥–µ—ô–∞ –Ω–µ–¥. –Ω–µ'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '7 7. 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14. 02. 2010'],
                ['LL',                                 '14. —Ñ–µ–±—Ä—É–∞—Ä 2010'],
                ['LLL',                                '14. —Ñ–µ–±—Ä—É–∞—Ä 2010 15:25'],
                ['LLLL',                               '–Ω–µ–¥–µ—ô–∞, 14. —Ñ–µ–±—Ä—É–∞—Ä 2010 15:25'],
                ['l',                                  '14. 2. 2010'],
                ['ll',                                 '14. —Ñ–µ–±. 2010'],
                ['lll',                                '14. —Ñ–µ–±. 2010 15:25'],
                ['llll',                               '–Ω–µ–¥., 14. —Ñ–µ–±. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = '—ò–∞–Ω—É–∞—Ä —ò–∞–Ω._—Ñ–µ–±—Ä—É–∞—Ä —Ñ–µ–±._–º–∞—Ä—Ç –º–∞—Ä._–∞–ø—Ä–∏–ª –∞–ø—Ä._–º–∞—ò –º–∞—ò_—ò—É–Ω —ò—É–Ω_—ò—É–ª —ò—É–ª_–∞–≤–≥—É—Å—Ç –∞–≤–≥._—Å–µ–ø—Ç–µ–º–±–∞—Ä —Å–µ–ø._–æ–∫—Ç–æ–±–∞—Ä –æ–∫—Ç._–Ω–æ–≤–µ–º–±–∞—Ä –Ω–æ–≤._–¥–µ—Ü–µ–º–±–∞—Ä –¥–µ—Ü.'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '–Ω–µ–¥–µ—ô–∞ –Ω–µ–¥. –Ω–µ_–ø–æ–Ω–µ–¥–µ—ô–∞–∫ –ø–æ–Ω. –ø–æ_—É—Ç–æ—Ä–∞–∫ —É—Ç–æ. —É—Ç_—Å—Ä–µ–¥–∞ —Å—Ä–µ. —Å—Ä_—á–µ—Ç–≤—Ä—Ç–∞–∫ —á–µ—Ç. —á–µ_–ø–µ—Ç–∞–∫ –ø–µ—Ç. –ø–µ_—Å—É–±–æ—Ç–∞ —Å—É–±. —Å—É'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '–Ω–µ–∫–æ–ª–∏–∫–æ —Å–µ–∫—É–Ω–¥–∏', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '—ò–µ–¥–∞–Ω –º–∏–Ω—É—Ç',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '—ò–µ–¥–∞–Ω –º–∏–Ω—É—Ç',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 –º–∏–Ω—É—Ç–µ',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 –º–∏–Ω—É—Ç–∞',     '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '—ò–µ–¥–∞–Ω —Å–∞—Ç',      '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '—ò–µ–¥–∞–Ω —Å–∞—Ç',      '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 —Å–∞—Ç–∞',        '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 —Å–∞—Ç–∏',         '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 —Å–∞—Ç–∏',        '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '–¥–∞–Ω',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '–¥–∞–Ω',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 –¥–∞–Ω–∞',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '–¥–∞–Ω',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 –¥–∞–Ω–∞',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 –¥–∞–Ω–∞',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '–º–µ—Å–µ—Ü',     '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '–º–µ—Å–µ—Ü',     '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '–º–µ—Å–µ—Ü',     '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 –º–µ—Å–µ—Ü–∞',     '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 –º–µ—Å–µ—Ü–∞',     '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 –º–µ—Å–µ—Ü–∞',     '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '–º–µ—Å–µ—Ü',     '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 –º–µ—Å–µ—Ü–∏',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '–≥–æ–¥–∏–Ω—É',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 –≥–æ–¥–∏–Ω–µ',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '–≥–æ–¥–∏–Ω—É',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 –≥–æ–¥–∏–Ω–∞',        '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '–∑–∞ –Ω–µ–∫–æ–ª–∏–∫–æ —Å–µ–∫—É–Ω–¥–∏',  'prefix');
        assert.equal(moment(0).from(30000), '–ø—Ä–µ –Ω–µ–∫–æ–ª–∏–∫–æ —Å–µ–∫—É–Ω–¥–∏', 'prefix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '–ø—Ä–µ –Ω–µ–∫–æ–ª–∏–∫–æ —Å–µ–∫—É–Ω–¥–∏',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '–∑–∞ –Ω–µ–∫–æ–ª–∏–∫–æ —Å–µ–∫—É–Ω–¥–∏', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '–∑–∞ 5 –¥–∞–Ω–∞', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '–¥–∞–Ω–∞—Å —É 2:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '–¥–∞–Ω–∞—Å —É 2:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '–¥–∞–Ω–∞—Å —É 3:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '—Å—É—Ç—Ä–∞ —É 2:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '–¥–∞–Ω–∞—Å —É 1:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '—ò—É—á–µ —É 2:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
                return '[—É] [–Ω–µ–¥–µ—ô—É] [—É] LT';
            case 3:
                return '[—É] [—Å—Ä–µ–¥—É] [—É] LT';
            case 6:
                return '[—É] [—Å—É–±–æ—Ç—É] [—É] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[—É] dddd [—É] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            var lastWeekDay = [
                    '[–ø—Ä–æ—à–ª–µ] [–Ω–µ–¥–µ—ô–µ] [—É] LT',
                    '[–ø—Ä–æ—à–ª–æ–≥] [–ø–æ–Ω–µ–¥–µ—ô–∫–∞] [—É] LT',
                    '[–ø—Ä–æ—à–ª–æ–≥] [—É—Ç–æ—Ä–∫–∞] [—É] LT',
                    '[–ø—Ä–æ—à–ª–µ] [—Å—Ä–µ–¥–µ] [—É] LT',
                    '[–ø—Ä–æ—à–ª–æ–≥] [—á–µ—Ç–≤—Ä—Ç–∫–∞] [—É] LT',
                    '[–ø—Ä–æ—à–ª–æ–≥] [–ø–µ—Ç–∫–∞] [—É] LT',
                    '[–ø—Ä–æ—à–ª–µ] [—Å—É–±–æ—Ç–µ] [—É] LT'
                ];

            return lastWeekDay[d.day()];
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('sr');

    test('parse', function (assert) {
        var tests = 'januar jan._februar feb._mart mar._april apr._maj maj_jun jun_jul jul_avgust avg._septembar sep._oktobar okt._novembar nov._decembar dec.'.split('_'),
            i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'nedelja, 14. februar 2010, 3:25:50 pm'],
                ['ddd, hA',                            'ned., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. nedelja ned. ne'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '7 7. 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14. 02. 2010'],
                ['LL',                                 '14. februar 2010'],
                ['LLL',                                '14. februar 2010 15:25'],
                ['LLLL',                               'nedelja, 14. februar 2010 15:25'],
                ['l',                                  '14. 2. 2010'],
                ['ll',                                 '14. feb. 2010'],
                ['lll',                                '14. feb. 2010 15:25'],
                ['llll',                               'ned., 14. feb. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'januar jan._februar feb._mart mar._april apr._maj maj_jun jun_jul jul_avgust avg._septembar sep._oktobar okt._novembar nov._decembar dec.'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'nedelja ned. ne_ponedeljak pon. po_utorak uto. ut_sreda sre. sr_ƒçetvrtak ƒçet. ƒçe_petak pet. pe_subota sub. su'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'nekoliko sekundi', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'jedan minut',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'jedan minut',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minute',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuta',     '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'jedan sat',      '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'jedan sat',      '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 sata',        '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 sati',         '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 sati',        '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'dan',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'dan',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dana',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'dan',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dana',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dana',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mesec',     '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mesec',     '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mesec',     '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 meseca',     '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 meseca',     '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 meseca',     '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mesec',     '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 meseci',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'godinu',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 godine',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'godinu',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 godina',        '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'za nekoliko sekundi',  'prefix');
        assert.equal(moment(0).from(30000), 'pre nekoliko sekundi', 'prefix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'pre nekoliko sekundi',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'za nekoliko sekundi', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'za 5 dana', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'danas u 2:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'danas u 2:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'danas u 3:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'sutra u 2:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'danas u 1:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'juƒçe u 2:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
                return '[u] [nedelju] [u] LT';
            case 3:
                return '[u] [sredu] [u] LT';
            case 6:
                return '[u] [subotu] [u] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[u] dddd [u] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            var lastWeekDay = [
                    '[pro≈°le] [nedelje] [u] LT',
                    '[pro≈°log] [ponedeljka] [u] LT',
                    '[pro≈°log] [utorka] [u] LT',
                    '[pro≈°le] [srede] [u] LT',
                    '[pro≈°log] [ƒçetvrtka] [u] LT',
                    '[pro≈°log] [petka] [u] LT',
                    '[pro≈°le] [subote] [u] LT'
                ];

            return lastWeekDay[d.day()];
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('sv');

    test('parse', function (assert) {
        var tests = 'januari jan_februari feb_mars mar_april apr_maj maj_juni jun_juli jul_augusti aug_september sep_oktober okt_november nov_december dec'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      's√∂ndag, februari 14e 2010, 3:25:50 pm'],
                ['ddd, hA',                            's√∂n, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2a 02 februari feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14e 14'],
                ['d do dddd ddd dd',                   '0 0e s√∂ndag s√∂n s√∂'],
                ['DDD DDDo DDDD',                      '45 45e 045'],
                ['w wo ww',                            '6 6e 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45e day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '2010-02-14'],
                ['LL',                                 '14 februari 2010'],
                ['LLL',                                '14 februari 2010 15:25'],
                ['LLLL',                               's√∂ndag 14 februari 2010 15:25'],
                ['l',                                  '2010-2-14'],
                ['ll',                                 '14 feb 2010'],
                ['lll',                                '14 feb 2010 15:25'],
                ['llll',                               's√∂n 14 feb 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1a', '1a');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2a', '2a');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3e', '3e');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4e', '4e');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5e', '5e');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6e', '6e');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7e', '7e');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8e', '8e');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9e', '9e');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10e', '10e');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11e', '11e');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12e', '12e');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13e', '13e');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14e', '14e');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15e', '15e');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16e', '16e');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17e', '17e');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18e', '18e');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19e', '19e');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20e', '20e');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21a', '21a');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22a', '22a');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23e', '23e');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24e', '24e');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25e', '25e');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26e', '26e');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27e', '27e');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28e', '28e');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29e', '29e');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30e', '30e');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31a', '31a');
    });

    test('format month', function (assert) {
        var expected = 'januari jan_februari feb_mars mar_april apr_maj maj_juni jun_juli jul_augusti aug_september sep_oktober okt_november nov_december dec'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 's√∂ndag s√∂n s√∂_m√•ndag m√•n m√•_tisdag tis ti_onsdag ons on_torsdag tor to_fredag fre fr_l√∂rdag l√∂r l√∂'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'n√•gra sekunder', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'en minut',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'en minut',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuter',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuter',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'en timme',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'en timme',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 timmar',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 timmar',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 timmar',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'en dag',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'en dag',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dagar',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'en dag',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dagar',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dagar',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'en m√•nad',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'en m√•nad',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'en m√•nad',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 m√•nader',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 m√•nader',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 m√•nader',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'en m√•nad',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 m√•nader',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ett √•r',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 √•r',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'ett √•r',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 √•r',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'om n√•gra sekunder',  'prefix');
        assert.equal(moment(0).from(30000), 'f√∂r n√•gra sekunder sedan', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'f√∂r n√•gra sekunder sedan',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'om n√•gra sekunder', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'om 5 dagar', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Idag 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Idag 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Idag 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Imorgon 02:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Idag 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Ig√•r 02:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[P√•] dddd LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[P√•] dddd LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[P√•] dddd LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[I] dddd[s] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[I] dddd[s] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[I] dddd[s] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52a', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1a', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1a', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2a', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2a', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('ta');

    test('parse', function (assert) {
        var tests = '‡Æú‡Æ©‡Æµ‡Æ∞‡Æø ‡Æú‡Æ©‡Æµ‡Æ∞‡Æø_‡Æ™‡Æø‡Æ™‡Øç‡Æ∞‡Æµ‡Æ∞‡Æø ‡Æ™‡Æø‡Æ™‡Øç‡Æ∞‡Æµ‡Æ∞‡Æø_‡ÆÆ‡Ææ‡Æ∞‡Øç‡Æö‡Øç ‡ÆÆ‡Ææ‡Æ∞‡Øç‡Æö‡Øç_‡Æè‡Æ™‡Øç‡Æ∞‡Æ≤‡Øç ‡Æè‡Æ™‡Øç‡Æ∞‡Æ≤‡Øç_‡ÆÆ‡Øá ‡ÆÆ‡Øá_‡Æú‡ØÇ‡Æ©‡Øç ‡Æú‡ØÇ‡Æ©‡Øç_‡Æú‡ØÇ‡Æ≤‡Øà ‡Æú‡ØÇ‡Æ≤‡Øà_‡ÆÜ‡Æï‡Æ∏‡Øç‡Æü‡Øç ‡ÆÜ‡Æï‡Æ∏‡Øç‡Æü‡Øç_‡Æö‡ØÜ‡Æ™‡Øç‡Æü‡ØÜ‡ÆÆ‡Øç‡Æ™‡Æ∞‡Øç ‡Æö‡ØÜ‡Æ™‡Øç‡Æü‡ØÜ‡ÆÆ‡Øç‡Æ™‡Æ∞‡Øç_‡ÆÖ‡Æï‡Øç‡Æü‡Øá‡Ææ‡Æ™‡Æ∞‡Øç ‡ÆÖ‡Æï‡Øç‡Æü‡Øá‡Ææ‡Æ™‡Æ∞‡Øç_‡Æ®‡Æµ‡ÆÆ‡Øç‡Æ™‡Æ∞‡Øç ‡Æ®‡Æµ‡ÆÆ‡Øç‡Æ™‡Æ∞‡Øç_‡Æü‡Æø‡Æö‡ÆÆ‡Øç‡Æ™‡Æ∞‡Øç ‡Æü‡Æø‡Æö‡ÆÆ‡Øç‡Æ™‡Æ∞‡Øç'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a', '‡Æû‡Ææ‡ÆØ‡Æø‡Æ±‡Øç‡Æ±‡ØÅ‡Æï‡Øç‡Æï‡Æø‡Æ¥‡ÆÆ‡Øà, ‡Æ™‡Æø‡Æ™‡Øç‡Æ∞‡Æµ‡Æ∞‡Æø 14‡Æµ‡Æ§‡ØÅ 2010, 3:25:50  ‡Æé‡Æ±‡Øç‡Æ™‡Ææ‡Æü‡ØÅ'],
                ['ddd, hA',                       '‡Æû‡Ææ‡ÆØ‡Æø‡Æ±‡ØÅ, 3 ‡Æé‡Æ±‡Øç‡Æ™‡Ææ‡Æü‡ØÅ'],
                ['M Mo MM MMMM MMM',              '2 2‡Æµ‡Æ§‡ØÅ 02 ‡Æ™‡Æø‡Æ™‡Øç‡Æ∞‡Æµ‡Æ∞‡Æø ‡Æ™‡Æø‡Æ™‡Øç‡Æ∞‡Æµ‡Æ∞‡Æø'],
                ['YYYY YY',                       '2010 10'],
                ['D Do DD',                       '14 14‡Æµ‡Æ§‡ØÅ 14'],
                ['d do dddd ddd dd',              '0 0‡Æµ‡Æ§‡ØÅ ‡Æû‡Ææ‡ÆØ‡Æø‡Æ±‡Øç‡Æ±‡ØÅ‡Æï‡Øç‡Æï‡Æø‡Æ¥‡ÆÆ‡Øà ‡Æû‡Ææ‡ÆØ‡Æø‡Æ±‡ØÅ ‡Æû‡Ææ'],
                ['DDD DDDo DDDD',                 '45 45‡Æµ‡Æ§‡ØÅ 045'],
                ['w wo ww',                       '8 8‡Æµ‡Æ§‡ØÅ 08'],
                ['h hh',                          '3 03'],
                ['H HH',                          '15 15'],
                ['m mm',                          '25 25'],
                ['s ss',                          '50 50'],
                ['a A',                           ' ‡Æé‡Æ±‡Øç‡Æ™‡Ææ‡Æü‡ØÅ  ‡Æé‡Æ±‡Øç‡Æ™‡Ææ‡Æü‡ØÅ'],
                ['[‡ÆÜ‡Æ£‡Øç‡Æü‡Æø‡Æ©‡Øç] DDDo  [‡Æ®‡Ææ‡Æ≥‡Øç]', '‡ÆÜ‡Æ£‡Øç‡Æü‡Æø‡Æ©‡Øç 45‡Æµ‡Æ§‡ØÅ  ‡Æ®‡Ææ‡Æ≥‡Øç'],
                ['LTS',                           '15:25:50'],
                ['L',                             '14/02/2010'],
                ['LL',                            '14 ‡Æ™‡Æø‡Æ™‡Øç‡Æ∞‡Æµ‡Æ∞‡Æø 2010'],
                ['LLL',                           '14 ‡Æ™‡Æø‡Æ™‡Øç‡Æ∞‡Æµ‡Æ∞‡Æø 2010, 15:25'],
                ['LLLL',                          '‡Æû‡Ææ‡ÆØ‡Æø‡Æ±‡Øç‡Æ±‡ØÅ‡Æï‡Øç‡Æï‡Æø‡Æ¥‡ÆÆ‡Øà, 14 ‡Æ™‡Æø‡Æ™‡Øç‡Æ∞‡Æµ‡Æ∞‡Æø 2010, 15:25'],
                ['l',                             '14/2/2010'],
                ['ll',                            '14 ‡Æ™‡Æø‡Æ™‡Øç‡Æ∞‡Æµ‡Æ∞‡Æø 2010'],
                ['lll',                           '14 ‡Æ™‡Æø‡Æ™‡Øç‡Æ∞‡Æµ‡Æ∞‡Æø 2010, 15:25'],
                ['llll',                          '‡Æû‡Ææ‡ÆØ‡Æø‡Æ±‡ØÅ, 14 ‡Æ™‡Æø‡Æ™‡Øç‡Æ∞‡Æµ‡Æ∞‡Æø 2010, 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1‡Æµ‡Æ§‡ØÅ', '1‡Æµ‡Æ§‡ØÅ');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2‡Æµ‡Æ§‡ØÅ', '2‡Æµ‡Æ§‡ØÅ');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3‡Æµ‡Æ§‡ØÅ', '3‡Æµ‡Æ§‡ØÅ');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4‡Æµ‡Æ§‡ØÅ', '4‡Æµ‡Æ§‡ØÅ');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5‡Æµ‡Æ§‡ØÅ', '5‡Æµ‡Æ§‡ØÅ');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6‡Æµ‡Æ§‡ØÅ', '6‡Æµ‡Æ§‡ØÅ');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7‡Æµ‡Æ§‡ØÅ', '7‡Æµ‡Æ§‡ØÅ');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8‡Æµ‡Æ§‡ØÅ', '8‡Æµ‡Æ§‡ØÅ');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9‡Æµ‡Æ§‡ØÅ', '9‡Æµ‡Æ§‡ØÅ');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10‡Æµ‡Æ§‡ØÅ', '10‡Æµ‡Æ§‡ØÅ');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11‡Æµ‡Æ§‡ØÅ', '11‡Æµ‡Æ§‡ØÅ');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12‡Æµ‡Æ§‡ØÅ', '12‡Æµ‡Æ§‡ØÅ');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13‡Æµ‡Æ§‡ØÅ', '13‡Æµ‡Æ§‡ØÅ');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14‡Æµ‡Æ§‡ØÅ', '14‡Æµ‡Æ§‡ØÅ');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15‡Æµ‡Æ§‡ØÅ', '15‡Æµ‡Æ§‡ØÅ');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16‡Æµ‡Æ§‡ØÅ', '16‡Æµ‡Æ§‡ØÅ');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17‡Æµ‡Æ§‡ØÅ', '17‡Æµ‡Æ§‡ØÅ');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18‡Æµ‡Æ§‡ØÅ', '18‡Æµ‡Æ§‡ØÅ');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19‡Æµ‡Æ§‡ØÅ', '19‡Æµ‡Æ§‡ØÅ');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20‡Æµ‡Æ§‡ØÅ', '20‡Æµ‡Æ§‡ØÅ');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21‡Æµ‡Æ§‡ØÅ', '21‡Æµ‡Æ§‡ØÅ');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22‡Æµ‡Æ§‡ØÅ', '22‡Æµ‡Æ§‡ØÅ');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23‡Æµ‡Æ§‡ØÅ', '23‡Æµ‡Æ§‡ØÅ');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24‡Æµ‡Æ§‡ØÅ', '24‡Æµ‡Æ§‡ØÅ');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25‡Æµ‡Æ§‡ØÅ', '25‡Æµ‡Æ§‡ØÅ');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26‡Æµ‡Æ§‡ØÅ', '26‡Æµ‡Æ§‡ØÅ');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27‡Æµ‡Æ§‡ØÅ', '27‡Æµ‡Æ§‡ØÅ');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28‡Æµ‡Æ§‡ØÅ', '28‡Æµ‡Æ§‡ØÅ');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29‡Æµ‡Æ§‡ØÅ', '29‡Æµ‡Æ§‡ØÅ');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30‡Æµ‡Æ§‡ØÅ', '30‡Æµ‡Æ§‡ØÅ');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31‡Æµ‡Æ§‡ØÅ', '31‡Æµ‡Æ§‡ØÅ');
    });

    test('format month', function (assert) {
        var expected = '‡Æú‡Æ©‡Æµ‡Æ∞‡Æø ‡Æú‡Æ©‡Æµ‡Æ∞‡Æø_‡Æ™‡Æø‡Æ™‡Øç‡Æ∞‡Æµ‡Æ∞‡Æø ‡Æ™‡Æø‡Æ™‡Øç‡Æ∞‡Æµ‡Æ∞‡Æø_‡ÆÆ‡Ææ‡Æ∞‡Øç‡Æö‡Øç ‡ÆÆ‡Ææ‡Æ∞‡Øç‡Æö‡Øç_‡Æè‡Æ™‡Øç‡Æ∞‡Æ≤‡Øç ‡Æè‡Æ™‡Øç‡Æ∞‡Æ≤‡Øç_‡ÆÆ‡Øá ‡ÆÆ‡Øá_‡Æú‡ØÇ‡Æ©‡Øç ‡Æú‡ØÇ‡Æ©‡Øç_‡Æú‡ØÇ‡Æ≤‡Øà ‡Æú‡ØÇ‡Æ≤‡Øà_‡ÆÜ‡Æï‡Æ∏‡Øç‡Æü‡Øç ‡ÆÜ‡Æï‡Æ∏‡Øç‡Æü‡Øç_‡Æö‡ØÜ‡Æ™‡Øç‡Æü‡ØÜ‡ÆÆ‡Øç‡Æ™‡Æ∞‡Øç ‡Æö‡ØÜ‡Æ™‡Øç‡Æü‡ØÜ‡ÆÆ‡Øç‡Æ™‡Æ∞‡Øç_‡ÆÖ‡Æï‡Øç‡Æü‡Øá‡Ææ‡Æ™‡Æ∞‡Øç ‡ÆÖ‡Æï‡Øç‡Æü‡Øá‡Ææ‡Æ™‡Æ∞‡Øç_‡Æ®‡Æµ‡ÆÆ‡Øç‡Æ™‡Æ∞‡Øç ‡Æ®‡Æµ‡ÆÆ‡Øç‡Æ™‡Æ∞‡Øç_‡Æü‡Æø‡Æö‡ÆÆ‡Øç‡Æ™‡Æ∞‡Øç ‡Æü‡Æø‡Æö‡ÆÆ‡Øç‡Æ™‡Æ∞‡Øç'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '‡Æû‡Ææ‡ÆØ‡Æø‡Æ±‡Øç‡Æ±‡ØÅ‡Æï‡Øç‡Æï‡Æø‡Æ¥‡ÆÆ‡Øà ‡Æû‡Ææ‡ÆØ‡Æø‡Æ±‡ØÅ ‡Æû‡Ææ_‡Æ§‡Æø‡Æô‡Øç‡Æï‡Æü‡Øç‡Æï‡Æø‡Æ¥‡ÆÆ‡Øà ‡Æ§‡Æø‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æ§‡Æø_‡Æö‡ØÜ‡Æµ‡Øç‡Æµ‡Ææ‡ÆØ‡Øç‡Æï‡Æø‡Æ¥‡ÆÆ‡Øà ‡Æö‡ØÜ‡Æµ‡Øç‡Æµ‡Ææ‡ÆØ‡Øç ‡Æö‡ØÜ_‡Æ™‡ØÅ‡Æ§‡Æ©‡Øç‡Æï‡Æø‡Æ¥‡ÆÆ‡Øà ‡Æ™‡ØÅ‡Æ§‡Æ©‡Øç ‡Æ™‡ØÅ_‡Æµ‡Æø‡ÆØ‡Ææ‡Æ¥‡Æï‡Øç‡Æï‡Æø‡Æ¥‡ÆÆ‡Øà ‡Æµ‡Æø‡ÆØ‡Ææ‡Æ¥‡Æ©‡Øç ‡Æµ‡Æø_‡Æµ‡ØÜ‡Æ≥‡Øç‡Æ≥‡Æø‡Æï‡Øç‡Æï‡Æø‡Æ¥‡ÆÆ‡Øà ‡Æµ‡ØÜ‡Æ≥‡Øç‡Æ≥‡Æø ‡Æµ‡ØÜ_‡Æö‡Æ©‡Æø‡Æï‡Øç‡Æï‡Æø‡Æ¥‡ÆÆ‡Øà ‡Æö‡Æ©‡Æø ‡Æö'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '‡Æí‡Æ∞‡ØÅ ‡Æö‡Æø‡Æ≤ ‡Æµ‡Æø‡Æ®‡Ææ‡Æü‡Æø‡Æï‡Æ≥‡Øç', '44 ‡Æµ‡Æø‡Æ®‡Ææ‡Æü‡Æø‡Æï‡Æ≥‡Øç = ‡Æí‡Æ∞‡ØÅ ‡Æö‡Æø‡Æ≤ ‡Æµ‡Æø‡Æ®‡Ææ‡Æü‡Æø‡Æï‡Æ≥‡Øç');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '‡Æí‡Æ∞‡ØÅ ‡Æ®‡Æø‡ÆÆ‡Æø‡Æü‡ÆÆ‡Øç',      '45 ‡Æµ‡Æø‡Æ®‡Ææ‡Æü‡Æø‡Æï‡Æ≥‡Øç = ‡Æí‡Æ∞‡ØÅ ‡Æ®‡Æø‡ÆÆ‡Æø‡Æü‡ÆÆ‡Øç');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '‡Æí‡Æ∞‡ØÅ ‡Æ®‡Æø‡ÆÆ‡Æø‡Æü‡ÆÆ‡Øç',      '89 ‡Æµ‡Æø‡Æ®‡Ææ‡Æü‡Æø‡Æï‡Æ≥‡Øç = ‡Æí‡Æ∞‡ØÅ ‡Æ®‡Æø‡ÆÆ‡Æø‡Æü‡ÆÆ‡Øç');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ‡Æ®‡Æø‡ÆÆ‡Æø‡Æü‡Æô‡Øç‡Æï‡Æ≥‡Øç',     '90 ‡Æµ‡Æø‡Æ®‡Ææ‡Æü‡Æø‡Æï‡Æ≥‡Øç = 2 ‡Æ®‡Æø‡ÆÆ‡Æø‡Æü‡Æô‡Øç‡Æï‡Æ≥‡Øç');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ‡Æ®‡Æø‡ÆÆ‡Æø‡Æü‡Æô‡Øç‡Æï‡Æ≥‡Øç',    '44 ‡Æ®‡Æø‡ÆÆ‡Æø‡Æü‡Æô‡Øç‡Æï‡Æ≥‡Øç = 44 ‡Æ®‡Æø‡ÆÆ‡Æø‡Æü‡Æô‡Øç‡Æï‡Æ≥‡Øç');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '‡Æí‡Æ∞‡ØÅ ‡ÆÆ‡Æ£‡Æø ‡Æ®‡Øá‡Æ∞‡ÆÆ‡Øç',       '45 ‡Æ®‡Æø‡ÆÆ‡Æø‡Æü‡Æô‡Øç‡Æï‡Æ≥‡Øç = ‡Æí‡Æ∞‡ØÅ ‡ÆÆ‡Æ£‡Æø ‡Æ®‡Øá‡Æ∞‡ÆÆ‡Øç');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '‡Æí‡Æ∞‡ØÅ ‡ÆÆ‡Æ£‡Æø ‡Æ®‡Øá‡Æ∞‡ÆÆ‡Øç',       '89 ‡Æ®‡Æø‡ÆÆ‡Æø‡Æü‡Æô‡Øç‡Æï‡Æ≥‡Øç = ‡Æí‡Æ∞‡ØÅ ‡ÆÆ‡Æ£‡Æø ‡Æ®‡Øá‡Æ∞‡ÆÆ‡Øç');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ‡ÆÆ‡Æ£‡Æø ‡Æ®‡Øá‡Æ∞‡ÆÆ‡Øç',       '90 ‡Æ®‡Æø‡ÆÆ‡Æø‡Æü‡Æô‡Øç‡Æï‡Æ≥‡Øç = 2 ‡ÆÆ‡Æ£‡Æø ‡Æ®‡Øá‡Æ∞‡ÆÆ‡Øç');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ‡ÆÆ‡Æ£‡Æø ‡Æ®‡Øá‡Æ∞‡ÆÆ‡Øç',       '5 ‡ÆÆ‡Æ£‡Æø ‡Æ®‡Øá‡Æ∞‡ÆÆ‡Øç = 5 ‡ÆÆ‡Æ£‡Æø ‡Æ®‡Øá‡Æ∞‡ÆÆ‡Øç');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ‡ÆÆ‡Æ£‡Æø ‡Æ®‡Øá‡Æ∞‡ÆÆ‡Øç',      '21 ‡ÆÆ‡Æ£‡Æø ‡Æ®‡Øá‡Æ∞‡ÆÆ‡Øç = 21 ‡ÆÆ‡Æ£‡Æø ‡Æ®‡Øá‡Æ∞‡ÆÆ‡Øç');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '‡Æí‡Æ∞‡ØÅ ‡Æ®‡Ææ‡Æ≥‡Øç',         '22 ‡ÆÆ‡Æ£‡Æø ‡Æ®‡Øá‡Æ∞‡ÆÆ‡Øç = ‡Æí‡Æ∞‡ØÅ ‡Æ®‡Ææ‡Æ≥‡Øç');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '‡Æí‡Æ∞‡ØÅ ‡Æ®‡Ææ‡Æ≥‡Øç',         '35 ‡ÆÆ‡Æ£‡Æø ‡Æ®‡Øá‡Æ∞‡ÆÆ‡Øç = ‡Æí‡Æ∞‡ØÅ ‡Æ®‡Ææ‡Æ≥‡Øç');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Øç',        '36 ‡ÆÆ‡Æ£‡Æø ‡Æ®‡Øá‡Æ∞‡ÆÆ‡Øç = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '‡Æí‡Æ∞‡ØÅ ‡Æ®‡Ææ‡Æ≥‡Øç',         '1 ‡Æ®‡Ææ‡Æ≥‡Øç = ‡Æí‡Æ∞‡ØÅ ‡Æ®‡Ææ‡Æ≥‡Øç');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Øç',        '5 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Øç = 5 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Øç');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Øç',       '25 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Øç = 25 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Øç');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '‡Æí‡Æ∞‡ØÅ ‡ÆÆ‡Ææ‡Æ§‡ÆÆ‡Øç',       '26 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Øç = ‡Æí‡Æ∞‡ØÅ ‡ÆÆ‡Ææ‡Æ§‡ÆÆ‡Øç');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '‡Æí‡Æ∞‡ØÅ ‡ÆÆ‡Ææ‡Æ§‡ÆÆ‡Øç',       '30 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Øç = ‡Æí‡Æ∞‡ØÅ ‡ÆÆ‡Ææ‡Æ§‡ÆÆ‡Øç');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '‡Æí‡Æ∞‡ØÅ ‡ÆÆ‡Ææ‡Æ§‡ÆÆ‡Øç',       '45 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Øç = ‡Æí‡Æ∞‡ØÅ ‡ÆÆ‡Ææ‡Æ§‡ÆÆ‡Øç');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ‡ÆÆ‡Ææ‡Æ§‡Æô‡Øç‡Æï‡Æ≥‡Øç',      '46 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Øç = 2 ‡ÆÆ‡Ææ‡Æ§‡Æô‡Øç‡Æï‡Æ≥‡Øç');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ‡ÆÆ‡Ææ‡Æ§‡Æô‡Øç‡Æï‡Æ≥‡Øç',      '75 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Øç = 2 ‡ÆÆ‡Ææ‡Æ§‡Æô‡Øç‡Æï‡Æ≥‡Øç');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ‡ÆÆ‡Ææ‡Æ§‡Æô‡Øç‡Æï‡Æ≥‡Øç',      '76 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Øç = 3 ‡ÆÆ‡Ææ‡Æ§‡Æô‡Øç‡Æï‡Æ≥‡Øç');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '‡Æí‡Æ∞‡ØÅ ‡ÆÆ‡Ææ‡Æ§‡ÆÆ‡Øç',       '1 ‡ÆÆ‡Ææ‡Æ§‡ÆÆ‡Øç = ‡Æí‡Æ∞‡ØÅ ‡ÆÆ‡Ææ‡Æ§‡ÆÆ‡Øç');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ‡ÆÆ‡Ææ‡Æ§‡Æô‡Øç‡Æï‡Æ≥‡Øç',      '5 ‡ÆÆ‡Ææ‡Æ§‡Æô‡Øç‡Æï‡Æ≥‡Øç = 5 ‡ÆÆ‡Ææ‡Æ§‡Æô‡Øç‡Æï‡Æ≥‡Øç');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '‡Æí‡Æ∞‡ØÅ ‡Æµ‡Æ∞‡ØÅ‡Æü‡ÆÆ‡Øç',        '345 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Øç = ‡Æí‡Æ∞‡ØÅ ‡Æµ‡Æ∞‡ØÅ‡Æü‡ÆÆ‡Øç');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ‡ÆÜ‡Æ£‡Øç‡Æü‡ØÅ‡Æï‡Æ≥‡Øç',       '548 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Øç = 2 ‡ÆÜ‡Æ£‡Øç‡Æü‡ØÅ‡Æï‡Æ≥‡Øç');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '‡Æí‡Æ∞‡ØÅ ‡Æµ‡Æ∞‡ØÅ‡Æü‡ÆÆ‡Øç',        '1 ‡Æµ‡Æ∞‡ØÅ‡Æü‡ÆÆ‡Øç = ‡Æí‡Æ∞‡ØÅ ‡Æµ‡Æ∞‡ØÅ‡Æü‡ÆÆ‡Øç');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ‡ÆÜ‡Æ£‡Øç‡Æü‡ØÅ‡Æï‡Æ≥‡Øç',       '5 ‡ÆÜ‡Æ£‡Øç‡Æü‡ØÅ‡Æï‡Æ≥‡Øç = 5 ‡ÆÜ‡Æ£‡Øç‡Æü‡ØÅ‡Æï‡Æ≥‡Øç');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '‡Æí‡Æ∞‡ØÅ ‡Æö‡Æø‡Æ≤ ‡Æµ‡Æø‡Æ®‡Ææ‡Æü‡Æø‡Æï‡Æ≥‡Øç ‡Æá‡Æ≤‡Øç',  'prefix');
        assert.equal(moment(0).from(30000), '‡Æí‡Æ∞‡ØÅ ‡Æö‡Æø‡Æ≤ ‡Æµ‡Æø‡Æ®‡Ææ‡Æü‡Æø‡Æï‡Æ≥‡Øç ‡ÆÆ‡ØÅ‡Æ©‡Øç', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '‡Æí‡Æ∞‡ØÅ ‡Æö‡Æø‡Æ≤ ‡Æµ‡Æø‡Æ®‡Ææ‡Æü‡Æø‡Æï‡Æ≥‡Øç ‡ÆÆ‡ØÅ‡Æ©‡Øç',  '‡Æá‡Æ™‡Øç‡Æ™‡Øá‡Ææ‡Æ§‡ØÅ ‡Æá‡Æ∞‡ØÅ‡Æ®‡Øç‡Æ§‡ØÅ ‡Æï‡Æü‡Æ®‡Øç‡Æ§ ‡Æï‡Ææ‡Æ≤‡Æ§‡Øç‡Æ§‡Æø‡Æ≤‡Øç ‡Æï‡Ææ‡Æü‡Øç‡Æü ‡Æµ‡Øá‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '‡Æí‡Æ∞‡ØÅ ‡Æö‡Æø‡Æ≤ ‡Æµ‡Æø‡Æ®‡Ææ‡Æü‡Æø‡Æï‡Æ≥‡Øç ‡Æá‡Æ≤‡Øç', '‡Æí‡Æ∞‡ØÅ ‡Æö‡Æø‡Æ≤ ‡Æµ‡Æø‡Æ®‡Ææ‡Æü‡Æø‡Æï‡Æ≥‡Øç ‡Æá‡Æ≤‡Øç');
        assert.equal(moment().add({d: 5}).fromNow(), '5 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Øç ‡Æá‡Æ≤‡Øç', '5 ‡Æ®‡Ææ‡Æü‡Øç‡Æï‡Æ≥‡Øç ‡Æá‡Æ≤‡Øç');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),  '‡Æá‡Æ©‡Øç‡Æ±‡ØÅ 02:00', '‡Æá‡Æ©‡Øç‡Æ±‡ØÅ  02:00');
        assert.equal(moment(a).add({m: 25}).calendar(), '‡Æá‡Æ©‡Øç‡Æ±‡ØÅ 02:25', '‡Æá‡Æ©‡Øç‡Æ±‡ØÅ  02:25');
        assert.equal(moment(a).add({h: 1}).calendar(), '‡Æá‡Æ©‡Øç‡Æ±‡ØÅ 03:00', '‡Æá‡Æ©‡Øç‡Æ±‡ØÅ  03:00');
        assert.equal(moment(a).add({d: 1}).calendar(), '‡Æ®‡Ææ‡Æ≥‡Øà 02:00', '‡Æ®‡Ææ‡Æ≥‡Øà  02:00');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '‡Æá‡Æ©‡Øç‡Æ±‡ØÅ 01:00',      '‡Æá‡Æ©‡Øç‡Æ±‡ØÅ  01:00');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '‡Æ®‡Øá‡Æ±‡Øç‡Æ±‡ØÅ 02:00',  '‡Æ®‡Øá‡Æ±‡Øç‡Æ±‡ØÅ  02:00');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd, LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd, LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd, LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[‡Æï‡Æü‡Æ®‡Øç‡Æ§ ‡Æµ‡Ææ‡Æ∞‡ÆÆ‡Øç] dddd, LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[‡Æï‡Æü‡Æ®‡Øç‡Æ§ ‡Æµ‡Ææ‡Æ∞‡ÆÆ‡Øç] dddd, LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[‡Æï‡Æü‡Æ®‡Øç‡Æ§ ‡Æµ‡Ææ‡Æ∞‡ÆÆ‡Øç] dddd, LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  0, 30]).format('a'), ' ‡ÆØ‡Ææ‡ÆÆ‡ÆÆ‡Øç', '(after) midnight');
        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), ' ‡Æµ‡Øà‡Æï‡Æ±‡Øà', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), ' ‡Æï‡Ææ‡Æ≤‡Øà', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), ' ‡Æé‡Æ±‡Øç‡Æ™‡Ææ‡Æü‡ØÅ', 'during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), ' ‡Æé‡Æ±‡Øç‡Æ™‡Ææ‡Æü‡ØÅ', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), ' ‡ÆÆ‡Ææ‡Æ≤‡Øà', 'late evening');
        assert.equal(moment([2011, 2, 23, 23, 30]).format('a'), ' ‡ÆØ‡Ææ‡ÆÆ‡ÆÆ‡Øç', '(before) midnight');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('meridiem invariant', function (assert) {
        var h, m, t1, t2;
        for (h = 0; h < 24; ++h) {
            for (m = 0; m < 60; m += 15) {
                t1 = moment.utc([2000, 0, 1, h, m]);
                t2 = moment(t1.format('A h:mm'), 'A h:mm');
                assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                        'meridiem at ' + t1.format('HH:mm'));
            }
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('th');

    test('parse', function (assert) {
        var tests = '‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏° ‡∏°‡∏Å‡∏£‡∏≤_‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå ‡∏Å‡∏∏‡∏°‡∏†‡∏≤_‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏° ‡∏°‡∏µ‡∏ô‡∏≤_‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô ‡πÄ‡∏°‡∏©‡∏≤_‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏° ‡∏û‡∏§‡∏©‡∏†‡∏≤_‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô ‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤_‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏° ‡∏Å‡∏£‡∏Å‡∏é‡∏≤_‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏° ‡∏™‡∏¥‡∏á‡∏´‡∏≤_‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô ‡∏Å‡∏±‡∏ô‡∏¢‡∏≤_‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏° ‡∏ï‡∏∏‡∏•‡∏≤_‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô ‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤_‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏° ‡∏ò‡∏±‡∏ô‡∏ß‡∏≤'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      '‡∏≠‡∏≤‡∏ó‡∏¥‡∏ï‡∏¢‡πå, 14 ‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå 2010, 3:25:50 ‡∏´‡∏•‡∏±‡∏á‡πÄ‡∏ó‡∏µ‡πà‡∏¢‡∏á'],
                ['ddd, h A',                           '‡∏≠‡∏≤‡∏ó‡∏¥‡∏ï‡∏¢‡πå, 3 ‡∏´‡∏•‡∏±‡∏á‡πÄ‡∏ó‡∏µ‡πà‡∏¢‡∏á'],
                ['M Mo MM MMMM MMM',                   '2 2 02 ‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå ‡∏Å‡∏∏‡∏°‡∏†‡∏≤'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 ‡∏≠‡∏≤‡∏ó‡∏¥‡∏ï‡∏¢‡πå ‡∏≠‡∏≤‡∏ó‡∏¥‡∏ï‡∏¢‡πå ‡∏≠‡∏≤.'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '8 8 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                '‡∏´‡∏•‡∏±‡∏á‡πÄ‡∏ó‡∏µ‡πà‡∏¢‡∏á ‡∏´‡∏•‡∏±‡∏á‡πÄ‡∏ó‡∏µ‡πà‡∏¢‡∏á'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15 ‡∏ô‡∏≤‡∏¨‡∏¥‡∏Å‡∏≤ 25 ‡∏ô‡∏≤‡∏ó‡∏µ 50 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ'],
                ['L',                                  '2010/02/14'],
                ['LL',                                 '14 ‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå 2010'],
                ['LLL',                                '14 ‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå 2010 ‡πÄ‡∏ß‡∏•‡∏≤ 15 ‡∏ô‡∏≤‡∏¨‡∏¥‡∏Å‡∏≤ 25 ‡∏ô‡∏≤‡∏ó‡∏µ'],
                ['LLLL',                               '‡∏ß‡∏±‡∏ô‡∏≠‡∏≤‡∏ó‡∏¥‡∏ï‡∏¢‡πå‡∏ó‡∏µ‡πà 14 ‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå 2010 ‡πÄ‡∏ß‡∏•‡∏≤ 15 ‡∏ô‡∏≤‡∏¨‡∏¥‡∏Å‡∏≤ 25 ‡∏ô‡∏≤‡∏ó‡∏µ'],
                ['l',                                  '2010/2/14'],
                ['ll',                                 '14 ‡∏Å‡∏∏‡∏°‡∏†‡∏≤ 2010'],
                ['lll',                                '14 ‡∏Å‡∏∏‡∏°‡∏†‡∏≤ 2010 ‡πÄ‡∏ß‡∏•‡∏≤ 15 ‡∏ô‡∏≤‡∏¨‡∏¥‡∏Å‡∏≤ 25 ‡∏ô‡∏≤‡∏ó‡∏µ'],
                ['llll',                               '‡∏ß‡∏±‡∏ô‡∏≠‡∏≤‡∏ó‡∏¥‡∏ï‡∏¢‡πå‡∏ó‡∏µ‡πà 14 ‡∏Å‡∏∏‡∏°‡∏†‡∏≤ 2010 ‡πÄ‡∏ß‡∏•‡∏≤ 15 ‡∏ô‡∏≤‡∏¨‡∏¥‡∏Å‡∏≤ 25 ‡∏ô‡∏≤‡∏ó‡∏µ']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format month', function (assert) {
        var expected = '‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏° ‡∏°‡∏Å‡∏£‡∏≤_‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå ‡∏Å‡∏∏‡∏°‡∏†‡∏≤_‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏° ‡∏°‡∏µ‡∏ô‡∏≤_‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô ‡πÄ‡∏°‡∏©‡∏≤_‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏° ‡∏û‡∏§‡∏©‡∏†‡∏≤_‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô ‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤_‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏° ‡∏Å‡∏£‡∏Å‡∏é‡∏≤_‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏° ‡∏™‡∏¥‡∏á‡∏´‡∏≤_‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô ‡∏Å‡∏±‡∏ô‡∏¢‡∏≤_‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏° ‡∏ï‡∏∏‡∏•‡∏≤_‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô ‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤_‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏° ‡∏ò‡∏±‡∏ô‡∏ß‡∏≤'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '‡∏≠‡∏≤‡∏ó‡∏¥‡∏ï‡∏¢‡πå ‡∏≠‡∏≤‡∏ó‡∏¥‡∏ï‡∏¢‡πå ‡∏≠‡∏≤._‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå ‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå ‡∏à._‡∏≠‡∏±‡∏á‡∏Ñ‡∏≤‡∏£ ‡∏≠‡∏±‡∏á‡∏Ñ‡∏≤‡∏£ ‡∏≠._‡∏û‡∏∏‡∏ò ‡∏û‡∏∏‡∏ò ‡∏û._‡∏û‡∏§‡∏´‡∏±‡∏™‡∏ö‡∏î‡∏µ ‡∏û‡∏§‡∏´‡∏±‡∏™ ‡∏û‡∏§._‡∏®‡∏∏‡∏Å‡∏£‡πå ‡∏®‡∏∏‡∏Å‡∏£‡πå ‡∏®._‡πÄ‡∏™‡∏≤‡∏£‡πå ‡πÄ‡∏™‡∏≤‡∏£‡πå ‡∏™.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '‡πÑ‡∏°‡πà‡∏Å‡∏µ‡πà‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ',   '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '1 ‡∏ô‡∏≤‡∏ó‡∏µ', '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '1 ‡∏ô‡∏≤‡∏ó‡∏µ', '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ‡∏ô‡∏≤‡∏ó‡∏µ',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ‡∏ô‡∏≤‡∏ó‡∏µ', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '1 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á', '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '1 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á', '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á',  '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á',  '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á', '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '1 ‡∏ß‡∏±‡∏ô',   '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '1 ‡∏ß‡∏±‡∏ô',   '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ‡∏ß‡∏±‡∏ô',   '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '1 ‡∏ß‡∏±‡∏ô',   '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ‡∏ß‡∏±‡∏ô',   '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ‡∏ß‡∏±‡∏ô',  '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '1 ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô', '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '1 ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô', '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '1 ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô', '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô',  '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô',  '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô',  '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '1 ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô', '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô',  '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '1 ‡∏õ‡∏µ',   '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ‡∏õ‡∏µ',   '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '1 ‡∏õ‡∏µ',   '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ‡∏õ‡∏µ',   '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '‡∏≠‡∏µ‡∏Å ‡πÑ‡∏°‡πà‡∏Å‡∏µ‡πà‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ',  'prefix');
        assert.equal(moment(0).from(30000), '‡πÑ‡∏°‡πà‡∏Å‡∏µ‡πà‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡∏ó‡∏µ‡πà‡πÅ‡∏•‡πâ‡∏ß', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '‡πÑ‡∏°‡πà‡∏Å‡∏µ‡πà‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡∏ó‡∏µ‡πà‡πÅ‡∏•‡πâ‡∏ß',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '‡∏≠‡∏µ‡∏Å ‡πÑ‡∏°‡πà‡∏Å‡∏µ‡πà‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '‡∏≠‡∏µ‡∏Å 5 ‡∏ß‡∏±‡∏ô', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ ‡πÄ‡∏ß‡∏•‡∏≤ 2 ‡∏ô‡∏≤‡∏¨‡∏¥‡∏Å‡∏≤ 0 ‡∏ô‡∏≤‡∏ó‡∏µ',      'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ ‡πÄ‡∏ß‡∏•‡∏≤ 2 ‡∏ô‡∏≤‡∏¨‡∏¥‡∏Å‡∏≤ 25 ‡∏ô‡∏≤‡∏ó‡∏µ',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ ‡πÄ‡∏ß‡∏•‡∏≤ 3 ‡∏ô‡∏≤‡∏¨‡∏¥‡∏Å‡∏≤ 0 ‡∏ô‡∏≤‡∏ó‡∏µ',      'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '‡∏û‡∏£‡∏∏‡πà‡∏á‡∏ô‡∏µ‡πâ ‡πÄ‡∏ß‡∏•‡∏≤ 2 ‡∏ô‡∏≤‡∏¨‡∏¥‡∏Å‡∏≤ 0 ‡∏ô‡∏≤‡∏ó‡∏µ', 'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ ‡πÄ‡∏ß‡∏•‡∏≤ 1 ‡∏ô‡∏≤‡∏¨‡∏¥‡∏Å‡∏≤ 0 ‡∏ô‡∏≤‡∏ó‡∏µ',      'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ß‡∏≤‡∏ô‡∏ô‡∏µ‡πâ ‡πÄ‡∏ß‡∏•‡∏≤ 2 ‡∏ô‡∏≤‡∏¨‡∏¥‡∏Å‡∏≤ 0 ‡∏ô‡∏≤‡∏ó‡∏µ', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd[‡∏´‡∏ô‡πâ‡∏≤ ‡πÄ‡∏ß‡∏•‡∏≤] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd[‡∏´‡∏ô‡πâ‡∏≤ ‡πÄ‡∏ß‡∏•‡∏≤] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd[‡∏´‡∏ô‡πâ‡∏≤ ‡πÄ‡∏ß‡∏•‡∏≤] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[‡∏ß‡∏±‡∏ô]dddd[‡∏ó‡∏µ‡πà‡πÅ‡∏•‡πâ‡∏ß ‡πÄ‡∏ß‡∏•‡∏≤] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[‡∏ß‡∏±‡∏ô]dddd[‡∏ó‡∏µ‡πà‡πÅ‡∏•‡πâ‡∏ß ‡πÄ‡∏ß‡∏•‡∏≤] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[‡∏ß‡∏±‡∏ô]dddd[‡∏ó‡∏µ‡πà‡πÅ‡∏•‡πâ‡∏ß ‡πÄ‡∏ß‡∏•‡∏≤] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),      '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),      '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3', 'Jan 15 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('tl-ph');

    test('parse', function (assert) {
        var tests = 'Enero Ene_Pebrero Peb_Marso Mar_Abril Abr_Mayo May_Hunyo Hun_Hulyo Hul_Agosto Ago_Setyembre Set_Oktubre Okt_Nobyembre Nob_Disyembre Dis'.split('_'),
            i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Linggo, Pebrero 14 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Lin, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2 02 Pebrero Peb'],
                ['YYYY YY',                             '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 Linggo Lin Li'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '6 6 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '02/14/2010'],
                ['LL',                                 'Pebrero 14, 2010'],
                ['LLL',                                'Pebrero 14, 2010 15:25'],
                ['LLLL',                               'Linggo, Pebrero 14, 2010 15:25'],
                ['l',                                  '2/14/2010'],
                ['ll',                                 'Peb 14, 2010'],
                ['lll',                                'Peb 14, 2010 15:25'],
                ['llll',                               'Lin, Peb 14, 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = 'Enero Ene_Pebrero Peb_Marso Mar_Abril Abr_Mayo May_Hunyo Hun_Hulyo Hul_Agosto Ago_Setyembre Set_Oktubre Okt_Nobyembre Nob_Disyembre Dis'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Linggo Lin Li_Lunes Lun Lu_Martes Mar Ma_Miyerkules Miy Mi_Huwebes Huw Hu_Biyernes Biy Bi_Sabado Sab Sab'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'ilang segundo', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'isang minuto',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'isang minuto',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuto',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuto', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'isang oras',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'isang oras',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 oras',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 oras',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 oras',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'isang araw',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'isang araw',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 araw',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'isang araw',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 araw',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 araw',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'isang buwan',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'isang buwan',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'isang buwan',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 buwan',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 buwan',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 buwan',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'isang buwan',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 buwan',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'isang taon',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 taon',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'isang taon',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 taon',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'sa loob ng ilang segundo', 'prefix');
        assert.equal(moment(0).from(30000), 'ilang segundo ang nakalipas', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'sa loob ng ilang segundo', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'sa loob ng 5 araw', 'in 5 days');
    });

    test('same day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Ngayon sa 02:00',    'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Ngayon sa 02:25',    'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Ngayon sa 03:00',    'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Bukas sa 02:00',     'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Ngayon sa 01:00',    'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Kahapon sa 02:00',   'yesterday at the same time');
    });

    test('same next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [sa] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [sa] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [sa] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('same last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [huling linggo] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [huling linggo] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [huling linggo] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('same all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'), '1 01 1', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '1 01 1', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('tr');

    test('parse', function (assert) {
        var tests = 'Ocak Oca_≈ûubat ≈ûub_Mart Mar_Nisan Nis_Mayƒ±s May_Haziran Haz_Temmuz Tem_Aƒüustos Aƒüu_Eyl√ºl Eyl_Ekim Eki_Kasƒ±m Kas_Aralƒ±k Ara'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Pazar, ≈ûubat 14\'√ºnc√º 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Paz, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2\'nci 02 ≈ûubat ≈ûub'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14\'√ºnc√º 14'],
                ['d do dddd ddd dd',                   '0 0\'ƒ±ncƒ± Pazar Paz Pz'],
                ['DDD DDDo DDDD',                      '45 45\'inci 045'],
                ['w wo ww',                            '7 7\'nci 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[yƒ±lƒ±n] DDDo [g√ºn√º]',                'yƒ±lƒ±n 45\'inci g√ºn√º'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14 ≈ûubat 2010'],
                ['LLL',                                '14 ≈ûubat 2010 15:25'],
                ['LLLL',                               'Pazar, 14 ≈ûubat 2010 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14 ≈ûub 2010'],
                ['lll',                                '14 ≈ûub 2010 15:25'],
                ['llll',                               'Paz, 14 ≈ûub 2010 15:25']
            ],
            DDDo = [
                [359, '360\'ƒ±ncƒ±'],
                [199, '200\'√ºnc√º'],
                [149, '150\'nci']
            ],
            dt = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            DDDoDt,
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(dt.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
        for (i = 0; i < DDDo.length; i++) {
            DDDoDt = moment([2010]);
            assert.equal(DDDoDt.add(DDDo[i][0], 'days').format('DDDo'), DDDo[i][1], DDDo[i][0] + ' ---> ' + DDDo[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1\'inci', '1st');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2\'nci', '2nd');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3\'√ºnc√º', '3rd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4\'√ºnc√º', '4th');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5\'inci', '5th');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6\'ncƒ±', '6th');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7\'nci', '7th');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8\'inci', '8th');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9\'uncu', '9th');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10\'uncu', '10th');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11\'inci', '11th');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12\'nci', '12th');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13\'√ºnc√º', '13th');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14\'√ºnc√º', '14th');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15\'inci', '15th');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16\'ncƒ±', '16th');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17\'nci', '17th');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18\'inci', '18th');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19\'uncu', '19th');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20\'nci', '20th');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21\'inci', '21th');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22\'nci', '22th');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23\'√ºnc√º', '23th');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24\'√ºnc√º', '24th');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25\'inci', '25th');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26\'ncƒ±', '26th');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27\'nci', '27th');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28\'inci', '28th');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29\'uncu', '29th');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30\'uncu', '30th');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31\'inci', '31st');
    });

    test('format month', function (assert) {
        var expected = 'Ocak Oca_≈ûubat ≈ûub_Mart Mar_Nisan Nis_Mayƒ±s May_Haziran Haz_Temmuz Tem_Aƒüustos Aƒüu_Eyl√ºl Eyl_Ekim Eki_Kasƒ±m Kas_Aralƒ±k Ara'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Pazar Paz Pz_Pazartesi Pts Pt_Salƒ± Sal Sa_√áar≈üamba √áar √áa_Per≈üembe Per Pe_Cuma Cum Cu_Cumartesi Cts Ct'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'birka√ß saniye', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'bir dakika',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'bir dakika',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 dakika',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 dakika',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'bir saat',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'bir saat',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 saat',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 saat',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 saat',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'bir g√ºn',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'bir g√ºn',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 g√ºn',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'bir g√ºn',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 g√ºn',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 g√ºn',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'bir ay',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'bir ay',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'bir ay',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ay',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ay',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ay',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'bir ay',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ay',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'bir yƒ±l',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 yƒ±l',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'bir yƒ±l',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 yƒ±l',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'birka√ß saniye sonra',  'prefix');
        assert.equal(moment(0).from(30000), 'birka√ß saniye √∂nce', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'birka√ß saniye √∂nce',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'birka√ß saniye sonra', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5 g√ºn sonra', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'bug√ºn saat 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'bug√ºn saat 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'bug√ºn saat 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'yarƒ±n saat 02:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'bug√ºn saat 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'd√ºn 02:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[haftaya] dddd [saat] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[haftaya] dddd [saat] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[haftaya] dddd [saat] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[ge√ßen hafta] dddd [saat] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[ge√ßen hafta] dddd [saat] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[ge√ßen hafta] dddd [saat] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1\'inci', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1\'inci', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2\'nci', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2\'nci', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3\'√ºnc√º', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('tzm-latn');

    test('parse', function (assert) {
        var tests = 'innayr innayr_brÀ§ayrÀ§ brÀ§ayrÀ§_marÀ§sÀ§ marÀ§sÀ§_ibrir ibrir_mayyw mayyw_ywnyw ywnyw_ywlywz ywlywz_…£w≈°t …£w≈°t_≈°wtanbir ≈°wtanbir_ktÀ§wbrÀ§ ktÀ§wbrÀ§_nwwanbir nwwanbir_dwjnbir dwjnbir'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'asamas, brÀ§ayrÀ§ 14 2010, 3:25:50 pm'],
                ['ddd, hA',                            'asamas, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2 02 brÀ§ayrÀ§ brÀ§ayrÀ§'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 asamas asamas asamas'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '8 8 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 brÀ§ayrÀ§ 2010'],
                ['LLL',                                '14 brÀ§ayrÀ§ 2010 15:25'],
                ['LLLL',                               'asamas 14 brÀ§ayrÀ§ 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 brÀ§ayrÀ§ 2010'],
                ['lll',                                '14 brÀ§ayrÀ§ 2010 15:25'],
                ['llll',                               'asamas 14 brÀ§ayrÀ§ 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = 'innayr innayr_brÀ§ayrÀ§ brÀ§ayrÀ§_marÀ§sÀ§ marÀ§sÀ§_ibrir ibrir_mayyw mayyw_ywnyw ywnyw_ywlywz ywlywz_…£w≈°t …£w≈°t_≈°wtanbir ≈°wtanbir_ktÀ§wbrÀ§ ktÀ§wbrÀ§_nwwanbir nwwanbir_dwjnbir dwjnbir'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'asamas asamas asamas_aynas aynas aynas_asinas asinas asinas_akras akras akras_akwas akwas akwas_asimwas asimwas asimwas_asi·∏çyas asi·∏çyas asi·∏çyas'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'imik', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'minu·∏ç',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'minu·∏ç',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minu·∏ç',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minu·∏ç',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'sa…õa',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'sa…õa',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 tassa…õin',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 tassa…õin',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 tassa…õin',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ass',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ass',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ossan',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ass',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ossan',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ossan',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ayowr',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ayowr',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ayowr',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 iyyirn',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 iyyirn',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 iyyirn',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ayowr',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 iyyirn',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'asgas',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 isgasn',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'asgas',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 isgasn',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'dadkh s yan imik',  'prefix');
        assert.equal(moment(0).from(30000), 'yan imik', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'yan imik',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'dadkh s yan imik', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'dadkh s yan 5 ossan', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'asdkh g 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'asdkh g 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'asdkh g 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'aska g 02:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'asdkh g 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'assant g 02:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [g] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [g] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [g] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [g] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [g] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [g] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 31]).week(), 1, 'Dec 31 2011 should be week 1');
        assert.equal(moment([2012,  0,  6]).week(), 1, 'Jan  6 2012 should be week 1');
        assert.equal(moment([2012,  0,  7]).week(), 2, 'Jan  7 2012 should be week 2');
        assert.equal(moment([2012,  0, 13]).week(), 2, 'Jan 13 2012 should be week 2');
        assert.equal(moment([2012,  0, 14]).week(), 3, 'Jan 14 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 30]).week(), 1, 'Dec 30 2006 should be week 1');
        assert.equal(moment([2007,  0,  5]).week(), 1, 'Jan  5 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 2, 'Jan  6 2007 should be week 2');
        assert.equal(moment([2007,  0, 12]).week(), 2, 'Jan 12 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 3, 'Jan 13 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 1, 'Dec 29 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  4]).week(), 1, 'Jan  4 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 2, 'Jan  5 2008 should be week 2');
        assert.equal(moment([2008,  0, 11]).week(), 2, 'Jan 11 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 3, 'Jan 12 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 28]).week(), 1, 'Dec 28 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  3]).week(), 1, 'Jan  3 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 2, 'Jan  4 2003 should be week 2');
        assert.equal(moment([2003,  0, 10]).week(), 2, 'Jan 10 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 3, 'Jan 11 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 27]).week(), 1, 'Dec 27 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  2]).week(), 1, 'Jan  2 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 2, 'Jan  3 2009 should be week 2');
        assert.equal(moment([2009,  0,  9]).week(), 2, 'Jan  9 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 3, 'Jan 10 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 26]).week(), 1, 'Dec 26 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 2, 'Jan  2 2010 should be week 2');
        assert.equal(moment([2010,  0,  8]).week(), 2, 'Jan  8 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 3, 'Jan  9 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2011, 0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011, 0,  7]).week(), 1, 'Jan  7 2011 should be week 1');
        assert.equal(moment([2011, 0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011, 0, 14]).week(), 2, 'Jan 14 2011 should be week 2');
        assert.equal(moment([2011, 0, 15]).week(), 3, 'Jan 15 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 31]).format('w ww wo'), '1 01 1', 'Dec 31 2011 should be week 1');
        assert.equal(moment([2012,  0,  6]).format('w ww wo'), '1 01 1', 'Jan  6 2012 should be week 1');
        assert.equal(moment([2012,  0,  7]).format('w ww wo'), '2 02 2', 'Jan  7 2012 should be week 2');
        assert.equal(moment([2012,  0, 13]).format('w ww wo'), '2 02 2', 'Jan 13 2012 should be week 2');
        assert.equal(moment([2012,  0, 14]).format('w ww wo'), '3 03 3', 'Jan 14 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('tzm');

    test('parse', function (assert) {
        var tests = '‚µâ‚µè‚µè‚¥∞‚µ¢‚µî ‚µâ‚µè‚µè‚¥∞‚µ¢‚µî_‚¥±‚µï‚¥∞‚µ¢‚µï ‚¥±‚µï‚¥∞‚µ¢‚µï_‚µé‚¥∞‚µï‚µö ‚µé‚¥∞‚µï‚µö_‚µâ‚¥±‚µî‚µâ‚µî ‚µâ‚¥±‚µî‚µâ‚µî_‚µé‚¥∞‚µ¢‚µ¢‚µì ‚µé‚¥∞‚µ¢‚µ¢‚µì_‚µ¢‚µì‚µè‚µ¢‚µì ‚µ¢‚µì‚µè‚µ¢‚µì_‚µ¢‚µì‚µç‚µ¢‚µì‚µ£ ‚µ¢‚µì‚µç‚µ¢‚µì‚µ£_‚µñ‚µì‚µõ‚µú ‚µñ‚µì‚µõ‚µú_‚µõ‚µì‚µú‚¥∞‚µè‚¥±‚µâ‚µî ‚µõ‚µì‚µú‚¥∞‚µè‚¥±‚µâ‚µî_‚¥Ω‚µü‚µì‚¥±‚µï ‚¥Ω‚µü‚µì‚¥±‚µï_‚µè‚µì‚µ°‚¥∞‚µè‚¥±‚µâ‚µî ‚µè‚µì‚µ°‚¥∞‚µè‚¥±‚µâ‚µî_‚¥∑‚µì‚µä‚µè‚¥±‚µâ‚µî ‚¥∑‚µì‚µä‚µè‚¥±‚µâ‚µî'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      '‚¥∞‚µô‚¥∞‚µé‚¥∞‚µô, ‚¥±‚µï‚¥∞‚µ¢‚µï 14 2010, 3:25:50 pm'],
                ['ddd, hA',                            '‚¥∞‚µô‚¥∞‚µé‚¥∞‚µô, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2 02 ‚¥±‚µï‚¥∞‚µ¢‚µï ‚¥±‚µï‚¥∞‚µ¢‚µï'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 ‚¥∞‚µô‚¥∞‚µé‚¥∞‚µô ‚¥∞‚µô‚¥∞‚µé‚¥∞‚µô ‚¥∞‚µô‚¥∞‚µé‚¥∞‚µô'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '8 8 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 ‚¥±‚µï‚¥∞‚µ¢‚µï 2010'],
                ['LLL',                                '14 ‚¥±‚µï‚¥∞‚µ¢‚µï 2010 15:25'],
                ['LLLL',                               '‚¥∞‚µô‚¥∞‚µé‚¥∞‚µô 14 ‚¥±‚µï‚¥∞‚µ¢‚µï 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 ‚¥±‚µï‚¥∞‚µ¢‚µï 2010'],
                ['lll',                                '14 ‚¥±‚µï‚¥∞‚µ¢‚µï 2010 15:25'],
                ['llll',                               '‚¥∞‚µô‚¥∞‚µé‚¥∞‚µô 14 ‚¥±‚µï‚¥∞‚µ¢‚µï 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = '‚µâ‚µè‚µè‚¥∞‚µ¢‚µî ‚µâ‚µè‚µè‚¥∞‚µ¢‚µî_‚¥±‚µï‚¥∞‚µ¢‚µï ‚¥±‚µï‚¥∞‚µ¢‚µï_‚µé‚¥∞‚µï‚µö ‚µé‚¥∞‚µï‚µö_‚µâ‚¥±‚µî‚µâ‚µî ‚µâ‚¥±‚µî‚µâ‚µî_‚µé‚¥∞‚µ¢‚µ¢‚µì ‚µé‚¥∞‚µ¢‚µ¢‚µì_‚µ¢‚µì‚µè‚µ¢‚µì ‚µ¢‚µì‚µè‚µ¢‚µì_‚µ¢‚µì‚µç‚µ¢‚µì‚µ£ ‚µ¢‚µì‚µç‚µ¢‚µì‚µ£_‚µñ‚µì‚µõ‚µú ‚µñ‚µì‚µõ‚µú_‚µõ‚µì‚µú‚¥∞‚µè‚¥±‚µâ‚µî ‚µõ‚µì‚µú‚¥∞‚µè‚¥±‚µâ‚µî_‚¥Ω‚µü‚µì‚¥±‚µï ‚¥Ω‚µü‚µì‚¥±‚µï_‚µè‚µì‚µ°‚¥∞‚µè‚¥±‚µâ‚µî ‚µè‚µì‚µ°‚¥∞‚µè‚¥±‚µâ‚µî_‚¥∑‚µì‚µä‚µè‚¥±‚µâ‚µî ‚¥∑‚µì‚µä‚µè‚¥±‚µâ‚µî'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '‚¥∞‚µô‚¥∞‚µé‚¥∞‚µô ‚¥∞‚µô‚¥∞‚µé‚¥∞‚µô ‚¥∞‚µô‚¥∞‚µé‚¥∞‚µô_‚¥∞‚µ¢‚µè‚¥∞‚µô ‚¥∞‚µ¢‚µè‚¥∞‚µô ‚¥∞‚µ¢‚µè‚¥∞‚µô_‚¥∞‚µô‚µâ‚µè‚¥∞‚µô ‚¥∞‚µô‚µâ‚µè‚¥∞‚µô ‚¥∞‚µô‚µâ‚µè‚¥∞‚µô_‚¥∞‚¥Ω‚µî‚¥∞‚µô ‚¥∞‚¥Ω‚µî‚¥∞‚µô ‚¥∞‚¥Ω‚µî‚¥∞‚µô_‚¥∞‚¥Ω‚µ°‚¥∞‚µô ‚¥∞‚¥Ω‚µ°‚¥∞‚µô ‚¥∞‚¥Ω‚µ°‚¥∞‚µô_‚¥∞‚µô‚µâ‚µé‚µ°‚¥∞‚µô ‚¥∞‚µô‚µâ‚µé‚µ°‚¥∞‚µô ‚¥∞‚µô‚µâ‚µé‚µ°‚¥∞‚µô_‚¥∞‚µô‚µâ‚¥π‚µ¢‚¥∞‚µô ‚¥∞‚µô‚µâ‚¥π‚µ¢‚¥∞‚µô ‚¥∞‚µô‚µâ‚¥π‚µ¢‚¥∞‚µô'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '‚µâ‚µé‚µâ‚¥Ω', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '‚µé‚µâ‚µè‚µì‚¥∫',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '‚µé‚µâ‚µè‚µì‚¥∫',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ‚µé‚µâ‚µè‚µì‚¥∫',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ‚µé‚µâ‚µè‚µì‚¥∫',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '‚µô‚¥∞‚µÑ‚¥∞',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '‚µô‚¥∞‚µÑ‚¥∞',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ‚µú‚¥∞‚µô‚µô‚¥∞‚µÑ‚µâ‚µè',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ‚µú‚¥∞‚µô‚µô‚¥∞‚µÑ‚µâ‚µè',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ‚µú‚¥∞‚µô‚µô‚¥∞‚µÑ‚µâ‚µè',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '‚¥∞‚µô‚µô',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '‚¥∞‚µô‚µô',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 o‚µô‚µô‚¥∞‚µè',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '‚¥∞‚µô‚µô',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 o‚µô‚µô‚¥∞‚µè',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 o‚µô‚µô‚¥∞‚µè',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '‚¥∞‚µ¢o‚µì‚µî',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '‚¥∞‚µ¢o‚µì‚µî',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '‚¥∞‚µ¢o‚µì‚µî',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ‚µâ‚µ¢‚µ¢‚µâ‚µî‚µè',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ‚µâ‚µ¢‚µ¢‚µâ‚µî‚µè',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ‚µâ‚µ¢‚µ¢‚µâ‚µî‚µè',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '‚¥∞‚µ¢o‚µì‚µî',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ‚µâ‚µ¢‚µ¢‚µâ‚µî‚µè',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '‚¥∞‚µô‚¥≥‚¥∞‚µô',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ‚µâ‚µô‚¥≥‚¥∞‚µô‚µè',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '‚¥∞‚µô‚¥≥‚¥∞‚µô',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ‚µâ‚µô‚¥≥‚¥∞‚µô‚µè',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '‚¥∑‚¥∞‚¥∑‚µÖ ‚µô ‚µ¢‚¥∞‚µè ‚µâ‚µé‚µâ‚¥Ω',  'prefix');
        assert.equal(moment(0).from(30000), '‚µ¢‚¥∞‚µè ‚µâ‚µé‚µâ‚¥Ω', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '‚µ¢‚¥∞‚µè ‚µâ‚µé‚µâ‚¥Ω',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '‚¥∑‚¥∞‚¥∑‚µÖ ‚µô ‚µ¢‚¥∞‚µè ‚µâ‚µé‚µâ‚¥Ω', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '‚¥∑‚¥∞‚¥∑‚µÖ ‚µô ‚µ¢‚¥∞‚µè 5 o‚µô‚µô‚¥∞‚µè', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '‚¥∞‚µô‚¥∑‚µÖ ‚¥¥ 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '‚¥∞‚µô‚¥∑‚µÖ ‚¥¥ 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '‚¥∞‚µô‚¥∑‚µÖ ‚¥¥ 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '‚¥∞‚µô‚¥Ω‚¥∞ ‚¥¥ 02:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '‚¥∞‚µô‚¥∑‚µÖ ‚¥¥ 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '‚¥∞‚µö‚¥∞‚µè‚µú ‚¥¥ 02:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [‚¥¥] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [‚¥¥] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [‚¥¥] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [‚¥¥] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [‚¥¥] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [‚¥¥] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 31]).week(), 1, 'Dec 31 2011 should be week 1');
        assert.equal(moment([2012,  0,  6]).week(), 1, 'Jan  6 2012 should be week 1');
        assert.equal(moment([2012,  0,  7]).week(), 2, 'Jan  7 2012 should be week 2');
        assert.equal(moment([2012,  0, 13]).week(), 2, 'Jan 13 2012 should be week 2');
        assert.equal(moment([2012,  0, 14]).week(), 3, 'Jan 14 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 30]).week(), 1, 'Dec 30 2006 should be week 1');
        assert.equal(moment([2007,  0,  5]).week(), 1, 'Jan  5 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 2, 'Jan  6 2007 should be week 2');
        assert.equal(moment([2007,  0, 12]).week(), 2, 'Jan 12 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 3, 'Jan 13 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 1, 'Dec 29 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  4]).week(), 1, 'Jan  4 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 2, 'Jan  5 2008 should be week 2');
        assert.equal(moment([2008,  0, 11]).week(), 2, 'Jan 11 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 3, 'Jan 12 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 28]).week(), 1, 'Dec 28 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  3]).week(), 1, 'Jan  3 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 2, 'Jan  4 2003 should be week 2');
        assert.equal(moment([2003,  0, 10]).week(), 2, 'Jan 10 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 3, 'Jan 11 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 27]).week(), 1, 'Dec 27 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  2]).week(), 1, 'Jan  2 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 2, 'Jan  3 2009 should be week 2');
        assert.equal(moment([2009,  0,  9]).week(), 2, 'Jan  9 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 3, 'Jan 10 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 26]).week(), 1, 'Dec 26 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 2, 'Jan  2 2010 should be week 2');
        assert.equal(moment([2010,  0,  8]).week(), 2, 'Jan  8 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 3, 'Jan  9 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2011, 0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011, 0,  7]).week(), 1, 'Jan  7 2011 should be week 1');
        assert.equal(moment([2011, 0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011, 0, 14]).week(), 2, 'Jan 14 2011 should be week 2');
        assert.equal(moment([2011, 0, 15]).week(), 3, 'Jan 15 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 31]).format('w ww wo'), '1 01 1', 'Dec 31 2011 should be week 1');
        assert.equal(moment([2012,  0,  6]).format('w ww wo'), '1 01 1', 'Jan  6 2012 should be week 1');
        assert.equal(moment([2012,  0,  7]).format('w ww wo'), '2 02 2', 'Jan  7 2012 should be week 2');
        assert.equal(moment([2012,  0, 13]).format('w ww wo'), '2 02 2', 'Jan 13 2012 should be week 2');
        assert.equal(moment([2012,  0, 14]).format('w ww wo'), '3 03 3', 'Jan 14 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('uk');

    test('parse', function (assert) {
        var tests = '—Å—ñ—á–µ–Ω—å —Å—ñ—á_–ª—é—Ç–∏–π –ª—é—Ç_–±–µ—Ä–µ–∑–µ–Ω—å –±–µ—Ä_–∫–≤—ñ—Ç–µ–Ω—å –∫–≤—ñ—Ç_—Ç—Ä–∞–≤–µ–Ω—å —Ç—Ä–∞–≤_—á–µ—Ä–≤–µ–Ω—å —á–µ—Ä–≤_–ª–∏–ø–µ–Ω—å –ª–∏–ø_—Å–µ—Ä–ø–µ–Ω—å —Å–µ—Ä–ø_–≤–µ—Ä–µ—Å–µ–Ω—å –≤–µ—Ä_–∂–æ–≤—Ç–µ–Ω—å –∂–æ–≤—Ç_–ª–∏—Å—Ç–æ–ø–∞–¥ –ª–∏—Å—Ç_–≥—Ä—É–¥–µ–Ω—å –≥—Ä—É–¥'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, HH:mm:ss',       '–Ω–µ–¥—ñ–ª—è, 14-–≥–æ –ª—é—Ç–æ–≥–æ 2010, 15:25:50'],
                ['ddd, h A',                           '–Ω–¥, 3 –¥–Ω—è'],
                ['M Mo MM MMMM MMM',                   '2 2-–π 02 –ª—é—Ç–∏–π –ª—é—Ç'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14-–≥–æ 14'],
                ['d do dddd ddd dd',                   '0 0-–π –Ω–µ–¥—ñ–ª—è –Ω–¥ –Ω–¥'],
                ['DDD DDDo DDDD',                      '45 45-–π 045'],
                ['w wo ww',                            '7 7-–π 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                '–¥–Ω—è –¥–Ω—è'],
                ['DDDo [–¥–µ–Ω—å —Ä–æ–∫—É]',                  '45-–π –¥–µ–Ω—å —Ä–æ–∫—É'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14 –ª—é—Ç–æ–≥–æ 2010 —Ä.'],
                ['LLL',                                '14 –ª—é—Ç–æ–≥–æ 2010 —Ä., 15:25'],
                ['LLLL',                               '–Ω–µ–¥—ñ–ª—è, 14 –ª—é—Ç–æ–≥–æ 2010 —Ä., 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format meridiem', function (assert) {
        assert.equal(moment([2012, 11, 28, 0, 0]).format('A'), '–Ω–æ—á—ñ', 'night');
        assert.equal(moment([2012, 11, 28, 3, 59]).format('A'), '–Ω–æ—á—ñ', 'night');
        assert.equal(moment([2012, 11, 28, 4, 0]).format('A'), '—Ä–∞–Ω–∫—É', 'morning');
        assert.equal(moment([2012, 11, 28, 11, 59]).format('A'), '—Ä–∞–Ω–∫—É', 'morning');
        assert.equal(moment([2012, 11, 28, 12, 0]).format('A'), '–¥–Ω—è', 'afternoon');
        assert.equal(moment([2012, 11, 28, 16, 59]).format('A'), '–¥–Ω—è', 'afternoon');
        assert.equal(moment([2012, 11, 28, 17, 0]).format('A'), '–≤–µ—á–æ—Ä–∞', 'evening');
        assert.equal(moment([2012, 11, 28, 23, 59]).format('A'), '–≤–µ—á–æ—Ä–∞', 'evening');
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-–π', '1-–π');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-–π', '2-–π');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-–π', '3-–π');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-–π', '4-–π');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-–π', '5-–π');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-–π', '6-–π');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-–π', '7-–π');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-–π', '8-–π');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-–π', '9-–π');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-–π', '10-–π');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-–π', '11-–π');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-–π', '12-–π');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-–π', '13-–π');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-–π', '14-–π');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-–π', '15-–π');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-–π', '16-–π');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-–π', '17-–π');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-–π', '18-–π');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-–π', '19-–π');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-–π', '20-–π');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-–π', '21-–π');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-–π', '22-–π');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-–π', '23-–π');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-–π', '24-–π');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-–π', '25-–π');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-–π', '26-–π');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-–π', '27-–π');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-–π', '28-–π');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-–π', '29-–π');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-–π', '30-–π');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-–π', '31-–π');
    });

    test('format month', function (assert) {
        var expected = '—Å—ñ—á–µ–Ω—å —Å—ñ—á_–ª—é—Ç–∏–π –ª—é—Ç_–±–µ—Ä–µ–∑–µ–Ω—å –±–µ—Ä_–∫–≤—ñ—Ç–µ–Ω—å –∫–≤—ñ—Ç_—Ç—Ä–∞–≤–µ–Ω—å —Ç—Ä–∞–≤_—á–µ—Ä–≤–µ–Ω—å —á–µ—Ä–≤_–ª–∏–ø–µ–Ω—å –ª–∏–ø_—Å–µ—Ä–ø–µ–Ω—å —Å–µ—Ä–ø_–≤–µ—Ä–µ—Å–µ–Ω—å –≤–µ—Ä_–∂–æ–≤—Ç–µ–Ω—å –∂–æ–≤—Ç_–ª–∏—Å—Ç–æ–ø–∞–¥ –ª–∏—Å—Ç_–≥—Ä—É–¥–µ–Ω—å –≥—Ä—É–¥'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format month case', function (assert) {
        var months = {
            'nominative': '—Å—ñ—á–µ–Ω—å_–ª—é—Ç–∏–π_–±–µ—Ä–µ–∑–µ–Ω—å_–∫–≤—ñ—Ç–µ–Ω—å_—Ç—Ä–∞–≤–µ–Ω—å_—á–µ—Ä–≤–µ–Ω—å_–ª–∏–ø–µ–Ω—å_—Å–µ—Ä–ø–µ–Ω—å_–≤–µ—Ä–µ—Å–µ–Ω—å_–∂–æ–≤—Ç–µ–Ω—å_–ª–∏—Å—Ç–æ–ø–∞–¥_–≥—Ä—É–¥–µ–Ω—å'.split('_'),
            'accusative': '—Å—ñ—á–Ω—è_–ª—é—Ç–æ–≥–æ_–±–µ—Ä–µ–∑–Ω—è_–∫–≤—ñ—Ç–Ω—è_—Ç—Ä–∞–≤–Ω—è_—á–µ—Ä–≤–Ω—è_–ª–∏–ø–Ω—è_—Å–µ—Ä–ø–Ω—è_–≤–µ—Ä–µ—Å–Ω—è_–∂–æ–≤—Ç–Ω—è_–ª–∏—Å—Ç–æ–ø–∞–¥–∞_–≥—Ä—É–¥–Ω—è'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2011, i, 1]).format('D MMMM'), '1 ' + months.accusative[i], '1 ' + months.accusative[i]);
            assert.equal(moment([2011, i, 1]).format('MMMM'), months.nominative[i], '1 ' + months.nominative[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '–Ω–µ–¥—ñ–ª—è –Ω–¥ –Ω–¥_–ø–æ–Ω–µ–¥—ñ–ª–æ–∫ –ø–Ω –ø–Ω_–≤—ñ–≤—Ç–æ—Ä–æ–∫ –≤—Ç –≤—Ç_—Å–µ—Ä–µ–¥–∞ —Å—Ä —Å—Ä_—á–µ—Ç–≤–µ—Ä —á—Ç —á—Ç_–ø‚Äô—è—Ç–Ω–∏—Ü—è –ø—Ç –ø—Ç_—Å—É–±–æ—Ç–∞ —Å–± —Å–±'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '–¥–µ–∫—ñ–ª—å–∫–∞ —Å–µ–∫—É–Ω–¥',    '44 seconds = seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '—Ö–≤–∏–ª–∏–Ω–∞',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '—Ö–≤–∏–ª–∏–Ω–∞',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 —Ö–≤–∏–ª–∏–Ω–∏',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 —Ö–≤–∏–ª–∏–Ω–∏', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '–≥–æ–¥–∏–Ω—É',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '–≥–æ–¥–∏–Ω—É',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 –≥–æ–¥–∏–Ω–∏',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 –≥–æ–¥–∏–Ω',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 –≥–æ–¥–∏–Ω–∞',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '–¥–µ–Ω—å',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '–¥–µ–Ω—å',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 –¥–Ω—ñ',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '–¥–µ–Ω—å',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 –¥–Ω—ñ–≤',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 11}), true),  '11 –¥–Ω—ñ–≤',     '11 days = 11 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 21}), true),  '21 –¥–µ–Ω—å',     '21 days = 21 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 –¥–Ω—ñ–≤',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '–º—ñ—Å—è—Ü—å',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '–º—ñ—Å—è—Ü—å',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '–º—ñ—Å—è—Ü—å',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 –º—ñ—Å—è—Ü—ñ',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 –º—ñ—Å—è—Ü—ñ',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 –º—ñ—Å—è—Ü—ñ',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '–º—ñ—Å—è—Ü—å',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 –º—ñ—Å—è—Ü—ñ–≤',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '—Ä—ñ–∫',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 —Ä–æ–∫–∏',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '—Ä—ñ–∫',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 —Ä–æ–∫—ñ–≤',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '–∑–∞ –¥–µ–∫—ñ–ª—å–∫–∞ —Å–µ–∫—É–Ω–¥', 'prefix');
        assert.equal(moment(0).from(30000), '–¥–µ–∫—ñ–ª—å–∫–∞ —Å–µ–∫—É–Ω–¥ —Ç–æ–º—É', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '–∑–∞ –¥–µ–∫—ñ–ª—å–∫–∞ —Å–µ–∫—É–Ω–¥', 'in seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '–∑–∞ 5 –¥–Ω—ñ–≤', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '–°—å–æ–≥–æ–¥–Ω—ñ –æ 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '–°—å–æ–≥–æ–¥–Ω—ñ –æ 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '–°—å–æ–≥–æ–¥–Ω—ñ –æ 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '–ó–∞–≤—Ç—Ä–∞ –æ 02:00',      'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '–°—å–æ–≥–æ–¥–Ω—ñ –æ 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '–í—á–æ—Ä–∞ –æ 02:00',       'yesterday at the same time');
        // A special case for Ukrainian since 11 hours have different preposition
        assert.equal(moment(a).add({h: 9}).calendar(),  '–°—å–æ–≥–æ–¥–Ω—ñ –æ–± 11:00',       'same day at 11 o\'clock');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[–£] dddd [–æ' + (m.hours() === 11 ? '–±' : '') + '] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[–£] dddd [–æ] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[–£] dddd [–æ] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
            case 3:
            case 5:
            case 6:
                return '[–ú–∏–Ω—É–ª–æ—ó] dddd [–æ' + (d.hours() === 11 ? '–±' : '') + '] LT';
            case 1:
            case 2:
            case 4:
                return '[–ú–∏–Ω—É–ª–æ–≥–æ] dddd [–æ' + (d.hours() === 11 ? '–±' : '') + '] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-–π', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-–π', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-–π', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-–π', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-–π', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('uz');

    test('parse', function (assert) {
        var tests = '—è–Ω–≤–∞—Ä—å —è–Ω–≤_—Ñ–µ–≤—Ä–∞–ª—å —Ñ–µ–≤_–º–∞—Ä—Ç –º–∞—Ä_–∞–ø—Ä–µ–ª—å –∞–ø—Ä_–º–∞–π –º–∞–π_–∏—é–Ω—å –∏—é–Ω—å_–∏—é–ª—å –∏—é–ª—å_–∞–≤–≥—É—Å—Ç –∞–≤–≥_—Å–µ–Ω—Ç—è–±—Ä—å —Å–µ–Ω_–æ–∫—Ç—è–±—Ä—å –æ–∫—Ç_–Ω–æ—è–±—Ä—å –Ω–æ—è_–¥–µ–∫–∞–±—Ä—å –¥–µ–∫'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do-MMMM YYYY, h:mm:ss',        '–Ø–∫—à–∞–Ω–±–∞, 14-—Ñ–µ–≤—Ä–∞–ª—å 2010, 3:25:50'],
                ['ddd, h:mm',                          '–Ø–∫—à, 3:25'],
                ['M Mo MM MMMM MMM',                   '2 2 02 —Ñ–µ–≤—Ä–∞–ª—å —Ñ–µ–≤'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 –Ø–∫—à–∞–Ω–±–∞ –Ø–∫—à –Ø–∫'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '7 7 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[–π–∏–ª–Ω–∏–Ω–≥] DDDo-[–∫—É–Ω–∏]',             '–π–∏–ª–Ω–∏–Ω–≥ 45-–∫—É–Ω–∏'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 —Ñ–µ–≤—Ä–∞–ª—å 2010'],
                ['LLL',                                '14 —Ñ–µ–≤—Ä–∞–ª—å 2010 15:25'],
                ['LLLL',                               '14 —Ñ–µ–≤—Ä–∞–ª—å 2010, –Ø–∫—à–∞–Ω–±–∞ 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 —Ñ–µ–≤ 2010'],
                ['lll',                                '14 —Ñ–µ–≤ 2010 15:25'],
                ['llll',                               '14 —Ñ–µ–≤ 2010, –Ø–∫—à 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = '—è–Ω–≤–∞—Ä—å —è–Ω–≤_—Ñ–µ–≤—Ä–∞–ª—å —Ñ–µ–≤_–º–∞—Ä—Ç –º–∞—Ä_–∞–ø—Ä–µ–ª—å –∞–ø—Ä_–º–∞–π –º–∞–π_–∏—é–Ω—å –∏—é–Ω_–∏—é–ª—å –∏—é–ª_–∞–≤–≥—É—Å—Ç –∞–≤–≥_—Å–µ–Ω—Ç—è–±—Ä—å —Å–µ–Ω_–æ–∫—Ç—è–±—Ä—å –æ–∫—Ç_–Ω–æ—è–±—Ä—å –Ω–æ—è_–¥–µ–∫–∞–±—Ä—å –¥–µ–∫'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '–Ø–∫—à–∞–Ω–±–∞ –Ø–∫—à –Ø–∫_–î—É—à–∞–Ω–±–∞ –î—É—à –î—É_–°–µ—à–∞–Ω–±–∞ –°–µ—à –°–µ_–ß–æ—Ä—à–∞–Ω–±–∞ –ß–æ—Ä –ß–æ_–ü–∞–π—à–∞–Ω–±–∞ –ü–∞–π –ü–∞_–ñ—É–º–∞ –ñ—É–º –ñ—É_–®–∞–Ω–±–∞ –®–∞–Ω –®–∞'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '—Ñ—É—Ä—Å–∞—Ç', '44 —Å–µ–∫—É–Ω–¥ = —Ñ—É—Ä—Å–∞—Ç');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '–±–∏—Ä –¥–∞–∫–∏–∫–∞',      '45 —Å–µ–∫—É–Ω–¥ = –±–∏—Ä –¥–∞–∫–∏–∫–∞');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '–±–∏—Ä –¥–∞–∫–∏–∫–∞',      '89 —Å–µ–∫—É–Ω–¥ = –±–∏—Ä –¥–∞–∫–∏–∫–∞');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 –¥–∞–∫–∏–∫–∞',     '90 —Å–µ–∫—É–Ω–¥ = 2 –¥–∞–∫–∏–∫–∞');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 –¥–∞–∫–∏–∫–∞',    '44 –¥–∞–∫–∏–∫–∞ = 44 –¥–∞–∫–∏–∫–∞');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '–±–∏—Ä —Å–æ–∞—Ç',       '45 –º–∏–Ω—É—Ç = –±–∏—Ä —Å–æ–∞—Ç');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '–±–∏—Ä —Å–æ–∞—Ç',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 —Å–æ–∞—Ç',       '90 –º–∏–Ω—É—Ç = 2 —Å–æ–∞—Ç');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 —Å–æ–∞—Ç',       '5 —Å–æ–∞—Ç = 5 —Å–æ–∞—Ç');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 —Å–æ–∞—Ç',      '21 —Å–æ–∞—Ç = 21 —Å–æ–∞—Ç');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '–±–∏—Ä –∫—É–Ω',         '22 —Å–æ–∞—Ç = –±–∏—Ä –∫—É–Ω');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '–±–∏—Ä –∫—É–Ω',         '35 —Å–æ–∞—Ç = –±–∏—Ä –∫—É–Ω');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 –∫—É–Ω',        '36 —Å–æ–∞—Ç = 2 –∫—É–Ω');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '–±–∏—Ä –∫—É–Ω',         '1 –∫—É–Ω = 1 –∫—É–Ω');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 –∫—É–Ω',        '5 –∫—É–Ω = 5 –∫—É–Ω');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 –∫—É–Ω',       '25 –∫—É–Ω = 25 –∫—É–Ω');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '–±–∏—Ä –æ–π',       '26 –∫—É–Ω = –±–∏—Ä –æ–π');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '–±–∏—Ä –æ–π',       '30 –∫—É–Ω = –±–∏—Ä –æ–π');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '–±–∏—Ä –æ–π',       '45 –∫—É–Ω = –±–∏—Ä –æ–π');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 –æ–π',      '46 –∫—É–Ω = 2 –æ–π');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 –æ–π',      '75 –∫—É–Ω = 2 –æ–π');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 –æ–π',      '76 –∫—É–Ω = 3 –æ–π');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '–±–∏—Ä –æ–π',       '–±–∏—Ä –æ–π = –±–∏—Ä –æ–π');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 –æ–π',      '5 –æ–π = 5 –æ–π');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '–±–∏—Ä –π–∏–ª',        '345 –∫—É–Ω = –±–∏—Ä –π–∏–ª');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 –π–∏–ª',       '548 –∫—É–Ω = 2 –π–∏–ª');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '–±–∏—Ä –π–∏–ª',        '1 –π–∏–ª = –±–∏—Ä –π–∏–ª');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 –π–∏–ª',       '5 –π–∏–ª = 5 –π–∏–ª');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '–Ø–∫–∏–Ω —Ñ—É—Ä—Å–∞—Ç –∏—á–∏–¥–∞',  'prefix');
        assert.equal(moment(0).from(30000), '–ë–∏—Ä –Ω–µ—á–∞ —Ñ—É—Ä—Å–∞—Ç –æ–ª–¥–∏–Ω', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '–ë–∏—Ä –Ω–µ—á–∞ —Ñ—É—Ä—Å–∞—Ç –æ–ª–¥–∏–Ω',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '–Ø–∫–∏–Ω —Ñ—É—Ä—Å–∞—Ç –∏—á–∏–¥–∞', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '–Ø–∫–∏–Ω 5 –∫—É–Ω –∏—á–∏–¥–∞', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '–ë—É–≥—É–Ω —Å–æ–∞—Ç 02:00 –¥–∞',      'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '–ë—É–≥—É–Ω —Å–æ–∞—Ç 02:25 –¥–∞',      'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '–ë—É–≥—É–Ω —Å–æ–∞—Ç 03:00 –¥–∞',      'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '–≠—Ä—Ç–∞–≥–∞ 02:00 –¥–∞',   'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '–ë—É–≥—É–Ω —Å–æ–∞—Ç 01:00 –¥–∞',      'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '–ö–µ—á–∞ —Å–æ–∞—Ç 02:00 –¥–∞',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [–∫—É–Ω–∏ —Å–æ–∞—Ç] LT [–¥–∞]'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [–∫—É–Ω–∏ —Å–æ–∞—Ç] LT [–¥–∞]'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [–∫—É–Ω–∏ —Å–æ–∞—Ç] LT [–¥–∞]'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[–£—Ç–≥–∞–Ω] dddd [–∫—É–Ω–∏ —Å–æ–∞—Ç] LT [–¥–∞]'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[–£—Ç–≥–∞–Ω] dddd [–∫—É–Ω–∏ —Å–æ–∞—Ç] LT [–¥–∞]'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[–£—Ç–≥–∞–Ω] dddd [–∫—É–Ω–∏ —Å–æ–∞—Ç] LT [–¥–∞]'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 1, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  2, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  2, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  3, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  2, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  2, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  3, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  2, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  2, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  3, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '2 02 2', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '2 02 2', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '3 03 3', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '3 03 3', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('vi');

    test('parse', function (assert) {
        var i,
            tests = 'th√°ng 1,Th01_th√°ng 2,Th02_th√°ng 3,Th03_th√°ng 4,Th04_th√°ng 5,Th05_th√°ng 6,Th06_th√°ng 7,Th07_th√°ng 8,Th08_th√°ng 9,Th09_th√°ng 10,Th10_th√°ng 11,Th11_th√°ng 12,Th12'.split('_');

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + i);
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(',');
            equalTest(tests[i][0], '[th√°ng] M', i);
            equalTest(tests[i][1], '[Th]M', i);
            equalTest(tests[i][0], '[th√°ng] MM', i);
            equalTest(tests[i][1], '[Th]MM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), '[TH√ÅNG] M', i);
            equalTest(tests[i][1].toLocaleLowerCase(), '[TH]M', i);
            equalTest(tests[i][0].toLocaleUpperCase(), '[TH√ÅNG] MM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), '[TH]MM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'ch·ªß nh·∫≠t, th√°ng 2 14 2010, 3:25:50 pm'],
                ['ddd, hA',                            'CN, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2 02 th√°ng 2 Th02'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 ch·ªß nh·∫≠t CN CN'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '6 6 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[ng√†y th·ª©] DDDo [c·ªßa nƒÉm]',          'ng√†y th·ª© 45 c·ªßa nƒÉm'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 th√°ng 2 nƒÉm 2010'],
                ['LLL',                                '14 th√°ng 2 nƒÉm 2010 15:25'],
                ['LLLL',                               'ch·ªß nh·∫≠t, 14 th√°ng 2 nƒÉm 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Th02 2010'],
                ['lll',                                '14 Th02 2010 15:25'],
                ['llll',                               'CN, 14 Th02 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var i,
            expected = 'th√°ng 1,Th01_th√°ng 2,Th02_th√°ng 3,Th03_th√°ng 4,Th04_th√°ng 5,Th05_th√°ng 6,Th06_th√°ng 7,Th07_th√°ng 8,Th08_th√°ng 9,Th09_th√°ng 10,Th10_th√°ng 11,Th11_th√°ng 12,Th12'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM,MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var i,
            expected = 'ch·ªß nh·∫≠t CN CN_th·ª© hai T2 T2_th·ª© ba T3 T3_th·ª© t∆∞ T4 T4_th·ª© nƒÉm T5 T5_th·ª© s√°u T6 T6_th·ª© b·∫£y T7 T7'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'v√†i gi√¢y', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'm·ªôt ph√∫t',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'm·ªôt ph√∫t',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ph√∫t',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ph√∫t',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'm·ªôt gi·ªù',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'm·ªôt gi·ªù',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 gi·ªù',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 gi·ªù',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 gi·ªù',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'm·ªôt ng√†y',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'm·ªôt ng√†y',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ng√†y',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'm·ªôt ng√†y',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ng√†y',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ng√†y',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'm·ªôt th√°ng',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'm·ªôt th√°ng',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'm·ªôt th√°ng',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 th√°ng',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 th√°ng',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 th√°ng',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'm·ªôt th√°ng',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 th√°ng',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'm·ªôt nƒÉm',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 nƒÉm',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'm·ªôt nƒÉm',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 nƒÉm',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'v√†i gi√¢y t·ªõi',  'prefix');
        assert.equal(moment(0).from(30000), 'v√†i gi√¢y tr∆∞·ªõc', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'v√†i gi√¢y tr∆∞·ªõc',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'v√†i gi√¢y t·ªõi', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5 ng√†y t·ªõi', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'H√¥m nay l√∫c 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'H√¥m nay l√∫c 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'H√¥m nay l√∫c 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Ng√†y mai l√∫c 02:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'H√¥m nay l√∫c 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'H√¥m qua l√∫c 02:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [tu·∫ßn t·ªõi l√∫c] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [tu·∫ßn t·ªõi l√∫c] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [tu·∫ßn t·ªõi l√∫c] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [tu·∫ßn r·ªìi l√∫c] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [tu·∫ßn r·ªìi l√∫c] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [tu·∫ßn r·ªìi l√∫c] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('zh-cn');

    test('parse', function (assert) {
        var tests = '‰∏ÄÊúà 1Êúà_‰∫åÊúà 2Êúà_‰∏âÊúà 3Êúà_ÂõõÊúà 4Êúà_‰∫îÊúà 5Êúà_ÂÖ≠Êúà 6Êúà_‰∏ÉÊúà 7Êúà_ÂÖ´Êúà 8Êúà_‰πùÊúà 9Êúà_ÂçÅÊúà 10Êúà_ÂçÅ‰∏ÄÊúà 11Êúà_ÂçÅ‰∫åÊúà 12Êúà'.split('_'), i;

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, a h:mm:ss',      'ÊòüÊúüÊó•, ‰∫åÊúà 14Êó• 2010, ‰∏ãÂçà 3:25:50'],
                ['ddd, Ah',                            'Âë®Êó•, ‰∏ãÂçà3'],
                ['M Mo MM MMMM MMM',                   '2 2Êúà 02 ‰∫åÊúà 2Êúà'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14Êó• 14'],
                ['d do dddd ddd dd',                   '0 0Êó• ÊòüÊúüÊó• Âë®Êó• Êó•'],
                ['DDD DDDo DDDD',                      '45 45Êó• 045'],
                ['w wo ww',                            '6 6Âë® 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                '‰∏ãÂçà ‰∏ãÂçà'],
                ['[ËøôÂπ¥ÁöÑÁ¨¨] DDDo',                    'ËøôÂπ¥ÁöÑÁ¨¨ 45Êó•'],
                ['LTS',                                '‰∏ãÂçà3ÁÇπ25ÂàÜ50Áßí'],
                ['L',                                  '2010-02-14'],
                ['LL',                                 '2010Âπ¥2Êúà14Êó•'],
                ['LLL',                                '2010Âπ¥2Êúà14Êó•‰∏ãÂçà3ÁÇπ25ÂàÜ'],
                ['LLLL',                               '2010Âπ¥2Êúà14Êó•ÊòüÊúüÊó•‰∏ãÂçà3ÁÇπ25ÂàÜ'],
                ['l',                                  '2010-02-14'],
                ['ll',                                 '2010Âπ¥2Êúà14Êó•'],
                ['lll',                                '2010Âπ¥2Êúà14Êó•‰∏ãÂçà3ÁÇπ25ÂàÜ'],
                ['llll',                               '2010Âπ¥2Êúà14Êó•ÊòüÊúüÊó•‰∏ãÂçà3ÁÇπ25ÂàÜ']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format month', function (assert) {
        var expected = '‰∏ÄÊúà 1Êúà_‰∫åÊúà 2Êúà_‰∏âÊúà 3Êúà_ÂõõÊúà 4Êúà_‰∫îÊúà 5Êúà_ÂÖ≠Êúà 6Êúà_‰∏ÉÊúà 7Êúà_ÂÖ´Êúà 8Êúà_‰πùÊúà 9Êúà_ÂçÅÊúà 10Êúà_ÂçÅ‰∏ÄÊúà 11Êúà_ÂçÅ‰∫åÊúà 12Êúà'.split('_'), i;

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'ÊòüÊúüÊó• Âë®Êó• Êó•_ÊòüÊúü‰∏Ä Âë®‰∏Ä ‰∏Ä_ÊòüÊúü‰∫å Âë®‰∫å ‰∫å_ÊòüÊúü‰∏â Âë®‰∏â ‰∏â_ÊòüÊúüÂõõ Âë®Âõõ Âõõ_ÊòüÊúü‰∫î Âë®‰∫î ‰∫î_ÊòüÊúüÂÖ≠ Âë®ÂÖ≠ ÂÖ≠'.split('_'), i;

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'Âá†Áßí',   '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '1 ÂàÜÈíü', '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '1 ÂàÜÈíü', '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ÂàÜÈíü',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ÂàÜÈíü', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '1 Â∞èÊó∂', '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '1 Â∞èÊó∂', '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 Â∞èÊó∂',  '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 Â∞èÊó∂',  '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 Â∞èÊó∂', '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '1 Â§©',   '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '1 Â§©',   '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 Â§©',   '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '1 Â§©',   '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 Â§©',   '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 Â§©',  '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '1 ‰∏™Êúà', '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '1 ‰∏™Êúà', '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '1 ‰∏™Êúà', '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ‰∏™Êúà',  '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ‰∏™Êúà',  '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ‰∏™Êúà',  '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '1 ‰∏™Êúà', '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ‰∏™Êúà',  '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '1 Âπ¥',   '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Âπ¥',   '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '1 Âπ¥',   '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 Âπ¥',   '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'Âá†ÁßíÂÜÖ',  'prefix');
        assert.equal(moment(0).from(30000), 'Âá†ÁßíÂâç', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'Âá†ÁßíÂâç',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'Âá†ÁßíÂÜÖ', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5 Â§©ÂÜÖ', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   '‰ªäÂ§©ÂáåÊô®2ÁÇπÊï¥',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '‰ªäÂ§©ÂáåÊô®2ÁÇπ25ÂàÜ',   'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '‰ªäÂ§©ÂáåÊô®3ÁÇπÊï¥',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'ÊòéÂ§©ÂáåÊô®2ÁÇπÊï¥',     'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '‰ªäÂ§©ÂáåÊô®1ÁÇπÊï¥',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Êò®Â§©ÂáåÊô®2ÁÇπÊï¥',     'yesterday at the same time');
    });

    test('calendar current week', function (assert) {
        var i, m,
            today = moment().startOf('day');

        for (i = 0; i < 7; i++) {
            m = moment().startOf('week').add({d: i});
            if (Math.abs(m.diff(today, 'days')) <= 1) {
                continue; // skip today, yesterday, tomorrow
            }
            assert.equal(m.calendar(),       m.format('[Êú¨]dddÂáåÊô®12ÁÇπÊï¥'),  'Monday + ' + i + ' days current time');
        }
    });

    test('calendar next week', function (assert) {
        var i, m,
            today = moment().startOf('day');

        for (i = 7; i < 14; i++) {
            m = moment().startOf('week').add({d: i});
            if (Math.abs(m.diff(today, 'days')) >= 7) {
                continue;
            }
            if (Math.abs(m.diff(today, 'days')) <= 1) {
                continue; // skip today, yesterday, tomorrow
            }
            assert.equal(m.calendar(),  m.format('[‰∏ã]dddÂáåÊô®12ÁÇπÊï¥'), 'Today + ' + i + ' days beginning of day');
        }
        assert.equal(42, 42, 'at least one assert');
    });

    test('calendar last week', function (assert) {
        var i, m,
            today = moment().startOf('day');

        for (i = 1; i < 8; i++) {
            m = moment().startOf('week').subtract({d: i});
            if ((Math.abs(m.diff(today, 'days')) >= 7) || (Math.abs(m.diff(today, 'days')) <= 1)) {
                continue;
            }
            assert.equal(m.calendar(),  m.format('[‰∏ä]dddÂáåÊô®12ÁÇπÊï¥'),  'Monday - ' + i + ' days next week');
        }
        assert.equal(42, 42, 'at least one assert');
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('LL'),      '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('LL'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('LL'),      '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('LL'),  'in 2 weeks');
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  0, 0]).format('A'), 'ÂáåÊô®', 'before dawn');
        assert.equal(moment([2011, 2, 23,  6, 0]).format('A'), 'Êó©‰∏ä', 'morning');
        assert.equal(moment([2011, 2, 23,  9, 0]).format('A'), '‰∏äÂçà', 'before noon');
        assert.equal(moment([2011, 2, 23, 12, 0]).format('A'), '‰∏≠Âçà', 'noon');
        assert.equal(moment([2011, 2, 23, 13, 0]).format('A'), '‰∏ãÂçà', 'afternoon');
        assert.equal(moment([2011, 2, 23, 18, 0]).format('A'), 'Êôö‰∏ä', 'night');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).week(), 1, 'Jan  2 2012 should be week 52');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 52, 'Dec 31 2006 should be week 52');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 52, 'Dec 29 2002 should be week 52');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2010,  0,  2]).week(), 53, 'Jan  2 2010 should be week 53');
        assert.equal(moment([2010,  0, 10]).week(), 1, 'Jan 10 2010 should be week 1');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  8]).week(), 1, 'Jan  8 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(), 1, 'Jan  9 2011 should be week 1');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52Âë®', 'Jan  1 2012 Â∫îËØ•ÊòØÁ¨¨52Âë®');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1Âë®', 'Jan  7 2012 Â∫îËØ•ÊòØÁ¨¨ 1Âë®');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2Âë®', 'Jan 14 2012 Â∫îËØ•ÊòØÁ¨¨ 2Âë®');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('meridiem invariant', function (assert) {
        var h, m, t1, t2;
        for (h = 0; h < 24; ++h) {
            for (m = 0; m < 60; m += 15) {
                t1 = moment.utc([2000, 0, 1, h, m]);
                t2 = moment(t1.format('A h:mm'), 'A h:mm');
                assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                        'meridiem at ' + t1.format('HH:mm'));
            }
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('zh-tw');

    test('parse', function (assert) {
        var tests = '‰∏ÄÊúà 1Êúà_‰∫åÊúà 2Êúà_‰∏âÊúà 3Êúà_ÂõõÊúà 4Êúà_‰∫îÊúà 5Êúà_ÂÖ≠Êúà 6Êúà_‰∏ÉÊúà 7Êúà_ÂÖ´Êúà 8Êúà_‰πùÊúà 9Êúà_ÂçÅÊúà 10Êúà_ÂçÅ‰∏ÄÊúà 11Êúà_ÂçÅ‰∫åÊúà 12Êúà'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, a h:mm:ss',      'ÊòüÊúüÊó•, ‰∫åÊúà 14Êó• 2010, ‰∏ãÂçà 3:25:50'],
                ['ddd, Ah',                            'ÈÄ±Êó•, ‰∏ãÂçà3'],
                ['M Mo MM MMMM MMM',                   '2 2Êúà 02 ‰∫åÊúà 2Êúà'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14Êó• 14'],
                ['d do dddd ddd dd',                   '0 0Êó• ÊòüÊúüÊó• ÈÄ±Êó• Êó•'],
                ['DDD DDDo DDDD',                      '45 45Êó• 045'],
                ['w wo ww',                            '8 8ÈÄ± 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                '‰∏ãÂçà ‰∏ãÂçà'],
                ['[ÈÄôÂπ¥ÁöÑÁ¨¨] DDDo',                    'ÈÄôÂπ¥ÁöÑÁ¨¨ 45Êó•'],
                ['LTS',                                '‰∏ãÂçà3Èªû25ÂàÜ50Áßí'],
                ['L',                                  '2010Âπ¥2Êúà14Êó•'],
                ['LL',                                 '2010Âπ¥2Êúà14Êó•'],
                ['LLL',                                '2010Âπ¥2Êúà14Êó•‰∏ãÂçà3Èªû25ÂàÜ'],
                ['LLLL',                               '2010Âπ¥2Êúà14Êó•ÊòüÊúüÊó•‰∏ãÂçà3Èªû25ÂàÜ'],
                ['l',                                  '2010Âπ¥2Êúà14Êó•'],
                ['ll',                                 '2010Âπ¥2Êúà14Êó•'],
                ['lll',                                '2010Âπ¥2Êúà14Êó•‰∏ãÂçà3Èªû25ÂàÜ'],
                ['llll',                               '2010Âπ¥2Êúà14Êó•ÊòüÊúüÊó•‰∏ãÂçà3Èªû25ÂàÜ']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format month', function (assert) {
        var expected = '‰∏ÄÊúà 1Êúà_‰∫åÊúà 2Êúà_‰∏âÊúà 3Êúà_ÂõõÊúà 4Êúà_‰∫îÊúà 5Êúà_ÂÖ≠Êúà 6Êúà_‰∏ÉÊúà 7Êúà_ÂÖ´Êúà 8Êúà_‰πùÊúà 9Êúà_ÂçÅÊúà 10Êúà_ÂçÅ‰∏ÄÊúà 11Êúà_ÂçÅ‰∫åÊúà 12Êúà'.split('_'), i;

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'ÊòüÊúüÊó• ÈÄ±Êó• Êó•_ÊòüÊúü‰∏Ä ÈÄ±‰∏Ä ‰∏Ä_ÊòüÊúü‰∫å ÈÄ±‰∫å ‰∫å_ÊòüÊúü‰∏â ÈÄ±‰∏â ‰∏â_ÊòüÊúüÂõõ ÈÄ±Âõõ Âõõ_ÊòüÊúü‰∫î ÈÄ±‰∫î ‰∫î_ÊòüÊúüÂÖ≠ ÈÄ±ÂÖ≠ ÂÖ≠'.split('_'), i;

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'ÂπæÁßí',   '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '‰∏ÄÂàÜÈêò', '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '‰∏ÄÂàÜÈêò', '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2ÂàÜÈêò',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44ÂàÜÈêò', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '‰∏ÄÂ∞èÊôÇ', '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '‰∏ÄÂ∞èÊôÇ', '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2Â∞èÊôÇ',  '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5Â∞èÊôÇ',  '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21Â∞èÊôÇ', '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '‰∏ÄÂ§©',   '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '‰∏ÄÂ§©',   '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2Â§©',   '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '‰∏ÄÂ§©',   '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5Â§©',   '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25Â§©',  '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '‰∏ÄÂÄãÊúà', '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '‰∏ÄÂÄãÊúà', '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '‰∏ÄÂÄãÊúà', '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2ÂÄãÊúà',  '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2ÂÄãÊúà',  '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3ÂÄãÊúà',  '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '‰∏ÄÂÄãÊúà', '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5ÂÄãÊúà',  '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '‰∏ÄÂπ¥',   '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2Âπ¥',   '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '‰∏ÄÂπ¥',   '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5Âπ¥',   '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'ÂπæÁßíÂÖß',  'prefix');
        assert.equal(moment(0).from(30000), 'ÂπæÁßíÂâç', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'ÂπæÁßíÂâç',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'ÂπæÁßíÂÖß', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5Â§©ÂÖß', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   '‰ªäÂ§©Êó©‰∏ä2Èªû00ÂàÜ',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '‰ªäÂ§©Êó©‰∏ä2Èªû25ÂàÜ',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '‰ªäÂ§©Êó©‰∏ä3Èªû00ÂàÜ',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'ÊòéÂ§©Êó©‰∏ä2Èªû00ÂàÜ',     'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '‰ªäÂ§©Êó©‰∏ä1Èªû00ÂàÜ',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Êò®Â§©Êó©‰∏ä2Èªû00ÂàÜ',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[‰∏ã]ddddLT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[‰∏ã]ddddLT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[‰∏ã]ddddLT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[‰∏ä]ddddLT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[‰∏ä]ddddLT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[‰∏ä]ddddLT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),      '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),      '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  0, 0]).format('a'), 'Êó©‰∏ä', 'morning');
        assert.equal(moment([2011, 2, 23,  9, 0]).format('a'), '‰∏äÂçà', 'before noon');
        assert.equal(moment([2011, 2, 23, 12, 0]).format('a'), '‰∏≠Âçà', 'noon');
        assert.equal(moment([2011, 2, 23, 13, 0]).format('a'), '‰∏ãÂçà', 'after noon');
        assert.equal(moment([2011, 2, 23, 18, 0]).format('a'), 'Êôö‰∏ä', 'night');

        assert.equal(moment([2011, 2, 23,  0, 0]).format('A'), 'Êó©‰∏ä', 'morning');
        assert.equal(moment([2011, 2, 23,  9, 0]).format('A'), '‰∏äÂçà', 'before noon');
        assert.equal(moment([2011, 2, 23, 12, 0]).format('A'), '‰∏≠Âçà', 'noon');
        assert.equal(moment([2011, 2, 23, 13, 0]).format('A'), '‰∏ãÂçà', 'afternoon');
        assert.equal(moment([2011, 2, 23, 18, 0]).format('A'), 'Êôö‰∏ä', 'night');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1ÈÄ±', 'Jan  1 2012 ÊáâË©≤ÊòØÁ¨¨ 1ÈÄ±');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1ÈÄ±', 'Jan  7 2012 ÊáâË©≤ÊòØÁ¨¨ 1ÈÄ±');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2ÈÄ±', 'Jan  8 2012 ÊáâË©≤ÊòØÁ¨¨ 2ÈÄ±');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2ÈÄ±', 'Jan 14 2012 ÊáâË©≤ÊòØÁ¨¨ 2ÈÄ±');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3ÈÄ±', 'Jan 15 2012 ÊáâË©≤ÊòØÁ¨¨ 3ÈÄ±');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('meridiem invariant', function (assert) {
        var h, m, t1, t2;
        for (h = 0; h < 24; ++h) {
            for (m = 0; m < 60; m += 15) {
                t1 = moment.utc([2000, 0, 1, h, m]);
                t2 = moment(t1.format('A h:mm'), 'A h:mm');
                assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                        'meridiem at ' + t1.format('HH:mm'));
            }
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('add and subtract');

    test('add short reverse args', function (assert) {
        var a = moment(), b, c, d;
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.add({ms: 50}).milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add({s: 1}).seconds(), 9, 'Add seconds');
        assert.equal(a.add({m: 1}).minutes(), 8, 'Add minutes');
        assert.equal(a.add({h: 1}).hours(), 7, 'Add hours');
        assert.equal(a.add({d: 1}).date(), 13, 'Add date');
        assert.equal(a.add({w: 1}).date(), 20, 'Add week');
        assert.equal(a.add({M: 1}).month(), 10, 'Add month');
        assert.equal(a.add({y: 1}).year(), 2012, 'Add year');
        assert.equal(a.add({Q: 1}).month(), 1, 'Add quarter');

        b = moment([2010, 0, 31]).add({M: 1});
        c = moment([2010, 1, 28]).subtract({M: 1});
        d = moment([2010, 1, 28]).subtract({Q: 1});

        assert.equal(b.month(), 1, 'add month, jan 31st to feb 28th');
        assert.equal(b.date(), 28, 'add month, jan 31st to feb 28th');
        assert.equal(c.month(), 0, 'subtract month, feb 28th to jan 28th');
        assert.equal(c.date(), 28, 'subtract month, feb 28th to jan 28th');
        assert.equal(d.month(), 10, 'subtract quarter, feb 28th 2010 to nov 28th 2009');
        assert.equal(d.date(), 28, 'subtract quarter, feb 28th 2010 to nov 28th 2009');
        assert.equal(d.year(), 2009, 'subtract quarter, feb 28th 2010 to nov 28th 2009');
    });

    test('add long reverse args', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.add({milliseconds: 50}).milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add({seconds: 1}).seconds(), 9, 'Add seconds');
        assert.equal(a.add({minutes: 1}).minutes(), 8, 'Add minutes');
        assert.equal(a.add({hours: 1}).hours(), 7, 'Add hours');
        assert.equal(a.add({days: 1}).date(), 13, 'Add date');
        assert.equal(a.add({weeks: 1}).date(), 20, 'Add week');
        assert.equal(a.add({months: 1}).month(), 10, 'Add month');
        assert.equal(a.add({years: 1}).year(), 2012, 'Add year');
        assert.equal(a.add({quarters: 1}).month(), 1, 'Add quarter');
    });

    test('add long singular reverse args', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.add({millisecond: 50}).milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add({second: 1}).seconds(), 9, 'Add seconds');
        assert.equal(a.add({minute: 1}).minutes(), 8, 'Add minutes');
        assert.equal(a.add({hour: 1}).hours(), 7, 'Add hours');
        assert.equal(a.add({day: 1}).date(), 13, 'Add date');
        assert.equal(a.add({week: 1}).date(), 20, 'Add week');
        assert.equal(a.add({month: 1}).month(), 10, 'Add month');
        assert.equal(a.add({year: 1}).year(), 2012, 'Add year');
        assert.equal(a.add({quarter: 1}).month(), 1, 'Add quarter');
    });

    test('add string long reverse args', function (assert) {
        var a = moment(), b;
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        b = a.clone();

        assert.equal(a.add('millisecond', 50).milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add('second', 1).seconds(), 9, 'Add seconds');
        assert.equal(a.add('minute', 1).minutes(), 8, 'Add minutes');
        assert.equal(a.add('hour', 1).hours(), 7, 'Add hours');
        assert.equal(a.add('day', 1).date(), 13, 'Add date');
        assert.equal(a.add('week', 1).date(), 20, 'Add week');
        assert.equal(a.add('month', 1).month(), 10, 'Add month');
        assert.equal(a.add('year', 1).year(), 2012, 'Add year');
        assert.equal(b.add('day', '01').date(), 13, 'Add date');
        assert.equal(a.add('quarter', 1).month(), 1, 'Add quarter');
    });

    test('add string long singular reverse args', function (assert) {
        var a = moment(), b;
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        b = a.clone();

        assert.equal(a.add('milliseconds', 50).milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add('seconds', 1).seconds(), 9, 'Add seconds');
        assert.equal(a.add('minutes', 1).minutes(), 8, 'Add minutes');
        assert.equal(a.add('hours', 1).hours(), 7, 'Add hours');
        assert.equal(a.add('days', 1).date(), 13, 'Add date');
        assert.equal(a.add('weeks', 1).date(), 20, 'Add week');
        assert.equal(a.add('months', 1).month(), 10, 'Add month');
        assert.equal(a.add('years', 1).year(), 2012, 'Add year');
        assert.equal(b.add('days', '01').date(), 13, 'Add date');
        assert.equal(a.add('quarters', 1).month(), 1, 'Add quarter');
    });

    test('add string short reverse args', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.add('ms', 50).milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add('s', 1).seconds(), 9, 'Add seconds');
        assert.equal(a.add('m', 1).minutes(), 8, 'Add minutes');
        assert.equal(a.add('h', 1).hours(), 7, 'Add hours');
        assert.equal(a.add('d', 1).date(), 13, 'Add date');
        assert.equal(a.add('w', 1).date(), 20, 'Add week');
        assert.equal(a.add('M', 1).month(), 10, 'Add month');
        assert.equal(a.add('y', 1).year(), 2012, 'Add year');
        assert.equal(a.add('Q', 1).month(), 1, 'Add quarter');
    });

    test('add string long', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.add(50, 'millisecond').milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add(1, 'second').seconds(), 9, 'Add seconds');
        assert.equal(a.add(1, 'minute').minutes(), 8, 'Add minutes');
        assert.equal(a.add(1, 'hour').hours(), 7, 'Add hours');
        assert.equal(a.add(1, 'day').date(), 13, 'Add date');
        assert.equal(a.add(1, 'week').date(), 20, 'Add week');
        assert.equal(a.add(1, 'month').month(), 10, 'Add month');
        assert.equal(a.add(1, 'year').year(), 2012, 'Add year');
        assert.equal(a.add(1, 'quarter').month(), 1, 'Add quarter');
    });

    test('add string long singular', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.add(50, 'milliseconds').milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add(1, 'seconds').seconds(), 9, 'Add seconds');
        assert.equal(a.add(1, 'minutes').minutes(), 8, 'Add minutes');
        assert.equal(a.add(1, 'hours').hours(), 7, 'Add hours');
        assert.equal(a.add(1, 'days').date(), 13, 'Add date');
        assert.equal(a.add(1, 'weeks').date(), 20, 'Add week');
        assert.equal(a.add(1, 'months').month(), 10, 'Add month');
        assert.equal(a.add(1, 'years').year(), 2012, 'Add year');
        assert.equal(a.add(1, 'quarters').month(), 1, 'Add quarter');
    });

    test('add string short', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.add(50, 'ms').milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add(1, 's').seconds(), 9, 'Add seconds');
        assert.equal(a.add(1, 'm').minutes(), 8, 'Add minutes');
        assert.equal(a.add(1, 'h').hours(), 7, 'Add hours');
        assert.equal(a.add(1, 'd').date(), 13, 'Add date');
        assert.equal(a.add(1, 'w').date(), 20, 'Add week');
        assert.equal(a.add(1, 'M').month(), 10, 'Add month');
        assert.equal(a.add(1, 'y').year(), 2012, 'Add year');
        assert.equal(a.add(1, 'Q').month(), 1, 'Add quarter');
    });

    test('add strings string short args', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.add('ms', '50').milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add('s', '1').seconds(), 9, 'Add seconds');
        assert.equal(a.add('m', '1').minutes(), 8, 'Add minutes');
        assert.equal(a.add('h', '1').hours(), 7, 'Add hours');
        assert.equal(a.add('d', '1').date(), 13, 'Add date');
        assert.equal(a.add('w', '1').date(), 20, 'Add week');
        assert.equal(a.add('M', '1').month(), 10, 'Add month');
        assert.equal(a.add('y', '1').year(), 2012, 'Add year');
        assert.equal(a.add('Q', '1').month(), 1, 'Add quarter');
    });

    test('subtract strings string short args', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.subtract('ms', '50').milliseconds(), 450, 'Subtract milliseconds');
        assert.equal(a.subtract('s', '1').seconds(), 7, 'Subtract seconds');
        assert.equal(a.subtract('m', '1').minutes(), 6, 'Subtract minutes');
        assert.equal(a.subtract('h', '1').hours(), 5, 'Subtract hours');
        assert.equal(a.subtract('d', '1').date(), 11, 'Subtract date');
        assert.equal(a.subtract('w', '1').date(), 4, 'Subtract week');
        assert.equal(a.subtract('M', '1').month(), 8, 'Subtract month');
        assert.equal(a.subtract('y', '1').year(), 2010, 'Subtract year');
        assert.equal(a.subtract('Q', '1').month(), 5, 'Subtract quarter');
    });

    test('add strings string short', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.add('50', 'ms').milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add('1', 's').seconds(), 9, 'Add seconds');
        assert.equal(a.add('1', 'm').minutes(), 8, 'Add minutes');
        assert.equal(a.add('1', 'h').hours(), 7, 'Add hours');
        assert.equal(a.add('1', 'd').date(), 13, 'Add date');
        assert.equal(a.add('1', 'w').date(), 20, 'Add week');
        assert.equal(a.add('1', 'M').month(), 10, 'Add month');
        assert.equal(a.add('1', 'y').year(), 2012, 'Add year');
        assert.equal(a.add('1', 'Q').month(), 1, 'Add quarter');
    });

    test('subtract strings string short', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.subtract('50', 'ms').milliseconds(), 450, 'Subtract milliseconds');
        assert.equal(a.subtract('1', 's').seconds(), 7, 'Subtract seconds');
        assert.equal(a.subtract('1', 'm').minutes(), 6, 'Subtract minutes');
        assert.equal(a.subtract('1', 'h').hours(), 5, 'Subtract hours');
        assert.equal(a.subtract('1', 'd').date(), 11, 'Subtract date');
        assert.equal(a.subtract('1', 'w').date(), 4, 'Subtract week');
        assert.equal(a.subtract('1', 'M').month(), 8, 'Subtract month');
        assert.equal(a.subtract('1', 'y').year(), 2010, 'Subtract year');
        assert.equal(a.subtract('1', 'Q').month(), 5, 'Subtract quarter');
    });

    test('add across DST', function (assert) {
        // Detect Safari bug and bail. Hours on 13th March 2011 are shifted
        // with 1 ahead.
        if (new Date(2011, 2, 13, 5, 0, 0).getHours() !== 5) {
            return;
        }

        var a = moment(new Date(2011, 2, 12, 5, 0, 0)),
            b = moment(new Date(2011, 2, 12, 5, 0, 0)),
            c = moment(new Date(2011, 2, 12, 5, 0, 0)),
            d = moment(new Date(2011, 2, 12, 5, 0, 0)),
            e = moment(new Date(2011, 2, 12, 5, 0, 0));
        a.add(1, 'days');
        b.add(24, 'hours');
        c.add(1, 'months');
        e.add(1, 'quarter');

        assert.equal(a.hours(), 5, 'adding days over DST difference should result in the same hour');
        if (b.isDST() && !d.isDST()) {
            assert.equal(b.hours(), 6, 'adding hours over DST difference should result in a different hour');
        } else if (!b.isDST() && d.isDST()) {
            assert.equal(b.hours(), 4, 'adding hours over DST difference should result in a different hour');
        } else {
            assert.equal(b.hours(), 5, 'adding hours over DST difference should result in a same hour if the timezone does not have daylight savings time');
        }
        assert.equal(c.hours(), 5, 'adding months over DST difference should result in the same hour');
        assert.equal(e.hours(), 5, 'adding quarters over DST difference should result in the same hour');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('create');

    test('array', function (assert) {
        assert.ok(moment([2010]).toDate() instanceof Date, '[2010]');
        assert.ok(moment([2010, 1]).toDate() instanceof Date, '[2010, 1]');
        assert.ok(moment([2010, 1, 12]).toDate() instanceof Date, '[2010, 1, 12]');
        assert.ok(moment([2010, 1, 12, 1]).toDate() instanceof Date, '[2010, 1, 12, 1]');
        assert.ok(moment([2010, 1, 12, 1, 1]).toDate() instanceof Date, '[2010, 1, 12, 1, 1]');
        assert.ok(moment([2010, 1, 12, 1, 1, 1]).toDate() instanceof Date, '[2010, 1, 12, 1, 1, 1]');
        assert.ok(moment([2010, 1, 12, 1, 1, 1, 1]).toDate() instanceof Date, '[2010, 1, 12, 1, 1, 1, 1]');
        assert.equal(+moment(new Date(2010, 1, 14, 15, 25, 50, 125)), +moment([2010, 1, 14, 15, 25, 50, 125]), 'constructing with array === constructing with new Date()');
    });

    test('array copying', function (assert) {
        var importantArray = [2009, 11];
        moment(importantArray);
        assert.deepEqual(importantArray, [2009, 11], 'initializer should not mutate the original array');
    });

    test('object', function (assert) {
        var fmt = 'YYYY-MM-DD HH:mm:ss.SSS',
            tests = [
                [{year: 2010}, '2010-01-01 00:00:00.000'],
                [{year: 2010, month: 1}, '2010-02-01 00:00:00.000'],
                [{year: 2010, month: 1, day: 12}, '2010-02-12 00:00:00.000'],
                [{year: 2010, month: 1, date: 12}, '2010-02-12 00:00:00.000'],
                [{year: 2010, month: 1, day: 12, hours: 1}, '2010-02-12 01:00:00.000'],
                [{year: 2010, month: 1, date: 12, hours: 1}, '2010-02-12 01:00:00.000'],
                [{year: 2010, month: 1, day: 12, hours: 1, minutes: 1}, '2010-02-12 01:01:00.000'],
                [{year: 2010, month: 1, date: 12, hours: 1, minutes: 1}, '2010-02-12 01:01:00.000'],
                [{year: 2010, month: 1, day: 12, hours: 1, minutes: 1, seconds: 1}, '2010-02-12 01:01:01.000'],
                [{year: 2010, month: 1, day: 12, hours: 1, minutes: 1, seconds: 1, milliseconds: 1}, '2010-02-12 01:01:01.001'],
                [{years: 2010, months: 1, days: 14, hours: 15, minutes: 25, seconds: 50, milliseconds: 125}, '2010-02-14 15:25:50.125'],
                [{year: 2010, month: 1, day: 14, hour: 15, minute: 25, second: 50, millisecond: 125}, '2010-02-14 15:25:50.125'],
                [{y: 2010, M: 1, d: 14, h: 15, m: 25, s: 50, ms: 125}, '2010-02-14 15:25:50.125']
            ], i;
        for (i = 0; i < tests.length; ++i) {
            assert.equal(moment(tests[i][0]).format(fmt), tests[i][1]);
        }
    });

    test('multi format array copying', function (assert) {
        var importantArray = ['MM/DD/YYYY', 'YYYY-MM-DD', 'MM-DD-YYYY'];
        moment('1999-02-13', importantArray);
        assert.deepEqual(importantArray, ['MM/DD/YYYY', 'YYYY-MM-DD', 'MM-DD-YYYY'], 'initializer should not mutate the original array');
    });

    test('number', function (assert) {
        assert.ok(moment(1000).toDate() instanceof Date, '1000');
        assert.equal(moment(1000).valueOf(), 1000, 'asserting valueOf');
        assert.equal(moment.utc(1000).valueOf(), 1000, 'asserting valueOf');
    });

    test('unix', function (assert) {
        assert.equal(moment.unix(1).valueOf(), 1000, '1 unix timestamp == 1000 Date.valueOf');
        assert.equal(moment(1000).unix(), 1, '1000 Date.valueOf == 1 unix timestamp');
        assert.equal(moment.unix(1000).valueOf(), 1000000, '1000 unix timestamp == 1000000 Date.valueOf');
        assert.equal(moment(1500).unix(), 1, '1500 Date.valueOf == 1 unix timestamp');
        assert.equal(moment(1900).unix(), 1, '1900 Date.valueOf == 1 unix timestamp');
        assert.equal(moment(2100).unix(), 2, '2100 Date.valueOf == 2 unix timestamp');
        assert.equal(moment(1333129333524).unix(), 1333129333, '1333129333524 Date.valueOf == 1333129333 unix timestamp');
        assert.equal(moment(1333129333524000).unix(), 1333129333524, '1333129333524000 Date.valueOf == 1333129333524 unix timestamp');
    });

    test('date', function (assert) {
        assert.ok(moment(new Date()).toDate() instanceof Date, 'new Date()');
    });

    test('date mutation', function (assert) {
        var a = new Date();
        assert.ok(moment(a).toDate() !== a, 'the date moment uses should not be the date passed in');
    });

    test('moment', function (assert) {
        assert.ok(moment(moment()).toDate() instanceof Date, 'moment(moment())');
        assert.ok(moment(moment(moment())).toDate() instanceof Date, 'moment(moment(moment()))');
    });

    test('cloning moment should only copy own properties', function (assert) {
        assert.ok(!moment().clone().hasOwnProperty('month'), 'Should not clone prototype methods');
    });

    test('cloning moment works with weird clones', function (assert) {
        var extend = function (a, b) {
            var i;
            for (i in b) {
                a[i] = b[i];
            }
            return a;
        },
        now = moment(),
        nowu = moment.utc();

        assert.equal(+extend({}, now).clone(), +now, 'cloning extend-ed now is now');
        assert.equal(+extend({}, nowu).clone(), +nowu, 'cloning extend-ed utc now is utc now');
    });

    test('cloning respects moment.momentProperties', function (assert) {
        var m = moment();

        assert.equal(m.clone()._special, undefined, 'cloning ignores extra properties');
        m._special = 'bacon';
        moment.momentProperties.push('_special');
        assert.equal(m.clone()._special, 'bacon', 'cloning respects momentProperties');
        moment.momentProperties.pop();
    });

    test('undefined', function (assert) {
        assert.ok(moment().toDate() instanceof Date, 'undefined');
    });

    test('iso format 24hrs', function (assert) {
        assert.equal(moment('2014-01-01T24:00:00.000').format('YYYY-MM-DD[T]HH:mm:ss.SSS'),
                '2014-01-02T00:00:00.000', 'iso format with 24:00 localtime');
        assert.equal(moment.utc('2014-01-01T24:00:00.000').format('YYYY-MM-DD[T]HH:mm:ss.SSS'),
                '2014-01-02T00:00:00.000', 'iso format with 24:00 utc');
    });

    test('string without format - json', function (assert) {
        assert.equal(moment('Date(1325132654000)').valueOf(), 1325132654000, 'Date(1325132654000)');
        assert.equal(moment('Date(-1325132654000)').valueOf(), -1325132654000, 'Date(-1325132654000)');
        assert.equal(moment('/Date(1325132654000)/').valueOf(), 1325132654000, '/Date(1325132654000)/');
        assert.equal(moment('/Date(1325132654000+0700)/').valueOf(), 1325132654000, '/Date(1325132654000+0700)/');
        assert.equal(moment('/Date(1325132654000-0700)/').valueOf(), 1325132654000, '/Date(1325132654000-0700)/');
    });

    test('string with format dropped am/pm bug', function (assert) {
        moment.locale('en');

        assert.equal(moment('05/1/2012 12:25:00', 'MM/DD/YYYY h:m:s a').format('MM/DD/YYYY'), '05/01/2012', 'should not break if am/pm is left off from the parsing tokens');
        assert.equal(moment('05/1/2012 12:25:00 am', 'MM/DD/YYYY h:m:s a').format('MM/DD/YYYY'), '05/01/2012', 'should not break if am/pm is left off from the parsing tokens');
        assert.equal(moment('05/1/2012 12:25:00 pm', 'MM/DD/YYYY h:m:s a').format('MM/DD/YYYY'), '05/01/2012', 'should not break if am/pm is left off from the parsing tokens');

        assert.ok(moment('05/1/2012 12:25:00', 'MM/DD/YYYY h:m:s a').isValid());
        assert.ok(moment('05/1/2012 12:25:00 am', 'MM/DD/YYYY h:m:s a').isValid());
        assert.ok(moment('05/1/2012 12:25:00 pm', 'MM/DD/YYYY h:m:s a').isValid());
    });

    test('empty string with formats', function (assert) {
        assert.equal(moment('', 'MM').format('YYYY-MM-DD HH:mm:ss'), 'Invalid date');
        assert.equal(moment(' ', 'MM').format('YYYY-MM-DD HH:mm:ss'), 'Invalid date');
        assert.equal(moment(' ', 'DD').format('YYYY-MM-DD HH:mm:ss'), 'Invalid date');
        assert.equal(moment(' ', ['MM', 'DD']).format('YYYY-MM-DD HH:mm:ss'), 'Invalid date');

        assert.ok(!moment('', 'MM').isValid());
        assert.ok(!moment(' ', 'MM').isValid());
        assert.ok(!moment(' ', 'DD').isValid());
        assert.ok(!moment(' ', ['MM', 'DD']).isValid());
    });

    test('defaulting to current date', function (assert) {
        var now = moment();
        assert.equal(moment('12:13:14', 'hh:mm:ss').format('YYYY-MM-DD hh:mm:ss'),
                     now.clone().hour(12).minute(13).second(14).format('YYYY-MM-DD hh:mm:ss'),
                     'given only time default to current date');
        assert.equal(moment('05', 'DD').format('YYYY-MM-DD'),
                     now.clone().date(5).format('YYYY-MM-DD'),
                     'given day of month default to current month, year');
        assert.equal(moment('05', 'MM').format('YYYY-MM-DD'),
                     now.clone().month(4).date(1).format('YYYY-MM-DD'),
                     'given month default to current year');
        assert.equal(moment('1996', 'YYYY').format('YYYY-MM-DD'),
                     now.clone().year(1996).month(0).date(1).format('YYYY-MM-DD'),
                     'given year do not default');
    });

    test('matching am/pm', function (assert) {
        assert.equal(moment('2012-09-03T03:00PM',   'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00PM', 'am/pm should parse correctly for PM');
        assert.equal(moment('2012-09-03T03:00P.M.', 'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00PM', 'am/pm should parse correctly for P.M.');
        assert.equal(moment('2012-09-03T03:00P',    'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00PM', 'am/pm should parse correctly for P');
        assert.equal(moment('2012-09-03T03:00pm',   'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00PM', 'am/pm should parse correctly for pm');
        assert.equal(moment('2012-09-03T03:00p.m.', 'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00PM', 'am/pm should parse correctly for p.m.');
        assert.equal(moment('2012-09-03T03:00p',    'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00PM', 'am/pm should parse correctly for p');

        assert.equal(moment('2012-09-03T03:00AM',   'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00AM', 'am/pm should parse correctly for AM');
        assert.equal(moment('2012-09-03T03:00A.M.', 'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00AM', 'am/pm should parse correctly for A.M.');
        assert.equal(moment('2012-09-03T03:00A',    'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00AM', 'am/pm should parse correctly for A');
        assert.equal(moment('2012-09-03T03:00am',   'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00AM', 'am/pm should parse correctly for am');
        assert.equal(moment('2012-09-03T03:00a.m.', 'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00AM', 'am/pm should parse correctly for a.m.');
        assert.equal(moment('2012-09-03T03:00a',    'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00AM', 'am/pm should parse correctly for a');

        assert.equal(moment('5:00p.m.March 4 2012', 'h:mmAMMMM D YYYY').format('YYYY-MM-DDThh:mmA'), '2012-03-04T05:00PM', 'am/pm should parse correctly before month names');
    });

    test('string with format', function (assert) {
        moment.locale('en');
        var a = [
            ['YYYY-Q',              '2014-4'],
            ['MM-DD-YYYY',          '12-02-1999'],
            ['DD-MM-YYYY',          '12-02-1999'],
            ['DD/MM/YYYY',          '12/02/1999'],
            ['DD_MM_YYYY',          '12_02_1999'],
            ['DD:MM:YYYY',          '12:02:1999'],
            ['D-M-YY',              '2-2-99'],
            ['YY',                  '99'],
            ['DDD-YYYY',            '300-1999'],
            ['DD-MM-YYYY h:m:s',    '12-02-1999 2:45:10'],
            ['DD-MM-YYYY h:m:s a',  '12-02-1999 2:45:10 am'],
            ['DD-MM-YYYY h:m:s a',  '12-02-1999 2:45:10 pm'],
            ['h:mm a',              '12:00 pm'],
            ['h:mm a',              '12:30 pm'],
            ['h:mm a',              '12:00 am'],
            ['h:mm a',              '12:30 am'],
            ['HH:mm',               '12:00'],
            ['YYYY-MM-DDTHH:mm:ss', '2011-11-11T11:11:11'],
            ['MM-DD-YYYY [M]',      '12-02-1999 M'],
            ['ddd MMM DD HH:mm:ss YYYY', 'Tue Apr 07 22:52:51 2009'],
            ['HH:mm:ss',            '12:00:00'],
            ['HH:mm:ss',            '12:30:00'],
            ['HH:mm:ss',            '00:00:00'],
            ['HH:mm:ss S',          '00:30:00 1'],
            ['HH:mm:ss SS',         '00:30:00 12'],
            ['HH:mm:ss SSS',        '00:30:00 123'],
            ['HH:mm:ss S',          '00:30:00 7'],
            ['HH:mm:ss SS',         '00:30:00 78'],
            ['HH:mm:ss SSS',        '00:30:00 789'],
            ['X',                   '1234567890'],
            ['x',                   '1234567890123'],
            ['LT',                  '12:30 AM'],
            ['LTS',                 '12:30:29 AM'],
            ['L',                   '09/02/1999'],
            ['l',                   '9/2/1999'],
            ['LL',                  'September 2, 1999'],
            ['ll',                  'Sep 2, 1999'],
            ['LLL',                 'September 2, 1999 12:30 AM'],
            ['lll',                 'Sep 2, 1999 12:30 AM'],
            ['LLLL',                'Thursday, September 2, 1999 12:30 AM'],
            ['llll',                'Thu, Sep 2, 1999 12:30 AM']
        ],
        m,
        i;

        for (i = 0; i < a.length; i++) {
            m = moment(a[i][1], a[i][0]);
            assert.ok(m.isValid());
            assert.equal(m.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('unix timestamp format', function (assert) {
        var formats = ['X', 'X.S', 'X.SS', 'X.SSS'], i, format;

        for (i = 0; i < formats.length; i++) {
            format = formats[i];
            assert.equal(moment('1234567890',     format).valueOf(), 1234567890 * 1000,       format + ' matches timestamp without milliseconds');
            assert.equal(moment('1234567890.1',   format).valueOf(), 1234567890 * 1000 + 100, format + ' matches timestamp with deciseconds');
            assert.equal(moment('1234567890.12',  format).valueOf(), 1234567890 * 1000 + 120, format + ' matches timestamp with centiseconds');
            assert.equal(moment('1234567890.123', format).valueOf(), 1234567890 * 1000 + 123, format + ' matches timestamp with milliseconds');
        }
    });

    test('unix offset milliseconds', function (assert) {
        assert.equal(moment('1234567890123', 'x').valueOf(), 1234567890123, 'x matches unix offset in milliseconds');
    });

    test('milliseconds format', function (assert) {
        assert.equal(moment('1', 'S').get('ms'), 100, 'deciseconds');
        // assert.equal(moment('10', 'S', true).isValid(), false, 'deciseconds with two digits');
        // assert.equal(moment('1', 'SS', true).isValid(), false, 'centiseconds with one digits');
        assert.equal(moment('12', 'SS').get('ms'), 120, 'centiseconds');
        // assert.equal(moment('123', 'SS', true).isValid(), false, 'centiseconds with three digits');
        assert.equal(moment('123', 'SSS').get('ms'), 123, 'milliseconds');
        assert.equal(moment('1234', 'SSSS').get('ms'), 123, 'milliseconds with SSSS');
        assert.equal(moment('123456789101112', 'SSSS').get('ms'), 123, 'milliseconds with SSSS');
    });

    test('string with format no separators', function (assert) {
        moment.locale('en');
        var a = [
            ['MMDDYYYY',          '12021999'],
            ['DDMMYYYY',          '12021999'],
            ['YYYYMMDD',          '19991202'],
            ['DDMMMYYYY',         '10Sep2001']
        ], i;

        for (i = 0; i < a.length; i++) {
            assert.equal(moment(a[i][1], a[i][0]).format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('string with format (timezone)', function (assert) {
        assert.equal(moment('5 -0700', 'H ZZ').toDate().getUTCHours(), 12, 'parse hours \'5 -0700\' ---> \'H ZZ\'');
        assert.equal(moment('5 -07:00', 'H Z').toDate().getUTCHours(), 12, 'parse hours \'5 -07:00\' ---> \'H Z\'');
        assert.equal(moment('5 -0730', 'H ZZ').toDate().getUTCMinutes(), 30, 'parse hours \'5 -0730\' ---> \'H ZZ\'');
        assert.equal(moment('5 -07:30', 'H Z').toDate().getUTCMinutes(), 30, 'parse hours \'5 -07:0\' ---> \'H Z\'');
        assert.equal(moment('5 +0100', 'H ZZ').toDate().getUTCHours(), 4, 'parse hours \'5 +0100\' ---> \'H ZZ\'');
        assert.equal(moment('5 +01:00', 'H Z').toDate().getUTCHours(), 4, 'parse hours \'5 +01:00\' ---> \'H Z\'');
        assert.equal(moment('5 +0130', 'H ZZ').toDate().getUTCMinutes(), 30, 'parse hours \'5 +0130\' ---> \'H ZZ\'');
        assert.equal(moment('5 +01:30', 'H Z').toDate().getUTCMinutes(), 30, 'parse hours \'5 +01:30\' ---> \'H Z\'');
    });

    test('string with format (timezone offset)', function (assert) {
        var a, b, c, d, e, f;
        a = new Date(Date.UTC(2011, 0, 1, 1));
        b = moment('2011 1 1 0 -01:00', 'YYYY MM DD HH Z');
        assert.equal(a.getHours(), b.hours(), 'date created with utc == parsed string with timezone offset');
        assert.equal(+a, +b, 'date created with utc == parsed string with timezone offset');
        c = moment('2011 2 1 10 -05:00', 'YYYY MM DD HH Z');
        d = moment('2011 2 1 8 -07:00', 'YYYY MM DD HH Z');
        assert.equal(c.hours(), d.hours(), '10 am central time == 8 am pacific time');
        e = moment.utc('Fri, 20 Jul 2012 17:15:00', 'ddd, DD MMM YYYY HH:mm:ss');
        f = moment.utc('Fri, 20 Jul 2012 10:15:00 -0700', 'ddd, DD MMM YYYY HH:mm:ss ZZ');
        assert.equal(e.hours(), f.hours(), 'parse timezone offset in utc');
    });

    test('string with timezone around start of year', function (assert) {
        assert.equal(moment('2000-01-01T00:00:00.000+01:00').toISOString(), '1999-12-31T23:00:00.000Z', '+1:00 around 2000');
        assert.equal(moment('2000-01-01T00:00:00.000-01:00').toISOString(), '2000-01-01T01:00:00.000Z', '-1:00 around 2000');
        assert.equal(moment('1970-01-01T00:00:00.000+01:00').toISOString(), '1969-12-31T23:00:00.000Z', '+1:00 around 1970');
        assert.equal(moment('1970-01-01T00:00:00.000-01:00').toISOString(), '1970-01-01T01:00:00.000Z', '-1:00 around 1970');
        assert.equal(moment('1200-01-01T00:00:00.000+01:00').toISOString(), '1199-12-31T23:00:00.000Z', '+1:00 around 1200');
        assert.equal(moment('1200-01-01T00:00:00.000-01:00').toISOString(), '1200-01-01T01:00:00.000Z', '-1:00 around 1200');
    });

    test('string with array of formats', function (assert) {
        assert.equal(moment('11-02-1999', ['MM-DD-YYYY', 'DD-MM-YYYY']).format('MM DD YYYY'), '11 02 1999', 'switching month and day');
        assert.equal(moment('02-11-1999', ['MM/DD/YYYY', 'YYYY MM DD', 'MM-DD-YYYY']).format('MM DD YYYY'), '02 11 1999', 'year last');
        assert.equal(moment('1999-02-11', ['MM/DD/YYYY', 'YYYY MM DD', 'MM-DD-YYYY']).format('MM DD YYYY'), '02 11 1999', 'year first');

        assert.equal(moment('02-11-1999', ['MM/DD/YYYY', 'YYYY MM DD']).format('MM DD YYYY'), '02 11 1999', 'year last');
        assert.equal(moment('1999-02-11', ['MM/DD/YYYY', 'YYYY MM DD']).format('MM DD YYYY'), '02 11 1999', 'year first');
        assert.equal(moment('02-11-1999', ['YYYY MM DD', 'MM/DD/YYYY']).format('MM DD YYYY'), '02 11 1999', 'year last');
        assert.equal(moment('1999-02-11', ['YYYY MM DD', 'MM/DD/YYYY']).format('MM DD YYYY'), '02 11 1999', 'year first');

        assert.equal(moment('13-11-1999', ['MM/DD/YYYY', 'DD/MM/YYYY']).format('MM DD YYYY'), '11 13 1999', 'second must be month');
        assert.equal(moment('11-13-1999', ['MM/DD/YYYY', 'DD/MM/YYYY']).format('MM DD YYYY'), '11 13 1999', 'first must be month');
        assert.equal(moment('01-02-2000', ['MM/DD/YYYY', 'DD/MM/YYYY']).format('MM DD YYYY'), '01 02 2000', 'either can be a month, month first format');
        assert.equal(moment('02-01-2000', ['DD/MM/YYYY', 'MM/DD/YYYY']).format('MM DD YYYY'), '01 02 2000', 'either can be a month, day first format');

        assert.equal(moment('11-02-10', ['MM/DD/YY', 'YY MM DD', 'DD-MM-YY']).format('MM DD YYYY'), '02 11 2010', 'all unparsed substrings have influence on format penalty');
        assert.equal(moment('11-02-10', ['MM-DD-YY HH:mm', 'YY MM DD']).format('MM DD YYYY'), '02 10 2011', 'prefer formats without extra tokens');
        assert.equal(moment('11-02-10 junk', ['MM-DD-YY', 'YY.MM.DD junk']).format('MM DD YYYY'), '02 10 2011', 'prefer formats that dont result in extra characters');
        assert.equal(moment('11-22-10', ['YY-MM-DD', 'YY-DD-MM']).format('MM DD YYYY'), '10 22 2011', 'prefer valid results');

        assert.equal(moment('gibberish', ['YY-MM-DD', 'YY-DD-MM']).format('MM DD YYYY'), 'Invalid date', 'doest throw for invalid strings');
        assert.equal(moment('gibberish', []).format('MM DD YYYY'), 'Invalid date', 'doest throw for an empty array');

        //https://github.com/moment/moment/issues/1143
        assert.equal(moment(
            'System Administrator and Database Assistant (7/1/2011), System Administrator and Database Assistant (7/1/2011), Database Coordinator (7/1/2011), Vice President (7/1/2011), System Administrator and Database Assistant (5/31/2012), Database Coordinator (7/1/2012), System Administrator and Database Assistant (7/1/2013)',
            ['MM/DD/YYYY', 'MM-DD-YYYY', 'YYYY-MM-DD', 'YYYY-MM-DDTHH:mm:ssZ'])
            .format('YYYY-MM-DD'), '2011-07-01', 'Works for long strings');

        assert.equal(moment('11-02-10', ['MM.DD.YY', 'DD-MM-YY']).format('MM DD YYYY'), '02 11 2010', 'escape RegExp special characters on comparing');

        assert.equal(moment('13-10-98', ['DD MM YY', 'DD MM YYYY'])._f, 'DD MM YY', 'use two digit year');
        assert.equal(moment('13-10-1998', ['DD MM YY', 'DD MM YYYY'])._f, 'DD MM YYYY', 'use four digit year');

        assert.equal(moment('01', ['MM', 'DD'])._f, 'MM', 'Should use first valid format');
    });

    test('string with array of formats + ISO', function (assert) {
        assert.equal(moment('1994', [moment.ISO_8601, 'MM', 'HH:mm', 'YYYY']).year(), 1994, 'iso: assert parse YYYY');
        assert.equal(moment('17:15', [moment.ISO_8601, 'MM', 'HH:mm', 'YYYY']).hour(), 17, 'iso: assert parse HH:mm (1)');
        assert.equal(moment('17:15', [moment.ISO_8601, 'MM', 'HH:mm', 'YYYY']).minutes(), 15, 'iso: assert parse HH:mm (2)');
        assert.equal(moment('06', [moment.ISO_8601, 'MM', 'HH:mm', 'YYYY']).month(), 6 - 1, 'iso: assert parse MM');
        assert.equal(moment('2012-06-01', [moment.ISO_8601, 'MM', 'HH:mm', 'YYYY']).parsingFlags().iso, true, 'iso: assert parse iso');
        assert.equal(moment('2014-05-05', [moment.ISO_8601, 'YYYY-MM-DD']).parsingFlags().iso, true, 'iso: edge case array precedence iso');
        assert.equal(moment('2014-05-05', ['YYYY-MM-DD', moment.ISO_8601]).parsingFlags().iso, false, 'iso: edge case array precedence not iso');
    });

    test('string with format - years', function (assert) {
        assert.equal(moment('67', 'YY').format('YYYY'), '2067', '67 > 2067');
        assert.equal(moment('68', 'YY').format('YYYY'), '2068', '68 > 2068');
        assert.equal(moment('69', 'YY').format('YYYY'), '1969', '69 > 1969');
        assert.equal(moment('70', 'YY').format('YYYY'), '1970', '70 > 1970');
    });

    test('implicit cloning', function (assert) {
        var momentA = moment([2011, 10, 10]),
        momentB = moment(momentA);
        momentA.month(5);
        assert.equal(momentB.month(), 10, 'Calling moment() on a moment will create a clone');
        assert.equal(momentA.month(), 5, 'Calling moment() on a moment will create a clone');
    });

    test('explicit cloning', function (assert) {
        var momentA = moment([2011, 10, 10]),
        momentB = momentA.clone();
        momentA.month(5);
        assert.equal(momentB.month(), 10, 'Calling moment() on a moment will create a clone');
        assert.equal(momentA.month(), 5, 'Calling moment() on a moment will create a clone');
    });

    test('cloning carrying over utc mode', function (assert) {
        assert.equal(moment().local().clone()._isUTC, false, 'An explicit cloned local moment should have _isUTC == false');
        assert.equal(moment().utc().clone()._isUTC, true, 'An cloned utc moment should have _isUTC == true');
        assert.equal(moment().clone()._isUTC, false, 'An explicit cloned local moment should have _isUTC == false');
        assert.equal(moment.utc().clone()._isUTC, true, 'An explicit cloned utc moment should have _isUTC == true');
        assert.equal(moment(moment().local())._isUTC, false, 'An implicit cloned local moment should have _isUTC == false');
        assert.equal(moment(moment().utc())._isUTC, true, 'An implicit cloned utc moment should have _isUTC == true');
        assert.equal(moment(moment())._isUTC, false, 'An implicit cloned local moment should have _isUTC == false');
        assert.equal(moment(moment.utc())._isUTC, true, 'An implicit cloned utc moment should have _isUTC == true');
    });

    test('parsing iso', function (assert) {
        var offset = moment([2011, 9, 8]).utcOffset(),
        pad = function (input) {
            if (input < 10) {
                return '0' + input;
            }
            return '' + input;
        },
        hourOffset = (offset > 0 ? Math.floor(offset / 60) : Math.ceil(offset / 60)),
        minOffset = offset - (hourOffset * 60),
        tz = (offset >= 0) ?
            '+' + pad(hourOffset) + ':' + pad(minOffset) :
            '-' + pad(-hourOffset) + ':' + pad(-minOffset),
        tz2 = tz.replace(':', ''),
        tz3 = tz2.slice(0, 3),
        formats = [
            ['2011-10-08',                    '2011-10-08T00:00:00.000' + tz],
            ['2011-10-08T18',                 '2011-10-08T18:00:00.000' + tz],
            ['2011-10-08T18:04',              '2011-10-08T18:04:00.000' + tz],
            ['2011-10-08T18:04:20',           '2011-10-08T18:04:20.000' + tz],
            ['2011-10-08T18:04' + tz,         '2011-10-08T18:04:00.000' + tz],
            ['2011-10-08T18:04:20' + tz,      '2011-10-08T18:04:20.000' + tz],
            ['2011-10-08T18:04' + tz2,        '2011-10-08T18:04:00.000' + tz],
            ['2011-10-08T18:04:20' + tz2,     '2011-10-08T18:04:20.000' + tz],
            ['2011-10-08T18:04' + tz3,        '2011-10-08T18:04:00.000' + tz],
            ['2011-10-08T18:04:20' + tz3,     '2011-10-08T18:04:20.000' + tz],
            ['2011-10-08T18:04:20.1' + tz2,   '2011-10-08T18:04:20.100' + tz],
            ['2011-10-08T18:04:20.11' + tz2,  '2011-10-08T18:04:20.110' + tz],
            ['2011-10-08T18:04:20.111' + tz2, '2011-10-08T18:04:20.111' + tz],
            ['2011-10-08 18',                 '2011-10-08T18:00:00.000' + tz],
            ['2011-10-08 18:04',              '2011-10-08T18:04:00.000' + tz],
            ['2011-10-08 18:04:20',           '2011-10-08T18:04:20.000' + tz],
            ['2011-10-08 18:04' + tz,         '2011-10-08T18:04:00.000' + tz],
            ['2011-10-08 18:04:20' + tz,      '2011-10-08T18:04:20.000' + tz],
            ['2011-10-08 18:04' + tz2,        '2011-10-08T18:04:00.000' + tz],
            ['2011-10-08 18:04:20' + tz2,     '2011-10-08T18:04:20.000' + tz],
            ['2011-10-08 18:04' + tz3,        '2011-10-08T18:04:00.000' + tz],
            ['2011-10-08 18:04:20' + tz3,     '2011-10-08T18:04:20.000' + tz],
            ['2011-10-08 18:04:20.1' + tz2,   '2011-10-08T18:04:20.100' + tz],
            ['2011-10-08 18:04:20.11' + tz2,  '2011-10-08T18:04:20.110' + tz],
            ['2011-10-08 18:04:20.111' + tz2, '2011-10-08T18:04:20.111' + tz],
            ['2011-W40',                      '2011-10-03T00:00:00.000' + tz],
            ['2011-W40-6',                    '2011-10-08T00:00:00.000' + tz],
            ['2011-W40-6T18',                 '2011-10-08T18:00:00.000' + tz],
            ['2011-W40-6T18:04',              '2011-10-08T18:04:00.000' + tz],
            ['2011-W40-6T18:04:20',           '2011-10-08T18:04:20.000' + tz],
            ['2011-W40-6T18:04' + tz,         '2011-10-08T18:04:00.000' + tz],
            ['2011-W40-6T18:04:20' + tz,      '2011-10-08T18:04:20.000' + tz],
            ['2011-W40-6T18:04' + tz2,        '2011-10-08T18:04:00.000' + tz],
            ['2011-W40-6T18:04:20' + tz2,     '2011-10-08T18:04:20.000' + tz],
            ['2011-W40-6T18:04' + tz3,        '2011-10-08T18:04:00.000' + tz],
            ['2011-W40-6T18:04:20' + tz3,     '2011-10-08T18:04:20.000' + tz],
            ['2011-W40-6T18:04:20.1' + tz2,   '2011-10-08T18:04:20.100' + tz],
            ['2011-W40-6T18:04:20.11' + tz2,  '2011-10-08T18:04:20.110' + tz],
            ['2011-W40-6T18:04:20.111' + tz2, '2011-10-08T18:04:20.111' + tz],
            ['2011-W40-6 18',                 '2011-10-08T18:00:00.000' + tz],
            ['2011-W40-6 18:04',              '2011-10-08T18:04:00.000' + tz],
            ['2011-W40-6 18:04:20',           '2011-10-08T18:04:20.000' + tz],
            ['2011-W40-6 18:04' + tz,         '2011-10-08T18:04:00.000' + tz],
            ['2011-W40-6 18:04:20' + tz,      '2011-10-08T18:04:20.000' + tz],
            ['2011-W40-6 18:04' + tz2,        '2011-10-08T18:04:00.000' + tz],
            ['2011-W40-6 18:04:20' + tz2,     '2011-10-08T18:04:20.000' + tz],
            ['2011-W40-6 18:04' + tz3,        '2011-10-08T18:04:00.000' + tz],
            ['2011-W40-6 18:04:20' + tz3,     '2011-10-08T18:04:20.000' + tz],
            ['2011-W40-6 18:04:20.1' + tz2,   '2011-10-08T18:04:20.100' + tz],
            ['2011-W40-6 18:04:20.11' + tz2,  '2011-10-08T18:04:20.110' + tz],
            ['2011-W40-6 18:04:20.111' + tz2, '2011-10-08T18:04:20.111' + tz],
            ['2011-281',                      '2011-10-08T00:00:00.000' + tz],
            ['2011-281T18',                   '2011-10-08T18:00:00.000' + tz],
            ['2011-281T18:04',                '2011-10-08T18:04:00.000' + tz],
            ['2011-281T18:04:20',             '2011-10-08T18:04:20.000' + tz],
            ['2011-281T18:04' + tz,           '2011-10-08T18:04:00.000' + tz],
            ['2011-281T18:04:20' + tz,        '2011-10-08T18:04:20.000' + tz],
            ['2011-281T18:04' + tz2,          '2011-10-08T18:04:00.000' + tz],
            ['2011-281T18:04:20' + tz2,       '2011-10-08T18:04:20.000' + tz],
            ['2011-281T18:04' + tz3,          '2011-10-08T18:04:00.000' + tz],
            ['2011-281T18:04:20' + tz3,       '2011-10-08T18:04:20.000' + tz],
            ['2011-281T18:04:20.1' + tz2,     '2011-10-08T18:04:20.100' + tz],
            ['2011-281T18:04:20.11' + tz2,    '2011-10-08T18:04:20.110' + tz],
            ['2011-281T18:04:20.111' + tz2,   '2011-10-08T18:04:20.111' + tz],
            ['2011-281 18',                   '2011-10-08T18:00:00.000' + tz],
            ['2011-281 18:04',                '2011-10-08T18:04:00.000' + tz],
            ['2011-281 18:04:20',             '2011-10-08T18:04:20.000' + tz],
            ['2011-281 18:04' + tz,           '2011-10-08T18:04:00.000' + tz],
            ['2011-281 18:04:20' + tz,        '2011-10-08T18:04:20.000' + tz],
            ['2011-281 18:04' + tz2,          '2011-10-08T18:04:00.000' + tz],
            ['2011-281 18:04:20' + tz2,       '2011-10-08T18:04:20.000' + tz],
            ['2011-281 18:04' + tz3,          '2011-10-08T18:04:00.000' + tz],
            ['2011-281 18:04:20' + tz3,       '2011-10-08T18:04:20.000' + tz],
            ['2011-281 18:04:20.1' + tz2,     '2011-10-08T18:04:20.100' + tz],
            ['2011-281 18:04:20.11' + tz2,    '2011-10-08T18:04:20.110' + tz],
            ['2011-281 18:04:20.111' + tz2,   '2011-10-08T18:04:20.111' + tz]
        ], i;
        for (i = 0; i < formats.length; i++) {
            assert.equal(moment(formats[i][0]).format('YYYY-MM-DDTHH:mm:ss.SSSZ'), formats[i][1], 'moment should be able to parse ISO ' + formats[i][0]);
        }
    });

    test('parsing iso week year/week/weekday', function (assert) {
        assert.equal(moment.utc('2007-W01').format(), '2007-01-01T00:00:00+00:00', '2008 week 1 (1st Jan Mon)');
        assert.equal(moment.utc('2008-W01').format(), '2007-12-31T00:00:00+00:00', '2008 week 1 (1st Jan Tue)');
        assert.equal(moment.utc('2003-W01').format(), '2002-12-30T00:00:00+00:00', '2008 week 1 (1st Jan Wed)');
        assert.equal(moment.utc('2009-W01').format(), '2008-12-29T00:00:00+00:00', '2009 week 1 (1st Jan Thu)');
        assert.equal(moment.utc('2010-W01').format(), '2010-01-04T00:00:00+00:00', '2010 week 1 (1st Jan Fri)');
        assert.equal(moment.utc('2011-W01').format(), '2011-01-03T00:00:00+00:00', '2011 week 1 (1st Jan Sat)');
        assert.equal(moment.utc('2012-W01').format(), '2012-01-02T00:00:00+00:00', '2012 week 1 (1st Jan Sun)');
    });

    test('parsing week year/week/weekday (dow 1, doy 4)', function (assert) {
        moment.locale('dow:1,doy:4', {week: {dow: 1, doy: 4}});

        assert.equal(moment.utc('2007-01', 'gggg-ww').format(), '2007-01-01T00:00:00+00:00', '2007 week 1 (1st Jan Mon)');
        assert.equal(moment.utc('2008-01', 'gggg-ww').format(), '2007-12-31T00:00:00+00:00', '2008 week 1 (1st Jan Tue)');
        assert.equal(moment.utc('2003-01', 'gggg-ww').format(), '2002-12-30T00:00:00+00:00', '2003 week 1 (1st Jan Wed)');
        assert.equal(moment.utc('2009-01', 'gggg-ww').format(), '2008-12-29T00:00:00+00:00', '2009 week 1 (1st Jan Thu)');
        assert.equal(moment.utc('2010-01', 'gggg-ww').format(), '2010-01-04T00:00:00+00:00', '2010 week 1 (1st Jan Fri)');
        assert.equal(moment.utc('2011-01', 'gggg-ww').format(), '2011-01-03T00:00:00+00:00', '2011 week 1 (1st Jan Sat)');
        assert.equal(moment.utc('2012-01', 'gggg-ww').format(), '2012-01-02T00:00:00+00:00', '2012 week 1 (1st Jan Sun)');

        moment.defineLocale('dow:1,doy:4', null);
    });

    test('parsing week year/week/weekday (dow 1, doy 7)', function (assert) {
        moment.locale('dow:1,doy:7', {week: {dow: 1, doy: 7}});

        assert.equal(moment.utc('2007-01', 'gggg-ww').format(), '2007-01-01T00:00:00+00:00', '2007 week 1 (1st Jan Mon)');
        assert.equal(moment.utc('2008-01', 'gggg-ww').format(), '2007-12-31T00:00:00+00:00', '2008 week 1 (1st Jan Tue)');
        assert.equal(moment.utc('2003-01', 'gggg-ww').format(), '2002-12-30T00:00:00+00:00', '2003 week 1 (1st Jan Wed)');
        assert.equal(moment.utc('2009-01', 'gggg-ww').format(), '2008-12-29T00:00:00+00:00', '2009 week 1 (1st Jan Thu)');
        assert.equal(moment.utc('2010-01', 'gggg-ww').format(), '2009-12-28T00:00:00+00:00', '2010 week 1 (1st Jan Fri)');
        assert.equal(moment.utc('2011-01', 'gggg-ww').format(), '2010-12-27T00:00:00+00:00', '2011 week 1 (1st Jan Sat)');
        assert.equal(moment.utc('2012-01', 'gggg-ww').format(), '2011-12-26T00:00:00+00:00', '2012 week 1 (1st Jan Sun)');
        moment.defineLocale('dow:1,doy:7', null);
    });

    test('parsing week year/week/weekday (dow 0, doy 6)', function (assert) {
        moment.locale('dow:0,doy:6', {week: {dow: 0, doy: 6}});

        assert.equal(moment.utc('2007-01', 'gggg-ww').format(), '2006-12-31T00:00:00+00:00', '2007 week 1 (1st Jan Mon)');
        assert.equal(moment.utc('2008-01', 'gggg-ww').format(), '2007-12-30T00:00:00+00:00', '2008 week 1 (1st Jan Tue)');
        assert.equal(moment.utc('2003-01', 'gggg-ww').format(), '2002-12-29T00:00:00+00:00', '2003 week 1 (1st Jan Wed)');
        assert.equal(moment.utc('2009-01', 'gggg-ww').format(), '2008-12-28T00:00:00+00:00', '2009 week 1 (1st Jan Thu)');
        assert.equal(moment.utc('2010-01', 'gggg-ww').format(), '2009-12-27T00:00:00+00:00', '2010 week 1 (1st Jan Fri)');
        assert.equal(moment.utc('2011-01', 'gggg-ww').format(), '2010-12-26T00:00:00+00:00', '2011 week 1 (1st Jan Sat)');
        assert.equal(moment.utc('2012-01', 'gggg-ww').format(), '2012-01-01T00:00:00+00:00', '2012 week 1 (1st Jan Sun)');
        moment.defineLocale('dow:0,doy:6', null);
    });

    test('parsing week year/week/weekday (dow 6, doy 12)', function (assert) {
        moment.locale('dow:6,doy:12', {week: {dow: 6, doy: 12}});

        assert.equal(moment.utc('2007-01', 'gggg-ww').format(), '2006-12-30T00:00:00+00:00', '2007 week 1 (1st Jan Mon)');
        assert.equal(moment.utc('2008-01', 'gggg-ww').format(), '2007-12-29T00:00:00+00:00', '2008 week 1 (1st Jan Tue)');
        assert.equal(moment.utc('2003-01', 'gggg-ww').format(), '2002-12-28T00:00:00+00:00', '2003 week 1 (1st Jan Wed)');
        assert.equal(moment.utc('2009-01', 'gggg-ww').format(), '2008-12-27T00:00:00+00:00', '2009 week 1 (1st Jan Thu)');
        assert.equal(moment.utc('2010-01', 'gggg-ww').format(), '2009-12-26T00:00:00+00:00', '2010 week 1 (1st Jan Fri)');
        assert.equal(moment.utc('2011-01', 'gggg-ww').format(), '2011-01-01T00:00:00+00:00', '2011 week 1 (1st Jan Sat)');
        assert.equal(moment.utc('2012-01', 'gggg-ww').format(), '2011-12-31T00:00:00+00:00', '2012 week 1 (1st Jan Sun)');
    });

    test('parsing ISO with Z', function (assert) {
        var i, mom, formats = [
            ['2011-10-08T18:04',             '2011-10-08T18:04:00.000'],
            ['2011-10-08T18:04:20',          '2011-10-08T18:04:20.000'],
            ['2011-10-08T18:04:20.1',        '2011-10-08T18:04:20.100'],
            ['2011-10-08T18:04:20.11',       '2011-10-08T18:04:20.110'],
            ['2011-10-08T18:04:20.111',      '2011-10-08T18:04:20.111'],
            ['2011-W40-6T18',                '2011-10-08T18:00:00.000'],
            ['2011-W40-6T18:04',             '2011-10-08T18:04:00.000'],
            ['2011-W40-6T18:04:20',          '2011-10-08T18:04:20.000'],
            ['2011-W40-6T18:04:20.1',        '2011-10-08T18:04:20.100'],
            ['2011-W40-6T18:04:20.11',       '2011-10-08T18:04:20.110'],
            ['2011-W40-6T18:04:20.111',      '2011-10-08T18:04:20.111'],
            ['2011-281T18',                  '2011-10-08T18:00:00.000'],
            ['2011-281T18:04',               '2011-10-08T18:04:00.000'],
            ['2011-281T18:04:20',            '2011-10-08T18:04:20.000'],
            ['2011-281T18:04:20',            '2011-10-08T18:04:20.000'],
            ['2011-281T18:04:20.1',          '2011-10-08T18:04:20.100'],
            ['2011-281T18:04:20.11',         '2011-10-08T18:04:20.110'],
            ['2011-281T18:04:20.111',        '2011-10-08T18:04:20.111']
        ];

        for (i = 0; i < formats.length; i++) {
            mom = moment(formats[i][0] + 'Z').utc();
            assert.equal(mom.format('YYYY-MM-DDTHH:mm:ss.SSS'), formats[i][1], 'moment should be able to parse ISO in UTC ' + formats[i][0] + 'Z');

            mom = moment(formats[i][0] + ' Z').utc();
            assert.equal(mom.format('YYYY-MM-DDTHH:mm:ss.SSS'), formats[i][1], 'moment should be able to parse ISO in UTC ' + formats[i][0] + ' Z');
        }
    });

    test('parsing iso with T', function (assert) {
        assert.equal(moment('2011-10-08T18')._f, 'YYYY-MM-DDTHH', 'should include \'T\' in the format');
        assert.equal(moment('2011-10-08T18:20')._f, 'YYYY-MM-DDTHH:mm', 'should include \'T\' in the format');
        assert.equal(moment('2011-10-08T18:20:13')._f, 'YYYY-MM-DDTHH:mm:ss', 'should include \'T\' in the format');
        assert.equal(moment('2011-10-08T18:20:13.321')._f, 'YYYY-MM-DDTHH:mm:ss.SSSS', 'should include \'T\' in the format');

        assert.equal(moment('2011-10-08 18')._f, 'YYYY-MM-DD HH', 'should not include \'T\' in the format');
        assert.equal(moment('2011-10-08 18:20')._f, 'YYYY-MM-DD HH:mm', 'should not include \'T\' in the format');
        assert.equal(moment('2011-10-08 18:20:13')._f, 'YYYY-MM-DD HH:mm:ss', 'should not include \'T\' in the format');
        assert.equal(moment('2011-10-08 18:20:13.321')._f, 'YYYY-MM-DD HH:mm:ss.SSSS', 'should not include \'T\' in the format');
    });

    test('parsing iso Z timezone', function (assert) {
        var i,
        formats = [
            ['2011-10-08T18:04Z',             '2011-10-08T18:04:00.000+00:00'],
            ['2011-10-08T18:04:20Z',          '2011-10-08T18:04:20.000+00:00'],
            ['2011-10-08T18:04:20.111Z',      '2011-10-08T18:04:20.111+00:00']
        ];
        for (i = 0; i < formats.length; i++) {
            assert.equal(moment.utc(formats[i][0]).format('YYYY-MM-DDTHH:mm:ss.SSSZ'), formats[i][1], 'moment should be able to parse ISO ' + formats[i][0]);
        }
    });

    test('parsing iso Z timezone into local', function (assert) {
        var m = moment('2011-10-08T18:04:20.111Z');

        assert.equal(m.utc().format('YYYY-MM-DDTHH:mm:ss.SSS'), '2011-10-08T18:04:20.111', 'moment should be able to parse ISO 2011-10-08T18:04:20.111Z');
    });

    test('parsing iso with more subsecond precision digits', function (assert) {
        assert.equal(moment.utc('2013-07-31T22:00:00.0000000Z').format(), '2013-07-31T22:00:00+00:00', 'more than 3 subsecond digits');
    });

    test('null or empty', function (assert) {
        assert.equal(moment('').isValid(), false, 'moment(\'\') is not valid');
        assert.equal(moment(null).isValid(), false, 'moment(null) is not valid');
        assert.equal(moment(null, 'YYYY-MM-DD').isValid(), false, 'moment(\'\', \'format\') is not valid');
        assert.equal(moment('', 'YYYY-MM-DD').isValid(), false, 'moment(\'\', \'format\') is not valid');
        assert.equal(moment.utc('').isValid(), false, 'moment.utc(\'\') is not valid');
        assert.equal(moment.utc(null).isValid(), false, 'moment.utc(null) is not valid');
        assert.equal(moment.utc(null, 'YYYY-MM-DD').isValid(), false, 'moment.utc(null) is not valid');
        assert.equal(moment.utc('', 'YYYY-MM-DD').isValid(), false, 'moment.utc(\'\', \'YYYY-MM-DD\') is not valid');
    });

    test('first century', function (assert) {
        assert.equal(moment([0, 0, 1]).format('YYYY-MM-DD'), '0000-01-01', 'Year AD 0');
        assert.equal(moment([99, 0, 1]).format('YYYY-MM-DD'), '0099-01-01', 'Year AD 99');
        assert.equal(moment([999, 0, 1]).format('YYYY-MM-DD'), '0999-01-01', 'Year AD 999');
        assert.equal(moment('0 1 1', 'YYYY MM DD').format('YYYY-MM-DD'), '0000-01-01', 'Year AD 0');
        assert.equal(moment('99 1 1', 'YYYY MM DD').format('YYYY-MM-DD'), '0099-01-01', 'Year AD 99');
        assert.equal(moment('999 1 1', 'YYYY MM DD').format('YYYY-MM-DD'), '0999-01-01', 'Year AD 999');
        assert.equal(moment('0 1 1', 'YYYYY MM DD').format('YYYYY-MM-DD'), '00000-01-01', 'Year AD 0');
        assert.equal(moment('99 1 1', 'YYYYY MM DD').format('YYYYY-MM-DD'), '00099-01-01', 'Year AD 99');
        assert.equal(moment('999 1 1', 'YYYYY MM DD').format('YYYYY-MM-DD'), '00999-01-01', 'Year AD 999');
    });

    test('six digit years', function (assert) {
        assert.equal(moment([-270000, 0, 1]).format('YYYYY-MM-DD'), '-270000-01-01', 'format BC 270,001');
        assert.equal(moment([270000, 0, 1]).format('YYYYY-MM-DD'), '270000-01-01', 'format AD 270,000');
        assert.equal(moment('-270000-01-01', 'YYYYY-MM-DD').toDate().getFullYear(), -270000, 'parse BC 270,001');
        assert.equal(moment('270000-01-01',  'YYYYY-MM-DD').toDate().getFullYear(), 270000, 'parse AD 270,000');
        assert.equal(moment('+270000-01-01', 'YYYYY-MM-DD').toDate().getFullYear(), 270000, 'parse AD +270,000');
        assert.equal(moment.utc('-270000-01-01', 'YYYYY-MM-DD').toDate().getUTCFullYear(), -270000, 'parse utc BC 270,001');
        assert.equal(moment.utc('270000-01-01',  'YYYYY-MM-DD').toDate().getUTCFullYear(), 270000, 'parse utc AD 270,000');
        assert.equal(moment.utc('+270000-01-01', 'YYYYY-MM-DD').toDate().getUTCFullYear(), 270000, 'parse utc AD +270,000');
    });

    test('negative four digit years', function (assert) {
        assert.equal(moment('-1000-01-01', 'YYYYY-MM-DD').toDate().getFullYear(), -1000, 'parse BC 1,001');
        assert.equal(moment.utc('-1000-01-01', 'YYYYY-MM-DD').toDate().getUTCFullYear(), -1000, 'parse utc BC 1,001');
    });

    test('strict parsing', function (assert) {
        assert.equal(moment('2014-', 'YYYY-Q', true).isValid(), false, 'fail missing quarter');

        assert.equal(moment('2012-05', 'YYYY-MM', true).format('YYYY-MM'), '2012-05', 'parse correct string');
        assert.equal(moment(' 2012-05', 'YYYY-MM', true).isValid(), false, 'fail on extra whitespace');
        assert.equal(moment('foo 2012-05', '[foo] YYYY-MM', true).format('YYYY-MM'), '2012-05', 'handle fixed text');
        assert.equal(moment('2012 05', 'YYYY-MM', true).isValid(), false, 'fail on different separator');
        assert.equal(moment('2012 05', 'YYYY MM DD', true).isValid(), false, 'fail on too many tokens');

        assert.equal(moment('05 30 2010', ['DD MM YYYY', 'MM DD YYYY'], true).format('MM DD YYYY'), '05 30 2010', 'array with bad date');
        assert.equal(moment('05 30 2010', ['', 'MM DD YYYY'], true).format('MM DD YYYY'), '05 30 2010', 'array with invalid format');
        assert.equal(moment('05 30 2010', [' DD MM YYYY', 'MM DD YYYY'], true).format('MM DD YYYY'), '05 30 2010', 'array with non-matching format');

        assert.equal(moment('2010.*...', 'YYYY.*', true).isValid(), false, 'invalid format with regex chars');
        assert.equal(moment('2010.*', 'YYYY.*', true).year(), 2010, 'valid format with regex chars');
        assert.equal(moment('.*2010.*', '.*YYYY.*', true).year(), 2010, 'valid format with regex chars on both sides');

        //strict tokens
        assert.equal(moment('-5-05-25', 'YYYY-MM-DD', true).isValid(), false, 'invalid negative year');
        assert.equal(moment('2-05-25', 'YYYY-MM-DD', true).isValid(), false, 'invalid one-digit year');
        assert.equal(moment('20-05-25', 'YYYY-MM-DD', true).isValid(), false, 'invalid two-digit year');
        assert.equal(moment('201-05-25', 'YYYY-MM-DD', true).isValid(), false, 'invalid three-digit year');
        assert.equal(moment('2010-05-25', 'YYYY-MM-DD', true).isValid(), true, 'valid four-digit year');
        assert.equal(moment('22010-05-25', 'YYYY-MM-DD', true).isValid(), false, 'invalid five-digit year');

        assert.equal(moment('12-05-25', 'YY-MM-DD', true).isValid(), true, 'valid two-digit year');
        assert.equal(moment('2012-05-25', 'YY-MM-DD', true).isValid(), false, 'invalid four-digit year');

        assert.equal(moment('-5-05-25', 'Y-MM-DD', true).isValid(), true, 'valid negative year');
        assert.equal(moment('2-05-25', 'Y-MM-DD', true).isValid(), true, 'valid one-digit year');
        assert.equal(moment('20-05-25', 'Y-MM-DD', true).isValid(), true, 'valid two-digit year');
        assert.equal(moment('201-05-25', 'Y-MM-DD', true).isValid(), true, 'valid three-digit year');

        assert.equal(moment('2012-5-25', 'YYYY-M-DD', true).isValid(), true, 'valid one-digit month');
        assert.equal(moment('2012-5-25', 'YYYY-MM-DD', true).isValid(), false, 'invalid one-digit month');
        assert.equal(moment('2012-05-25', 'YYYY-M-DD', true).isValid(), true, 'valid one-digit month');
        assert.equal(moment('2012-05-25', 'YYYY-MM-DD', true).isValid(), true, 'valid one-digit month');

        assert.equal(moment('2012-05-2', 'YYYY-MM-D', true).isValid(), true, 'valid one-digit day');
        assert.equal(moment('2012-05-2', 'YYYY-MM-DD', true).isValid(), false, 'invalid one-digit day');
        assert.equal(moment('2012-05-02', 'YYYY-MM-D', true).isValid(), true, 'valid two-digit day');
        assert.equal(moment('2012-05-02', 'YYYY-MM-DD', true).isValid(), true, 'valid two-digit day');

        assert.equal(moment('+002012-05-25', 'YYYYY-MM-DD', true).isValid(), true, 'valid six-digit year');
        assert.equal(moment('+2012-05-25', 'YYYYY-MM-DD', true).isValid(), false, 'invalid four-digit year');

        //thse are kinda pointless, but they should work as expected
        assert.equal(moment('1', 'S', true).isValid(), true, 'valid one-digit milisecond');
        assert.equal(moment('12', 'S', true).isValid(), false, 'invalid two-digit milisecond');
        assert.equal(moment('123', 'S', true).isValid(), false, 'invalid three-digit milisecond');

        assert.equal(moment('1', 'SS', true).isValid(), false, 'invalid one-digit milisecond');
        assert.equal(moment('12', 'SS', true).isValid(), true, 'valid two-digit milisecond');
        assert.equal(moment('123', 'SS', true).isValid(), false, 'invalid three-digit milisecond');

        assert.equal(moment('1', 'SSS', true).isValid(), false, 'invalid one-digit milisecond');
        assert.equal(moment('12', 'SSS', true).isValid(), false, 'invalid two-digit milisecond');
        assert.equal(moment('123', 'SSS', true).isValid(), true, 'valid three-digit milisecond');

        // strict parsing respects month length
        assert.ok(moment('1 January 2000', 'D MMMM YYYY', true).isValid(), 'capital long-month + MMMM');
        assert.ok(!moment('1 January 2000', 'D MMM YYYY', true).isValid(), 'capital long-month + MMM');
        assert.ok(!moment('1 Jan 2000', 'D MMMM YYYY', true).isValid(), 'capital short-month + MMMM');
        assert.ok(moment('1 Jan 2000', 'D MMM YYYY', true).isValid(), 'capital short-month + MMM');
        assert.ok(moment('1 january 2000', 'D MMMM YYYY', true).isValid(), 'lower long-month + MMMM');
        assert.ok(!moment('1 january 2000', 'D MMM YYYY', true).isValid(), 'lower long-month + MMM');
        assert.ok(!moment('1 jan 2000', 'D MMMM YYYY', true).isValid(), 'lower short-month + MMMM');
        assert.ok(moment('1 jan 2000', 'D MMM YYYY', true).isValid(), 'lower short-month + MMM');
    });

    test('parsing into a locale', function (assert) {
        moment.defineLocale('parselocale', {
            months : 'one_two_three_four_five_six_seven_eight_nine_ten_eleven_twelve'.split('_'),
            monthsShort : 'one_two_three_four_five_six_seven_eight_nine_ten_eleven_twelve'.split('_')
        });

        moment.locale('en');

        assert.equal(moment('2012 seven', 'YYYY MMM', 'parselocale').month(), 6, 'should be able to parse in a specific locale');

        moment.locale('parselocale');

        assert.equal(moment('2012 july', 'YYYY MMM', 'en').month(), 6, 'should be able to parse in a specific locale');

        moment.defineLocale('parselocale', null);
    });

    function getVerifier(test) {
        return function (input, format, expected, description, asymetrical) {
            var m = moment(input, format);
            test.equal(m.format('YYYY MM DD'), expected, 'compare: ' + description);

            //test round trip
            if (!asymetrical) {
                test.equal(m.format(format), input, 'round trip: ' + description);
            }
        };
    }

    test('parsing week and weekday information', function (assert) {
        var ver = getVerifier(assert);

        // year
        ver('12', 'gg', '2012 01 01', 'week-year two digits');
        ver('2012', 'gggg', '2012 01 01', 'week-year four digits');

        ver('99', 'gg', '1998 12 27', 'week-year two digits previous year');
        ver('1999', 'gggg', '1998 12 27', 'week-year four digits previous year');

        ver('99', 'GG', '1999 01 04', 'iso week-year two digits');
        ver('1999', 'GGGG', '1999 01 04', 'iso week-year four digits');

        ver('13', 'GG', '2012 12 31', 'iso week-year two digits previous year');
        ver('2013', 'GGGG', '2012 12 31', 'iso week-year four digits previous year');

        // year + week
        ver('1999 37', 'gggg w', '1999 09 05', 'week');
        ver('1999 37', 'gggg ww', '1999 09 05', 'week double');
        ver('1999 37', 'GGGG W', '1999 09 13', 'iso week');
        ver('1999 37', 'GGGG WW', '1999 09 13', 'iso week double');

        ver('1999 37 4', 'GGGG WW E', '1999 09 16', 'iso day');
        ver('1999 37 04', 'GGGG WW E', '1999 09 16', 'iso day wide', true);

        ver('1999 37 4', 'gggg ww e', '1999 09 09', 'day');
        ver('1999 37 04', 'gggg ww e', '1999 09 09', 'day wide', true);

        // year + week + day
        ver('1999 37 4', 'gggg ww d', '1999 09 09', 'd');
        ver('1999 37 Th', 'gggg ww dd', '1999 09 09', 'dd');
        ver('1999 37 Thu', 'gggg ww ddd', '1999 09 09', 'ddd');
        ver('1999 37 Thursday', 'gggg ww dddd', '1999 09 09', 'dddd');

        // lower-order only
        assert.equal(moment('22', 'ww').week(), 22, 'week sets the week by itself');
        assert.equal(moment('22', 'ww').weekYear(), moment().weekYear(), 'week keeps this year');
        assert.equal(moment('2012 22', 'YYYY ww').weekYear(), 2012, 'week keeps parsed year');

        assert.equal(moment('22', 'WW').isoWeek(), 22, 'iso week sets the week by itself');
        assert.equal(moment('2012 22', 'YYYY WW').weekYear(), 2012, 'iso week keeps parsed year');
        assert.equal(moment('22', 'WW').isoWeekYear(), moment().isoWeekYear(), 'iso week keeps this year');

        // order
        ver('6 2013 2', 'e gggg w', '2013 01 12', 'order doesn\'t matter');
        ver('6 2013 2', 'E GGGG W', '2013 01 12', 'iso order doesn\'t matter');

        //can parse other stuff too
        assert.equal(moment('1999-W37-4 3:30', 'GGGG-[W]WW-E HH:mm').format('YYYY MM DD HH:mm'), '1999 09 16 03:30', 'parsing weeks and hours');

        // In safari, all years before 1300 are shifted back with one day.
        // http://stackoverflow.com/questions/20768975/safari-subtracts-1-day-from-dates-before-1300
        if (new Date('1300-01-01').getUTCFullYear() === 1300) {
            // Years less than 100
            ver('0098-06', 'GGGG-WW', '0098 02 03', 'small years work', true);
        }
    });

    test('parsing localized weekdays', function (assert) {
        var ver = getVerifier(assert);
        try {
            moment.locale('dow:1,doy:4', {
                weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
                weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
                weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
                week: {dow: 1, doy: 4}
            });
            ver('1999 37 4', 'GGGG WW E', '1999 09 16', 'iso ignores locale');
            ver('1999 37 7', 'GGGG WW E', '1999 09 19', 'iso ignores locale');

            ver('1999 37 0', 'gggg ww e', '1999 09 13', 'localized e uses local doy and dow: 0 = monday');
            ver('1999 37 4', 'gggg ww e', '1999 09 17', 'localized e uses local doy and dow: 4 = friday');

            ver('1999 37 1', 'gggg ww d', '1999 09 13', 'localized d uses 0-indexed days: 1 = monday');
            ver('1999 37 Lu', 'gggg ww dd', '1999 09 13', 'localized d uses 0-indexed days: Mo');
            ver('1999 37 lun.', 'gggg ww ddd', '1999 09 13', 'localized d uses 0-indexed days: Mon');
            ver('1999 37 lundi', 'gggg ww dddd', '1999 09 13', 'localized d uses 0-indexed days: Monday');
            ver('1999 37 4', 'gggg ww d', '1999 09 16', 'localized d uses 0-indexed days: 4');

            //sunday goes at the end of the week
            ver('1999 37 0', 'gggg ww d', '1999 09 19', 'localized d uses 0-indexed days: 0 = sund');
            ver('1999 37 Di', 'gggg ww dd', '1999 09 19', 'localized d uses 0-indexed days: 0 = sund');
        }
        finally {
            moment.locale('en');
        }
    });

    test('parsing with customized two-digit year', function (assert) {
        var original = moment.parseTwoDigitYear;
        try {
            assert.equal(moment('68', 'YY').year(), 2068);
            assert.equal(moment('69', 'YY').year(), 1969);
            moment.parseTwoDigitYear = function (input) {
                return +input + (+input > 30 ? 1900 : 2000);
            };
            assert.equal(moment('68', 'YY').year(), 1968);
            assert.equal(moment('67', 'YY').year(), 1967);
            assert.equal(moment('31', 'YY').year(), 1931);
            assert.equal(moment('30', 'YY').year(), 2030);
        }
        finally {
            moment.parseTwoDigitYear = original;
        }
    });

    test('array with strings', function (assert) {
        assert.equal(moment(['2014', '7', '31']).isValid(), true, 'string array + isValid');
    });

    test('utc with array of formats', function (assert) {
        assert.equal(moment.utc('2014-01-01', ['YYYY-MM-DD', 'YYYY-MM']).format(), '2014-01-01T00:00:00+00:00', 'moment.utc works with array of formats');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    var helpers_each = each;

    module('days in month');

    test('days in month', function (assert) {
        helpers_each([31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], function (days, i) {
            var firstDay = moment([2012, i]),
                lastDay  = moment([2012, i, days]);
            assert.equal(firstDay.daysInMonth(), days, firstDay.format('L') + ' should have ' + days + ' days.');
            assert.equal(lastDay.daysInMonth(), days, lastDay.format('L') + ' should have ' + days + ' days.');
        });
    });

    test('days in month leap years', function (assert) {
        assert.equal(moment([2010, 1]).daysInMonth(), 28, 'Feb 2010 should have 28 days');
        assert.equal(moment([2100, 1]).daysInMonth(), 28, 'Feb 2100 should have 28 days');
        assert.equal(moment([2008, 1]).daysInMonth(), 29, 'Feb 2008 should have 29 days');
        assert.equal(moment([2000, 1]).daysInMonth(), 29, 'Feb 2000 should have 29 days');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function equal(assert, a, b, message) {
        assert.ok(Math.abs(a - b) < 0.00000001, '(' + a + ' === ' + b + ') ' + message);
    }

    function dstForYear(year) {
        var start = moment([year]),
            end = moment([year + 1]),
            current = start.clone(),
            last;

        while (current < end) {
            last = current.clone();
            current.add(24, 'hour');
            if (last.utcOffset() !== current.utcOffset()) {
                end = current.clone();
                current = last.clone();
                break;
            }
        }

        while (current < end) {
            last = current.clone();
            current.add(1, 'hour');
            if (last.utcOffset() !== current.utcOffset()) {
                return {
                    moment : last,
                    diff : -(current.utcOffset() - last.utcOffset()) / 60
                };
            }
        }
    }

    module('diff');

    test('diff', function (assert) {
        assert.equal(moment(1000).diff(0), 1000, '1 second - 0 = 1000');
        assert.equal(moment(1000).diff(500), 500, '1 second - 0.5 seconds = 500');
        assert.equal(moment(0).diff(1000), -1000, '0 - 1 second = -1000');
        assert.equal(moment(new Date(1000)).diff(1000), 0, '1 second - 1 second = 0');
        var oneHourDate = new Date(),
        nowDate = new Date(+oneHourDate);
        oneHourDate.setHours(oneHourDate.getHours() + 1);
        assert.equal(moment(oneHourDate).diff(nowDate), 60 * 60 * 1000, '1 hour from now = 3600000');
    });

    test('diff key after', function (assert) {
        assert.equal(moment([2010]).diff([2011], 'years'), -1, 'year diff');
        assert.equal(moment([2010]).diff([2010, 2], 'months'), -2, 'month diff');
        assert.equal(moment([2010]).diff([2010, 0, 7], 'weeks'), 0, 'week diff');
        assert.equal(moment([2010]).diff([2010, 0, 8], 'weeks'), -1, 'week diff');
        assert.equal(moment([2010]).diff([2010, 0, 21], 'weeks'), -2, 'week diff');
        assert.equal(moment([2010]).diff([2010, 0, 22], 'weeks'), -3, 'week diff');
        assert.equal(moment([2010]).diff([2010, 0, 4], 'days'), -3, 'day diff');
        assert.equal(moment([2010]).diff([2010, 0, 1, 4], 'hours'), -4, 'hour diff');
        assert.equal(moment([2010]).diff([2010, 0, 1, 0, 5], 'minutes'), -5, 'minute diff');
        assert.equal(moment([2010]).diff([2010, 0, 1, 0, 0, 6], 'seconds'), -6, 'second diff');
    });

    test('diff key before', function (assert) {
        assert.equal(moment([2011]).diff([2010], 'years'), 1, 'year diff');
        assert.equal(moment([2010, 2]).diff([2010], 'months'), 2, 'month diff');
        assert.equal(moment([2010, 0, 4]).diff([2010], 'days'), 3, 'day diff');
        assert.equal(moment([2010, 0, 7]).diff([2010], 'weeks'), 0, 'week diff');
        assert.equal(moment([2010, 0, 8]).diff([2010], 'weeks'), 1, 'week diff');
        assert.equal(moment([2010, 0, 21]).diff([2010], 'weeks'), 2, 'week diff');
        assert.equal(moment([2010, 0, 22]).diff([2010], 'weeks'), 3, 'week diff');
        assert.equal(moment([2010, 0, 1, 4]).diff([2010], 'hours'), 4, 'hour diff');
        assert.equal(moment([2010, 0, 1, 0, 5]).diff([2010], 'minutes'), 5, 'minute diff');
        assert.equal(moment([2010, 0, 1, 0, 0, 6]).diff([2010], 'seconds'), 6, 'second diff');
    });

    test('diff key before singular', function (assert) {
        assert.equal(moment([2011]).diff([2010], 'year'), 1, 'year diff singular');
        assert.equal(moment([2010, 2]).diff([2010], 'month'), 2, 'month diff singular');
        assert.equal(moment([2010, 0, 4]).diff([2010], 'day'), 3, 'day diff singular');
        assert.equal(moment([2010, 0, 7]).diff([2010], 'week'), 0, 'week diff singular');
        assert.equal(moment([2010, 0, 8]).diff([2010], 'week'), 1, 'week diff singular');
        assert.equal(moment([2010, 0, 21]).diff([2010], 'week'), 2, 'week diff singular');
        assert.equal(moment([2010, 0, 22]).diff([2010], 'week'), 3, 'week diff singular');
        assert.equal(moment([2010, 0, 1, 4]).diff([2010], 'hour'), 4, 'hour diff singular');
        assert.equal(moment([2010, 0, 1, 0, 5]).diff([2010], 'minute'), 5, 'minute diff singular');
        assert.equal(moment([2010, 0, 1, 0, 0, 6]).diff([2010], 'second'), 6, 'second diff singular');
    });

    test('diff key before abbreviated', function (assert) {
        assert.equal(moment([2011]).diff([2010], 'y'), 1, 'year diff abbreviated');
        assert.equal(moment([2010, 2]).diff([2010], 'M'), 2, 'month diff abbreviated');
        assert.equal(moment([2010, 0, 4]).diff([2010], 'd'), 3, 'day diff abbreviated');
        assert.equal(moment([2010, 0, 7]).diff([2010], 'w'), 0, 'week diff abbreviated');
        assert.equal(moment([2010, 0, 8]).diff([2010], 'w'), 1, 'week diff abbreviated');
        assert.equal(moment([2010, 0, 21]).diff([2010], 'w'), 2, 'week diff abbreviated');
        assert.equal(moment([2010, 0, 22]).diff([2010], 'w'), 3, 'week diff abbreviated');
        assert.equal(moment([2010, 0, 1, 4]).diff([2010], 'h'), 4, 'hour diff abbreviated');
        assert.equal(moment([2010, 0, 1, 0, 5]).diff([2010], 'm'), 5, 'minute diff abbreviated');
        assert.equal(moment([2010, 0, 1, 0, 0, 6]).diff([2010], 's'), 6, 'second diff abbreviated');
    });

    test('diff month', function (assert) {
        assert.equal(moment([2011, 0, 31]).diff([2011, 2, 1], 'months'), -1, 'month diff');
    });

    test('diff across DST', function (assert) {
        var dst = dstForYear(2012), a, b, daysInMonth;
        if (!dst) {
            assert.equal(42, 42, 'at least one assertion');
            return;
        }

        a = dst.moment;
        b = a.clone().utc().add(12, 'hours').local();
        daysInMonth = (a.daysInMonth() + b.daysInMonth()) / 2;
        assert.equal(b.diff(a, 'milliseconds', true), 12 * 60 * 60 * 1000,
                'ms diff across DST');
        assert.equal(b.diff(a, 'seconds', true), 12 * 60 * 60,
                'second diff across DST');
        assert.equal(b.diff(a, 'minutes', true), 12 * 60,
                'minute diff across DST');
        assert.equal(b.diff(a, 'hours', true), 12,
                'hour diff across DST');
        assert.equal(b.diff(a, 'days', true), (12 - dst.diff) / 24,
                'day diff across DST');
        equal(assert, b.diff(a, 'weeks', true),  (12 - dst.diff) / 24 / 7,
                'week diff across DST');
        assert.ok(0.95 / (2 * 31) < b.diff(a, 'months', true),
                'month diff across DST, lower bound');
        assert.ok(b.diff(a, 'month', true) < 1.05 / (2 * 28),
                'month diff across DST, upper bound');
        assert.ok(0.95 / (2 * 31 * 12) < b.diff(a, 'years', true),
                'year diff across DST, lower bound');
        assert.ok(b.diff(a, 'year', true) < 1.05 / (2 * 28 * 12),
                'year diff across DST, upper bound');

        a = dst.moment;
        b = a.clone().utc().add(12 + dst.diff, 'hours').local();
        daysInMonth = (a.daysInMonth() + b.daysInMonth()) / 2;

        assert.equal(b.diff(a, 'milliseconds', true),
                (12 + dst.diff) * 60 * 60 * 1000,
                'ms diff across DST');
        assert.equal(b.diff(a, 'seconds', true),  (12 + dst.diff) * 60 * 60,
                'second diff across DST');
        assert.equal(b.diff(a, 'minutes', true),  (12 + dst.diff) * 60,
                'minute diff across DST');
        assert.equal(b.diff(a, 'hours', true),  (12 + dst.diff),
                'hour diff across DST');
        assert.equal(b.diff(a, 'days', true),  12 / 24, 'day diff across DST');
        equal(assert, b.diff(a, 'weeks', true),  12 / 24 / 7,
                'week diff across DST');
        assert.ok(0.95 / (2 * 31) < b.diff(a, 'months', true),
                'month diff across DST, lower bound');
        assert.ok(b.diff(a, 'month', true) < 1.05 / (2 * 28),
                'month diff across DST, upper bound');
        assert.ok(0.95 / (2 * 31 * 12) < b.diff(a, 'years', true),
                'year diff across DST, lower bound');
        assert.ok(b.diff(a, 'year', true) < 1.05 / (2 * 28 * 12),
                'year diff across DST, upper bound');
    });

    test('diff overflow', function (assert) {
        assert.equal(moment([2011]).diff([2010], 'months'), 12, 'month diff');
        assert.equal(moment([2010, 0, 2]).diff([2010], 'hours'), 24, 'hour diff');
        assert.equal(moment([2010, 0, 1, 2]).diff([2010], 'minutes'), 120, 'minute diff');
        assert.equal(moment([2010, 0, 1, 0, 4]).diff([2010], 'seconds'), 240, 'second diff');
    });

    test('diff between utc and local', function (assert) {
        if (moment([2012]).utcOffset() === moment([2011]).utcOffset()) {
            // Russia's utc offset on 1st of Jan 2012 vs 2011 is different
            assert.equal(moment([2012]).utc().diff([2011], 'years'), 1, 'year diff');
        }
        assert.equal(moment([2010, 2, 2]).utc().diff([2010, 0, 2], 'months'), 2, 'month diff');
        assert.equal(moment([2010, 0, 4]).utc().diff([2010], 'days'), 3, 'day diff');
        assert.equal(moment([2010, 0, 22]).utc().diff([2010], 'weeks'), 3, 'week diff');
        assert.equal(moment([2010, 0, 1, 4]).utc().diff([2010], 'hours'), 4, 'hour diff');
        assert.equal(moment([2010, 0, 1, 0, 5]).utc().diff([2010], 'minutes'), 5, 'minute diff');
        assert.equal(moment([2010, 0, 1, 0, 0, 6]).utc().diff([2010], 'seconds'), 6, 'second diff');
    });

    test('diff floored', function (assert) {
        assert.equal(moment([2010, 0, 1, 23]).diff([2010], 'day'), 0, '23 hours = 0 days');
        assert.equal(moment([2010, 0, 1, 23, 59]).diff([2010], 'day'), 0, '23:59 hours = 0 days');
        assert.equal(moment([2010, 0, 1, 24]).diff([2010], 'day'), 1, '24 hours = 1 day');
        assert.equal(moment([2010, 0, 2]).diff([2011, 0, 1], 'year'), 0, 'year rounded down');
        assert.equal(moment([2011, 0, 1]).diff([2010, 0, 2], 'year'), 0, 'year rounded down');
        assert.equal(moment([2010, 0, 2]).diff([2011, 0, 2], 'year'), -1, 'year rounded down');
        assert.equal(moment([2011, 0, 2]).diff([2010, 0, 2], 'year'), 1, 'year rounded down');
    });

    test('year diffs include dates', function (assert) {
        assert.ok(moment([2012, 1, 19]).diff(moment([2002, 1, 20]), 'years', true) < 10, 'year diff should include date of month');
    });

    test('month diffs', function (assert) {
        // due to floating point math errors, these tests just need to be accurate within 0.00000001
        assert.equal(moment([2012, 0, 1]).diff([2012, 1, 1], 'months', true), -1, 'Jan 1 to Feb 1 should be 1 month');
        equal(assert, moment([2012, 0, 1]).diff([2012, 0, 1, 12], 'months', true), -0.5 / 31, 'Jan 1 to Jan 1 noon should be 0.5 / 31 months');
        assert.equal(moment([2012, 0, 15]).diff([2012, 1, 15], 'months', true), -1, 'Jan 15 to Feb 15 should be 1 month');
        assert.equal(moment([2012, 0, 28]).diff([2012, 1, 28], 'months', true), -1, 'Jan 28 to Feb 28 should be 1 month');
        assert.ok(moment([2012, 0, 31]).diff([2012, 1, 29], 'months', true), -1, 'Jan 31 to Feb 29 should be 1 month');
        assert.ok(-1 > moment([2012, 0, 31]).diff([2012, 2, 1], 'months', true), 'Jan 31 to Mar 1 should be more than 1 month');
        assert.ok(-30 / 28 < moment([2012, 0, 31]).diff([2012, 2, 1], 'months', true), 'Jan 31 to Mar 1 should be less than 1 month and 1 day');
        equal(assert, moment([2012, 0, 1]).diff([2012, 0, 31], 'months', true), -(30 / 31), 'Jan 1 to Jan 31 should be 30 / 31 months');
        assert.ok(0 < moment('2014-02-01').diff(moment('2014-01-31'), 'months', true), 'jan-31 to feb-1 diff is positive');
    });

    test('exact month diffs', function (assert) {
        // generate all pairs of months and compute month diff, with fixed day
        // of month = 15.

        var m1, m2;
        for (m1 = 0; m1 < 12; ++m1) {
            for (m2 = m1; m2 < 12; ++m2) {
                assert.equal(moment([2013, m2, 15]).diff(moment([2013, m1, 15]), 'months', true), m2 - m1,
                             'month diff from 2013-' + m1 + '-15 to 2013-' + m2 + '-15');
            }
        }
    });

    test('year diffs', function (assert) {
        // due to floating point math errors, these tests just need to be accurate within 0.00000001
        equal(assert, moment([2012, 0, 1]).diff([2013, 0, 1], 'years', true), -1, 'Jan 1 2012 to Jan 1 2013 should be 1 year');
        equal(assert, moment([2012, 1, 28]).diff([2013, 1, 28], 'years', true), -1, 'Feb 28 2012 to Feb 28 2013 should be 1 year');
        equal(assert, moment([2012, 2, 1]).diff([2013, 2, 1], 'years', true), -1, 'Mar 1 2012 to Mar 1 2013 should be 1 year');
        equal(assert, moment([2012, 11, 1]).diff([2013, 11, 1], 'years', true), -1, 'Dec 1 2012 to Dec 1 2013 should be 1 year');
        equal(assert, moment([2012, 11, 31]).diff([2013, 11, 31], 'years', true), -1, 'Dec 31 2012 to Dec 31 2013 should be 1 year');
        equal(assert, moment([2012, 0, 1]).diff([2013, 6, 1], 'years', true), -1.5, 'Jan 1 2012 to Jul 1 2013 should be 1.5 years');
        equal(assert, moment([2012, 0, 31]).diff([2013, 6, 31], 'years', true), -1.5, 'Jan 31 2012 to Jul 31 2013 should be 1.5 years');
        equal(assert, moment([2012, 0, 1]).diff([2013, 0, 1, 12], 'years', true), -1 - (0.5 / 31) / 12, 'Jan 1 2012 to Jan 1 2013 noon should be 1+(0.5 / 31) / 12 years');
        equal(assert, moment([2012, 0, 1]).diff([2013, 6, 1, 12], 'years', true), -1.5 - (0.5 / 31) / 12, 'Jan 1 2012 to Jul 1 2013 noon should be 1.5+(0.5 / 31) / 12 years');
        equal(assert, moment([2012, 1, 29]).diff([2013, 1, 28], 'years', true), -1, 'Feb 29 2012 to Feb 28 2013 should be 1-(1 / 28.5) / 12 years');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('duration');

    test('object instantiation', function (assert) {
        var d = moment.duration({
            years: 2,
            months: 3,
            weeks: 2,
            days: 1,
            hours: 8,
            minutes: 9,
            seconds: 20,
            milliseconds: 12
        });

        assert.equal(d.years(),        2,  'years');
        assert.equal(d.months(),       3,  'months');
        assert.equal(d.weeks(),        2,  'weeks');
        assert.equal(d.days(),         15, 'days'); // two weeks + 1 day
        assert.equal(d.hours(),        8,  'hours');
        assert.equal(d.minutes(),      9,  'minutes');
        assert.equal(d.seconds(),      20, 'seconds');
        assert.equal(d.milliseconds(), 12, 'milliseconds');
    });

    test('object instantiation with strings', function (assert) {
        var d = moment.duration({
            years: '2',
            months: '3',
            weeks: '2',
            days: '1',
            hours: '8',
            minutes: '9',
            seconds: '20',
            milliseconds: '12'
        });

        assert.equal(d.years(),        2,  'years');
        assert.equal(d.months(),       3,  'months');
        assert.equal(d.weeks(),        2,  'weeks');
        assert.equal(d.days(),         15, 'days'); // two weeks + 1 day
        assert.equal(d.hours(),        8,  'hours');
        assert.equal(d.minutes(),      9,  'minutes');
        assert.equal(d.seconds(),      20, 'seconds');
        assert.equal(d.milliseconds(), 12, 'milliseconds');
    });

    test('milliseconds instantiation', function (assert) {
        assert.equal(moment.duration(72).milliseconds(), 72, 'milliseconds');
    });

    test('undefined instantiation', function (assert) {
        assert.equal(moment.duration(undefined).milliseconds(), 0, 'milliseconds');
    });

    test('null instantiation', function (assert) {
        assert.equal(moment.duration(null).milliseconds(), 0, 'milliseconds');
    });

    test('instantiation by type', function (assert) {
        assert.equal(moment.duration(1, 'years').years(),                 1, 'years');
        assert.equal(moment.duration(1, 'y').years(),                     1, 'y');
        assert.equal(moment.duration(2, 'months').months(),               2, 'months');
        assert.equal(moment.duration(2, 'M').months(),                    2, 'M');
        assert.equal(moment.duration(3, 'weeks').weeks(),                 3, 'weeks');
        assert.equal(moment.duration(3, 'w').weeks(),                     3, 'weeks');
        assert.equal(moment.duration(4, 'days').days(),                   4, 'days');
        assert.equal(moment.duration(4, 'd').days(),                      4, 'd');
        assert.equal(moment.duration(5, 'hours').hours(),                 5, 'hours');
        assert.equal(moment.duration(5, 'h').hours(),                     5, 'h');
        assert.equal(moment.duration(6, 'minutes').minutes(),             6, 'minutes');
        assert.equal(moment.duration(6, 'm').minutes(),                   6, 'm');
        assert.equal(moment.duration(7, 'seconds').seconds(),             7, 'seconds');
        assert.equal(moment.duration(7, 's').seconds(),                   7, 's');
        assert.equal(moment.duration(8, 'milliseconds').milliseconds(),   8, 'milliseconds');
        assert.equal(moment.duration(8, 'ms').milliseconds(),             8, 'ms');
    });

    test('shortcuts', function (assert) {
        assert.equal(moment.duration({y: 1}).years(),         1, 'years = y');
        assert.equal(moment.duration({M: 2}).months(),        2, 'months = M');
        assert.equal(moment.duration({w: 3}).weeks(),         3, 'weeks = w');
        assert.equal(moment.duration({d: 4}).days(),          4, 'days = d');
        assert.equal(moment.duration({h: 5}).hours(),         5, 'hours = h');
        assert.equal(moment.duration({m: 6}).minutes(),       6, 'minutes = m');
        assert.equal(moment.duration({s: 7}).seconds(),       7, 'seconds = s');
        assert.equal(moment.duration({ms: 8}).milliseconds(), 8, 'milliseconds = ms');
    });

    test('generic getter', function (assert) {
        assert.equal(moment.duration(1, 'years').get('years'),                1, 'years');
        assert.equal(moment.duration(1, 'years').get('year'),                 1, 'years = year');
        assert.equal(moment.duration(1, 'years').get('y'),                    1, 'years = y');
        assert.equal(moment.duration(2, 'months').get('months'),              2, 'months');
        assert.equal(moment.duration(2, 'months').get('month'),               2, 'months = month');
        assert.equal(moment.duration(2, 'months').get('M'),                   2, 'months = M');
        assert.equal(moment.duration(3, 'weeks').get('weeks'),                3, 'weeks');
        assert.equal(moment.duration(3, 'weeks').get('week'),                 3, 'weeks = week');
        assert.equal(moment.duration(3, 'weeks').get('w'),                    3, 'weeks = w');
        assert.equal(moment.duration(4, 'days').get('days'),                  4, 'days');
        assert.equal(moment.duration(4, 'days').get('day'),                   4, 'days = day');
        assert.equal(moment.duration(4, 'days').get('d'),                     4, 'days = d');
        assert.equal(moment.duration(5, 'hours').get('hours'),                5, 'hours');
        assert.equal(moment.duration(5, 'hours').get('hour'),                 5, 'hours = hour');
        assert.equal(moment.duration(5, 'hours').get('h'),                    5, 'hours = h');
        assert.equal(moment.duration(6, 'minutes').get('minutes'),            6, 'minutes');
        assert.equal(moment.duration(6, 'minutes').get('minute'),             6, 'minutes = minute');
        assert.equal(moment.duration(6, 'minutes').get('m'),                  6, 'minutes = m');
        assert.equal(moment.duration(7, 'seconds').get('seconds'),            7, 'seconds');
        assert.equal(moment.duration(7, 'seconds').get('second'),             7, 'seconds = second');
        assert.equal(moment.duration(7, 'seconds').get('s'),                  7, 'seconds = s');
        assert.equal(moment.duration(8, 'milliseconds').get('milliseconds'),  8, 'milliseconds');
        assert.equal(moment.duration(8, 'milliseconds').get('millisecond'),   8, 'milliseconds = millisecond');
        assert.equal(moment.duration(8, 'milliseconds').get('ms'),            8, 'milliseconds = ms');
    });

    test('instantiation from another duration', function (assert) {
        var simple = moment.duration(1234),
            lengthy = moment.duration(60 * 60 * 24 * 360 * 1e3),
            complicated = moment.duration({
                years: 2,
                months: 3,
                weeks: 4,
                days: 1,
                hours: 8,
                minutes: 9,
                seconds: 20,
                milliseconds: 12
            }),
            modified = moment.duration(1, 'day').add(moment.duration(1, 'day'));

        assert.deepEqual(moment.duration(simple), simple, 'simple clones are equal');
        assert.deepEqual(moment.duration(lengthy), lengthy, 'lengthy clones are equal');
        assert.deepEqual(moment.duration(complicated), complicated, 'complicated clones are equal');
        assert.deepEqual(moment.duration(modified), modified, 'cloning modified duration works');
    });

    test('instantiation from 24-hour time zero', function (assert) {
        assert.equal(moment.duration('00:00').years(), 0, '0 years');
        assert.equal(moment.duration('00:00').days(), 0, '0 days');
        assert.equal(moment.duration('00:00').hours(), 0, '0 hours');
        assert.equal(moment.duration('00:00').minutes(), 0, '0 minutes');
        assert.equal(moment.duration('00:00').seconds(), 0, '0 seconds');
        assert.equal(moment.duration('00:00').milliseconds(), 0, '0 milliseconds');
    });

    test('instantiation from 24-hour time <24 hours', function (assert) {
        assert.equal(moment.duration('06:45').years(), 0, '0 years');
        assert.equal(moment.duration('06:45').days(), 0, '0 days');
        assert.equal(moment.duration('06:45').hours(), 6, '6 hours');
        assert.equal(moment.duration('06:45').minutes(), 45, '45 minutes');
        assert.equal(moment.duration('06:45').seconds(), 0, '0 seconds');
        assert.equal(moment.duration('06:45').milliseconds(), 0, '0 milliseconds');
    });

    test('instantiation from 24-hour time >24 hours', function (assert) {
        assert.equal(moment.duration('26:45').years(), 0, '0 years');
        assert.equal(moment.duration('26:45').days(), 1, '0 days');
        assert.equal(moment.duration('26:45').hours(), 2, '2 hours');
        assert.equal(moment.duration('26:45').minutes(), 45, '45 minutes');
        assert.equal(moment.duration('26:45').seconds(), 0, '0 seconds');
        assert.equal(moment.duration('26:45').milliseconds(), 0, '0 milliseconds');
    });

    test('instatiation from serialized C# TimeSpan zero', function (assert) {
        assert.equal(moment.duration('00:00:00').years(), 0, '0 years');
        assert.equal(moment.duration('00:00:00').days(), 0, '0 days');
        assert.equal(moment.duration('00:00:00').hours(), 0, '0 hours');
        assert.equal(moment.duration('00:00:00').minutes(), 0, '0 minutes');
        assert.equal(moment.duration('00:00:00').seconds(), 0, '0 seconds');
        assert.equal(moment.duration('00:00:00').milliseconds(), 0, '0 milliseconds');
    });

    test('instatiation from serialized C# TimeSpan with days', function (assert) {
        assert.equal(moment.duration('1.02:03:04.9999999').years(), 0, '0 years');
        assert.equal(moment.duration('1.02:03:04.9999999').days(), 1, '1 day');
        assert.equal(moment.duration('1.02:03:04.9999999').hours(), 2, '2 hours');
        assert.equal(moment.duration('1.02:03:04.9999999').minutes(), 3, '3 minutes');
        assert.equal(moment.duration('1.02:03:04.9999999').seconds(), 4, '4 seconds');
        assert.equal(moment.duration('1.02:03:04.9999999').milliseconds(), 999, '999 milliseconds');
    });

    test('instatiation from serialized C# TimeSpan without days', function (assert) {
        assert.equal(moment.duration('01:02:03.9999999').years(), 0, '0 years');
        assert.equal(moment.duration('01:02:03.9999999').days(), 0, '0 days');
        assert.equal(moment.duration('01:02:03.9999999').hours(), 1, '1 hour');
        assert.equal(moment.duration('01:02:03.9999999').minutes(), 2, '2 minutes');
        assert.equal(moment.duration('01:02:03.9999999').seconds(), 3, '3 seconds');
        assert.equal(moment.duration('01:02:03.9999999').milliseconds(), 999, '999 milliseconds');

        assert.equal(moment.duration('23:59:59.9999999').days(), 0, '0 days');
        assert.equal(moment.duration('23:59:59.9999999').hours(), 23, '23 hours');

        assert.equal(moment.duration('500:59:59.9999999').days(), 20, '500 hours overflows to 20 days');
        assert.equal(moment.duration('500:59:59.9999999').hours(), 20, '500 hours overflows to 20 hours');
    });

    test('instatiation from serialized C# TimeSpan without days or milliseconds', function (assert) {
        assert.equal(moment.duration('01:02:03').years(), 0, '0 years');
        assert.equal(moment.duration('01:02:03').days(), 0, '0 days');
        assert.equal(moment.duration('01:02:03').hours(), 1, '1 hour');
        assert.equal(moment.duration('01:02:03').minutes(), 2, '2 minutes');
        assert.equal(moment.duration('01:02:03').seconds(), 3, '3 seconds');
        assert.equal(moment.duration('01:02:03').milliseconds(), 0, '0 milliseconds');
    });

    test('instatiation from serialized C# TimeSpan without milliseconds', function (assert) {
        assert.equal(moment.duration('1.02:03:04').years(), 0, '0 years');
        assert.equal(moment.duration('1.02:03:04').days(), 1, '1 day');
        assert.equal(moment.duration('1.02:03:04').hours(), 2, '2 hours');
        assert.equal(moment.duration('1.02:03:04').minutes(), 3, '3 minutes');
        assert.equal(moment.duration('1.02:03:04').seconds(), 4, '4 seconds');
        assert.equal(moment.duration('1.02:03:04').milliseconds(), 0, '0 milliseconds');
    });

    test('instatiation from serialized C# TimeSpan maxValue', function (assert) {
        var d = moment.duration('10675199.02:48:05.4775807');

        assert.equal(d.years(), 29227, '29227 years');
        assert.equal(d.months(), 8, '8 months');
        assert.equal(d.days(), 17, '17 day');  // this should be 13

        assert.equal(d.hours(), 2, '2 hours');
        assert.equal(d.minutes(), 48, '48 minutes');
        assert.equal(d.seconds(), 5, '5 seconds');
        assert.equal(d.milliseconds(), 477, '477 milliseconds');
    });

    test('instatiation from serialized C# TimeSpan minValue', function (assert) {
        var d = moment.duration('-10675199.02:48:05.4775808');

        assert.equal(d.years(), -29227, '29653 years');
        assert.equal(d.months(), -8, '8 day');
        assert.equal(d.days(), -17, '17 day'); // this should be 13

        assert.equal(d.hours(), -2, '2 hours');
        assert.equal(d.minutes(), -48, '48 minutes');
        assert.equal(d.seconds(), -5, '5 seconds');
        assert.equal(d.milliseconds(), -477, '477 milliseconds');
    });

    test('instantiation from ISO 8601 duration', function (assert) {
        assert.equal(moment.duration('P1Y2M3DT4H5M6S').asSeconds(), moment.duration({y: 1, M: 2, d: 3, h: 4, m: 5, s: 6}).asSeconds(), 'all fields');
        assert.equal(moment.duration('P1M').asSeconds(), moment.duration({M: 1}).asSeconds(), 'single month field');
        assert.equal(moment.duration('PT1M').asSeconds(), moment.duration({m: 1}).asSeconds(), 'single minute field');
        assert.equal(moment.duration('P1MT2H').asSeconds(), moment.duration({M: 1, h: 2}).asSeconds(), 'random fields missing');
        assert.equal(moment.duration('-P60D').asSeconds(), moment.duration({d: -60}).asSeconds(), 'negative days');
        assert.equal(moment.duration('PT0.5S').asSeconds(), moment.duration({s: 0.5}).asSeconds(), 'fractional seconds');
        assert.equal(moment.duration('PT0,5S').asSeconds(), moment.duration({s: 0.5}).asSeconds(), 'fractional seconds (comma)');
    });

    test('serialization to ISO 8601 duration strings', function (assert) {
        assert.equal(moment.duration({y: 1, M: 2, d: 3, h: 4, m: 5, s: 6}).toISOString(), 'P1Y2M3DT4H5M6S', 'all fields');
        assert.equal(moment.duration({M: -1}).toISOString(), '-P1M', 'one month ago');
        assert.equal(moment.duration({m: -1}).toISOString(), '-PT1M', 'one minute ago');
        assert.equal(moment.duration({s: -0.5}).toISOString(), '-PT0.5S', 'one half second ago');
        assert.equal(moment.duration({y: -0.5, M: 1}).toISOString(), '-P5M', 'a month after half a year ago');
        assert.equal(moment.duration({}).toISOString(), 'P0D', 'zero duration');
    });

    test('toString acts as toISOString', function (assert) {
        assert.equal(moment.duration({y: 1, M: 2, d: 3, h: 4, m: 5, s: 6}).toString(), 'P1Y2M3DT4H5M6S', 'all fields');
        assert.equal(moment.duration({M: -1}).toString(), '-P1M', 'one month ago');
        assert.equal(moment.duration({m: -1}).toString(), '-PT1M', 'one minute ago');
        assert.equal(moment.duration({s: -0.5}).toString(), '-PT0.5S', 'one half second ago');
        assert.equal(moment.duration({y: -0.5, M: 1}).toString(), '-P5M', 'a month after half a year ago');
        assert.equal(moment.duration({}).toString(), 'P0D', 'zero duration');
    });

    test('toIsoString deprecation', function (assert) {
        assert.equal(moment.duration({}).toIsoString(), moment.duration({}).toISOString(), 'toIsoString delegates to toISOString');
    });

    test('`isodate` (python) test cases', function (assert) {
        assert.equal(moment.duration('P18Y9M4DT11H9M8S').asSeconds(), moment.duration({y: 18, M: 9, d: 4, h: 11, m: 9, s: 8}).asSeconds(), 'python isodate 1');
        assert.equal(moment.duration('P2W').asSeconds(), moment.duration({w: 2}).asSeconds(), 'python isodate 2');
        assert.equal(moment.duration('P3Y6M4DT12H30M5S').asSeconds(), moment.duration({y: 3, M: 6, d: 4, h: 12, m: 30, s: 5}).asSeconds(), 'python isodate 3');
        assert.equal(moment.duration('P23DT23H').asSeconds(), moment.duration({d: 23, h: 23}).asSeconds(), 'python isodate 4');
        assert.equal(moment.duration('P4Y').asSeconds(), moment.duration({y: 4}).asSeconds(), 'python isodate 5');
        assert.equal(moment.duration('P1M').asSeconds(), moment.duration({M: 1}).asSeconds(), 'python isodate 6');
        assert.equal(moment.duration('PT1M').asSeconds(), moment.duration({m: 1}).asSeconds(), 'python isodate 7');
        assert.equal(moment.duration('P0.5Y').asSeconds(), moment.duration({y: 0.5}).asSeconds(), 'python isodate 8');
        assert.equal(moment.duration('PT36H').asSeconds(), moment.duration({h: 36}).asSeconds(), 'python isodate 9');
        assert.equal(moment.duration('P1DT12H').asSeconds(), moment.duration({d: 1, h: 12}).asSeconds(), 'python isodate 10');
        assert.equal(moment.duration('-P2W').asSeconds(), moment.duration({w: -2}).asSeconds(), 'python isodate 11');
        assert.equal(moment.duration('-P2.2W').asSeconds(), moment.duration({w: -2.2}).asSeconds(), 'python isodate 12');
        assert.equal(moment.duration('P1DT2H3M4S').asSeconds(), moment.duration({d: 1, h: 2, m: 3, s: 4}).asSeconds(), 'python isodate 13');
        assert.equal(moment.duration('P1DT2H3M').asSeconds(), moment.duration({d: 1, h: 2, m: 3}).asSeconds(), 'python isodate 14');
        assert.equal(moment.duration('P1DT2H').asSeconds(), moment.duration({d: 1, h: 2}).asSeconds(), 'python isodate 15');
        assert.equal(moment.duration('PT2H').asSeconds(), moment.duration({h: 2}).asSeconds(), 'python isodate 16');
        assert.equal(moment.duration('PT2.3H').asSeconds(), moment.duration({h: 2.3}).asSeconds(), 'python isodate 17');
        assert.equal(moment.duration('PT2H3M4S').asSeconds(), moment.duration({h: 2, m: 3, s: 4}).asSeconds(), 'python isodate 18');
        assert.equal(moment.duration('PT3M4S').asSeconds(), moment.duration({m: 3, s: 4}).asSeconds(), 'python isodate 19');
        assert.equal(moment.duration('PT22S').asSeconds(), moment.duration({s: 22}).asSeconds(), 'python isodate 20');
        assert.equal(moment.duration('PT22.22S').asSeconds(), moment.duration({s: 22.22}).asSeconds(), 'python isodate 21');
        assert.equal(moment.duration('-P2Y').asSeconds(), moment.duration({y: -2}).asSeconds(), 'python isodate 22');
        assert.equal(moment.duration('-P3Y6M4DT12H30M5S').asSeconds(), moment.duration({y: -3, M: -6, d: -4, h: -12, m: -30, s: -5}).asSeconds(), 'python isodate 23');
        assert.equal(moment.duration('-P1DT2H3M4S').asSeconds(), moment.duration({d: -1, h: -2, m: -3, s: -4}).asSeconds(), 'python isodate 24');
    });

    test('ISO 8601 misuse cases', function (assert) {
        assert.equal(moment.duration('P').asSeconds(), 0, 'lonely P');
        assert.equal(moment.duration('PT').asSeconds(), 0, 'just P and T');
        assert.equal(moment.duration('P1H').asSeconds(), 0, 'missing T');
        assert.equal(moment.duration('P1D1Y').asSeconds(), 0, 'out of order');
        assert.equal(moment.duration('PT.5S').asSeconds(), 0.5, 'accept no leading zero for decimal');
        assert.equal(moment.duration('PT1,S').asSeconds(), 1, 'accept trailing decimal separator');
        assert.equal(moment.duration('PT1M0,,5S').asSeconds(), 60, 'extra decimal separators are ignored as 0');
        assert.equal(moment.duration('P-1DS').asSeconds(), 0, 'wrong position of negative');
    });

    test('humanize', function (assert) {
        moment.locale('en');
        assert.equal(moment.duration({seconds: 44}).humanize(),  'a few seconds', '44 seconds = a few seconds');
        assert.equal(moment.duration({seconds: 45}).humanize(),  'a minute',      '45 seconds = a minute');
        assert.equal(moment.duration({seconds: 89}).humanize(),  'a minute',      '89 seconds = a minute');
        assert.equal(moment.duration({seconds: 90}).humanize(),  '2 minutes',     '90 seconds = 2 minutes');
        assert.equal(moment.duration({minutes: 44}).humanize(),  '44 minutes',    '44 minutes = 44 minutes');
        assert.equal(moment.duration({minutes: 45}).humanize(),  'an hour',       '45 minutes = an hour');
        assert.equal(moment.duration({minutes: 89}).humanize(),  'an hour',       '89 minutes = an hour');
        assert.equal(moment.duration({minutes: 90}).humanize(),  '2 hours',       '90 minutes = 2 hours');
        assert.equal(moment.duration({hours: 5}).humanize(),     '5 hours',       '5 hours = 5 hours');
        assert.equal(moment.duration({hours: 21}).humanize(),    '21 hours',      '21 hours = 21 hours');
        assert.equal(moment.duration({hours: 22}).humanize(),    'a day',         '22 hours = a day');
        assert.equal(moment.duration({hours: 35}).humanize(),    'a day',         '35 hours = a day');
        assert.equal(moment.duration({hours: 36}).humanize(),    '2 days',        '36 hours = 2 days');
        assert.equal(moment.duration({days: 1}).humanize(),      'a day',         '1 day = a day');
        assert.equal(moment.duration({days: 5}).humanize(),      '5 days',        '5 days = 5 days');
        assert.equal(moment.duration({weeks: 1}).humanize(),     '7 days',        '1 week = 7 days');
        assert.equal(moment.duration({days: 25}).humanize(),     '25 days',       '25 days = 25 days');
        assert.equal(moment.duration({days: 26}).humanize(),     'a month',       '26 days = a month');
        assert.equal(moment.duration({days: 30}).humanize(),     'a month',       '30 days = a month');
        assert.equal(moment.duration({days: 45}).humanize(),     'a month',       '45 days = a month');
        assert.equal(moment.duration({days: 46}).humanize(),     '2 months',      '46 days = 2 months');
        assert.equal(moment.duration({days: 74}).humanize(),     '2 months',      '74 days = 2 months');
        assert.equal(moment.duration({days: 77}).humanize(),     '3 months',      '77 days = 3 months');
        assert.equal(moment.duration({months: 1}).humanize(),    'a month',       '1 month = a month');
        assert.equal(moment.duration({months: 5}).humanize(),    '5 months',      '5 months = 5 months');
        assert.equal(moment.duration({days: 344}).humanize(),    'a year',        '344 days = a year');
        assert.equal(moment.duration({days: 345}).humanize(),    'a year',        '345 days = a year');
        assert.equal(moment.duration({days: 547}).humanize(),    'a year',        '547 days = a year');
        assert.equal(moment.duration({days: 548}).humanize(),    '2 years',       '548 days = 2 years');
        assert.equal(moment.duration({years: 1}).humanize(),     'a year',        '1 year = a year');
        assert.equal(moment.duration({years: 5}).humanize(),     '5 years',       '5 years = 5 years');
        assert.equal(moment.duration(7200000).humanize(),        '2 hours',       '7200000 = 2 minutes');
    });

    test('humanize duration with suffix', function (assert) {
        moment.locale('en');
        assert.equal(moment.duration({seconds:  44}).humanize(true),  'in a few seconds', '44 seconds = a few seconds');
        assert.equal(moment.duration({seconds: -44}).humanize(true),  'a few seconds ago', '44 seconds = a few seconds');
    });

    test('bubble value up', function (assert) {
        assert.equal(moment.duration({milliseconds: 61001}).milliseconds(), 1, '61001 milliseconds has 1 millisecond left over');
        assert.equal(moment.duration({milliseconds: 61001}).seconds(),      1, '61001 milliseconds has 1 second left over');
        assert.equal(moment.duration({milliseconds: 61001}).minutes(),      1, '61001 milliseconds has 1 minute left over');

        assert.equal(moment.duration({minutes: 350}).minutes(), 50, '350 minutes has 50 minutes left over');
        assert.equal(moment.duration({minutes: 350}).hours(),   5,  '350 minutes has 5 hours left over');
    });

    test('clipping', function (assert) {
        assert.equal(moment.duration({months: 11}).months(), 11, '11 months is 11 months');
        assert.equal(moment.duration({months: 11}).years(),  0,  '11 months makes no year');
        assert.equal(moment.duration({months: 12}).months(), 0,  '12 months is 0 months left over');
        assert.equal(moment.duration({months: 12}).years(),  1,  '12 months makes 1 year');
        assert.equal(moment.duration({months: 13}).months(), 1,  '13 months is 1 month left over');
        assert.equal(moment.duration({months: 13}).years(),  1,  '13 months makes 1 year');

        assert.equal(moment.duration({days: 29}).days(),   29, '29 days is 29 days');
        assert.equal(moment.duration({days: 29}).months(), 0,  '29 days makes no month');
        assert.equal(moment.duration({days: 30}).days(),   0,  '30 days is 0 days left over');
        assert.equal(moment.duration({days: 30}).months(), 1,  '30 days is a month');
        assert.equal(moment.duration({days: 31}).days(),   1,  '31 days is 1 day left over');
        assert.equal(moment.duration({days: 31}).months(), 1,  '31 days is a month');

        assert.equal(moment.duration({hours: 23}).hours(), 23, '23 hours is 23 hours');
        assert.equal(moment.duration({hours: 23}).days(),  0,  '23 hours makes no day');
        assert.equal(moment.duration({hours: 24}).hours(), 0,  '24 hours is 0 hours left over');
        assert.equal(moment.duration({hours: 24}).days(),  1,  '24 hours makes 1 day');
        assert.equal(moment.duration({hours: 25}).hours(), 1,  '25 hours is 1 hour left over');
        assert.equal(moment.duration({hours: 25}).days(),  1,  '25 hours makes 1 day');
    });

    test('effective equivalency', function (assert) {
        assert.deepEqual(moment.duration({seconds: 1})._data,  moment.duration({milliseconds: 1000})._data, '1 second is the same as 1000 milliseconds');
        assert.deepEqual(moment.duration({seconds: 60})._data, moment.duration({minutes: 1})._data,         '1 minute is the same as 60 seconds');
        assert.deepEqual(moment.duration({minutes: 60})._data, moment.duration({hours: 1})._data,           '1 hour is the same as 60 minutes');
        assert.deepEqual(moment.duration({hours: 24})._data,   moment.duration({days: 1})._data,            '1 day is the same as 24 hours');
        assert.deepEqual(moment.duration({days: 7})._data,     moment.duration({weeks: 1})._data,           '1 week is the same as 7 days');
        assert.deepEqual(moment.duration({days: 30})._data,    moment.duration({months: 1})._data,          '1 month is the same as 30 days');
        assert.deepEqual(moment.duration({months: 12})._data,  moment.duration({years: 1})._data,           '1 years is the same as 12 months');
    });

    test('asGetters', function (assert) {
        // 400 years have exactly 146097 days

        // years
        assert.equal(moment.duration(1, 'year').asYears(),            1,           '1 year as years');
        assert.equal(moment.duration(1, 'year').asMonths(),           12,          '1 year as months');
        assert.equal(moment.duration(400, 'year').asMonths(),         4800,        '400 years as months');
        assert.equal(moment.duration(1, 'year').asWeeks().toFixed(3), 52.143,      '1 year as weeks');
        assert.equal(moment.duration(1, 'year').asDays(),             365,         '1 year as days');
        assert.equal(moment.duration(2, 'year').asDays(),             730,         '2 years as days');
        assert.equal(moment.duration(3, 'year').asDays(),             1096,        '3 years as days');
        assert.equal(moment.duration(4, 'year').asDays(),             1461,        '4 years as days');
        assert.equal(moment.duration(400, 'year').asDays(),           146097,      '400 years as days');
        assert.equal(moment.duration(1, 'year').asHours(),            8760,        '1 year as hours');
        assert.equal(moment.duration(1, 'year').asMinutes(),          525600,      '1 year as minutes');
        assert.equal(moment.duration(1, 'year').asSeconds(),          31536000,    '1 year as seconds');
        assert.equal(moment.duration(1, 'year').asMilliseconds(),     31536000000, '1 year as milliseconds');

        // months
        assert.equal(moment.duration(1, 'month').asYears().toFixed(4), 0.0833,     '1 month as years');
        assert.equal(moment.duration(1, 'month').asMonths(),           1,          '1 month as months');
        assert.equal(moment.duration(1, 'month').asWeeks().toFixed(3), 4.286,      '1 month as weeks');
        assert.equal(moment.duration(1, 'month').asDays(),             30,         '1 month as days');
        assert.equal(moment.duration(2, 'month').asDays(),             61,         '2 months as days');
        assert.equal(moment.duration(3, 'month').asDays(),             91,         '3 months as days');
        assert.equal(moment.duration(4, 'month').asDays(),             122,        '4 months as days');
        assert.equal(moment.duration(5, 'month').asDays(),             152,        '5 months as days');
        assert.equal(moment.duration(6, 'month').asDays(),             183,        '6 months as days');
        assert.equal(moment.duration(7, 'month').asDays(),             213,        '7 months as days');
        assert.equal(moment.duration(8, 'month').asDays(),             243,        '8 months as days');
        assert.equal(moment.duration(9, 'month').asDays(),             274,        '9 months as days');
        assert.equal(moment.duration(10, 'month').asDays(),            304,        '10 months as days');
        assert.equal(moment.duration(11, 'month').asDays(),            335,        '11 months as days');
        assert.equal(moment.duration(12, 'month').asDays(),            365,        '12 months as days');
        assert.equal(moment.duration(24, 'month').asDays(),            730,        '24 months as days');
        assert.equal(moment.duration(36, 'month').asDays(),            1096,       '36 months as days');
        assert.equal(moment.duration(48, 'month').asDays(),            1461,       '48 months as days');
        assert.equal(moment.duration(4800, 'month').asDays(),          146097,     '4800 months as days');
        assert.equal(moment.duration(1, 'month').asHours(),            720,        '1 month as hours');
        assert.equal(moment.duration(1, 'month').asMinutes(),          43200,      '1 month as minutes');
        assert.equal(moment.duration(1, 'month').asSeconds(),          2592000,    '1 month as seconds');
        assert.equal(moment.duration(1, 'month').asMilliseconds(),     2592000000, '1 month as milliseconds');

        // weeks
        assert.equal(moment.duration(1, 'week').asYears().toFixed(4),  0.0192,    '1 week as years');
        assert.equal(moment.duration(1, 'week').asMonths().toFixed(3), 0.230,     '1 week as months');
        assert.equal(moment.duration(1, 'week').asWeeks(),             1,         '1 week as weeks');
        assert.equal(moment.duration(1, 'week').asDays(),              7,         '1 week as days');
        assert.equal(moment.duration(1, 'week').asHours(),             168,       '1 week as hours');
        assert.equal(moment.duration(1, 'week').asMinutes(),           10080,     '1 week as minutes');
        assert.equal(moment.duration(1, 'week').asSeconds(),           604800,    '1 week as seconds');
        assert.equal(moment.duration(1, 'week').asMilliseconds(),      604800000, '1 week as milliseconds');

        // days
        assert.equal(moment.duration(1, 'day').asYears().toFixed(4),  0.0027,   '1 day as years');
        assert.equal(moment.duration(1, 'day').asMonths().toFixed(3), 0.033,    '1 day as months');
        assert.equal(moment.duration(1, 'day').asWeeks().toFixed(3),  0.143,    '1 day as weeks');
        assert.equal(moment.duration(1, 'day').asDays(),              1,        '1 day as days');
        assert.equal(moment.duration(1, 'day').asHours(),             24,       '1 day as hours');
        assert.equal(moment.duration(1, 'day').asMinutes(),           1440,     '1 day as minutes');
        assert.equal(moment.duration(1, 'day').asSeconds(),           86400,    '1 day as seconds');
        assert.equal(moment.duration(1, 'day').asMilliseconds(),      86400000, '1 day as milliseconds');

        // hours
        assert.equal(moment.duration(1, 'hour').asYears().toFixed(6),  0.000114, '1 hour as years');
        assert.equal(moment.duration(1, 'hour').asMonths().toFixed(5), 0.00137,  '1 hour as months');
        assert.equal(moment.duration(1, 'hour').asWeeks().toFixed(5),  0.00595,  '1 hour as weeks');
        assert.equal(moment.duration(1, 'hour').asDays().toFixed(4),   0.0417,   '1 hour as days');
        assert.equal(moment.duration(1, 'hour').asHours(),             1,        '1 hour as hours');
        assert.equal(moment.duration(1, 'hour').asMinutes(),           60,       '1 hour as minutes');
        assert.equal(moment.duration(1, 'hour').asSeconds(),           3600,     '1 hour as seconds');
        assert.equal(moment.duration(1, 'hour').asMilliseconds(),      3600000,  '1 hour as milliseconds');

        // minutes
        assert.equal(moment.duration(1, 'minute').asYears().toFixed(8),  0.00000190, '1 minute as years');
        assert.equal(moment.duration(1, 'minute').asMonths().toFixed(7), 0.0000228,  '1 minute as months');
        assert.equal(moment.duration(1, 'minute').asWeeks().toFixed(7),  0.0000992,  '1 minute as weeks');
        assert.equal(moment.duration(1, 'minute').asDays().toFixed(6),   0.000694,   '1 minute as days');
        assert.equal(moment.duration(1, 'minute').asHours().toFixed(4),  0.0167,     '1 minute as hours');
        assert.equal(moment.duration(1, 'minute').asMinutes(),           1,          '1 minute as minutes');
        assert.equal(moment.duration(1, 'minute').asSeconds(),           60,         '1 minute as seconds');
        assert.equal(moment.duration(1, 'minute').asMilliseconds(),      60000,      '1 minute as milliseconds');

        // seconds
        assert.equal(moment.duration(1, 'second').asYears().toFixed(10),  0.0000000317, '1 second as years');
        assert.equal(moment.duration(1, 'second').asMonths().toFixed(9),  0.000000380,  '1 second as months');
        assert.equal(moment.duration(1, 'second').asWeeks().toFixed(8),   0.00000165,   '1 second as weeks');
        assert.equal(moment.duration(1, 'second').asDays().toFixed(7),    0.0000116,    '1 second as days');
        assert.equal(moment.duration(1, 'second').asHours().toFixed(6),   0.000278,     '1 second as hours');
        assert.equal(moment.duration(1, 'second').asMinutes().toFixed(4), 0.0167,       '1 second as minutes');
        assert.equal(moment.duration(1, 'second').asSeconds(),            1,            '1 second as seconds');
        assert.equal(moment.duration(1, 'second').asMilliseconds(),       1000,         '1 second as milliseconds');

        // milliseconds
        assert.equal(moment.duration(1, 'millisecond').asYears().toFixed(13),  0.0000000000317, '1 millisecond as years');
        assert.equal(moment.duration(1, 'millisecond').asMonths().toFixed(12), 0.000000000380,  '1 millisecond as months');
        assert.equal(moment.duration(1, 'millisecond').asWeeks().toFixed(11),  0.00000000165,   '1 millisecond as weeks');
        assert.equal(moment.duration(1, 'millisecond').asDays().toFixed(10),   0.0000000116,    '1 millisecond as days');
        assert.equal(moment.duration(1, 'millisecond').asHours().toFixed(9),   0.000000278,     '1 millisecond as hours');
        assert.equal(moment.duration(1, 'millisecond').asMinutes().toFixed(7), 0.0000167,       '1 millisecond as minutes');
        assert.equal(moment.duration(1, 'millisecond').asSeconds(),            0.001,           '1 millisecond as seconds');
        assert.equal(moment.duration(1, 'millisecond').asMilliseconds(),       1,               '1 millisecond as milliseconds');
    });

    test('as getters for small units', function (assert) {
        var dS = moment.duration(1, 'milliseconds'),
            ds = moment.duration(3, 'seconds'),
            dm = moment.duration(13, 'minutes');

        // Tests for issue #1867.
        // Floating point errors for small duration units were introduced in version 2.8.0.
        assert.equal(dS.as('milliseconds'), 1, 'as("milliseconds")');
        assert.equal(dS.asMilliseconds(),   1, 'asMilliseconds()');
        assert.equal(ds.as('seconds'),      3, 'as("seconds")');
        assert.equal(ds.asSeconds(),        3, 'asSeconds()');
        assert.equal(dm.as('minutes'),      13, 'as("minutes")');
        assert.equal(dm.asMinutes(),        13, 'asMinutes()');
    });

    test('isDuration', function (assert) {
        assert.ok(moment.isDuration(moment.duration(12345678)), 'correctly says true');
        assert.ok(!moment.isDuration(moment()), 'moment object is not a duration');
        assert.ok(!moment.isDuration({milliseconds: 1}), 'plain object is not a duration');
    });

    test('add', function (assert) {
        var d = moment.duration({months: 4, weeks: 3, days: 2});
        // for some reason, d._data._months does not get updated; use d._months instead.
        assert.equal(d.add(1, 'month')._months, 5, 'Add months');
        assert.equal(d.add(5, 'days')._days, 28, 'Add days');
        assert.equal(d.add(10000)._milliseconds, 10000, 'Add milliseconds');
        assert.equal(d.add({h: 23, m: 59})._milliseconds, 23 * 60 * 60 * 1000 + 59 * 60 * 1000 + 10000, 'Add hour:minute');
    });

    test('add and bubble', function (assert) {
        assert.equal(moment.duration(1, 'second').add(1000, 'milliseconds').seconds(), 2, 'Adding milliseconds should bubble up to seconds');
        assert.equal(moment.duration(1, 'minute').add(60, 'second').minutes(), 2, 'Adding seconds should bubble up to minutes');
        assert.equal(moment.duration(1, 'hour').add(60, 'minutes').hours(), 2, 'Adding minutes should bubble up to hours');
        assert.equal(moment.duration(1, 'day').add(24, 'hours').days(), 2, 'Adding hours should bubble up to days');
    });

    test('subtract and bubble', function (assert) {
        assert.equal(moment.duration(2, 'second').subtract(1000, 'milliseconds').seconds(), 1, 'Subtracting milliseconds should bubble up to seconds');
        assert.equal(moment.duration(2, 'minute').subtract(60, 'second').minutes(), 1, 'Subtracting seconds should bubble up to minutes');
        assert.equal(moment.duration(2, 'hour').subtract(60, 'minutes').hours(), 1, 'Subtracting minutes should bubble up to hours');
        assert.equal(moment.duration(2, 'day').subtract(24, 'hours').days(), 1, 'Subtracting hours should bubble up to days');
    });

    test('subtract', function (assert) {
        var d = moment.duration({months: 2, weeks: 2, days: 0, hours: 5});
        // for some reason, d._data._months does not get updated; use d._months instead.
        assert.equal(d.subtract(1, 'months')._months, 1, 'Subtract months');
        assert.equal(d.subtract(14, 'days')._days, 0, 'Subtract days');
        assert.equal(d.subtract(10000)._milliseconds, 5 * 60 * 60 * 1000 - 10000, 'Subtract milliseconds');
        assert.equal(d.subtract({h: 1, m: 59})._milliseconds, 3 * 60 * 60 * 1000 + 1 * 60 * 1000 - 10000, 'Subtract hour:minute');
    });

    test('JSON.stringify duration', function (assert) {
        var d = moment.duration(1024, 'h');

        assert.equal(JSON.stringify(d), '"' + d.toISOString() + '"', 'JSON.stringify on duration should return ISO string');
    });

    test('duration plugins', function (assert) {
        var durationObject = moment.duration();
        moment.duration.fn.foo = function (arg) {
            assert.equal(this, durationObject);
            assert.equal(arg, 5);
        };
        durationObject.foo(5);
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('duration from moments');

    test('pure year diff', function (assert) {
        var m1 = moment('2012-01-01T00:00:00.000Z'),
            m2 = moment('2013-01-01T00:00:00.000Z');

        assert.equal(moment.duration({from: m1, to: m2}).as('years'), 1, 'year moment difference');
        assert.equal(moment.duration({from: m2, to: m1}).as('years'), -1, 'negative year moment difference');
    });

    test('month and day diff', function (assert) {
        var m1 = moment('2012-01-15T00:00:00.000Z'),
            m2 = moment('2012-02-17T00:00:00.000Z'),
            d = moment.duration({from: m1, to: m2});

        assert.equal(d.get('days'), 2);
        assert.equal(d.get('months'), 1);
    });

    test('day diff, separate months', function (assert) {
        var m1 = moment('2012-01-15T00:00:00.000Z'),
            m2 = moment('2012-02-13T00:00:00.000Z'),
            d = moment.duration({from: m1, to: m2});

        assert.equal(d.as('days'), 29);
    });

    test('hour diff', function (assert) {
        var m1 = moment('2012-01-15T17:00:00.000Z'),
            m2 = moment('2012-01-16T03:00:00.000Z'),
            d = moment.duration({from: m1, to: m2});

        assert.equal(d.as('hours'), 10);
    });

    test('minute diff', function (assert) {
        var m1 = moment('2012-01-15T17:45:00.000Z'),
            m2 = moment('2012-01-16T03:15:00.000Z'),
            d = moment.duration({from: m1, to: m2});

        assert.equal(d.as('hours'), 9.5);
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('format');

    test('format YY', function (assert) {
        var b = moment(new Date(2009, 1, 14, 15, 25, 50, 125));
        assert.equal(b.format('YY'), '09', 'YY ---> 09');
    });

    test('format escape brackets', function (assert) {
        moment.locale('en');

        var b = moment(new Date(2009, 1, 14, 15, 25, 50, 125));
        assert.equal(b.format('[day]'), 'day', 'Single bracket');
        assert.equal(b.format('[day] YY [YY]'), 'day 09 YY', 'Double bracket');
        assert.equal(b.format('[YY'), '[09', 'Un-ended bracket');
        assert.equal(b.format('[[YY]]'), '[YY]', 'Double nested brackets');
        assert.equal(b.format('[[]'), '[', 'Escape open bracket');
        assert.equal(b.format('[Last]'), 'Last', 'localized tokens');
        assert.equal(b.format('[L] L'), 'L 02/14/2009', 'localized tokens with escaped localized tokens');
        assert.equal(b.format('[L LL LLL LLLL aLa]'), 'L LL LLL LLLL aLa', 'localized tokens with escaped localized tokens');
        assert.equal(b.format('[LLL] LLL'), 'LLL February 14, 2009 3:25 PM', 'localized tokens with escaped localized tokens (recursion)');
        assert.equal(b.format('YYYY[\n]DD[\n]'), '2009\n14\n', 'Newlines');
    });

    test('handle negative years', function (assert) {
        moment.locale('en');
        assert.equal(moment.utc().year(-1).format('YY'), '-01', 'YY with negative year');
        assert.equal(moment.utc().year(-1).format('YYYY'), '-0001', 'YYYY with negative year');
        assert.equal(moment.utc().year(-12).format('YY'), '-12', 'YY with negative year');
        assert.equal(moment.utc().year(-12).format('YYYY'), '-0012', 'YYYY with negative year');
        assert.equal(moment.utc().year(-123).format('YY'), '-23', 'YY with negative year');
        assert.equal(moment.utc().year(-123).format('YYYY'), '-0123', 'YYYY with negative year');
        assert.equal(moment.utc().year(-1234).format('YY'), '-34', 'YY with negative year');
        assert.equal(moment.utc().year(-1234).format('YYYY'), '-1234', 'YYYY with negative year');
        assert.equal(moment.utc().year(-12345).format('YY'), '-45', 'YY with negative year');
        assert.equal(moment.utc().year(-12345).format('YYYY'), '-12345', 'YYYY with negative year');
    });

    test('format milliseconds', function (assert) {
        var b = moment(new Date(2009, 1, 14, 15, 25, 50, 123));
        assert.equal(b.format('S'), '1', 'Deciseconds');
        assert.equal(b.format('SS'), '12', 'Centiseconds');
        assert.equal(b.format('SSS'), '123', 'Milliseconds');
        b.milliseconds(789);
        assert.equal(b.format('S'), '7', 'Deciseconds');
        assert.equal(b.format('SS'), '78', 'Centiseconds');
        assert.equal(b.format('SSS'), '789', 'Milliseconds');
    });

    test('format timezone', function (assert) {
        var b = moment(new Date(2010, 1, 14, 15, 25, 50, 125));
        assert.ok(b.format('Z').match(/^[\+\-]\d\d:\d\d$/), b.format('Z') + ' should be something like \'+07:30\'');
        assert.ok(b.format('ZZ').match(/^[\+\-]\d{4}$/), b.format('ZZ') + ' should be something like \'+0700\'');
    });

    test('format multiple with utc offset', function (assert) {
        var b = moment('2012-10-08 -1200', ['YYYY-MM-DD HH:mm ZZ', 'YYYY-MM-DD ZZ', 'YYYY-MM-DD']);
        assert.equal(b.format('YYYY-MM'), '2012-10', 'Parsing multiple formats should not crash with different sized formats');
    });

    test('isDST', function (assert) {
        var janOffset = new Date(2011, 0, 1).getTimezoneOffset(),
            julOffset = new Date(2011, 6, 1).getTimezoneOffset(),
            janIsDst = janOffset < julOffset,
            julIsDst = julOffset < janOffset,
            jan1 = moment([2011]),
            jul1 = moment([2011, 6]);

        if (janIsDst && julIsDst) {
            assert.ok(0, 'January and July cannot both be in DST');
            assert.ok(0, 'January and July cannot both be in DST');
        } else if (janIsDst) {
            assert.ok(jan1.isDST(), 'January 1 is DST');
            assert.ok(!jul1.isDST(), 'July 1 is not DST');
        } else if (julIsDst) {
            assert.ok(!jan1.isDST(), 'January 1 is not DST');
            assert.ok(jul1.isDST(), 'July 1 is DST');
        } else {
            assert.ok(!jan1.isDST(), 'January 1 is not DST');
            assert.ok(!jul1.isDST(), 'July 1 is not DST');
        }
    });

    test('unix timestamp', function (assert) {
        var m = moment('1234567890.123', 'X');
        assert.equal(m.format('X'), '1234567890', 'unix timestamp without milliseconds');
        assert.equal(m.format('X.S'), '1234567890.1', 'unix timestamp with deciseconds');
        assert.equal(m.format('X.SS'), '1234567890.12', 'unix timestamp with centiseconds');
        assert.equal(m.format('X.SSS'), '1234567890.123', 'unix timestamp with milliseconds');

        m = moment(1234567890.123, 'X');
        assert.equal(m.format('X'), '1234567890', 'unix timestamp as integer');
    });

    test('unix offset milliseconds', function (assert) {
        var m = moment('1234567890123', 'x');
        assert.equal(m.format('x'), '1234567890123', 'unix offset in milliseconds');

        m = moment(1234567890123, 'x');
        assert.equal(m.format('x'), '1234567890123', 'unix offset in milliseconds as integer');
    });

    test('utcOffset sanity checks', function (assert) {
        assert.equal(moment().utcOffset() % 15, 0,
                'utc offset should be a multiple of 15 (was ' + moment().utcOffset() + ')');

        assert.equal(moment().utcOffset(), -(new Date()).getTimezoneOffset(),
            'utcOffset should return the opposite of getTimezoneOffset');
    });

    test('default format', function (assert) {
        var isoRegex = /\d{4}.\d\d.\d\dT\d\d.\d\d.\d\d[\+\-]\d\d:\d\d/;
        assert.ok(isoRegex.exec(moment().format()), 'default format (' + moment().format() + ') should match ISO');
    });

    test('toJSON', function (assert) {
        var supportsJson = typeof JSON !== 'undefined' && JSON.stringify && JSON.stringify.call,
            date = moment('2012-10-09T21:30:40.678+0100');

        assert.equal(date.toJSON(), '2012-10-09T20:30:40.678Z', 'should output ISO8601 on moment.fn.toJSON');

        if (supportsJson) {
            assert.equal(JSON.stringify({
                date : date
            }), '{"date":"2012-10-09T20:30:40.678Z"}', 'should output ISO8601 on JSON.stringify');
        }
    });

    test('toISOString', function (assert) {
        var date = moment.utc('2012-10-09T20:30:40.678');

        assert.equal(date.toISOString(), '2012-10-09T20:30:40.678Z', 'should output ISO8601 on moment.fn.toISOString');

        // big years
        date = moment.utc('+020123-10-09T20:30:40.678');
        assert.equal(date.toISOString(), '+020123-10-09T20:30:40.678Z', 'ISO8601 format on big positive year');
        // negative years
        date = moment.utc('-000001-10-09T20:30:40.678');
        assert.equal(date.toISOString(), '-000001-10-09T20:30:40.678Z', 'ISO8601 format on negative year');
        // big negative years
        date = moment.utc('-020123-10-09T20:30:40.678');
        assert.equal(date.toISOString(), '-020123-10-09T20:30:40.678Z', 'ISO8601 format on big negative year');
    });

    test('long years', function (assert) {
        assert.equal(moment.utc().year(2).format('YYYYYY'), '+000002', 'small year with YYYYYY');
        assert.equal(moment.utc().year(2012).format('YYYYYY'), '+002012', 'regular year with YYYYYY');
        assert.equal(moment.utc().year(20123).format('YYYYYY'), '+020123', 'big year with YYYYYY');

        assert.equal(moment.utc().year(-1).format('YYYYYY'), '-000001', 'small negative year with YYYYYY');
        assert.equal(moment.utc().year(-2012).format('YYYYYY'), '-002012', 'negative year with YYYYYY');
        assert.equal(moment.utc().year(-20123).format('YYYYYY'), '-020123', 'big negative year with YYYYYY');
    });

    test('iso week formats', function (assert) {
        // http://en.wikipedia.org/wiki/ISO_week_date
        var cases = {
            '2005-01-02': '2004-53',
            '2005-12-31': '2005-52',
            '2007-01-01': '2007-01',
            '2007-12-30': '2007-52',
            '2007-12-31': '2008-01',
            '2008-01-01': '2008-01',
            '2008-12-28': '2008-52',
            '2008-12-29': '2009-01',
            '2008-12-30': '2009-01',
            '2008-12-31': '2009-01',
            '2009-01-01': '2009-01',
            '2009-12-31': '2009-53',
            '2010-01-01': '2009-53',
            '2010-01-02': '2009-53',
            '2010-01-03': '2009-53',
            '404-12-31': '0404-53',
            '405-12-31': '0405-52'
        }, i, isoWeek, formatted2, formatted1;

        for (i in cases) {
            isoWeek = cases[i].split('-').pop();
            formatted2 = moment(i, 'YYYY-MM-DD').format('WW');
            assert.equal(isoWeek, formatted2, i + ': WW should be ' + isoWeek + ', but ' + formatted2);
            isoWeek = isoWeek.replace(/^0+/, '');
            formatted1 = moment(i, 'YYYY-MM-DD').format('W');
            assert.equal(isoWeek, formatted1, i + ': W should be ' + isoWeek + ', but ' + formatted1);
        }
    });

    test('iso week year formats', function (assert) {
        // http://en.wikipedia.org/wiki/ISO_week_date
        var cases = {
            '2005-01-02': '2004-53',
            '2005-12-31': '2005-52',
            '2007-01-01': '2007-01',
            '2007-12-30': '2007-52',
            '2007-12-31': '2008-01',
            '2008-01-01': '2008-01',
            '2008-12-28': '2008-52',
            '2008-12-29': '2009-01',
            '2008-12-30': '2009-01',
            '2008-12-31': '2009-01',
            '2009-01-01': '2009-01',
            '2009-12-31': '2009-53',
            '2010-01-01': '2009-53',
            '2010-01-02': '2009-53',
            '2010-01-03': '2009-53',
            '404-12-31': '0404-53',
            '405-12-31': '0405-52'
        }, i, isoWeekYear, formatted5, formatted4, formatted2;

        for (i in cases) {
            isoWeekYear = cases[i].split('-')[0];
            formatted5 = moment(i, 'YYYY-MM-DD').format('GGGGG');
            assert.equal('0' + isoWeekYear, formatted5, i + ': GGGGG should be ' + isoWeekYear + ', but ' + formatted5);
            formatted4 = moment(i, 'YYYY-MM-DD').format('GGGG');
            assert.equal(isoWeekYear, formatted4, i + ': GGGG should be ' + isoWeekYear + ', but ' + formatted4);
            formatted2 = moment(i, 'YYYY-MM-DD').format('GG');
            assert.equal(isoWeekYear.slice(2, 4), formatted2, i + ': GG should be ' + isoWeekYear + ', but ' + formatted2);
        }
    });

    test('week year formats', function (assert) {
        // http://en.wikipedia.org/wiki/ISO_week_date
        var cases = {
            '2005-01-02': '2004-53',
            '2005-12-31': '2005-52',
            '2007-01-01': '2007-01',
            '2007-12-30': '2007-52',
            '2007-12-31': '2008-01',
            '2008-01-01': '2008-01',
            '2008-12-28': '2008-52',
            '2008-12-29': '2009-01',
            '2008-12-30': '2009-01',
            '2008-12-31': '2009-01',
            '2009-01-01': '2009-01',
            '2009-12-31': '2009-53',
            '2010-01-01': '2009-53',
            '2010-01-02': '2009-53',
            '2010-01-03': '2009-53',
            '404-12-31': '0404-53',
            '405-12-31': '0405-52'
        }, i, isoWeekYear, formatted5, formatted4, formatted2;

        moment.locale('dow:1,doy:4', {week: {dow: 1, doy: 4}});

        for (i in cases) {
            isoWeekYear = cases[i].split('-')[0];
            formatted5 = moment(i, 'YYYY-MM-DD').format('ggggg');
            assert.equal('0' + isoWeekYear, formatted5, i + ': ggggg should be ' + isoWeekYear + ', but ' + formatted5);
            formatted4 = moment(i, 'YYYY-MM-DD').format('gggg');
            assert.equal(isoWeekYear, formatted4, i + ': gggg should be ' + isoWeekYear + ', but ' + formatted4);
            formatted2 = moment(i, 'YYYY-MM-DD').format('gg');
            assert.equal(isoWeekYear.slice(2, 4), formatted2, i + ': gg should be ' + isoWeekYear + ', but ' + formatted2);
        }
    });

    test('iso weekday formats', function (assert) {
        assert.equal(moment([1985, 1,  4]).format('E'), '1', 'Feb  4 1985 is Monday    -- 1st day');
        assert.equal(moment([2029, 8, 18]).format('E'), '2', 'Sep 18 2029 is Tuesday   -- 2nd day');
        assert.equal(moment([2013, 3, 24]).format('E'), '3', 'Apr 24 2013 is Wednesday -- 3rd day');
        assert.equal(moment([2015, 2,  5]).format('E'), '4', 'Mar  5 2015 is Thursday  -- 4th day');
        assert.equal(moment([1970, 0,  2]).format('E'), '5', 'Jan  2 1970 is Friday    -- 5th day');
        assert.equal(moment([2001, 4, 12]).format('E'), '6', 'May 12 2001 is Saturday  -- 6th day');
        assert.equal(moment([2000, 0,  2]).format('E'), '7', 'Jan  2 2000 is Sunday    -- 7th day');
    });

    test('weekday formats', function (assert) {
        moment.locale('dow: 3,doy: 5', {week: {dow: 3, doy: 5}});
        assert.equal(moment([1985, 1,  6]).format('e'), '0', 'Feb  6 1985 is Wednesday -- 0th day');
        assert.equal(moment([2029, 8, 20]).format('e'), '1', 'Sep 20 2029 is Thursday  -- 1st day');
        assert.equal(moment([2013, 3, 26]).format('e'), '2', 'Apr 26 2013 is Friday    -- 2nd day');
        assert.equal(moment([2015, 2,  7]).format('e'), '3', 'Mar  7 2015 is Saturday  -- 3nd day');
        assert.equal(moment([1970, 0,  4]).format('e'), '4', 'Jan  4 1970 is Sunday    -- 4th day');
        assert.equal(moment([2001, 4, 14]).format('e'), '5', 'May 14 2001 is Monday    -- 5th day');
        assert.equal(moment([2000, 0,  4]).format('e'), '6', 'Jan  4 2000 is Tuesday   -- 6th day');
    });

    test('toString is just human readable format', function (assert) {
        var b = moment(new Date(2009, 1, 5, 15, 25, 50, 125));
        assert.equal(b.toString(), b.format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ'));
    });

    test('toJSON skips postformat', function (assert) {
        moment.locale('postformat', {
            postformat: function (s) {
                s.replace(/./g, 'X');
            }
        });
        assert.equal(moment.utc([2000, 0, 1]).toJSON(), '2000-01-01T00:00:00.000Z', 'toJSON doesn\'t postformat');
        moment.locale('postformat', null);
    });

    test('calendar day timezone', function (assert) {
        moment.locale('en');
        var zones = [60, -60, 90, -90, 360, -360, 720, -720],
            b = moment().utc().startOf('day').subtract({m : 1}),
            c = moment().local().startOf('day').subtract({m : 1}),
            d = moment().local().startOf('day').subtract({d : 2}),
            i, z, a;

        for (i = 0; i < zones.length; ++i) {
            z = zones[i];
            a = moment().utcOffset(z).startOf('day').subtract({m: 1});
            assert.equal(moment(a).utcOffset(z).calendar(), 'Yesterday at 11:59 PM',
                         'Yesterday at 11:59 PM, not Today, or the wrong time, tz = ' + z);
        }

        assert.equal(moment(b).utc().calendar(), 'Yesterday at 11:59 PM', 'Yesterday at 11:59 PM, not Today, or the wrong time');
        assert.equal(moment(c).local().calendar(), 'Yesterday at 11:59 PM', 'Yesterday at 11:59 PM, not Today, or the wrong time');
        assert.equal(moment(c).local().calendar(d), 'Tomorrow at 11:59 PM', 'Tomorrow at 11:59 PM, not Yesterday, or the wrong time');
    });

    test('invalid', function (assert) {
        assert.equal(moment.invalid().format(), 'Invalid date');
        assert.equal(moment.invalid().format('YYYY-MM-DD'), 'Invalid date');
    });

    test('quarter formats', function (assert) {
        assert.equal(moment([1985, 1,  4]).format('Q'), '1', 'Feb  4 1985 is Q1');
        assert.equal(moment([2029, 8, 18]).format('Q'), '3', 'Sep 18 2029 is Q3');
        assert.equal(moment([2013, 3, 24]).format('Q'), '2', 'Apr 24 2013 is Q2');
        assert.equal(moment([2015, 2,  5]).format('Q'), '1', 'Mar  5 2015 is Q1');
        assert.equal(moment([1970, 0,  2]).format('Q'), '1', 'Jan  2 1970 is Q1');
        assert.equal(moment([2001, 11, 12]).format('Q'), '4', 'Dec 12 2001 is Q4');
        assert.equal(moment([2000, 0,  2]).format('[Q]Q-YYYY'), 'Q1-2000', 'Jan  2 2000 is Q1');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('from_to');

    test('from', function (assert) {
        var start = moment();
        moment.locale('en');
        assert.equal(start.from(start.clone().add(5, 'seconds')),  'a few seconds ago', '5 seconds = a few seconds ago');
        assert.equal(start.from(start.clone().add(1, 'minute')),  'a minute ago', '1 minute = a minute ago');
        assert.equal(start.from(start.clone().add(5, 'minutes')),  '5 minutes ago', '5 minutes = 5 minutes ago');

        assert.equal(start.from(start.clone().subtract(5, 'seconds')),  'in a few seconds', '5 seconds = in a few seconds');
        assert.equal(start.from(start.clone().subtract(1, 'minute')),  'in a minute', '1 minute = in a minute');
        assert.equal(start.from(start.clone().subtract(5, 'minutes')),  'in 5 minutes', '5 minutes = in 5 minutes');
    });

    test('from with absolute duration', function (assert) {
        var start = moment();
        moment.locale('en');
        assert.equal(start.from(start.clone().add(5, 'seconds'), true),  'a few seconds', '5 seconds = a few seconds');
        assert.equal(start.from(start.clone().add(1, 'minute'), true),  'a minute', '1 minute = a minute');
        assert.equal(start.from(start.clone().add(5, 'minutes'), true),  '5 minutes', '5 minutes = 5 minutes');

        assert.equal(start.from(start.clone().subtract(5, 'seconds'), true),  'a few seconds', '5 seconds = a few seconds');
        assert.equal(start.from(start.clone().subtract(1, 'minute'), true),  'a minute', '1 minute = a minute');
        assert.equal(start.from(start.clone().subtract(5, 'minutes'), true),  '5 minutes', '5 minutes = 5 minutes');
    });

    test('to', function (assert) {
        var start = moment();
        moment.locale('en');
        assert.equal(start.to(start.clone().subtract(5, 'seconds')),  'a few seconds ago', '5 seconds = a few seconds ago');
        assert.equal(start.to(start.clone().subtract(1, 'minute')),  'a minute ago', '1 minute = a minute ago');
        assert.equal(start.to(start.clone().subtract(5, 'minutes')),  '5 minutes ago', '5 minutes = 5 minutes ago');

        assert.equal(start.to(start.clone().add(5, 'seconds')),  'in a few seconds', '5 seconds = in a few seconds');
        assert.equal(start.to(start.clone().add(1, 'minute')),  'in a minute', '1 minute = in a minute');
        assert.equal(start.to(start.clone().add(5, 'minutes')),  'in 5 minutes', '5 minutes = in 5 minutes');
    });

    test('to with absolute duration', function (assert) {
        var start = moment();
        moment.locale('en');
        assert.equal(start.to(start.clone().add(5, 'seconds'), true),  'a few seconds', '5 seconds = a few seconds');
        assert.equal(start.to(start.clone().add(1, 'minute'), true),  'a minute', '1 minute = a minute');
        assert.equal(start.to(start.clone().add(5, 'minutes'), true),  '5 minutes', '5 minutes = 5 minutes');

        assert.equal(start.to(start.clone().subtract(5, 'seconds'), true),  'a few seconds', '5 seconds = a few seconds');
        assert.equal(start.to(start.clone().subtract(1, 'minute'), true),  'a minute', '1 minute = a minute');
        assert.equal(start.to(start.clone().subtract(5, 'minutes'), true),  '5 minutes', '5 minutes = 5 minutes');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('getters and setters');

    test('getters', function (assert) {
        var a = moment([2011, 9, 12, 6, 7, 8, 9]);
        assert.equal(a.year(), 2011, 'year');
        assert.equal(a.month(), 9, 'month');
        assert.equal(a.date(), 12, 'date');
        assert.equal(a.day(), 3, 'day');
        assert.equal(a.hours(), 6, 'hour');
        assert.equal(a.minutes(), 7, 'minute');
        assert.equal(a.seconds(), 8, 'second');
        assert.equal(a.milliseconds(), 9, 'milliseconds');
    });

    test('getters programmatic', function (assert) {
        var a = moment([2011, 9, 12, 6, 7, 8, 9]);
        assert.equal(a.get('year'), 2011, 'year');
        assert.equal(a.get('month'), 9, 'month');
        assert.equal(a.get('date'), 12, 'date');
        assert.equal(a.get('day'), 3, 'day');
        assert.equal(a.get('hour'), 6, 'hour');
        assert.equal(a.get('minute'), 7, 'minute');
        assert.equal(a.get('second'), 8, 'second');
        assert.equal(a.get('milliseconds'), 9, 'milliseconds');

        //actual getters tested elsewhere
        assert.equal(a.get('weekday'), a.weekday(), 'weekday');
        assert.equal(a.get('isoWeekday'), a.isoWeekday(), 'isoWeekday');
        assert.equal(a.get('week'), a.week(), 'week');
        assert.equal(a.get('isoWeek'), a.isoWeek(), 'isoWeek');
        assert.equal(a.get('dayOfYear'), a.dayOfYear(), 'dayOfYear');
    });

    test('setters plural', function (assert) {
        var a = moment();
        a.years(2011);
        a.months(9);
        a.dates(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(9);
        assert.equal(a.years(), 2011, 'years');
        assert.equal(a.months(), 9, 'months');
        assert.equal(a.dates(), 12, 'dates');
        assert.equal(a.days(), 3, 'days');
        assert.equal(a.hours(), 6, 'hours');
        assert.equal(a.minutes(), 7, 'minutes');
        assert.equal(a.seconds(), 8, 'seconds');
        assert.equal(a.milliseconds(), 9, 'milliseconds');
    });

    test('setters singular', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hour(6);
        a.minute(7);
        a.second(8);
        a.millisecond(9);
        assert.equal(a.year(), 2011, 'year');
        assert.equal(a.month(), 9, 'month');
        assert.equal(a.date(), 12, 'date');
        assert.equal(a.day(), 3, 'day');
        assert.equal(a.hour(), 6, 'hour');
        assert.equal(a.minute(), 7, 'minute');
        assert.equal(a.second(), 8, 'second');
        assert.equal(a.millisecond(), 9, 'milliseconds');
    });

    test('setters', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(9);
        assert.equal(a.year(), 2011, 'year');
        assert.equal(a.month(), 9, 'month');
        assert.equal(a.date(), 12, 'date');
        assert.equal(a.day(), 3, 'day');
        assert.equal(a.hours(), 6, 'hour');
        assert.equal(a.minutes(), 7, 'minute');
        assert.equal(a.seconds(), 8, 'second');
        assert.equal(a.milliseconds(), 9, 'milliseconds');

        // Test month() behavior. See https://github.com/timrwood/moment/pull/822
        a = moment('20130531', 'YYYYMMDD');
        a.month(3);
        assert.equal(a.month(), 3, 'month edge case');
    });

    test('setter programmatic', function (assert) {
        var a = moment();
        a.set('year', 2011);
        a.set('month', 9);
        a.set('date', 12);
        a.set('hours', 6);
        a.set('minutes', 7);
        a.set('seconds', 8);
        a.set('milliseconds', 9);
        assert.equal(a.year(), 2011, 'year');
        assert.equal(a.month(), 9, 'month');
        assert.equal(a.date(), 12, 'date');
        assert.equal(a.day(), 3, 'day');
        assert.equal(a.hours(), 6, 'hour');
        assert.equal(a.minutes(), 7, 'minute');
        assert.equal(a.seconds(), 8, 'second');
        assert.equal(a.milliseconds(), 9, 'milliseconds');

        // Test month() behavior. See https://github.com/timrwood/moment/pull/822
        a = moment('20130531', 'YYYYMMDD');
        a.month(3);
        assert.equal(a.month(), 3, 'month edge case');
    });

    // Disable this, until we weekYear setter is fixed.
    // https://github.com/moment/moment/issues/1379
    // test('setters programatic with weeks', function (assert) {
    //     var a = moment();
    //     a.set('weekYear', 2001);
    //     a.set('week', 49);
    //     a.set('day', 4);
    //     assert.equals(a.weekYear(), 2001);
    //     assert.equals(a.week(), 49);
    //     assert.equals(a.day(), 4);

    //     a.set('weekday', 1);
    //     assert.equals(a.weekday(), 1);

    //     assert.done();
    //},

    // I think this suffers from the same issue as the non-iso version.
    // test('setters programatic with weeks ISO', function (assert) {
    //     var a = moment();
    //     a.set('isoWeekYear', 2001);
    //     a.set('isoWeek', 49);
    //     a.set('isoWeekday', 4);

    //     assert.equals(a.weekYear(), 2001);
    //     assert.equals(a.week(), 49);
    //     assert.equals(a.day(), 4);

    //     assert.done();
    //},

    test('setters strings', function (assert) {
        var a = moment([2012]).locale('en');
        assert.equal(a.clone().day(0).day('Wednesday').day(), 3, 'day full name');
        assert.equal(a.clone().day(0).day('Wed').day(), 3, 'day short name');
        assert.equal(a.clone().day(0).day('We').day(), 3, 'day minimal name');
        assert.equal(a.clone().day(0).day('invalid').day(), 0, 'invalid day name');
        assert.equal(a.clone().month(0).month('April').month(), 3, 'month full name');
        assert.equal(a.clone().month(0).month('Apr').month(), 3, 'month short name');
        assert.equal(a.clone().month(0).month('invalid').month(), 0, 'invalid month name');
    });

    test('setters - falsey values', function (assert) {
        var a = moment();
        // ensure minutes wasn't coincidentally 0 already
        a.minutes(1);
        a.minutes(0);
        assert.equal(a.minutes(), 0, 'falsey value');
    });

    test('chaining setters', function (assert) {
        var a = moment();
        a.year(2011)
         .month(9)
         .date(12)
         .hours(6)
         .minutes(7)
         .seconds(8);
        assert.equal(a.year(), 2011, 'year');
        assert.equal(a.month(), 9, 'month');
        assert.equal(a.date(), 12, 'date');
        assert.equal(a.day(), 3, 'day');
        assert.equal(a.hours(), 6, 'hour');
        assert.equal(a.minutes(), 7, 'minute');
        assert.equal(a.seconds(), 8, 'second');
    });

    test('setter with multiple unit values', function (assert) {
        var a = moment();
        a.set({
            year: 2011,
            month: 9,
            date: 12,
            hours: 6,
            minutes: 7,
            seconds: 8,
            milliseconds: 9
        });
        assert.equal(a.year(), 2011, 'year');
        assert.equal(a.month(), 9, 'month');
        assert.equal(a.date(), 12, 'date');
        assert.equal(a.day(), 3, 'day');
        assert.equal(a.hours(), 6, 'hour');
        assert.equal(a.minutes(), 7, 'minute');
        assert.equal(a.seconds(), 8, 'second');
        assert.equal(a.milliseconds(), 9, 'milliseconds');
    });

    test('day setter', function (assert) {
        var a = moment([2011, 0, 15]);
        assert.equal(moment(a).day(0).date(), 9, 'set from saturday to sunday');
        assert.equal(moment(a).day(6).date(), 15, 'set from saturday to saturday');
        assert.equal(moment(a).day(3).date(), 12, 'set from saturday to wednesday');

        a = moment([2011, 0, 9]);
        assert.equal(moment(a).day(0).date(), 9, 'set from sunday to sunday');
        assert.equal(moment(a).day(6).date(), 15, 'set from sunday to saturday');
        assert.equal(moment(a).day(3).date(), 12, 'set from sunday to wednesday');

        a = moment([2011, 0, 12]);
        assert.equal(moment(a).day(0).date(), 9, 'set from wednesday to sunday');
        assert.equal(moment(a).day(6).date(), 15, 'set from wednesday to saturday');
        assert.equal(moment(a).day(3).date(), 12, 'set from wednesday to wednesday');

        assert.equal(moment(a).day(-7).date(), 2, 'set from wednesday to last sunday');
        assert.equal(moment(a).day(-1).date(), 8, 'set from wednesday to last saturday');
        assert.equal(moment(a).day(-4).date(), 5, 'set from wednesday to last wednesday');

        assert.equal(moment(a).day(7).date(), 16, 'set from wednesday to next sunday');
        assert.equal(moment(a).day(13).date(), 22, 'set from wednesday to next saturday');
        assert.equal(moment(a).day(10).date(), 19, 'set from wednesday to next wednesday');

        assert.equal(moment(a).day(14).date(), 23, 'set from wednesday to second next sunday');
        assert.equal(moment(a).day(20).date(), 29, 'set from wednesday to second next saturday');
        assert.equal(moment(a).day(17).date(), 26, 'set from wednesday to second next wednesday');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('invalid');

    test('invalid', function (assert) {
        var m = moment.invalid();
        assert.equal(m.isValid(), false);
        assert.equal(m.parsingFlags().userInvalidated, true);
        assert.ok(isNaN(m.valueOf()));
    });

    test('invalid with existing flag', function (assert) {
        var m = moment.invalid({invalidMonth : 'whatchamacallit'});
        assert.equal(m.isValid(), false);
        assert.equal(m.parsingFlags().userInvalidated, false);
        assert.equal(m.parsingFlags().invalidMonth, 'whatchamacallit');
        assert.ok(isNaN(m.valueOf()));
    });

    test('invalid with custom flag', function (assert) {
        var m = moment.invalid({tooBusyWith : 'reiculating splines'});
        assert.equal(m.isValid(), false);
        assert.equal(m.parsingFlags().userInvalidated, false);
        assert.equal(m.parsingFlags().tooBusyWith, 'reiculating splines');
        assert.ok(isNaN(m.valueOf()));
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('is after');

    test('is after without units', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isAfter(moment(new Date(2012, 3, 2, 3, 5, 5, 10))), false, 'year is later');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 3, 5, 10))), true, 'year is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 4, 2, 3, 4, 5, 10))), false, 'month is later');
        assert.equal(m.isAfter(moment(new Date(2011, 2, 2, 3, 4, 5, 10))), true, 'month is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 3, 3, 4, 5, 10))), false, 'day is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 3, 4, 5, 10))), true, 'day is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 4, 4, 5, 10))), false, 'hour is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 2, 4, 5, 10))), true, 'hour is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 5, 5, 10))), false, 'minute is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 3, 5, 10))), true, 'minute is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 6, 10))), false, 'second is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 4, 11))), true, 'second is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'millisecond match');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 11))), false, 'millisecond is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 9))), true, 'millisecond is earlier');
        assert.equal(m.isAfter(m), false, 'moments are not after themselves');
        assert.equal(+m, +mCopy, 'isAfter second should not change moment');
    });

    test('is after year', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isAfter(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year match');
        assert.equal(m.isAfter(moment(new Date(2010, 5, 6, 7, 8, 9, 10)), 'years'), true, 'plural should work');
        assert.equal(m.isAfter(moment(new Date(2013, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year is later');
        assert.equal(m.isAfter(moment(new Date(2010, 5, 6, 7, 8, 9, 10)), 'year'), true, 'year is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 0, 1, 0, 0, 0, 0)), 'year'), false, 'exact start of year');
        assert.equal(m.isAfter(moment(new Date(2011, 11, 31, 23, 59, 59, 999)), 'year'), false, 'exact end of year');
        assert.equal(m.isAfter(moment(new Date(2012, 0, 1, 0, 0, 0, 0)), 'year'), false, 'start of next year');
        assert.equal(m.isAfter(moment(new Date(2010, 11, 31, 23, 59, 59, 999)), 'year'), true, 'end of previous year');
        assert.equal(m.isAfter(moment(new Date(1980, 11, 31, 23, 59, 59, 999)), 'year'), true, 'end of year far before');
        assert.equal(m.isAfter(m, 'year'), false, 'same moments are not after the same year');
        assert.equal(+m, +mCopy, 'isAfter year should not change moment');
    });

    test('is after month', function (assert) {
        var m = moment(new Date(2011, 2, 3, 4, 5, 6, 7)), mCopy = moment(m);
        assert.equal(m.isAfter(moment(new Date(2011, 2, 6, 7, 8, 9, 10)), 'month'), false, 'month match');
        assert.equal(m.isAfter(moment(new Date(2010, 2, 6, 7, 8, 9, 10)), 'months'), true, 'plural should work');
        assert.equal(m.isAfter(moment(new Date(2012, 2, 6, 7, 8, 9, 10)), 'month'), false, 'year is later');
        assert.equal(m.isAfter(moment(new Date(2010, 2, 6, 7, 8, 9, 10)), 'month'), true, 'year is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'month'), false, 'month is later');
        assert.equal(m.isAfter(moment(new Date(2011, 1, 6, 7, 8, 9, 10)), 'month'), true, 'month is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 2, 1, 0, 0, 0, 0)), 'month'), false, 'exact start of month');
        assert.equal(m.isAfter(moment(new Date(2011, 2, 31, 23, 59, 59, 999)), 'month'), false, 'exact end of month');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 0, 0, 0, 0)), 'month'), false, 'start of next month');
        assert.equal(m.isAfter(moment(new Date(2011, 1, 27, 23, 59, 59, 999)), 'month'), true, 'end of previous month');
        assert.equal(m.isAfter(moment(new Date(2010, 12, 31, 23, 59, 59, 999)), 'month'), true, 'later month but earlier year');
        assert.equal(m.isAfter(m, 'month'), false, 'same moments are not after the same month');
        assert.equal(+m, +mCopy, 'isAfter month should not change moment');
    });

    test('is after day', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 7, 8, 9, 10)), 'day'), false, 'day match');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 7, 8, 9, 10)), 'days'), true, 'plural should work');
        assert.equal(m.isAfter(moment(new Date(2012, 3, 2, 7, 8, 9, 10)), 'day'), false, 'year is later');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 7, 8, 9, 10)), 'day'), true, 'year is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 4, 2, 7, 8, 9, 10)), 'day'), false, 'month is later');
        assert.equal(m.isAfter(moment(new Date(2011, 2, 2, 7, 8, 9, 10)), 'day'), true, 'month is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 3, 7, 8, 9, 10)), 'day'), false, 'day is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 7, 8, 9, 10)), 'day'), true, 'day is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 0, 0, 0, 0)), 'day'), false, 'exact start of day');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 23, 59, 59, 999)), 'day'), false, 'exact end of day');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 3, 0, 0, 0, 0)), 'day'), false, 'start of next day');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 23, 59, 59, 999)), 'day'), true, 'end of previous day');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 10, 0, 0, 0, 0)), 'day'), true, 'later day but earlier year');
        assert.equal(m.isAfter(m, 'day'), false, 'same moments are not after the same day');
        assert.equal(+m, +mCopy, 'isAfter day should not change moment');
    });

    test('is after hour', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 8, 9, 10)), 'hour'), false, 'hour match');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 8, 9, 10)), 'hours'), true, 'plural should work');
        assert.equal(m.isAfter(moment(new Date(2012, 3, 2, 3, 8, 9, 10)), 'hour'), false, 'year is later');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 8, 9, 10)), 'hour'), true, 'year is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 4, 2, 3, 8, 9, 10)), 'hour'), false, 'month is later');
        assert.equal(m.isAfter(moment(new Date(2011, 1, 2, 3, 8, 9, 10)), 'hour'), true, 'month is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 3, 3, 8, 9, 10)), 'hour'), false, 'day is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 3, 8, 9, 10)), 'hour'), true, 'day is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 4, 8, 9, 10)), 'hour'), false, 'hour is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 8, 9, 10)), 'hour'), false, 'hour is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 0, 0, 0)), 'hour'), false, 'exact start of hour');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 59, 59, 999)), 'hour'), false, 'exact end of hour');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 4, 0, 0, 0)), 'hour'), false, 'start of next hour');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 2, 59, 59, 999)), 'hour'), true, 'end of previous hour');
        assert.equal(m.isAfter(m, 'hour'), false, 'same moments are not after the same hour');
        assert.equal(+m, +mCopy, 'isAfter hour should not change moment');
    });

    test('is after minute', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 9, 10)), 'minute'), false, 'minute match');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 4, 9, 10)), 'minutes'), true, 'plural should work');
        assert.equal(m.isAfter(moment(new Date(2012, 3, 2, 3, 4, 9, 10)), 'minute'), false, 'year is later');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 4, 9, 10)), 'minute'), true, 'year is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 4, 2, 3, 4, 9, 10)), 'minute'), false, 'month is later');
        assert.equal(m.isAfter(moment(new Date(2011, 2, 2, 3, 4, 9, 10)), 'minute'), true, 'month is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 3, 3, 4, 9, 10)), 'minute'), false, 'day is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 3, 4, 9, 10)), 'minute'), true, 'day is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 4, 4, 9, 10)), 'minute'), false, 'hour is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 2, 4, 9, 10)), 'minute'), true, 'hour is earler');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 5, 9, 10)), 'minute'), false, 'minute is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 3, 9, 10)), 'minute'), true, 'minute is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 0, 0)), 'minute'), false, 'exact start of minute');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 59, 999)), 'minute'), false, 'exact end of minute');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 5, 0, 0)), 'minute'), false, 'start of next minute');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 3, 59, 999)), 'minute'), true, 'end of previous minute');
        assert.equal(m.isAfter(m, 'minute'), false, 'same moments are not after the same minute');
        assert.equal(+m, +mCopy, 'isAfter minute should not change moment');
    });

    test('is after second', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'second'), false, 'second match');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'seconds'), true, 'plural should work');
        assert.equal(m.isAfter(moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'second'), false, 'year is later');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'second'), true, 'year is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 4, 2, 3, 4, 5, 10)), 'second'), false, 'month is later');
        assert.equal(m.isAfter(moment(new Date(2011, 2, 2, 3, 4, 5, 10)), 'second'), true, 'month is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 3, 3, 4, 5, 10)), 'second'), false, 'day is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 1, 4, 5, 10)), 'second'), true, 'day is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 4, 4, 5, 10)), 'second'), false, 'hour is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 4, 1, 5, 10)), 'second'), true, 'hour is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 5, 5, 10)), 'second'), false, 'minute is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 3, 5, 10)), 'second'), true, 'minute is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 6, 10)), 'second'), false, 'second is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 4, 5)), 'second'), true, 'second is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 0)), 'second'), false, 'exact start of second');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 999)), 'second'), false, 'exact end of second');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 6, 0)), 'second'), false, 'start of next second');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 4, 999)), 'second'), true, 'end of previous second');
        assert.equal(m.isAfter(m, 'second'), false, 'same moments are not after the same second');
        assert.equal(+m, +mCopy, 'isAfter second should not change moment');
    });

    test('is after millisecond', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'millisecond'), false, 'millisecond match');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'milliseconds'), true, 'plural should work');
        assert.equal(m.isAfter(moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'millisecond'), false, 'year is later');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'millisecond'), true, 'year is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 4, 2, 3, 4, 5, 10)), 'millisecond'), false, 'month is later');
        assert.equal(m.isAfter(moment(new Date(2011, 2, 2, 3, 4, 5, 10)), 'millisecond'), true, 'month is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 3, 3, 4, 5, 10)), 'millisecond'), false, 'day is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 1, 4, 5, 10)), 'millisecond'), true, 'day is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 4, 4, 5, 10)), 'millisecond'), false, 'hour is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 4, 1, 5, 10)), 'millisecond'), true, 'hour is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 5, 5, 10)), 'millisecond'), false, 'minute is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 3, 5, 10)), 'millisecond'), true, 'minute is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 6, 10)), 'millisecond'), false, 'second is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 4, 5)), 'millisecond'), true, 'second is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 6, 11)), 'millisecond'), false, 'millisecond is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 4, 9)), 'millisecond'), true, 'millisecond is earlier');
        assert.equal(m.isAfter(m, 'millisecond'), false, 'same moments are not after the same millisecond');
        assert.equal(+m, +mCopy, 'isAfter millisecond should not change moment');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('is before');

    test('is after without units', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 5, 5, 10))), true, 'year is later');
        assert.equal(m.isBefore(moment(new Date(2010, 3, 2, 3, 3, 5, 10))), false, 'year is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 4, 2, 3, 4, 5, 10))), true, 'month is later');
        assert.equal(m.isBefore(moment(new Date(2011, 2, 2, 3, 4, 5, 10))), false, 'month is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 3, 3, 4, 5, 10))), true, 'day is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 3, 4, 5, 10))), false, 'day is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 4, 4, 5, 10))), true, 'hour is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 2, 4, 5, 10))), false, 'hour is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 5, 5, 10))), true, 'minute is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 3, 5, 10))), false, 'minute is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 6, 10))), true, 'second is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 4, 11))), false, 'second is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'millisecond match');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 11))), true, 'millisecond is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 9))), false, 'millisecond is earlier');
        assert.equal(m.isBefore(m), false, 'moments are not before themselves');
        assert.equal(+m, +mCopy, 'isBefore second should not change moment');
    });

    test('is before year', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBefore(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year match');
        assert.equal(m.isBefore(moment(new Date(2012, 5, 6, 7, 8, 9, 10)), 'years'), true, 'plural should work');
        assert.equal(m.isBefore(moment(new Date(2013, 5, 6, 7, 8, 9, 10)), 'year'), true, 'year is later');
        assert.equal(m.isBefore(moment(new Date(2010, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 0, 1, 0, 0, 0, 0)), 'year'), false, 'exact start of year');
        assert.equal(m.isBefore(moment(new Date(2011, 11, 31, 23, 59, 59, 999)), 'year'), false, 'exact end of year');
        assert.equal(m.isBefore(moment(new Date(2012, 0, 1, 0, 0, 0, 0)), 'year'), true, 'start of next year');
        assert.equal(m.isBefore(moment(new Date(2010, 11, 31, 23, 59, 59, 999)), 'year'), false, 'end of previous year');
        assert.equal(m.isBefore(moment(new Date(1980, 11, 31, 23, 59, 59, 999)), 'year'), false, 'end of year far before');
        assert.equal(m.isBefore(m, 'year'), false, 'same moments are not before the same year');
        assert.equal(+m, +mCopy, 'isBefore year should not change moment');
    });

    test('is before month', function (assert) {
        var m = moment(new Date(2011, 2, 3, 4, 5, 6, 7)), mCopy = moment(m);
        assert.equal(m.isBefore(moment(new Date(2011, 2, 6, 7, 8, 9, 10)), 'month'), false, 'month match');
        assert.equal(m.isBefore(moment(new Date(2012, 2, 6, 7, 8, 9, 10)), 'months'), true, 'plural should work');
        assert.equal(m.isBefore(moment(new Date(2012, 2, 6, 7, 8, 9, 10)), 'month'), true, 'year is later');
        assert.equal(m.isBefore(moment(new Date(2010, 2, 6, 7, 8, 9, 10)), 'month'), false, 'year is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'month'), true, 'month is later');
        assert.equal(m.isBefore(moment(new Date(2011, 1, 6, 7, 8, 9, 10)), 'month'), false, 'month is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 2, 1, 0, 0, 0, 0)), 'month'), false, 'exact start of month');
        assert.equal(m.isBefore(moment(new Date(2011, 2, 31, 23, 59, 59, 999)), 'month'), false, 'exact end of month');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 0, 0, 0, 0)), 'month'), true, 'start of next month');
        assert.equal(m.isBefore(moment(new Date(2011, 1, 27, 23, 59, 59, 999)), 'month'), false, 'end of previous month');
        assert.equal(m.isBefore(moment(new Date(2010, 12, 31, 23, 59, 59, 999)), 'month'), false, 'later month but earlier year');
        assert.equal(m.isBefore(m, 'month'), false, 'same moments are not before the same month');
        assert.equal(+m, +mCopy, 'isBefore month should not change moment');
    });

    test('is before day', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 7, 8, 9, 10)), 'day'), false, 'day match');
        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 7, 8, 9, 10)), 'days'), true, 'plural should work');
        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 7, 8, 9, 10)), 'day'), true, 'year is later');
        assert.equal(m.isBefore(moment(new Date(2010, 3, 2, 7, 8, 9, 10)), 'day'), false, 'year is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 4, 2, 7, 8, 9, 10)), 'day'), true, 'month is later');
        assert.equal(m.isBefore(moment(new Date(2011, 2, 2, 7, 8, 9, 10)), 'day'), false, 'month is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 3, 7, 8, 9, 10)), 'day'), true, 'day is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 7, 8, 9, 10)), 'day'), false, 'day is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 0, 0, 0, 0)), 'day'), false, 'exact start of day');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 23, 59, 59, 999)), 'day'), false, 'exact end of day');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 3, 0, 0, 0, 0)), 'day'), true, 'start of next day');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 23, 59, 59, 999)), 'day'), false, 'end of previous day');
        assert.equal(m.isBefore(moment(new Date(2010, 3, 10, 0, 0, 0, 0)), 'day'), false, 'later day but earlier year');
        assert.equal(m.isBefore(m, 'day'), false, 'same moments are not before the same day');
        assert.equal(+m, +mCopy, 'isBefore day should not change moment');
    });

    test('is before hour', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 8, 9, 10)), 'hour'), false, 'hour match');
        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 8, 9, 10)), 'hours'), true, 'plural should work');
        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 8, 9, 10)), 'hour'), true, 'year is later');
        assert.equal(m.isBefore(moment(new Date(2010, 3, 2, 3, 8, 9, 10)), 'hour'), false, 'year is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 4, 2, 3, 8, 9, 10)), 'hour'), true, 'month is later');
        assert.equal(m.isBefore(moment(new Date(2011, 1, 2, 3, 8, 9, 10)), 'hour'), false, 'month is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 3, 3, 8, 9, 10)), 'hour'), true, 'day is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 3, 8, 9, 10)), 'hour'), false, 'day is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 4, 8, 9, 10)), 'hour'), true, 'hour is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 8, 9, 10)), 'hour'), false, 'hour is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 0, 0, 0)), 'hour'), false, 'exact start of hour');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 59, 59, 999)), 'hour'), false, 'exact end of hour');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 4, 0, 0, 0)), 'hour'), true, 'start of next hour');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 2, 59, 59, 999)), 'hour'), false, 'end of previous hour');
        assert.equal(m.isBefore(m, 'hour'), false, 'same moments are not before the same hour');
        assert.equal(+m, +mCopy, 'isBefore hour should not change moment');
    });

    test('is before minute', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 9, 10)), 'minute'), false, 'minute match');
        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 4, 9, 10)), 'minutes'), true, 'plural should work');
        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 4, 9, 10)), 'minute'), true, 'year is later');
        assert.equal(m.isBefore(moment(new Date(2010, 3, 2, 3, 4, 9, 10)), 'minute'), false, 'year is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 4, 2, 3, 4, 9, 10)), 'minute'), true, 'month is later');
        assert.equal(m.isBefore(moment(new Date(2011, 2, 2, 3, 4, 9, 10)), 'minute'), false, 'month is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 3, 3, 4, 9, 10)), 'minute'), true, 'day is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 3, 4, 9, 10)), 'minute'), false, 'day is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 4, 4, 9, 10)), 'minute'), true, 'hour is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 2, 4, 9, 10)), 'minute'), false, 'hour is earler');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 5, 9, 10)), 'minute'), true, 'minute is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 3, 9, 10)), 'minute'), false, 'minute is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 0, 0)), 'minute'), false, 'exact start of minute');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 59, 999)), 'minute'), false, 'exact end of minute');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 5, 0, 0)), 'minute'), true, 'start of next minute');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 3, 59, 999)), 'minute'), false, 'end of previous minute');
        assert.equal(m.isBefore(m, 'minute'), false, 'same moments are not before the same minute');
        assert.equal(+m, +mCopy, 'isBefore minute should not change moment');
    });

    test('is before second', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'second'), false, 'second match');
        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'seconds'), true, 'plural should work');
        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'second'), true, 'year is later');
        assert.equal(m.isBefore(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'second'), false, 'year is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 4, 2, 3, 4, 5, 10)), 'second'), true, 'month is later');
        assert.equal(m.isBefore(moment(new Date(2011, 2, 2, 3, 4, 5, 10)), 'second'), false, 'month is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 3, 3, 4, 5, 10)), 'second'), true, 'day is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 1, 4, 5, 10)), 'second'), false, 'day is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 4, 4, 5, 10)), 'second'), true, 'hour is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 4, 1, 5, 10)), 'second'), false, 'hour is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 5, 5, 10)), 'second'), true, 'minute is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 3, 5, 10)), 'second'), false, 'minute is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 6, 10)), 'second'), true, 'second is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 4, 5)), 'second'), false, 'second is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 0)), 'second'), false, 'exact start of second');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 999)), 'second'), false, 'exact end of second');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 6, 0)), 'second'), true, 'start of next second');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 4, 999)), 'second'), false, 'end of previous second');
        assert.equal(m.isBefore(m, 'second'), false, 'same moments are not before the same second');
        assert.equal(+m, +mCopy, 'isBefore second should not change moment');
    });

    test('is before millisecond', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'millisecond'), false, 'millisecond match');
        assert.equal(m.isBefore(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'milliseconds'), false, 'plural should work');
        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'millisecond'), true, 'year is later');
        assert.equal(m.isBefore(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'millisecond'), false, 'year is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 4, 2, 3, 4, 5, 10)), 'millisecond'), true, 'month is later');
        assert.equal(m.isBefore(moment(new Date(2011, 2, 2, 3, 4, 5, 10)), 'millisecond'), false, 'month is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 3, 3, 4, 5, 10)), 'millisecond'), true, 'day is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 1, 4, 5, 10)), 'millisecond'), false, 'day is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 4, 4, 5, 10)), 'millisecond'), true, 'hour is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 4, 1, 5, 10)), 'millisecond'), false, 'hour is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 5, 5, 10)), 'millisecond'), true, 'minute is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 3, 5, 10)), 'millisecond'), false, 'minute is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 6, 10)), 'millisecond'), true, 'second is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 4, 5)), 'millisecond'), false, 'second is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 6, 11)), 'millisecond'), true, 'millisecond is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 4, 9)), 'millisecond'), false, 'millisecond is earlier');
        assert.equal(m.isBefore(m, 'millisecond'), false, 'same moments are not before the same millisecond');
        assert.equal(+m, +mCopy, 'isBefore millisecond should not change moment');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('is between');

    test('is between without units', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isBetween(
                    moment(new Date(2009, 3, 2, 3, 4, 5, 10)),
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'year is later');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
                    moment(new Date(2013, 3, 2, 3, 4, 5, 10))), false, 'year is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2010, 3, 2, 3, 4, 5, 10)),
                    moment(new Date(2012, 3, 2, 3, 4, 5, 10))), true, 'year is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 5, 10)),
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'month is later');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
                    moment(new Date(2011, 5, 2, 3, 4, 5, 10))), false, 'month is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 2, 2, 3, 4, 5, 10)),
                    moment(new Date(2011, 4, 2, 3, 4, 5, 10))), true, 'month is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 1, 3, 4, 5, 10)),
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'day is later');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
                    moment(new Date(2011, 3, 4, 3, 4, 5, 10))), false, 'day is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 1, 3, 4, 5, 10)),
                    moment(new Date(2011, 3, 3, 3, 4, 5, 10))), true, 'day is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 1, 4, 5, 10)),
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'hour is later');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
                    moment(new Date(2011, 3, 2, 5, 4, 5, 10))), false, 'hour is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 2, 4, 5, 10)),
                    moment(new Date(2011, 3, 2, 4, 4, 5, 10))), true, 'hour is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
                    moment(new Date(2011, 3, 2, 3, 6, 5, 10))), false, 'minute is later');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 2, 5, 10)),
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'minute is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 3, 5, 10)),
                    moment(new Date(2011, 3, 2, 3, 5, 5, 10))), true, 'minute is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
                    moment(new Date(2011, 3, 2, 3, 4, 7, 10))), false, 'second is later');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 3, 10)),
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'second is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 4, 10)),
                    moment(new Date(2011, 3, 2, 3, 4, 6, 10))), true, 'second is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
                    moment(new Date(2011, 3, 2, 3, 4, 5, 12))), false, 'millisecond is later');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 5, 8)),
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'millisecond is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 5, 9)),
                    moment(new Date(2011, 3, 2, 3, 4, 5, 11))), true, 'millisecond is between');
        assert.equal(m.isBetween(m, m), false, 'moments are not between themselves');
        assert.equal(+m, +mCopy, 'isBetween second should not change moment');
    });

    test('is between year', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBetween(
                    moment(new Date(2011, 5, 6, 7, 8, 9, 10)),
                    moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year match');
        assert.equal(m.isBetween(
                    moment(new Date(2010, 5, 6, 7, 8, 9, 10)),
                    moment(new Date(2012, 5, 6, 7, 8, 9, 10)), 'years'), true, 'plural should work');
        assert.equal(m.isBetween(
                    moment(new Date(2010, 5, 6, 7, 8, 9, 10)),
                    moment(new Date(2012, 5, 6, 7, 8, 9, 10)), 'year'), true, 'year is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 5, 6, 7, 8, 9, 10)),
                    moment(new Date(2013, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2010, 5, 6, 7, 8, 9, 10)),
                    moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year is later');
        assert.equal(m.isBetween(m, 'year'), false, 'same moments are not between the same year');
        assert.equal(+m, +mCopy, 'isBetween year should not change moment');
    });

    test('is between month', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 6, 7, 8, 9, 10)),
                    moment(new Date(2011, 1, 6, 7, 8, 9, 10)), 'month'), false, 'month match');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 0, 6, 7, 8, 9, 10)),
                    moment(new Date(2011, 2, 6, 7, 8, 9, 10)), 'months'), true, 'plural should work');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 0, 31, 23, 59, 59, 999)),
                    moment(new Date(2011, 2, 1, 0, 0, 0, 0)), 'month'), true, 'month is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 6, 7, 8, 9, 10)),
                    moment(new Date(2011, 2, 6, 7, 8, 9, 10)), 'month'), false, 'month is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 11, 6, 7, 8, 9, 10)),
                    moment(new Date(2011, 1, 6, 7, 8, 9, 10)), 'month'), false, 'month is later');
        assert.equal(m.isBetween(m, 'month'), false, 'same moments are not between the same month');
        assert.equal(+m, +mCopy, 'isBetween month should not change moment');
    });

    test('is between day', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)),
                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)), 'day'), false, 'day match');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 1, 7, 8, 9, 10)),
                    moment(new Date(2011, 1, 3, 7, 8, 9, 10)), 'days'), true, 'plural should work');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 1, 7, 8, 9, 10)),
                    moment(new Date(2011, 1, 3, 7, 8, 9, 10)), 'day'), true, 'day is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)),
                    moment(new Date(2011, 1, 4, 7, 8, 9, 10)), 'day'), false, 'day is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 1, 7, 8, 9, 10)),
                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)), 'day'), false, 'day is later');
        assert.equal(m.isBetween(m, 'day'), false, 'same moments are not between the same day');
        assert.equal(+m, +mCopy, 'isBetween day should not change moment');
    });

    test('is between hour', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 5, 9, 10)),
                    moment(new Date(2011, 1, 2, 3, 9, 9, 10)), 'hour'), false, 'hour match');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 1, 59, 59, 999)),
                    moment(new Date(2011, 1, 2, 4, 0, 0, 0)), 'hours'), true, 'plural should work');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 2, 59, 59, 999)),
                    moment(new Date(2011, 1, 2, 4, 0, 0, 0)), 'hour'), true, 'hour is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)),
                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)), 'hour'), false, 'hour is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)),
                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)), 'hour'), false, 'hour is later');
        assert.equal(m.isBetween(m, 'hour'), false, 'same moments are not between the same hour');
        assert.equal(+m, +mCopy, 'isBetween hour should not change moment');
    });

    test('is between minute', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 9, 10)),
                    moment(new Date(2011, 1, 2, 3, 4, 9, 10)), 'minute'), false, 'minute match');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 3, 9, 10)),
                    moment(new Date(2011, 1, 2, 3, 5, 9, 10)), 'minutes'), true, 'plural should work');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 3, 59, 999)),
                    moment(new Date(2011, 1, 2, 3, 5, 0, 0)), 'minute'), true, 'minute is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 5, 0, 0)),
                    moment(new Date(2011, 1, 2, 3, 8, 9, 10)), 'minute'), false, 'minute is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 2, 9, 10)),
                    moment(new Date(2011, 1, 2, 3, 3, 59, 999)), 'minute'), false, 'minute is later');
        assert.equal(m.isBetween(m, 'minute'), false, 'same moments are not between the same minute');
        assert.equal(+m, +mCopy, 'isBetween minute should not change moment');
    });

    test('is between second', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 5, 10)),
                    moment(new Date(2011, 1, 2, 3, 4, 5, 10)), 'second'), false, 'second match');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 4, 10)),
                    moment(new Date(2011, 1, 2, 3, 4, 6, 10)), 'seconds'), true, 'plural should work');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 4, 999)),
                    moment(new Date(2011, 1, 2, 3, 4, 6, 0)), 'second'), true, 'second is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 6, 0)),
                    moment(new Date(2011, 1, 2, 3, 4, 7, 10)), 'second'), false, 'second is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 3, 10)),
                    moment(new Date(2011, 1, 2, 3, 4, 4, 999)), 'second'), false, 'second is later');
        assert.equal(m.isBetween(m, 'second'), false, 'same moments are not between the same second');
        assert.equal(+m, +mCopy, 'isBetween second should not change moment');
    });

    test('is between millisecond', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 5, 6)),
                    moment(new Date(2011, 1, 2, 3, 4, 5, 6)), 'millisecond'), false, 'millisecond match');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 5, 5)),
                    moment(new Date(2011, 1, 2, 3, 4, 5, 7)), 'milliseconds'), true, 'plural should work');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 5, 5)),
                    moment(new Date(2011, 1, 2, 3, 4, 5, 7)), 'millisecond'), true, 'millisecond is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 5, 7)),
                    moment(new Date(2011, 1, 2, 3, 4, 5, 10)), 'millisecond'), false, 'millisecond is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 5, 4)),
                    moment(new Date(2011, 1, 2, 3, 4, 5, 6)), 'millisecond'), false, 'millisecond is later');
        assert.equal(m.isBetween(m, 'millisecond'), false, 'same moments are not between the same millisecond');
        assert.equal(+m, +mCopy, 'isBetween millisecond should not change moment');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('is date');

    test('isDate recognizes Date objects', function (assert) {
        assert.ok(moment.isDate(new Date()), 'no args (now)');
        assert.ok(moment.isDate(new Date([2014, 2, 15])), 'array args');
        assert.ok(moment.isDate(new Date('2014-03-15')), 'string args');
        assert.ok(moment.isDate(new Date('does NOT look like a date')), 'invalid date');
    });

    test('isDate rejects non-Date objects', function (assert) {
        assert.ok(!moment.isDate(), 'nothing');
        assert.ok(!moment.isDate(undefined), 'undefined');
        assert.ok(!moment.isDate(null), 'string args');
        assert.ok(!moment.isDate(42), 'number');
        assert.ok(!moment.isDate('2014-03-15'), 'string');
        assert.ok(!moment.isDate([2014, 2, 15]), 'array');
        assert.ok(!moment.isDate({year: 2014, month: 2, day: 15}), 'object');
        assert.ok(!moment.isDate({toString: function () {
            return '[object Date]';
        }}), 'lying object');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('is moment');

    test('is moment object', function (assert) {
        var MyObj = function () {},
            extend = function (a, b) {
                var i;
                for (i in b) {
                    a[i] = b[i];
                }
                return a;
            };
        MyObj.prototype.toDate = function () {
            return new Date();
        };

        assert.ok(moment.isMoment(moment()), 'simple moment object');
        assert.ok(moment.isMoment(moment(null)), 'invalid moment object');
        assert.ok(moment.isMoment(extend({}, moment())), 'externally cloned moments are moments');
        assert.ok(moment.isMoment(extend({}, moment.utc())), 'externally cloned utc moments are moments');

        assert.ok(!moment.isMoment(new MyObj()), 'myObj is not moment object');
        assert.ok(!moment.isMoment(moment), 'moment function is not moment object');
        assert.ok(!moment.isMoment(new Date()), 'date object is not moment object');
        assert.ok(!moment.isMoment(Object), 'Object is not moment object');
        assert.ok(!moment.isMoment('foo'), 'string is not moment object');
        assert.ok(!moment.isMoment(1), 'number is not moment object');
        assert.ok(!moment.isMoment(NaN), 'NaN is not moment object');
        assert.ok(!moment.isMoment(null), 'null is not moment object');
        assert.ok(!moment.isMoment(undefined), 'undefined is not moment object');
    });

    test('is moment with hacked hasOwnProperty', function (assert) {
        var obj = {};
        // HACK to suppress jshint warning about bad property name
        obj['hasOwnMoney'.replace('Money', 'Property')] = function () {
            return true;
        };

        assert.ok(!moment.isMoment(obj), 'isMoment works even if passed object has a wrong hasOwnProperty implementation (ie8)');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('is same');

    test('is same without units', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isSame(moment(new Date(2012, 3, 2, 3, 5, 5, 10))), false, 'year is later');
        assert.equal(m.isSame(moment(new Date(2010, 3, 2, 3, 3, 5, 10))), false, 'year is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 4, 2, 3, 4, 5, 10))), false, 'month is later');
        assert.equal(m.isSame(moment(new Date(2011, 2, 2, 3, 4, 5, 10))), false, 'month is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 3, 3, 3, 4, 5, 10))), false, 'day is later');
        assert.equal(m.isSame(moment(new Date(2011, 3, 1, 3, 4, 5, 10))), false, 'day is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 4, 4, 5, 10))), false, 'hour is later');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 2, 4, 5, 10))), false, 'hour is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 5, 5, 10))), false, 'minute is later');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 3, 5, 10))), false, 'minute is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 6, 10))), false, 'second is later');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 4, 11))), false, 'second is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 5, 10))), true, 'millisecond match');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 5, 11))), false, 'millisecond is later');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 5, 9))), false, 'millisecond is earlier');
        assert.equal(m.isSame(m), true, 'moments are the same as themselves');
        assert.equal(+m, +mCopy, 'isSame second should not change moment');
    });

    test('is same year', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isSame(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'year'), true, 'year match');
        assert.equal(m.isSame(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'years'), true, 'plural should work');
        assert.equal(m.isSame(moment(new Date(2012, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 0, 1, 0, 0, 0, 0)), 'year'), true, 'exact start of year');
        assert.equal(m.isSame(moment(new Date(2011, 11, 31, 23, 59, 59, 999)), 'year'), true, 'exact end of year');
        assert.equal(m.isSame(moment(new Date(2012, 0, 1, 0, 0, 0, 0)), 'year'), false, 'start of next year');
        assert.equal(m.isSame(moment(new Date(2010, 11, 31, 23, 59, 59, 999)), 'year'), false, 'end of previous year');
        assert.equal(m.isSame(m, 'year'), true, 'same moments are in the same year');
        assert.equal(+m, +mCopy, 'isSame year should not change moment');
    });

    test('is same month', function (assert) {
        var m = moment(new Date(2011, 2, 3, 4, 5, 6, 7)), mCopy = moment(m);
        assert.equal(m.isSame(moment(new Date(2011, 2, 6, 7, 8, 9, 10)), 'month'), true, 'month match');
        assert.equal(m.isSame(moment(new Date(2011, 2, 6, 7, 8, 9, 10)), 'months'), true, 'plural should work');
        assert.equal(m.isSame(moment(new Date(2012, 2, 6, 7, 8, 9, 10)), 'month'), false, 'year mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'month'), false, 'month mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 2, 1, 0, 0, 0, 0)), 'month'), true, 'exact start of month');
        assert.equal(m.isSame(moment(new Date(2011, 2, 31, 23, 59, 59, 999)), 'month'), true, 'exact end of month');
        assert.equal(m.isSame(moment(new Date(2011, 3, 1, 0, 0, 0, 0)), 'month'), false, 'start of next month');
        assert.equal(m.isSame(moment(new Date(2011, 1, 27, 23, 59, 59, 999)), 'month'), false, 'end of previous month');
        assert.equal(m.isSame(m, 'month'), true, 'same moments are in the same month');
        assert.equal(+m, +mCopy, 'isSame month should not change moment');
    });

    test('is same day', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 7, 8, 9, 10)), 'day'), true, 'day match');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 7, 8, 9, 10)), 'days'), true, 'plural should work');
        assert.equal(m.isSame(moment(new Date(2012, 1, 2, 7, 8, 9, 10)), 'day'), false, 'year mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 2, 2, 7, 8, 9, 10)), 'day'), false, 'month mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 3, 7, 8, 9, 10)), 'day'), false, 'day mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 0, 0, 0, 0)), 'day'), true, 'exact start of day');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 23, 59, 59, 999)), 'day'), true, 'exact end of day');
        assert.equal(m.isSame(moment(new Date(2011, 1, 3, 0, 0, 0, 0)), 'day'), false, 'start of next day');
        assert.equal(m.isSame(moment(new Date(2011, 1, 1, 23, 59, 59, 999)), 'day'), false, 'end of previous day');
        assert.equal(m.isSame(m, 'day'), true, 'same moments are in the same day');
        assert.equal(+m, +mCopy, 'isSame day should not change moment');
    });

    test('is same hour', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 8, 9, 10)), 'hour'), true, 'hour match');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 8, 9, 10)), 'hours'), true, 'plural should work');
        assert.equal(m.isSame(moment(new Date(2012, 1, 2, 3, 8, 9, 10)), 'hour'), false, 'year mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 2, 2, 3, 8, 9, 10)), 'hour'), false, 'month mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 3, 3, 8, 9, 10)), 'hour'), false, 'day mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 4, 8, 9, 10)), 'hour'), false, 'hour mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 0, 0, 0)), 'hour'), true, 'exact start of hour');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 59, 59, 999)), 'hour'), true, 'exact end of hour');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 4, 0, 0, 0)), 'hour'), false, 'start of next hour');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 2, 59, 59, 999)), 'hour'), false, 'end of previous hour');
        assert.equal(m.isSame(m, 'hour'), true, 'same moments are in the same hour');
        assert.equal(+m, +mCopy, 'isSame hour should not change moment');
    });

    test('is same minute', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 9, 10)), 'minute'), true, 'minute match');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 9, 10)), 'minutes'), true, 'plural should work');
        assert.equal(m.isSame(moment(new Date(2012, 1, 2, 3, 4, 9, 10)), 'minute'), false, 'year mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 2, 2, 3, 4, 9, 10)), 'minute'), false, 'month mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 3, 3, 4, 9, 10)), 'minute'), false, 'day mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 4, 4, 9, 10)), 'minute'), false, 'hour mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 5, 9, 10)), 'minute'), false, 'minute mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 0, 0)), 'minute'), true, 'exact start of minute');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 59, 999)), 'minute'), true, 'exact end of minute');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 5, 0, 0)), 'minute'), false, 'start of next minute');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 3, 59, 999)), 'minute'), false, 'end of previous minute');
        assert.equal(m.isSame(m, 'minute'), true, 'same moments are in the same minute');
        assert.equal(+m, +mCopy, 'isSame minute should not change moment');
    });

    test('is same second', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 5, 10)), 'second'), true, 'second match');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 5, 10)), 'seconds'), true, 'plural should work');
        assert.equal(m.isSame(moment(new Date(2012, 1, 2, 3, 4, 5, 10)), 'second'), false, 'year mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 2, 2, 3, 4, 5, 10)), 'second'), false, 'month mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 3, 3, 4, 5, 10)), 'second'), false, 'day mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 4, 4, 5, 10)), 'second'), false, 'hour mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 5, 5, 10)), 'second'), false, 'minute mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 6, 10)), 'second'), false, 'second mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 5, 0)), 'second'), true, 'exact start of second');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 5, 999)), 'second'), true, 'exact end of second');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 6, 0)), 'second'), false, 'start of next second');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 4, 999)), 'second'), false, 'end of previous second');
        assert.equal(m.isSame(m, 'second'), true, 'same moments are in the same second');
        assert.equal(+m, +mCopy, 'isSame second should not change moment');
    });

    test('is same millisecond', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'millisecond'), true, 'millisecond match');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'milliseconds'), true, 'plural should work');
        assert.equal(m.isSame(moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'millisecond'), false, 'year is later');
        assert.equal(m.isSame(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'millisecond'), false, 'year is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 4, 2, 3, 4, 5, 10)), 'millisecond'), false, 'month is later');
        assert.equal(m.isSame(moment(new Date(2011, 2, 2, 3, 4, 5, 10)), 'millisecond'), false, 'month is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 3, 3, 3, 4, 5, 10)), 'millisecond'), false, 'day is later');
        assert.equal(m.isSame(moment(new Date(2011, 3, 1, 1, 4, 5, 10)), 'millisecond'), false, 'day is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 4, 4, 5, 10)), 'millisecond'), false, 'hour is later');
        assert.equal(m.isSame(moment(new Date(2011, 3, 1, 4, 1, 5, 10)), 'millisecond'), false, 'hour is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 5, 5, 10)), 'millisecond'), false, 'minute is later');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 3, 5, 10)), 'millisecond'), false, 'minute is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 6, 10)), 'millisecond'), false, 'second is later');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 4, 5)), 'millisecond'), false, 'second is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 6, 11)), 'millisecond'), false, 'millisecond is later');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 4, 9)), 'millisecond'), false, 'millisecond is earlier');
        assert.equal(m.isSame(m, 'millisecond'), true, 'same moments are in the same millisecond');
        assert.equal(+m, +mCopy, 'isSame millisecond should not change moment');
    });

    test('is same with utc offset moments', function (assert) {
        assert.ok(moment.parseZone('2013-02-01T-05:00').isSame(moment('2013-02-01'), 'year'), 'zoned vs local moment');
        assert.ok(moment('2013-02-01').isSame(moment('2013-02-01').utcOffset('-05:00'), 'year'), 'local vs zoned moment');
        assert.ok(moment.parseZone('2013-02-01T-05:00').isSame(moment.parseZone('2013-02-01T-06:30'), 'year'),
                'zoned vs (differently) zoned moment');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('is valid');

    test('array bad month', function (assert) {
        assert.equal(moment([2010, -1]).isValid(), false, 'month -1 invalid');
        assert.equal(moment([2100, 12]).isValid(), false, 'month 12 invalid');
    });

    test('array good month', function (assert) {
        for (var i = 0; i < 12; i++) {
            assert.equal(moment([2010, i]).isValid(), true, 'month ' + i);
            assert.equal(moment.utc([2010, i]).isValid(), true, 'month ' + i);
        }
    });

    test('array bad date', function (assert) {
        var tests = [
            moment([2010, 0, 0]),
            moment([2100, 0, 32]),
            moment.utc([2010, 0, 0]),
            moment.utc([2100, 0, 32])
        ],
        i, m;

        for (i in tests) {
            m = tests[i];
            assert.equal(m.isValid(), false);
        }
    });

    test('h/hh with hour > 12', function (assert) {
        assert.ok(moment('06/20/2014 11:51 PM', 'MM/DD/YYYY hh:mm A', true).isValid(), '11 for hh');
        assert.ok(moment('06/20/2014 11:51 AM', 'MM/DD/YYYY hh:mm A', true).isValid(), '11 for hh');
        assert.ok(moment('06/20/2014 23:51 PM', 'MM/DD/YYYY hh:mm A').isValid(), 'non-strict validity 23 for hh');
        assert.ok(moment('06/20/2014 23:51 PM', 'MM/DD/YYYY hh:mm A').parsingFlags().bigHour, 'non-strict bigHour 23 for hh');
        assert.ok(!moment('06/20/2014 23:51 PM', 'MM/DD/YYYY hh:mm A', true).isValid(), 'validity 23 for hh');
        assert.ok(moment('06/20/2014 23:51 PM', 'MM/DD/YYYY hh:mm A', true).parsingFlags().bigHour, 'bigHour 23 for hh');
    });

    test('array bad date leap year', function (assert) {
        assert.equal(moment([2010, 1, 29]).isValid(), false, '2010 feb 29');
        assert.equal(moment([2100, 1, 29]).isValid(), false, '2100 feb 29');
        assert.equal(moment([2008, 1, 30]).isValid(), false, '2008 feb 30');
        assert.equal(moment([2000, 1, 30]).isValid(), false, '2000 feb 30');

        assert.equal(moment.utc([2010, 1, 29]).isValid(), false, 'utc 2010 feb 29');
        assert.equal(moment.utc([2100, 1, 29]).isValid(), false, 'utc 2100 feb 29');
        assert.equal(moment.utc([2008, 1, 30]).isValid(), false, 'utc 2008 feb 30');
        assert.equal(moment.utc([2000, 1, 30]).isValid(), false, 'utc 2000 feb 30');
    });

    test('string + formats bad date', function (assert) {
        assert.equal(moment('2020-00-00', []).isValid(), false, 'invalid on empty array');
        assert.equal(moment('2020-00-00', ['YYYY-MM-DD', 'DD-MM-YYYY']).isValid(), false, 'invalid on all in array');
        assert.equal(moment('2020-00-00', ['DD-MM-YYYY', 'YYYY-MM-DD']).isValid(), false, 'invalid on all in array');
        assert.equal(moment('2020-01-01', ['YYYY-MM-DD', 'DD-MM-YYYY']).isValid(), true, 'valid on first');
        assert.equal(moment('2020-01-01', ['DD-MM-YYYY', 'YYYY-MM-DD']).isValid(), true, 'valid on last');
        assert.equal(moment('2020-01-01', ['YYYY-MM-DD', 'YYYY-DD-MM']).isValid(), true, 'valid on both');
        assert.equal(moment('2020-13-01', ['YYYY-MM-DD', 'YYYY-DD-MM']).isValid(), true, 'valid on last');

        assert.equal(moment('12-13-2012', ['DD-MM-YYYY', 'YYYY-MM-DD']).isValid(), false, 'month rollover');
        assert.equal(moment('12-13-2012', ['DD-MM-YYYY', 'DD-MM-YYYY']).isValid(), false, 'month rollover');
        assert.equal(moment('38-12-2012', ['DD-MM-YYYY']).isValid(), false, 'day rollover');
    });

    test('string nonsensical with format', function (assert) {
        assert.equal(moment('fail', 'MM-DD-YYYY').isValid(), false, 'string \'fail\' with format \'MM-DD-YYYY\'');
        assert.equal(moment('xx-xx-2001', 'DD-MM-YYY').isValid(), true, 'string \'xx-xx-2001\' with format \'MM-DD-YYYY\'');
    });

    test('string with bad month name', function (assert) {
        assert.equal(moment('01-Nam-2012', 'DD-MMM-YYYY').isValid(), false, '\'Nam\' is an invalid month');
        assert.equal(moment('01-Aug-2012', 'DD-MMM-YYYY').isValid(), true, '\'Aug\' is a valid month');
    });

    test('string with spaceless format', function (assert) {
        assert.equal(moment('10Sep2001', 'DDMMMYYYY').isValid(), true, 'Parsing 10Sep2001 should result in a valid date');
    });

    test('invalid string iso 8601', function (assert) {
        var tests = [
            '2010-00-00',
            '2010-01-00',
            '2010-01-40',
            '2010-01-01T24:01',  // 24:00:00 is actually valid
            '2010-01-01T23:60',
            '2010-01-01T23:59:60'
        ], i;

        for (i = 0; i < tests.length; i++) {
            assert.equal(moment(tests[i]).isValid(), false, tests[i] + ' should be invalid');
            assert.equal(moment.utc(tests[i]).isValid(), false, tests[i] + ' should be invalid');
        }
    });

    test('invalid string iso 8601 + timezone', function (assert) {
        var tests = [
            '2010-00-00T+00:00',
            '2010-01-00T+00:00',
            '2010-01-40T+00:00',
            '2010-01-40T24:01+00:00',
            '2010-01-40T23:60+00:00',
            '2010-01-40T23:59:60+00:00',
            '2010-01-40T23:59:59.9999+00:00'
        ], i;

        for (i = 0; i < tests.length; i++) {
            assert.equal(moment(tests[i]).isValid(), false, tests[i] + ' should be invalid');
            assert.equal(moment.utc(tests[i]).isValid(), false, tests[i] + ' should be invalid');
        }
    });

    test('valid string iso 8601 + timezone', function (assert) {
        var tests = [
            '2010-01-01',
            '2010-01-30',
            '2010-01-30T23+00:00',
            '2010-01-30T23:59+00:00',
            '2010-01-30T23:59:59+00:00',
            '2010-01-30T23:59:59.999+00:00',
            '2010-01-30T23:59:59.999-07:00',
            '2010-01-30T00:00:00.000+07:00',
            '2010-01-30T00:00:00.000+07'
        ], i;

        for (i = 0; i < tests.length; i++) {
            assert.equal(moment(tests[i]).isValid(), true, tests[i] + ' should be valid');
            assert.equal(moment.utc(tests[i]).isValid(), true, tests[i] + ' should be valid');
        }
    });

    test('invalidAt', function (assert) {
        assert.equal(moment([2000, 12]).invalidAt(), 1, 'month 12 is invalid: 0-11');
        assert.equal(moment([2000, 1, 30]).invalidAt(), 2, '30 is not a valid february day');
        assert.equal(moment([2000, 1, 29, 25]).invalidAt(), 3, '25 is invalid hour');
        assert.equal(moment([2000, 1, 29, 24,  1]).invalidAt(), 3, '24:01 is invalid hour');
        assert.equal(moment([2000, 1, 29, 23, 60]).invalidAt(), 4, '60 is invalid minute');
        assert.equal(moment([2000, 1, 29, 23, 59, 60]).invalidAt(), 5, '60 is invalid second');
        assert.equal(moment([2000, 1, 29, 23, 59, 59, 1000]).invalidAt(), 6, '1000 is invalid millisecond');
        assert.equal(moment([2000, 1, 29, 23, 59, 59, 999]).invalidAt(), -1, '-1 if everything is fine');
    });

    test('valid Unix timestamp', function (assert) {
        assert.equal(moment(1371065286, 'X').isValid(), true, 'number integer');
        assert.equal(moment(1379066897.0, 'X').isValid(), true, 'number whole 1dp');
        assert.equal(moment(1379066897.7, 'X').isValid(), true, 'number 1dp');
        assert.equal(moment(1379066897.00, 'X').isValid(), true, 'number whole 2dp');
        assert.equal(moment(1379066897.07, 'X').isValid(), true, 'number 2dp');
        assert.equal(moment(1379066897.17, 'X').isValid(), true, 'number 2dp');
        assert.equal(moment(1379066897.000, 'X').isValid(), true, 'number whole 3dp');
        assert.equal(moment(1379066897.007, 'X').isValid(), true, 'number 3dp');
        assert.equal(moment(1379066897.017, 'X').isValid(), true, 'number 3dp');
        assert.equal(moment(1379066897.157, 'X').isValid(), true, 'number 3dp');
        assert.equal(moment('1371065286', 'X').isValid(), true, 'string integer');
        assert.equal(moment('1379066897.', 'X').isValid(), true, 'string trailing .');
        assert.equal(moment('1379066897.0', 'X').isValid(), true, 'string whole 1dp');
        assert.equal(moment('1379066897.7', 'X').isValid(), true, 'string 1dp');
        assert.equal(moment('1379066897.00', 'X').isValid(), true, 'string whole 2dp');
        assert.equal(moment('1379066897.07', 'X').isValid(), true, 'string 2dp');
        assert.equal(moment('1379066897.17', 'X').isValid(), true, 'string 2dp');
        assert.equal(moment('1379066897.000', 'X').isValid(), true, 'string whole 3dp');
        assert.equal(moment('1379066897.007', 'X').isValid(), true, 'string 3dp');
        assert.equal(moment('1379066897.017', 'X').isValid(), true, 'string 3dp');
        assert.equal(moment('1379066897.157', 'X').isValid(), true, 'string 3dp');
    });

    test('invalid Unix timestamp', function (assert) {
        assert.equal(moment(undefined, 'X').isValid(), false, 'undefined');
        assert.equal(moment('undefined', 'X').isValid(), false, 'string undefined');
        try {
            assert.equal(moment(null, 'X').isValid(), false, 'null');
        } catch (e) {
            assert.ok(true, 'null');
        }

        assert.equal(moment('null', 'X').isValid(), false, 'string null');
        assert.equal(moment([], 'X').isValid(), false, 'array');
        assert.equal(moment('{}', 'X').isValid(), false, 'object');
        try {
            assert.equal(moment('', 'X').isValid(), false, 'string empty');
        } catch (e) {
            assert.ok(true, 'string empty');
        }

        assert.equal(moment(' ', 'X').isValid(), false, 'string space');
    });

    test('valid Unix offset milliseconds', function (assert) {
        assert.equal(moment(1234567890123, 'x').isValid(), true, 'number integer');
        assert.equal(moment('1234567890123', 'x').isValid(), true, 'string integer');
    });

    test('invalid Unix offset milliseconds', function (assert) {
        assert.equal(moment(undefined, 'x').isValid(), false, 'undefined');
        assert.equal(moment('undefined', 'x').isValid(), false, 'string undefined');
        try {
            assert.equal(moment(null, 'x').isValid(), false, 'null');
        } catch (e) {
            assert.ok(true, 'null');
        }

        assert.equal(moment('null', 'x').isValid(), false, 'string null');
        assert.equal(moment([], 'x').isValid(), false, 'array');
        assert.equal(moment('{}', 'x').isValid(), false, 'object');
        try {
            assert.equal(moment('', 'x').isValid(), false, 'string empty');
        } catch (e) {
            assert.ok(true, 'string empty');
        }

        assert.equal(moment(' ', 'x').isValid(), false, 'string space');
    });

    test('empty', function (assert) {
        assert.equal(moment(null).isValid(), false, 'null');
        assert.equal(moment('').isValid(), false, 'empty string');
        assert.equal(moment(null, 'YYYY').isValid(), false, 'format + null');
        assert.equal(moment('', 'YYYY').isValid(), false, 'format + empty string');
        assert.equal(moment(' ', 'YYYY').isValid(), false, 'format + empty when trimmed');
    });

    test('days of the year', function (assert) {
        assert.equal(moment('2010 300', 'YYYY DDDD').isValid(), true, 'day 300 of year valid');
        assert.equal(moment('2010 365', 'YYYY DDDD').isValid(), true, 'day 365 of year valid');
        assert.equal(moment('2010 366', 'YYYY DDDD').isValid(), false, 'day 366 of year invalid');
        assert.equal(moment('2012 365', 'YYYY DDDD').isValid(), true, 'day 365 of leap year valid');
        assert.equal(moment('2012 366', 'YYYY DDDD').isValid(), true, 'day 366 of leap year valid');
        assert.equal(moment('2012 367', 'YYYY DDDD').isValid(), false, 'day 367 of leap year invalid');
    });

    test('24:00:00.000 is valid', function (assert) {
        assert.equal(moment('2014-01-01 24', 'YYYY-MM-DD HH').isValid(), true, '24 is valid');
        assert.equal(moment('2014-01-01 24:00', 'YYYY-MM-DD HH:mm').isValid(), true, '24:00 is valid');
        assert.equal(moment('2014-01-01 24:01', 'YYYY-MM-DD HH:mm').isValid(), false, '24:01 is not valid');
    });

    test('oddball permissiveness', function (assert) {
        //https://github.com/moment/moment/issues/1128
        assert.ok(moment('2010-10-3199', ['MM/DD/YYYY', 'MM-DD-YYYY', 'YYYY-MM-DD']).isValid());

        //https://github.com/moment/moment/issues/1122
        assert.ok(moment('3:25', ['h:mma', 'hh:mma', 'H:mm', 'HH:mm']).isValid());
    });

    test('0 hour is invalid in strict', function (assert) {
        assert.equal(moment('00:01', 'hh:mm', true).isValid(), false, '00 hour is invalid in strict');
        assert.equal(moment('00:01', 'hh:mm').isValid(), true, '00 hour is valid in normal');
        assert.equal(moment('0:01', 'h:mm', true).isValid(), false, '0 hour is invalid in strict');
        assert.equal(moment('0:01', 'h:mm').isValid(), true, '0 hour is valid in normal');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('leap year');

    test('leap year', function (assert) {
        assert.equal(moment([2010, 0, 1]).isLeapYear(), false, '2010');
        assert.equal(moment([2100, 0, 1]).isLeapYear(), false, '2100');
        assert.equal(moment([2008, 0, 1]).isLeapYear(), true, '2008');
        assert.equal(moment([2000, 0, 1]).isLeapYear(), true, '2000');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('listers');

    test('default', function (assert) {
        assert.deepEqual(moment.months(), ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']);
        assert.deepEqual(moment.monthsShort(), ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']);
        assert.deepEqual(moment.weekdays(), ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']);
        assert.deepEqual(moment.weekdaysShort(), ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']);
        assert.deepEqual(moment.weekdaysMin(), ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa']);
    });

    test('index', function (assert) {
        assert.equal(moment.months(0), 'January');
        assert.equal(moment.months(2), 'March');
        assert.equal(moment.monthsShort(0), 'Jan');
        assert.equal(moment.monthsShort(2), 'Mar');
        assert.equal(moment.weekdays(0), 'Sunday');
        assert.equal(moment.weekdays(2), 'Tuesday');
        assert.equal(moment.weekdaysShort(0), 'Sun');
        assert.equal(moment.weekdaysShort(2), 'Tue');
        assert.equal(moment.weekdaysMin(0), 'Su');
        assert.equal(moment.weekdaysMin(2), 'Tu');
    });

    test('localized', function (assert) {
        var months = 'one_two_three_four_five_six_seven_eight_nine_ten_eleven_twelve'.split('_'),
            monthsShort = 'on_tw_th_fo_fi_si_se_ei_ni_te_el_tw'.split('_'),
            weekdays = 'one_two_three_four_five_six_seven'.split('_'),
            weekdaysShort = 'on_tw_th_fo_fi_si_se'.split('_'),
            weekdaysMin = '1_2_3_4_5_6_7'.split('_');

        moment.locale('numerologists', {
            months : months,
            monthsShort : monthsShort,
            weekdays : weekdays,
            weekdaysShort: weekdaysShort,
            weekdaysMin: weekdaysMin
        });

        assert.deepEqual(moment.months(), months);
        assert.deepEqual(moment.monthsShort(), monthsShort);
        assert.deepEqual(moment.weekdays(), weekdays);
        assert.deepEqual(moment.weekdaysShort(), weekdaysShort);
        assert.deepEqual(moment.weekdaysMin(), weekdaysMin);

        assert.equal(moment.months(0), 'one');
        assert.equal(moment.monthsShort(0), 'on');
        assert.equal(moment.weekdays(0), 'one');
        assert.equal(moment.weekdaysShort(0), 'on');
        assert.equal(moment.weekdaysMin(0), '1');

        assert.equal(moment.months(2), 'three');
        assert.equal(moment.monthsShort(2), 'th');
        assert.equal(moment.weekdays(2), 'three');
        assert.equal(moment.weekdaysShort(2), 'th');
        assert.equal(moment.weekdaysMin(2), '3');
    });

    test('with functions', function (assert) {
        var monthsShort = 'one_two_three_four_five_six_seven_eight_nine_ten_eleven_twelve'.split('_'),
            monthsShortWeird = 'onesy_twosy_threesy_foursy_fivesy_sixsy_sevensy_eightsy_ninesy_tensy_elevensy_twelvesy'.split('_');

        moment.locale('difficult', {

            monthsShort: function (m, format) {
                var arr = format.match(/-MMM-/) ? monthsShortWeird : monthsShort;
                return arr[m.month()];
            }
        });

        assert.deepEqual(moment.monthsShort(), monthsShort);
        assert.deepEqual(moment.monthsShort('MMM'), monthsShort);
        assert.deepEqual(moment.monthsShort('-MMM-'), monthsShortWeird);

        assert.deepEqual(moment.monthsShort('MMM', 2), 'three');
        assert.deepEqual(moment.monthsShort('-MMM-', 2), 'threesy');
        assert.deepEqual(moment.monthsShort(2), 'three');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    var helpers_each = each;

    module('locale', {
        setup : function () {
            // TODO: Remove once locales are switched to ES6
            helpers_each([{
                name: 'en-gb',
                data: {}
            }, {
                name: 'en-ca',
                data: {}
            }, {
                name: 'es',
                data: {
                    relativeTime: {past: 'hace %s', s: 'unos segundos', d: 'un d√≠a'},
                    months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_')
                }
            }, {
                name: 'fr',
                data: {}
            }, {
                name: 'fr-ca',
                data: {}
            }, {
                name: 'it',
                data: {}
            }, {
                name: 'zh-cn',
                data: {
                    months: '‰∏ÄÊúà_‰∫åÊúà_‰∏âÊúà_ÂõõÊúà_‰∫îÊúà_ÂÖ≠Êúà_‰∏ÉÊúà_ÂÖ´Êúà_‰πùÊúà_ÂçÅÊúà_ÂçÅ‰∏ÄÊúà_ÂçÅ‰∫åÊúà'.split('_')
                }
            }], function (locale) {
                if (moment.locale(locale.name) !== locale.name) {
                    moment.defineLocale(locale.name, locale.data);
                }
            });
            moment.locale('en');
        }
    });

    test('library getters and setters', function (assert) {
        var r = moment.locale('en');

        assert.equal(r, 'en', 'locale should return en by default');
        assert.equal(moment.locale(), 'en', 'locale should return en by default');

        moment.locale('fr');
        assert.equal(moment.locale(), 'fr', 'locale should return the changed locale');

        moment.locale('en-gb');
        assert.equal(moment.locale(), 'en-gb', 'locale should return the changed locale');

        moment.locale('en');
        assert.equal(moment.locale(), 'en', 'locale should reset');

        moment.locale('does-not-exist');
        assert.equal(moment.locale(), 'en', 'locale should reset');

        moment.locale('EN');
        assert.equal(moment.locale(), 'en', 'Normalize locale key case');

        moment.locale('EN_gb');
        assert.equal(moment.locale(), 'en-gb', 'Normalize locale key underscore');
    });

    test('library setter array of locales', function (assert) {
        assert.equal(moment.locale(['non-existent', 'fr', 'also-non-existent']), 'fr', 'passing an array uses the first valid locale');
        assert.equal(moment.locale(['es', 'fr', 'also-non-existent']), 'es', 'passing an array uses the first valid locale');
    });

    test('library setter locale substrings', function (assert) {
        assert.equal(moment.locale('fr-crap'), 'fr', 'use substrings');
        assert.equal(moment.locale('fr-does-not-exist'), 'fr', 'uses deep substrings');
        assert.equal(moment.locale('fr-CA-does-not-exist'), 'fr-ca', 'uses deepest substring');
    });

    test('library getter locale array and substrings', function (assert) {
        assert.equal(moment.locale(['en-CH', 'fr']), 'en', 'prefer root locale to shallower ones');
        assert.equal(moment.locale(['en-gb-leeds', 'en-CA']), 'en-gb', 'prefer root locale to shallower ones');
        assert.equal(moment.locale(['en-fake', 'en-CA']), 'en-ca', 'prefer alternatives with shared roots');
        assert.equal(moment.locale(['en-fake', 'en-fake2', 'en-ca']), 'en-ca', 'prefer alternatives with shared roots');
        assert.equal(moment.locale(['fake-CA', 'fake-MX', 'fr']), 'fr', 'always find something if possible');
        assert.equal(moment.locale(['fake-CA', 'fake-MX', 'fr']), 'fr', 'always find something if possible');
        assert.equal(moment.locale(['fake-CA', 'fake-MX', 'fr-fake-fake-fake']), 'fr', 'always find something if possible');
        assert.equal(moment.locale(['en', 'en-CA']), 'en', 'prefer earlier if it works');
    });

    test('library ensure inheritance', function (assert) {
        moment.locale('made-up', {
            // I put them out of order
            months : 'February_March_April_May_June_July_August_September_October_November_December_January'.split('_')
            // the rest of the properties should be inherited.
        });

        assert.equal(moment([2012, 5, 6]).format('MMMM'), 'July', 'Override some of the configs');
        assert.equal(moment([2012, 5, 6]).format('MMM'), 'Jun', 'But not all of them');
    });

    test('library ensure inheritance LT L LL LLL LLLL', function (assert) {
        var locale = 'test-inherit-lt';

        moment.defineLocale(locale, {
            longDateFormat : {
                LT : '-[LT]-',
                L : '-[L]-',
                LL : '-[LL]-',
                LLL : '-[LLL]-',
                LLLL : '-[LLLL]-'
            },
            calendar : {
                sameDay : '[sameDay] LT',
                nextDay : '[nextDay] L',
                nextWeek : '[nextWeek] LL',
                lastDay : '[lastDay] LLL',
                lastWeek : '[lastWeek] LLLL',
                sameElse : 'L'
            }
        });

        moment.locale('es');

        assert.equal(moment().locale(locale).calendar(), 'sameDay -LT-', 'Should use instance locale in LT formatting');
        assert.equal(moment().add(1, 'days').locale(locale).calendar(), 'nextDay -L-', 'Should use instance locale in L formatting');
        assert.equal(moment().add(-1, 'days').locale(locale).calendar(), 'lastDay -LLL-', 'Should use instance locale in LL formatting');
        assert.equal(moment().add(4, 'days').locale(locale).calendar(), 'nextWeek -LL-', 'Should use instance locale in LLL formatting');
        assert.equal(moment().add(-4, 'days').locale(locale).calendar(), 'lastWeek -LLLL-', 'Should use instance locale in LLLL formatting');
    });

    test('library localeData', function (assert) {
        moment.locale('en');

        var jan = moment([2000, 0]);

        assert.equal(moment.localeData().months(jan), 'January', 'no arguments returns global');
        assert.equal(moment.localeData('zh-cn').months(jan), '‰∏ÄÊúà', 'a string returns the locale based on key');
        assert.equal(moment.localeData(moment().locale('es')).months(jan), 'Enero', 'if you pass in a moment it uses the moment\'s locale');
    });

    test('library deprecations', function (assert) {
        moment.lang('dude', {months: ['Movember']});
        assert.equal(moment.locale(), 'dude', 'setting the lang sets the locale');
        assert.equal(moment.lang(), moment.locale());
        assert.equal(moment.langData(), moment.localeData(), 'langData is localeData');
    });

    test('defineLocale', function (assert) {
        moment.locale('en');
        moment.defineLocale('dude', {months: ['Movember']});
        assert.equal(moment().locale(), 'dude', 'defineLocale also sets it');
        assert.equal(moment().locale('dude').locale(), 'dude', 'defineLocale defines a locale');
    });

    test('library convenience', function (assert) {
        moment.locale('something', {week: {dow: 3}});
        moment.locale('something');
        assert.equal(moment.locale(), 'something', 'locale can be used to create the locale too');
    });

    test('firstDayOfWeek firstDayOfYear locale getters', function (assert) {
        moment.locale('something', {week: {dow: 3, doy: 4}});
        moment.locale('something');
        assert.equal(moment.localeData().firstDayOfWeek(), 3, 'firstDayOfWeek');
        assert.equal(moment.localeData().firstDayOfYear(), 4, 'firstDayOfYear');
    });

    test('instance locale method', function (assert) {
        moment.locale('en');

        assert.equal(moment([2012, 5, 6]).format('MMMM'), 'June', 'Normally default to global');
        assert.equal(moment([2012, 5, 6]).locale('es').format('MMMM'), 'Junio', 'Use the instance specific locale');
        assert.equal(moment([2012, 5, 6]).format('MMMM'), 'June', 'Using an instance specific locale does not affect other moments');
    });

    test('instance locale method with array', function (assert) {
        var m = moment().locale(['non-existent', 'fr', 'also-non-existent']);
        assert.equal(m.locale(), 'fr', 'passing an array uses the first valid locale');
        m = moment().locale(['es', 'fr', 'also-non-existent']);
        assert.equal(m.locale(), 'es', 'passing an array uses the first valid locale');
    });

    test('instance getter locale substrings', function (assert) {
        var m = moment();

        m.locale('fr-crap');
        assert.equal(m.locale(), 'fr', 'use substrings');

        m.locale('fr-does-not-exist');
        assert.equal(m.locale(), 'fr', 'uses deep substrings');
    });

    test('instance locale persists with manipulation', function (assert) {
        moment.locale('en');

        assert.equal(moment([2012, 5, 6]).locale('es').add({days: 1}).format('MMMM'), 'Junio', 'With addition');
        assert.equal(moment([2012, 5, 6]).locale('es').day(0).format('MMMM'), 'Junio', 'With day getter');
        assert.equal(moment([2012, 5, 6]).locale('es').endOf('day').format('MMMM'), 'Junio', 'With endOf');
    });

    test('instance locale persists with cloning', function (assert) {
        moment.locale('en');

        var a = moment([2012, 5, 6]).locale('es'),
            b = a.clone(),
            c = moment(a);

        assert.equal(b.format('MMMM'), 'Junio', 'using moment.fn.clone()');
        assert.equal(b.format('MMMM'), 'Junio', 'using moment()');
    });

    test('duration locale method', function (assert) {
        moment.locale('en');

        assert.equal(moment.duration({seconds:  44}).humanize(), 'a few seconds', 'Normally default to global');
        assert.equal(moment.duration({seconds:  44}).locale('es').humanize(), 'unos segundos', 'Use the instance specific locale');
        assert.equal(moment.duration({seconds:  44}).humanize(), 'a few seconds', 'Using an instance specific locale does not affect other durations');
    });

    test('duration locale persists with cloning', function (assert) {
        moment.locale('en');

        var a = moment.duration({seconds:  44}).locale('es'),
            b = moment.duration(a);

        assert.equal(b.humanize(), 'unos segundos', 'using moment.duration()');
    });

    test('changing the global locale doesn\'t affect existing duration instances', function (assert) {
        var mom = moment.duration();
        moment.locale('fr');
        assert.equal('en', mom.locale());
    });

    test('duration deprecations', function (assert) {
        assert.equal(moment.duration().lang(), moment.duration().localeData(), 'duration.lang is the same as duration.localeData');
    });

    test('from and fromNow with invalid date', function (assert) {
        assert.equal(moment(NaN).from(), 'Invalid date', 'moment.from with invalid moment');
        assert.equal(moment(NaN).fromNow(), 'Invalid date', 'moment.fromNow with invalid moment');
    });

    test('from relative time future', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).subtract({s: 44})),  'in a few seconds', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({s: 45})),  'in a minute',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({s: 89})),  'in a minute',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({s: 90})),  'in 2 minutes',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({m: 44})),  'in 44 minutes',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({m: 45})),  'in an hour',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({m: 89})),  'in an hour',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({m: 90})),  'in 2 hours',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({h: 5})),   'in 5 hours',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({h: 21})),  'in 21 hours',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({h: 22})),  'in a day',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({h: 35})),  'in a day',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({h: 36})),  'in 2 days',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 1})),   'in a day',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 5})),   'in 5 days',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 25})),  'in 25 days',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 26})),  'in a month',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 30})),  'in a month',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 45})),  'in a month',       '45 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 47})),  'in 2 months',      '47 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 74})),  'in 2 months',      '74 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 78})),  'in 3 months',      '78 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({M: 1})),   'in a month',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({M: 5})),   'in 5 months',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 315})), 'in 10 months',     '315 days = 10 months');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 344})), 'in a year',        '344 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 345})), 'in a year',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 548})), 'in 2 years',       '548 days = in 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({y: 1})),   'in a year',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({y: 5})),   'in 5 years',       '5 years = 5 years');
    });

    test('from relative time past', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44})),  'a few seconds ago', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45})),  'a minute ago',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89})),  'a minute ago',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90})),  '2 minutes ago',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44})),  '44 minutes ago',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45})),  'an hour ago',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89})),  'an hour ago',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90})),  '2 hours ago',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5})),   '5 hours ago',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21})),  '21 hours ago',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22})),  'a day ago',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35})),  'a day ago',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36})),  '2 days ago',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1})),   'a day ago',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5})),   '5 days ago',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25})),  '25 days ago',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26})),  'a month ago',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30})),  'a month ago',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43})),  'a month ago',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46})),  '2 months ago',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74})),  '2 months ago',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76})),  '3 months ago',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1})),   'a month ago',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5})),   '5 months ago',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 315})), '10 months ago',     '315 days = 10 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 344})), 'a year ago',        '344 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345})), 'a year ago',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548})), '2 years ago',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1})),   'a year ago',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5})),   '5 years ago',       '5 years = 5 years');
    });

    test('instance locale used with from', function (assert) {
        moment.locale('en');

        var a = moment([2012, 5, 6]).locale('es'),
            b = moment([2012, 5, 7]);

        assert.equal(a.from(b), 'hace un d√≠a', 'preserve locale of first moment');
        assert.equal(b.from(a), 'in a day', 'do not preserve locale of second moment');
    });

    test('instance localeData', function (assert) {
        moment.defineLocale('dude', {week: {dow: 3}});
        assert.equal(moment().locale('dude').localeData()._week.dow, 3);
    });

    test('month name callback function', function (assert) {
        function fakeReplace(m, format) {
            if (/test/.test(format)) {
                return 'test';
            }
            if (m.date() === 1) {
                return 'date';
            }
            return 'default';
        }

        moment.locale('made-up-2', {
            months : fakeReplace,
            monthsShort : fakeReplace,
            weekdays : fakeReplace,
            weekdaysShort : fakeReplace,
            weekdaysMin : fakeReplace
        });

        assert.equal(moment().format('[test] dd ddd dddd MMM MMMM'), 'test test test test test test', 'format month name function should be able to access the format string');
        assert.equal(moment([2011, 0, 1]).format('dd ddd dddd MMM MMMM'), 'date date date date date', 'format month name function should be able to access the moment object');
        assert.equal(moment([2011, 0, 2]).format('dd ddd dddd MMM MMMM'), 'default default default default default', 'format month name function should be able to access the moment object');
    });

    test('changing parts of a locale config', function (assert) {
        moment.locale('partial-lang', {
            months : 'a b c d e f g h i j k l'.split(' ')
        });

        assert.equal(moment([2011, 0, 1]).format('MMMM'), 'a', 'should be able to set locale values when creating the localeuage');

        moment.locale('partial-lang', {
            monthsShort : 'A B C D E F G H I J K L'.split(' ')
        });

        assert.equal(moment([2011, 0, 1]).format('MMMM MMM'), 'a A', 'should be able to set locale values after creating the localeuage');
    });

    test('start/endOf week feature for first-day-is-monday locales', function (assert) {
        moment.locale('monday-lang', {
            week : {
                dow : 1 // Monday is the first day of the week
            }
        });

        moment.locale('monday-lang');
        assert.equal(moment([2013, 0, 1]).startOf('week').day(), 1, 'for locale monday-lang first day of the week should be monday');
        assert.equal(moment([2013, 0, 1]).endOf('week').day(), 0, 'for locale monday-lang last day of the week should be sunday');
    });

    test('meridiem parsing', function (assert) {
        moment.locale('meridiem-parsing', {
            meridiemParse : /[bd]/i,
            isPM : function (input) {
                return input === 'b';
            }
        });

        moment.locale('meridiem-parsing');
        assert.equal(moment('2012-01-01 3b', 'YYYY-MM-DD ha').hour(), 15, 'Custom parsing of meridiem should work');
        assert.equal(moment('2012-01-01 3d', 'YYYY-MM-DD ha').hour(), 3, 'Custom parsing of meridiem should work');
    });

    test('invalid date formatting', function (assert) {
        moment.locale('has-invalid', {
            invalidDate: 'KHAAAAAAAAAAAN!'
        });

        assert.equal(moment.invalid().format(), 'KHAAAAAAAAAAAN!');
        assert.equal(moment.invalid().format('YYYY-MM-DD'), 'KHAAAAAAAAAAAN!');
    });

    test('return locale name', function (assert) {
        var registered = moment.locale('return-this', {});

        assert.equal(registered, 'return-this', 'returns the locale configured');
    });

    test('changing the global locale doesn\'t affect existing instances', function (assert) {
        var mom = moment();
        moment.locale('fr');
        assert.equal('en', mom.locale());
    });

    test('setting a language on instance returns the original moment for chaining', function (assert) {
        var mom = moment();

        assert.equal(mom.lang('fr'), mom, 'setting the language (lang) returns the original moment for chaining');
        assert.equal(mom.locale('it'), mom, 'setting the language (locale) returns the original moment for chaining');
    });

    test('lang(key) changes the language of the instance', function (assert) {
        var m = moment().month(0);
        m.lang('fr');
        assert.equal(m.locale(), 'fr', 'm.lang(key) changes instance locale');
    });

    test('moment#locale(false) resets to global locale', function (assert) {
        var m = moment();

        moment.locale('fr');
        m.locale('it');

        assert.equal(moment.locale(), 'fr', 'global locale is it');
        assert.equal(m.locale(), 'it', 'instance locale is it');
        m.locale(false);
        assert.equal(m.locale(), 'fr', 'instance locale reset to global locale');
    });

    test('moment().locale with missing key doesn\'t change locale', function (assert) {
        assert.equal(moment().locale('boo').localeData(), moment.localeData(),
                'preserve global locale in case of bad locale id');
    });

    test('moment().lang with missing key doesn\'t change locale', function (assert) {
        assert.equal(moment().lang('boo').localeData(), moment.localeData(),
                'preserve global locale in case of bad locale id');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('min max');

    test('min', function (assert) {
        var now = moment(),
            future = now.clone().add(1, 'month'),
            past = now.clone().subtract(1, 'month');

        assert.equal(moment.min(now, future, past), past, 'min(now, future, past)');
        assert.equal(moment.min(future, now, past), past, 'min(future, now, past)');
        assert.equal(moment.min(future, past, now), past, 'min(future, past, now)');
        assert.equal(moment.min(past, future, now), past, 'min(past, future, now)');
        assert.equal(moment.min(now, past), past, 'min(now, past)');
        assert.equal(moment.min(past, now), past, 'min(past, now)');
        assert.equal(moment.min(now), now, 'min(now, past)');

        assert.equal(moment.min([now, future, past]), past, 'min([now, future, past])');
        assert.equal(moment.min([now, past]), past, 'min(now, past)');
        assert.equal(moment.min([now]), now, 'min(now)');
    });

    test('max', function (assert) {
        var now = moment(),
            future = now.clone().add(1, 'month'),
            past = now.clone().subtract(1, 'month');

        assert.equal(moment.max(now, future, past), future, 'max(now, future, past)');
        assert.equal(moment.max(future, now, past), future, 'max(future, now, past)');
        assert.equal(moment.max(future, past, now), future, 'max(future, past, now)');
        assert.equal(moment.max(past, future, now), future, 'max(past, future, now)');
        assert.equal(moment.max(now, past), now, 'max(now, past)');
        assert.equal(moment.max(past, now), now, 'max(past, now)');
        assert.equal(moment.max(now), now, 'max(now, past)');

        assert.equal(moment.max([now, future, past]), future, 'max([now, future, past])');
        assert.equal(moment.max([now, past]), now, 'max(now, past)');
        assert.equal(moment.max([now]), now, 'max(now)');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('mutable');

    test('manipulation methods', function (assert) {
        var m = moment();

        assert.equal(m, m.year(2011), 'year() should be mutable');
        assert.equal(m, m.month(1), 'month() should be mutable');
        assert.equal(m, m.hours(7), 'hours() should be mutable');
        assert.equal(m, m.minutes(33), 'minutes() should be mutable');
        assert.equal(m, m.seconds(44), 'seconds() should be mutable');
        assert.equal(m, m.milliseconds(55), 'milliseconds() should be mutable');
        assert.equal(m, m.day(2), 'day() should be mutable');
        assert.equal(m, m.startOf('week'), 'startOf() should be mutable');
        assert.equal(m, m.add(1, 'days'), 'add() should be mutable');
        assert.equal(m, m.subtract(2, 'years'), 'subtract() should be mutable');
        assert.equal(m, m.local(), 'local() should be mutable');
        assert.equal(m, m.utc(), 'utc() should be mutable');
    });

    test('non mutable methods', function (assert) {
        var m = moment();
        assert.notEqual(m, m.clone(), 'clone() should not be mutable');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('normalize units');

    test('normalize units', function (assert) {
        var fullKeys = ['year', 'quarter', 'month', 'isoWeek', 'week', 'day', 'hour', 'minute', 'second', 'millisecond', 'date', 'dayOfYear', 'weekday', 'isoWeekday', 'weekYear', 'isoWeekYear'],
            aliases = ['y', 'Q', 'M', 'W', 'w', 'd', 'h', 'm', 's', 'ms', 'D', 'DDD', 'e', 'E', 'gg', 'GG'],
            length = fullKeys.length,
            fullKey,
            fullKeyCaps,
            fullKeyPlural,
            fullKeyCapsPlural,
            fullKeyLower,
            alias,
            index;

        for (index = 0; index < length; index += 1) {
            fullKey = fullKeys[index];
            fullKeyCaps = fullKey.toUpperCase();
            fullKeyLower = fullKey.toLowerCase();
            fullKeyPlural = fullKey + 's';
            fullKeyCapsPlural = fullKeyCaps + 's';
            alias = aliases[index];
            assert.equal(moment.normalizeUnits(fullKey), fullKey, 'Testing full key ' + fullKey);
            assert.equal(moment.normalizeUnits(fullKeyCaps), fullKey, 'Testing full key capitalised ' + fullKey);
            assert.equal(moment.normalizeUnits(fullKeyPlural), fullKey, 'Testing full key plural ' + fullKey);
            assert.equal(moment.normalizeUnits(fullKeyCapsPlural), fullKey, 'Testing full key capitalised and plural ' + fullKey);
            assert.equal(moment.normalizeUnits(alias), fullKey, 'Testing alias ' + fullKey);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('parsing flags');

    function flags () {
        return moment.apply(null, arguments).parsingFlags();
    }

    test('overflow with array', function (assert) {
        //months
        assert.equal(flags([2010, 0]).overflow, -1, 'month 0 valid');
        assert.equal(flags([2010, 1]).overflow, -1, 'month 1 valid');
        assert.equal(flags([2010, -1]).overflow, 1, 'month -1 invalid');
        assert.equal(flags([2100, 12]).overflow, 1, 'month 12 invalid');

        //days
        assert.equal(flags([2010, 1, 16]).overflow, -1, 'date valid');
        assert.equal(flags([2010, 1, -1]).overflow, 2, 'date -1 invalid');
        assert.equal(flags([2010, 1, 0]).overflow, 2, 'date 0 invalid');
        assert.equal(flags([2010, 1, 32]).overflow, 2, 'date 32 invalid');
        assert.equal(flags([2012, 1, 29]).overflow, -1, 'date leap year valid');
        assert.equal(flags([2010, 1, 29]).overflow, 2, 'date leap year invalid');

        //hours
        assert.equal(flags([2010, 1, 1, 8]).overflow, -1, 'hour valid');
        assert.equal(flags([2010, 1, 1, 0]).overflow, -1, 'hour 0 valid');
        assert.equal(flags([2010, 1, 1, -1]).overflow, 3, 'hour -1 invalid');
        assert.equal(flags([2010, 1, 1, 25]).overflow, 3, 'hour 25 invalid');
        assert.equal(flags([2010, 1, 1, 24, 1]).overflow, 3, 'hour 24:01 invalid');

        //minutes
        assert.equal(flags([2010, 1, 1, 8, 15]).overflow, -1, 'minute valid');
        assert.equal(flags([2010, 1, 1, 8, 0]).overflow, -1, 'minute 0 valid');
        assert.equal(flags([2010, 1, 1, 8, -1]).overflow, 4, 'minute -1 invalid');
        assert.equal(flags([2010, 1, 1, 8, 60]).overflow, 4, 'minute 60 invalid');

        //seconds
        assert.equal(flags([2010, 1, 1, 8, 15, 12]).overflow, -1, 'second valid');
        assert.equal(flags([2010, 1, 1, 8, 15, 0]).overflow, -1, 'second 0 valid');
        assert.equal(flags([2010, 1, 1, 8, 15, -1]).overflow, 5, 'second -1 invalid');
        assert.equal(flags([2010, 1, 1, 8, 15, 60]).overflow, 5, 'second 60 invalid');

        //milliseconds
        assert.equal(flags([2010, 1, 1, 8, 15, 12, 345]).overflow, -1, 'millisecond valid');
        assert.equal(flags([2010, 1, 1, 8, 15, 12, 0]).overflow, -1, 'millisecond 0 valid');
        assert.equal(flags([2010, 1, 1, 8, 15, 12, -1]).overflow, 6, 'millisecond -1 invalid');
        assert.equal(flags([2010, 1, 1, 8, 15, 12, 1000]).overflow, 6, 'millisecond 1000 invalid');

        // 24 hrs
        assert.equal(flags([2010, 1, 1, 24, 0, 0, 0]).overflow, -1, '24:00:00.000 is fine');
        assert.equal(flags([2010, 1, 1, 24, 1, 0, 0]).overflow, 3, '24:01:00.000 is wrong hour');
        assert.equal(flags([2010, 1, 1, 24, 0, 1, 0]).overflow, 3, '24:00:01.000 is wrong hour');
        assert.equal(flags([2010, 1, 1, 24, 0, 0, 1]).overflow, 3, '24:00:00.001 is wrong hour');
    });

    test('overflow without format', function (assert) {
        //months
        assert.equal(flags('2001-01', 'YYYY-MM').overflow, -1, 'month 1 valid');
        assert.equal(flags('2001-12', 'YYYY-MM').overflow, -1, 'month 12 valid');
        assert.equal(flags('2001-13', 'YYYY-MM').overflow, 1, 'month 13 invalid');

        //days
        assert.equal(flags('2010-01-16', 'YYYY-MM-DD').overflow, -1, 'date 16 valid');
        assert.equal(flags('2010-01-0',  'YYYY-MM-DD').overflow, 2, 'date 0 invalid');
        assert.equal(flags('2010-01-32', 'YYYY-MM-DD').overflow, 2, 'date 32 invalid');
        assert.equal(flags('2012-02-29', 'YYYY-MM-DD').overflow, -1, 'date leap year valid');
        assert.equal(flags('2010-02-29', 'YYYY-MM-DD').overflow, 2, 'date leap year invalid');

        //days of the year
        assert.equal(flags('2010 300', 'YYYY DDDD').overflow, -1, 'day 300 of year valid');
        assert.equal(flags('2010 365', 'YYYY DDDD').overflow, -1, 'day 365 of year valid');
        assert.equal(flags('2010 366', 'YYYY DDDD').overflow, 2, 'day 366 of year invalid');
        assert.equal(flags('2012 366', 'YYYY DDDD').overflow, -1, 'day 366 of leap year valid');
        assert.equal(flags('2012 367', 'YYYY DDDD').overflow, 2, 'day 367 of leap year invalid');

        //hours
        assert.equal(flags('08', 'HH').overflow, -1, 'hour valid');
        assert.equal(flags('00', 'HH').overflow, -1, 'hour 0 valid');
        assert.equal(flags('25', 'HH').overflow, 3, 'hour 25 invalid');
        assert.equal(flags('24:01', 'HH:mm').overflow, 3, 'hour 24:01 invalid');

        //minutes
        assert.equal(flags('08:15', 'HH:mm').overflow, -1, 'minute valid');
        assert.equal(flags('08:00', 'HH:mm').overflow, -1, 'minute 0 valid');
        assert.equal(flags('08:60', 'HH:mm').overflow, 4, 'minute 60 invalid');

        //seconds
        assert.equal(flags('08:15:12', 'HH:mm:ss').overflow, -1, 'second valid');
        assert.equal(flags('08:15:00', 'HH:mm:ss').overflow, -1, 'second 0 valid');
        assert.equal(flags('08:15:60', 'HH:mm:ss').overflow, 5, 'second 60 invalid');

        //milliseconds
        assert.equal(flags('08:15:12:345', 'HH:mm:ss:SSSS').overflow, -1, 'millisecond valid');
        assert.equal(flags('08:15:12:000', 'HH:mm:ss:SSSS').overflow, -1, 'millisecond 0 valid');

        //this is OK because we don't match the last digit, so it's 100 ms
        assert.equal(flags('08:15:12:1000', 'HH:mm:ss:SSSS').overflow, -1, 'millisecond 1000 actually valid');
    });

    test('extra tokens', function (assert) {
        assert.deepEqual(flags('1982-05-25', 'YYYY-MM-DD').unusedTokens, [], 'nothing extra');
        assert.deepEqual(flags('1982-05', 'YYYY-MM-DD').unusedTokens, ['DD'], 'extra formatting token');
        assert.deepEqual(flags('1982', 'YYYY-MM-DD').unusedTokens, ['MM', 'DD'], 'multiple extra formatting tokens');
        assert.deepEqual(flags('1982-05', 'YYYY-MM-').unusedTokens, [], 'extra non-formatting token');
        assert.deepEqual(flags('1982-05-', 'YYYY-MM-DD').unusedTokens, ['DD'], 'non-extra non-formatting token');
        assert.deepEqual(flags('1982 05 1982', 'YYYY-MM-DD').unusedTokens, [], 'different non-formatting token');
    });

    test('extra tokens strict', function (assert) {
        assert.deepEqual(flags('1982-05-25', 'YYYY-MM-DD', true).unusedTokens, [], 'nothing extra');
        assert.deepEqual(flags('1982-05', 'YYYY-MM-DD', true).unusedTokens, ['-', 'DD'], 'extra formatting token');
        assert.deepEqual(flags('1982', 'YYYY-MM-DD', true).unusedTokens, ['-', 'MM', '-', 'DD'], 'multiple extra formatting tokens');
        assert.deepEqual(flags('1982-05', 'YYYY-MM-', true).unusedTokens, ['-'], 'extra non-formatting token');
        assert.deepEqual(flags('1982-05-', 'YYYY-MM-DD', true).unusedTokens, ['DD'], 'non-extra non-formatting token');
        assert.deepEqual(flags('1982 05 1982', 'YYYY-MM-DD', true).unusedTokens, ['-', '-'], 'different non-formatting token');
    });

    test('unused input', function (assert) {
        assert.deepEqual(flags('1982-05-25', 'YYYY-MM-DD').unusedInput, [], 'normal input');
        assert.deepEqual(flags('1982-05-25 this is more stuff', 'YYYY-MM-DD').unusedInput, [' this is more stuff'], 'trailing nonsense');
        assert.deepEqual(flags('1982-05-25 09:30', 'YYYY-MM-DD').unusedInput, [' 09:30'], ['trailing legit-looking input']);
        assert.deepEqual(flags('1982-05-25 some junk', 'YYYY-MM-DD [some junk]').unusedInput, [], 'junk that actually gets matched');
        assert.deepEqual(flags('stuff at beginning 1982-05-25', 'YYYY-MM-DD').unusedInput, ['stuff at beginning '], 'leading junk');
        assert.deepEqual(flags('junk 1982 more junk 05 yet more junk25', 'YYYY-MM-DD').unusedInput, ['junk ', ' more junk ', ' yet more junk'], 'interstitial junk');
    });

    test('unused input strict', function (assert) {
        assert.deepEqual(flags('1982-05-25', 'YYYY-MM-DD', true).unusedInput, [], 'normal input');
        assert.deepEqual(flags('1982-05-25 this is more stuff', 'YYYY-MM-DD', true).unusedInput, [' this is more stuff'], 'trailing nonsense');
        assert.deepEqual(flags('1982-05-25 09:30', 'YYYY-MM-DD', true).unusedInput, [' 09:30'], ['trailing legit-looking input']);
        assert.deepEqual(flags('1982-05-25 some junk', 'YYYY-MM-DD [some junk]', true).unusedInput, [], 'junk that actually gets matched');
        assert.deepEqual(flags('stuff at beginning 1982-05-25', 'YYYY-MM-DD', true).unusedInput, ['stuff at beginning '], 'leading junk');
        assert.deepEqual(flags('junk 1982 more junk 05 yet more junk25', 'YYYY-MM-DD', true).unusedInput, ['junk ', ' more junk ', ' yet more junk'], 'interstitial junk');
    });

    test('chars left over', function (assert) {
        assert.equal(flags('1982-05-25', 'YYYY-MM-DD').charsLeftOver, 0, 'normal input');
        assert.equal(flags('1982-05-25 this is more stuff', 'YYYY-MM-DD').charsLeftOver, ' this is more stuff'.length, 'trailing nonsense');
        assert.equal(flags('1982-05-25 09:30', 'YYYY-MM-DD').charsLeftOver, ' 09:30'.length, 'trailing legit-looking input');
        assert.equal(flags('stuff at beginning 1982-05-25', 'YYYY-MM-DD').charsLeftOver, 'stuff at beginning '.length, 'leading junk');
        assert.equal(flags('1982 junk 05 more junk25', 'YYYY-MM-DD').charsLeftOver, [' junk ', ' more junk'].join('').length, 'interstitial junk');
        assert.equal(flags('stuff at beginning 1982 junk 05 more junk25', 'YYYY-MM-DD').charsLeftOver, ['stuff at beginning ', ' junk ', ' more junk'].join('').length, 'leading and interstitial junk');
    });

    test('empty', function (assert) {
        assert.equal(flags('1982-05-25', 'YYYY-MM-DD').empty, false, 'normal input');
        assert.equal(flags('nothing here', 'YYYY-MM-DD').empty, true, 'pure garbage');
        assert.equal(flags('junk but has the number 2000 in it', 'YYYY-MM-DD').empty, false, 'only mostly garbage');
        assert.equal(flags('', 'YYYY-MM-DD').empty, true, 'empty string');
        assert.equal(flags('', 'YYYY-MM-DD').empty, true, 'blank string');
    });

    test('null', function (assert) {
        assert.equal(flags('1982-05-25', 'YYYY-MM-DD').nullInput, false, 'normal input');
        assert.equal(flags(null).nullInput, true, 'just null');
        assert.equal(flags(null, 'YYYY-MM-DD').nullInput, true, 'null with format');
    });

    test('invalid month', function (assert) {
        assert.equal(flags('1982 May', 'YYYY MMMM').invalidMonth, null, 'normal input');
        assert.equal(flags('1982 Laser', 'YYYY MMMM').invalidMonth, 'Laser', 'bad month name');
    });

    test('empty format array', function (assert) {
        assert.equal(flags('1982 May', ['YYYY MMM']).invalidFormat, false, 'empty format array');
        assert.equal(flags('1982 May', []).invalidFormat, true, 'empty format array');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    var symbolMap = {
            '1': '!',
            '2': '@',
            '3': '#',
            '4': '$',
            '5': '%',
            '6': '^',
            '7': '&',
            '8': '*',
            '9': '(',
            '0': ')'
        },
        numberMap = {
            '!': '1',
            '@': '2',
            '#': '3',
            '$': '4',
            '%': '5',
            '^': '6',
            '&': '7',
            '*': '8',
            '(': '9',
            ')': '0'
        };

    module('preparse and postformat', {
        setup: function () {
            moment.locale('symbol', {
                preparse: function (string) {
                    return string.replace(/[!@#$%\^&*()]/g, function (match) {
                        return numberMap[match];
                    });
                },

                postformat: function (string) {
                    return string.replace(/\d/g, function (match) {
                        return symbolMap[match];
                    });
                }
            });
        }
    });

    test('transform', function (assert) {
        assert.equal(moment.utc('@)!@-)*-@&', 'YYYY-MM-DD').unix(), 1346025600, 'preparse string + format');
        assert.equal(moment.utc('@)!@-)*-@&').unix(), 1346025600, 'preparse ISO8601 string');
        assert.equal(moment.unix(1346025600).utc().format('YYYY-MM-DD'), '@)!@-)*-@&', 'postformat');
    });

    test('transform from', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true), '@ minutes', 'postformat should work on moment.fn.from');
        assert.equal(moment().add(6, 'd').fromNow(true), '^ days', 'postformat should work on moment.fn.fromNow');
        assert.equal(moment.duration(10, 'h').humanize(), '!) hours', 'postformat should work on moment.duration.fn.humanize');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Today at @:)) AM',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Today at @:@% AM',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Today at #:)) AM',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Tomorrow at @:)) AM',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Today at !:)) AM',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Yesterday at @:)) AM', 'yesterday at the same time');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('quarter');

    test('library quarter getter', function (assert) {
        assert.equal(moment([1985,  1,  4]).quarter(), 1, 'Feb  4 1985 is Q1');
        assert.equal(moment([2029,  8, 18]).quarter(), 3, 'Sep 18 2029 is Q3');
        assert.equal(moment([2013,  3, 24]).quarter(), 2, 'Apr 24 2013 is Q2');
        assert.equal(moment([2015,  2,  5]).quarter(), 1, 'Mar  5 2015 is Q1');
        assert.equal(moment([1970,  0,  2]).quarter(), 1, 'Jan  2 1970 is Q1');
        assert.equal(moment([2001, 11, 12]).quarter(), 4, 'Dec 12 2001 is Q4');
        assert.equal(moment([2000,  0,  2]).quarter(), 1, 'Jan  2 2000 is Q1');
    });

    test('quarter setter singular', function (assert) {
        var m = moment([2014, 4, 11]);
        assert.equal(m.quarter(2).month(), 4, 'set same quarter');
        assert.equal(m.quarter(3).month(), 7, 'set 3rd quarter');
        assert.equal(m.quarter(1).month(), 1, 'set 1st quarter');
        assert.equal(m.quarter(4).month(), 10, 'set 4th quarter');
    });

    test('quarter setter plural', function (assert) {
        var m = moment([2014, 4, 11]);
        assert.equal(m.quarters(2).month(), 4, 'set same quarter');
        assert.equal(m.quarters(3).month(), 7, 'set 3rd quarter');
        assert.equal(m.quarters(1).month(), 1, 'set 1st quarter');
        assert.equal(m.quarters(4).month(), 10, 'set 4th quarter');
    });

    test('quarter setter programmatic', function (assert) {
        var m = moment([2014, 4, 11]);
        assert.equal(m.set('quarter', 2).month(), 4, 'set same quarter');
        assert.equal(m.set('quarter', 3).month(), 7, 'set 3rd quarter');
        assert.equal(m.set('quarter', 1).month(), 1, 'set 1st quarter');
        assert.equal(m.set('quarter', 4).month(), 10, 'set 4th quarter');
    });

    test('quarter setter programmatic plural', function (assert) {
        var m = moment([2014, 4, 11]);
        assert.equal(m.set('quarters', 2).month(), 4, 'set same quarter');
        assert.equal(m.set('quarters', 3).month(), 7, 'set 3rd quarter');
        assert.equal(m.set('quarters', 1).month(), 1, 'set 1st quarter');
        assert.equal(m.set('quarters', 4).month(), 10, 'set 4th quarter');
    });

    test('quarter setter programmatic abbr', function (assert) {
        var m = moment([2014, 4, 11]);
        assert.equal(m.set('Q', 2).month(), 4, 'set same quarter');
        assert.equal(m.set('Q', 3).month(), 7, 'set 3rd quarter');
        assert.equal(m.set('Q', 1).month(), 1, 'set 1st quarter');
        assert.equal(m.set('Q', 4).month(), 10, 'set 4th quarter');
    });

    test('quarter setter only month changes', function (assert) {
        var m = moment([2014, 4, 11, 1, 2, 3, 4]).quarter(4);
        assert.equal(m.year(), 2014, 'keep year');
        assert.equal(m.month(), 10, 'set month');
        assert.equal(m.date(), 11, 'keep date');
        assert.equal(m.hour(), 1, 'keep hour');
        assert.equal(m.minute(), 2, 'keep minutes');
        assert.equal(m.second(), 3, 'keep seconds');
        assert.equal(m.millisecond(), 4, 'keep milliseconds');
    });

    test('quarter setter bubble to next year', function (assert) {
        var m = moment([2014, 4, 11, 1, 2, 3, 4]).quarter(7);
        assert.equal(m.year(), 2015, 'year bubbled');
        assert.equal(m.month(), 7, 'set month');
        assert.equal(m.date(), 11, 'keep date');
        assert.equal(m.hour(), 1, 'keep hour');
        assert.equal(m.minute(), 2, 'keep minutes');
        assert.equal(m.second(), 3, 'keep seconds');
        assert.equal(m.millisecond(), 4, 'keep milliseconds');
    });

    test('quarter diff', function (assert) {
        assert.equal(moment('2014-01-01').diff(moment('2014-04-01'), 'quarter'),
                -1, 'diff -1 quarter');
        assert.equal(moment('2014-04-01').diff(moment('2014-01-01'), 'quarter'),
                1, 'diff 1 quarter');
        assert.equal(moment('2014-05-01').diff(moment('2014-01-01'), 'quarter'),
                1, 'diff 1 quarter');
        assert.ok(Math.abs((4 / 3) - moment('2014-05-01').diff(
                        moment('2014-01-01'), 'quarter', true)) < 0.00001,
                'diff 1 1/3 quarter');
        assert.equal(moment('2015-01-01').diff(moment('2014-01-01'), 'quarter'),
                4, 'diff 4 quarters');
    });

    test('quarter setter bubble to previous year', function (assert) {
        var m = moment([2014, 4, 11, 1, 2, 3, 4]).quarter(-3);
        assert.equal(m.year(), 2013, 'year bubbled');
        assert.equal(m.month(), 1, 'set month');
        assert.equal(m.date(), 11, 'keep date');
        assert.equal(m.hour(), 1, 'keep hour');
        assert.equal(m.minute(), 2, 'keep minutes');
        assert.equal(m.second(), 3, 'keep seconds');
        assert.equal(m.millisecond(), 4, 'keep milliseconds');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('relative time');

    test('default thresholds fromNow', function (assert) {
        var a = moment();

        // Seconds to minutes threshold
        a.subtract(44, 'seconds');
        assert.equal(a.fromNow(), 'a few seconds ago', 'Below default seconds to minutes threshold');
        a.subtract(1, 'seconds');
        assert.equal(a.fromNow(), 'a minute ago', 'Above default seconds to minutes threshold');

        // Minutes to hours threshold
        a = moment();
        a.subtract(44, 'minutes');
        assert.equal(a.fromNow(), '44 minutes ago', 'Below default minute to hour threshold');
        a.subtract(1, 'minutes');
        assert.equal(a.fromNow(), 'an hour ago', 'Above default minute to hour threshold');

        // Hours to days threshold
        a = moment();
        a.subtract(21, 'hours');
        assert.equal(a.fromNow(), '21 hours ago', 'Below default hours to day threshold');
        a.subtract(1, 'hours');
        assert.equal(a.fromNow(), 'a day ago', 'Above default hours to day threshold');

        // Days to month threshold
        a = moment();
        a.subtract(25, 'days');
        assert.equal(a.fromNow(), '25 days ago', 'Below default days to month (singular) threshold');
        a.subtract(1, 'days');
        assert.equal(a.fromNow(), 'a month ago', 'Above default days to month (singular) threshold');

        // months to year threshold
        a = moment();
        a.subtract(10, 'months');
        assert.equal(a.fromNow(), '10 months ago', 'Below default days to years threshold');
        a.subtract(1, 'month');
        assert.equal(a.fromNow(), 'a year ago', 'Above default days to years threshold');
    });

    test('default thresholds toNow', function (assert) {
        var a = moment();

        // Seconds to minutes threshold
        a.subtract(44, 'seconds');
        assert.equal(a.toNow(), 'in a few seconds', 'Below default seconds to minutes threshold');
        a.subtract(1, 'seconds');
        assert.equal(a.toNow(), 'in a minute', 'Above default seconds to minutes threshold');

        // Minutes to hours threshold
        a = moment();
        a.subtract(44, 'minutes');
        assert.equal(a.toNow(), 'in 44 minutes', 'Below default minute to hour threshold');
        a.subtract(1, 'minutes');
        assert.equal(a.toNow(), 'in an hour', 'Above default minute to hour threshold');

        // Hours to days threshold
        a = moment();
        a.subtract(21, 'hours');
        assert.equal(a.toNow(), 'in 21 hours', 'Below default hours to day threshold');
        a.subtract(1, 'hours');
        assert.equal(a.toNow(), 'in a day', 'Above default hours to day threshold');

        // Days to month threshold
        a = moment();
        a.subtract(25, 'days');
        assert.equal(a.toNow(), 'in 25 days', 'Below default days to month (singular) threshold');
        a.subtract(1, 'days');
        assert.equal(a.toNow(), 'in a month', 'Above default days to month (singular) threshold');

        // months to year threshold
        a = moment();
        a.subtract(10, 'months');
        assert.equal(a.toNow(), 'in 10 months', 'Below default days to years threshold');
        a.subtract(1, 'month');
        assert.equal(a.toNow(), 'in a year', 'Above default days to years threshold');
    });

    test('custom thresholds', function (assert) {
        // Seconds to minutes threshold
        moment.relativeTimeThreshold('s', 55);

        var a = moment();
        a.subtract(54, 'seconds');
        assert.equal(a.fromNow(), 'a few seconds ago', 'Below custom seconds to minutes threshold');
        a.subtract(1, 'seconds');
        assert.equal(a.fromNow(), 'a minute ago', 'Above custom seconds to minutes threshold');

        moment.relativeTimeThreshold('s', 45);

        // Minutes to hours threshold
        moment.relativeTimeThreshold('m', 55);
        a = moment();
        a.subtract(54, 'minutes');
        assert.equal(a.fromNow(), '54 minutes ago', 'Below custom minutes to hours threshold');
        a.subtract(1, 'minutes');
        assert.equal(a.fromNow(), 'an hour ago', 'Above custom minutes to hours threshold');
        moment.relativeTimeThreshold('m', 45);

        // Hours to days threshold
        moment.relativeTimeThreshold('h', 24);
        a = moment();
        a.subtract(23, 'hours');
        assert.equal(a.fromNow(), '23 hours ago', 'Below custom hours to days threshold');
        a.subtract(1, 'hours');
        assert.equal(a.fromNow(), 'a day ago', 'Above custom hours to days threshold');
        moment.relativeTimeThreshold('h', 22);

        // Days to month threshold
        moment.relativeTimeThreshold('d', 28);
        a = moment();
        a.subtract(27, 'days');
        assert.equal(a.fromNow(), '27 days ago', 'Below custom days to month (singular) threshold');
        a.subtract(1, 'days');
        assert.equal(a.fromNow(), 'a month ago', 'Above custom days to month (singular) threshold');
        moment.relativeTimeThreshold('d', 26);

        // months to years threshold
        moment.relativeTimeThreshold('M', 9);
        a = moment();
        a.subtract(8, 'months');
        assert.equal(a.fromNow(), '8 months ago', 'Below custom days to years threshold');
        a.subtract(1, 'months');
        assert.equal(a.fromNow(), 'a year ago', 'Above custom days to years threshold');
        moment.relativeTimeThreshold('M', 11);
    });

    test('retrive threshold settings', function (assert) {
        moment.relativeTimeThreshold('m', 45);
        var minuteThreshold = moment.relativeTimeThreshold('m');

        assert.equal(minuteThreshold, 45, 'Can retrieve minute setting');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('start and end of units');

    test('start of year', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('year'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('years'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('y');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 0, 'strip out the month');
        assert.equal(m.date(), 1, 'strip out the day');
        assert.equal(m.hours(), 0, 'strip out the hours');
        assert.equal(m.minutes(), 0, 'strip out the minutes');
        assert.equal(m.seconds(), 0, 'strip out the seconds');
        assert.equal(m.milliseconds(), 0, 'strip out the milliseconds');
    });

    test('end of year', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('year'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('years'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('y');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 11, 'set the month');
        assert.equal(m.date(), 31, 'set the day');
        assert.equal(m.hours(), 23, 'set the hours');
        assert.equal(m.minutes(), 59, 'set the minutes');
        assert.equal(m.seconds(), 59, 'set the seconds');
        assert.equal(m.milliseconds(), 999, 'set the seconds');
    });

    test('start of quarter', function (assert) {
        var m = moment(new Date(2011, 4, 2, 3, 4, 5, 6)).startOf('quarter'),
            ms = moment(new Date(2011, 4, 2, 3, 4, 5, 6)).startOf('quarters'),
            ma = moment(new Date(2011, 4, 2, 3, 4, 5, 6)).startOf('Q');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.quarter(), 2, 'keep the quarter');
        assert.equal(m.month(), 3, 'strip out the month');
        assert.equal(m.date(), 1, 'strip out the day');
        assert.equal(m.hours(), 0, 'strip out the hours');
        assert.equal(m.minutes(), 0, 'strip out the minutes');
        assert.equal(m.seconds(), 0, 'strip out the seconds');
        assert.equal(m.milliseconds(), 0, 'strip out the milliseconds');
    });

    test('end of quarter', function (assert) {
        var m = moment(new Date(2011, 4, 2, 3, 4, 5, 6)).endOf('quarter'),
            ms = moment(new Date(2011, 4, 2, 3, 4, 5, 6)).endOf('quarters'),
            ma = moment(new Date(2011, 4, 2, 3, 4, 5, 6)).endOf('Q');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.quarter(), 2, 'keep the quarter');
        assert.equal(m.month(), 5, 'set the month');
        assert.equal(m.date(), 30, 'set the day');
        assert.equal(m.hours(), 23, 'set the hours');
        assert.equal(m.minutes(), 59, 'set the minutes');
        assert.equal(m.seconds(), 59, 'set the seconds');
        assert.equal(m.milliseconds(), 999, 'set the seconds');
    });

    test('start of month', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('month'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('months'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('M');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 1, 'keep the month');
        assert.equal(m.date(), 1, 'strip out the day');
        assert.equal(m.hours(), 0, 'strip out the hours');
        assert.equal(m.minutes(), 0, 'strip out the minutes');
        assert.equal(m.seconds(), 0, 'strip out the seconds');
        assert.equal(m.milliseconds(), 0, 'strip out the milliseconds');
    });

    test('end of month', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('month'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('months'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('M');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 1, 'keep the month');
        assert.equal(m.date(), 28, 'set the day');
        assert.equal(m.hours(), 23, 'set the hours');
        assert.equal(m.minutes(), 59, 'set the minutes');
        assert.equal(m.seconds(), 59, 'set the seconds');
        assert.equal(m.milliseconds(), 999, 'set the seconds');
    });

    test('start of week', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('week'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('weeks'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('w');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 0, 'rolls back to January');
        assert.equal(m.day(), 0, 'set day of week');
        assert.equal(m.date(), 30, 'set correct date');
        assert.equal(m.hours(), 0, 'strip out the hours');
        assert.equal(m.minutes(), 0, 'strip out the minutes');
        assert.equal(m.seconds(), 0, 'strip out the seconds');
        assert.equal(m.milliseconds(), 0, 'strip out the milliseconds');
    });

    test('end of week', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('week'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('weeks'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('weeks');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 1, 'keep the month');
        assert.equal(m.day(), 6, 'set the day of the week');
        assert.equal(m.date(), 5, 'set the day');
        assert.equal(m.hours(), 23, 'set the hours');
        assert.equal(m.minutes(), 59, 'set the minutes');
        assert.equal(m.seconds(), 59, 'set the seconds');
        assert.equal(m.milliseconds(), 999, 'set the seconds');
    });

    test('start of iso-week', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('isoWeek'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('isoWeeks'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('W');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 0, 'rollback to January');
        assert.equal(m.isoWeekday(), 1, 'set day of iso-week');
        assert.equal(m.date(), 31, 'set correct date');
        assert.equal(m.hours(), 0, 'strip out the hours');
        assert.equal(m.minutes(), 0, 'strip out the minutes');
        assert.equal(m.seconds(), 0, 'strip out the seconds');
        assert.equal(m.milliseconds(), 0, 'strip out the milliseconds');
    });

    test('end of iso-week', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('isoWeek'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('isoWeeks'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('W');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 1, 'keep the month');
        assert.equal(m.isoWeekday(), 7, 'set the day of the week');
        assert.equal(m.date(), 6, 'set the day');
        assert.equal(m.hours(), 23, 'set the hours');
        assert.equal(m.minutes(), 59, 'set the minutes');
        assert.equal(m.seconds(), 59, 'set the seconds');
        assert.equal(m.milliseconds(), 999, 'set the seconds');
    });

    test('start of day', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('day'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('days'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('d');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 1, 'keep the month');
        assert.equal(m.date(), 2, 'keep the day');
        assert.equal(m.hours(), 0, 'strip out the hours');
        assert.equal(m.minutes(), 0, 'strip out the minutes');
        assert.equal(m.seconds(), 0, 'strip out the seconds');
        assert.equal(m.milliseconds(), 0, 'strip out the milliseconds');
    });

    test('end of day', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('day'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('days'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('d');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 1, 'keep the month');
        assert.equal(m.date(), 2, 'keep the day');
        assert.equal(m.hours(), 23, 'set the hours');
        assert.equal(m.minutes(), 59, 'set the minutes');
        assert.equal(m.seconds(), 59, 'set the seconds');
        assert.equal(m.milliseconds(), 999, 'set the seconds');
    });

    test('start of hour', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('hour'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('hours'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('h');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 1, 'keep the month');
        assert.equal(m.date(), 2, 'keep the day');
        assert.equal(m.hours(), 3, 'keep the hours');
        assert.equal(m.minutes(), 0, 'strip out the minutes');
        assert.equal(m.seconds(), 0, 'strip out the seconds');
        assert.equal(m.milliseconds(), 0, 'strip out the milliseconds');
    });

    test('end of hour', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('hour'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('hours'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('h');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 1, 'keep the month');
        assert.equal(m.date(), 2, 'keep the day');
        assert.equal(m.hours(), 3, 'keep the hours');
        assert.equal(m.minutes(), 59, 'set the minutes');
        assert.equal(m.seconds(), 59, 'set the seconds');
        assert.equal(m.milliseconds(), 999, 'set the seconds');
    });

    test('start of minute', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('minute'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('minutes'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('m');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 1, 'keep the month');
        assert.equal(m.date(), 2, 'keep the day');
        assert.equal(m.hours(), 3, 'keep the hours');
        assert.equal(m.minutes(), 4, 'keep the minutes');
        assert.equal(m.seconds(), 0, 'strip out the seconds');
        assert.equal(m.milliseconds(), 0, 'strip out the milliseconds');
    });

    test('end of minute', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('minute'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('minutes'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('m');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 1, 'keep the month');
        assert.equal(m.date(), 2, 'keep the day');
        assert.equal(m.hours(), 3, 'keep the hours');
        assert.equal(m.minutes(), 4, 'keep the minutes');
        assert.equal(m.seconds(), 59, 'set the seconds');
        assert.equal(m.milliseconds(), 999, 'set the seconds');
    });

    test('start of second', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('second'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('seconds'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('s');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 1, 'keep the month');
        assert.equal(m.date(), 2, 'keep the day');
        assert.equal(m.hours(), 3, 'keep the hours');
        assert.equal(m.minutes(), 4, 'keep the minutes');
        assert.equal(m.seconds(), 5, 'keep the the seconds');
        assert.equal(m.milliseconds(), 0, 'strip out the milliseconds');
    });

    test('end of second', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('second'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('seconds'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('s');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 1, 'keep the month');
        assert.equal(m.date(), 2, 'keep the day');
        assert.equal(m.hours(), 3, 'keep the hours');
        assert.equal(m.minutes(), 4, 'keep the minutes');
        assert.equal(m.seconds(), 5, 'keep the seconds');
        assert.equal(m.milliseconds(), 999, 'set the seconds');
    });

    test('startOf across DST +1', function (assert) {
        var oldUpdateOffset = moment.updateOffset,
            // Based on a real story somewhere in America/Los_Angeles
            dstAt = moment('2014-03-09T02:00:00-08:00').parseZone(),
            m;

        moment.updateOffset = function (mom, keepTime) {
            if (mom.isBefore(dstAt)) {
                mom.utcOffset(-8, keepTime);
            } else {
                mom.utcOffset(-7, keepTime);
            }
        };

        m = moment('2014-03-15T00:00:00-07:00').parseZone();
        m.startOf('M');
        assert.equal(m.format(), '2014-03-01T00:00:00-08:00', 'startOf(\'month\') across +1');

        m = moment('2014-03-09T09:00:00-07:00').parseZone();
        m.startOf('d');
        assert.equal(m.format(), '2014-03-09T00:00:00-08:00', 'startOf(\'day\') across +1');

        m = moment('2014-03-09T03:05:00-07:00').parseZone();
        m.startOf('h');
        assert.equal(m.format(), '2014-03-09T03:00:00-07:00', 'startOf(\'hour\') after +1');

        m = moment('2014-03-09T01:35:00-08:00').parseZone();
        m.startOf('h');
        assert.equal(m.format(), '2014-03-09T01:00:00-08:00', 'startOf(\'hour\') before +1');

        // There is no such time as 2:30-7 to try startOf('hour') across that

        moment.updateOffset = oldUpdateOffset;
    });

    test('startOf across DST -1', function (assert) {
        var oldUpdateOffset = moment.updateOffset,
            // Based on a real story somewhere in America/Los_Angeles
            dstAt = moment('2014-11-02T02:00:00-07:00').parseZone(),
            m;

        moment.updateOffset = function (mom, keepTime) {
            if (mom.isBefore(dstAt)) {
                mom.utcOffset(-7, keepTime);
            } else {
                mom.utcOffset(-8, keepTime);
            }
        };

        m = moment('2014-11-15T00:00:00-08:00').parseZone();
        m.startOf('M');
        assert.equal(m.format(), '2014-11-01T00:00:00-07:00', 'startOf(\'month\') across -1');

        m = moment('2014-11-02T09:00:00-08:00').parseZone();
        m.startOf('d');
        assert.equal(m.format(), '2014-11-02T00:00:00-07:00', 'startOf(\'day\') across -1');

        // note that utc offset is -8
        m = moment('2014-11-02T01:30:00-08:00').parseZone();
        m.startOf('h');
        assert.equal(m.format(), '2014-11-02T01:00:00-08:00', 'startOf(\'hour\') after +1');

        // note that utc offset is -7
        m = moment('2014-11-02T01:30:00-07:00').parseZone();
        m.startOf('h');
        assert.equal(m.format(), '2014-11-02T01:00:00-07:00', 'startOf(\'hour\') before +1');

        moment.updateOffset = oldUpdateOffset;
    });

    test('endOf millisecond and no-arg', function (assert) {
        var m = moment();
        assert.equal(+m, +m.clone().endOf(), 'endOf without argument should change time');
        assert.equal(+m, +m.clone().endOf('ms'), 'endOf with ms argument should change time');
        assert.equal(+m, +m.clone().endOf('millisecond'), 'endOf with millisecond argument should change time');
        assert.equal(+m, +m.clone().endOf('milliseconds'), 'endOf with milliseconds argument should change time');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('string prototype');

    test('string prototype overrides call', function (assert) {
        var prior = String.prototype.call, b;
        String.prototype.call = function () {
            return null;
        };

        b = moment(new Date(2011, 7, 28, 15, 25, 50, 125));
        assert.equal(b.format('MMMM Do YYYY, h:mm a'), 'August 28th 2011, 3:25 pm');

        String.prototype.call = prior;
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('utc');

    test('utc and local', function (assert) {
        var m = moment(Date.UTC(2011, 1, 2, 3, 4, 5, 6)), offset, expected;
        m.utc();
        // utc
        assert.equal(m.date(), 2, 'the day should be correct for utc');
        assert.equal(m.day(), 3, 'the date should be correct for utc');
        assert.equal(m.hours(), 3, 'the hours should be correct for utc');

        // local
        m.local();
        if (m.zone() > 180) {
            assert.equal(m.date(), 1, 'the date should be correct for local');
            assert.equal(m.day(), 2, 'the day should be correct for local');
        } else {
            assert.equal(m.date(), 2, 'the date should be correct for local');
            assert.equal(m.day(), 3, 'the day should be correct for local');
        }
        offset = Math.ceil(m.utcOffset() / 60);
        expected = (24 + 3 + offset) % 24;
        assert.equal(m.hours(), expected, 'the hours (' + m.hours() + ') should be correct for local');
        assert.equal(moment().utc().utcOffset(), 0, 'timezone in utc should always be zero');
    });

    test('creating with utc and no arguments', function (assert) {
        var startOfTest = new Date().valueOf(),
            momentDefaultUtcTime = moment.utc().valueOf(),
            afterMomentCreationTime = new Date().valueOf();

        assert.ok(startOfTest <= momentDefaultUtcTime, 'moment UTC default time should be now, not in the past');
        assert.ok(momentDefaultUtcTime <= afterMomentCreationTime, 'moment UTC default time should be now, not in the future');
    });

    test('creating with utc and a date parameter array', function (assert) {
        var m = moment.utc([2011, 1, 2, 3, 4, 5, 6]);
        assert.equal(m.date(), 2, 'the day should be correct for utc array');
        assert.equal(m.hours(), 3, 'the hours should be correct for utc array');

        m = moment.utc('2011-02-02 3:04:05', 'YYYY-MM-DD HH:mm:ss');
        assert.equal(m.date(), 2, 'the day should be correct for utc parsing format');
        assert.equal(m.hours(), 3, 'the hours should be correct for utc parsing format');

        m = moment.utc('2011-02-02T03:04:05+00:00');
        assert.equal(m.date(), 2, 'the day should be correct for utc parsing iso');
        assert.equal(m.hours(), 3, 'the hours should be correct for utc parsing iso');
    });

    test('creating with utc without timezone', function (assert) {
        var m = moment.utc('2012-01-02T08:20:00');
        assert.equal(m.date(), 2, 'the day should be correct for utc parse without timezone');
        assert.equal(m.hours(), 8, 'the hours should be correct for utc parse without timezone');

        m = moment.utc('2012-01-02T08:20:00+09:00');
        assert.equal(m.date(), 1, 'the day should be correct for utc parse with timezone');
        assert.equal(m.hours(), 23, 'the hours should be correct for utc parse with timezone');
    });

    test('cloning with utc offset', function (assert) {
        var m = moment.utc('2012-01-02T08:20:00');
        assert.equal(moment.utc(m)._isUTC, true, 'the local offset should be converted to UTC');
        assert.equal(moment.utc(m.clone().utc())._isUTC, true, 'the local offset should stay in UTC');

        m.utcOffset(120);
        assert.equal(moment.utc(m)._isUTC, true, 'the explicit utc offset should stay in UTC');
        assert.equal(moment.utc(m).utcOffset(), 0, 'the explicit utc offset should have an offset of 0');
    });

    test('weekday with utc', function (assert) {
        assert.equal(
            moment('2013-09-15T00:00:00Z').utc().weekday(), // first minute of the day
            moment('2013-09-15T23:59:00Z').utc().weekday(), // last minute of the day
            'a UTC-moment\'s .weekday() should not be affected by the local timezone'
        );
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('utc offset');

    test('setter / getter blackbox', function (assert) {
        var m = moment([2010]);

        assert.equal(m.clone().utcOffset(0).utcOffset(), 0, 'utcOffset 0');

        assert.equal(m.clone().utcOffset(1).utcOffset(), 60, 'utcOffset 1 is 60');
        assert.equal(m.clone().utcOffset(60).utcOffset(), 60, 'utcOffset 60');
        assert.equal(m.clone().utcOffset('+01:00').utcOffset(), 60, 'utcOffset +01:00 is 60');
        assert.equal(m.clone().utcOffset('+0100').utcOffset(), 60, 'utcOffset +0100 is 60');

        assert.equal(m.clone().utcOffset(-1).utcOffset(), -60, 'utcOffset -1 is -60');
        assert.equal(m.clone().utcOffset(-60).utcOffset(), -60, 'utcOffset -60');
        assert.equal(m.clone().utcOffset('-01:00').utcOffset(), -60, 'utcOffset -01:00 is -60');
        assert.equal(m.clone().utcOffset('-0100').utcOffset(), -60, 'utcOffset -0100 is -60');

        assert.equal(m.clone().utcOffset(1.5).utcOffset(), 90, 'utcOffset 1.5 is 90');
        assert.equal(m.clone().utcOffset(90).utcOffset(), 90, 'utcOffset 1.5 is 90');
        assert.equal(m.clone().utcOffset('+01:30').utcOffset(), 90, 'utcOffset +01:30 is 90');
        assert.equal(m.clone().utcOffset('+0130').utcOffset(), 90, 'utcOffset +0130 is 90');

        assert.equal(m.clone().utcOffset(-1.5).utcOffset(), -90, 'utcOffset -1.5');
        assert.equal(m.clone().utcOffset(-90).utcOffset(), -90, 'utcOffset -90');
        assert.equal(m.clone().utcOffset('-01:30').utcOffset(), -90, 'utcOffset +01:30 is 90');
        assert.equal(m.clone().utcOffset('-0130').utcOffset(), -90, 'utcOffset +0130 is 90');
    });

    test('utcOffset shorthand hours -> minutes', function (assert) {
        var i;
        for (i = -15; i <= 15; ++i) {
            assert.equal(moment().utcOffset(i).utcOffset(), i * 60,
                    '' + i + ' -> ' + i * 60);
        }
        assert.equal(moment().utcOffset(-16).utcOffset(), -16, '-16 -> -16');
        assert.equal(moment().utcOffset(16).utcOffset(), 16, '16 -> 16');
    });

    test('isLocal, isUtc, isUtcOffset', function (assert) {
        assert.ok(moment().isLocal(), 'moment() creates objects in local time');
        assert.ok(!moment.utc().isLocal(), 'moment.utc creates objects NOT in local time');
        assert.ok(moment.utc().local().isLocal(), 'moment.fn.local() converts to local time');
        assert.ok(!moment().utcOffset(5).isLocal(), 'moment.fn.utcOffset(N) puts objects NOT in local time');
        assert.ok(moment().utcOffset(5).local().isLocal(), 'moment.fn.local() converts to local time');

        assert.ok(moment.utc().isUtc(), 'moment.utc() creates objects in utc time');
        assert.ok(moment().utcOffset(0).isUtc(), 'utcOffset(0) is equivalent to utc mode');
        assert.ok(!moment().utcOffset(1).isUtc(), 'utcOffset(1) is NOT equivalent to utc mode');

        assert.ok(!moment().isUtcOffset(), 'moment() creates objects NOT in utc-offset mode');
        assert.ok(moment.utc().isUtcOffset(), 'moment.utc() creates objects in utc-offset mode');
        assert.ok(moment().utcOffset(3).isUtcOffset(), 'utcOffset(N != 0) creates objects in utc-offset mode');
        assert.ok(moment().utcOffset(0).isUtcOffset(), 'utcOffset(0) creates objects in utc-offset mode');
    });

    test('isUTC', function (assert) {
        assert.ok(moment.utc().isUTC(), 'moment.utc() creates objects in utc time');
        assert.ok(moment().utcOffset(0).isUTC(), 'utcOffset(0) is equivalent to utc mode');
        assert.ok(!moment().utcOffset(1).isUTC(), 'utcOffset(1) is NOT equivalent to utc mode');
    });

    test('change hours when changing the utc offset', function (assert) {
        var m = moment.utc([2000, 0, 1, 6]);
        assert.equal(m.hour(), 6, 'UTC 6AM should be 6AM at +0000');

        // sanity check
        m.utcOffset(0);
        assert.equal(m.hour(), 6, 'UTC 6AM should be 6AM at +0000');

        m.utcOffset(-60);
        assert.equal(m.hour(), 5, 'UTC 6AM should be 5AM at -0100');

        m.utcOffset(60);
        assert.equal(m.hour(), 7, 'UTC 6AM should be 7AM at +0100');
    });

    test('change minutes when changing the utc offset', function (assert) {
        var m = moment.utc([2000, 0, 1, 6, 31]);

        m.utcOffset(0);
        assert.equal(m.format('HH:mm'), '06:31', 'UTC 6:31AM should be 6:31AM at +0000');

        m.utcOffset(-30);
        assert.equal(m.format('HH:mm'), '06:01', 'UTC 6:31AM should be 6:01AM at -0030');

        m.utcOffset(30);
        assert.equal(m.format('HH:mm'), '07:01', 'UTC 6:31AM should be 7:01AM at +0030');

        m.utcOffset(-1380);
        assert.equal(m.format('HH:mm'), '07:31', 'UTC 6:31AM should be 7:31AM at +1380');
    });

    test('distance from the unix epoch', function (assert) {
        var zoneA = moment(),
            zoneB = moment(zoneA),
            zoneC = moment(zoneA),
            zoneD = moment(zoneA),
            zoneE = moment(zoneA);

        zoneB.utc();
        assert.equal(+zoneA, +zoneB, 'moment should equal moment.utc');

        zoneC.utcOffset(60);
        assert.equal(+zoneA, +zoneC, 'moment should equal moment.utcOffset(60)');

        zoneD.utcOffset(-480);
        assert.equal(+zoneA, +zoneD,
                'moment should equal moment.utcOffset(-480)');

        zoneE.utcOffset(-1000);
        assert.equal(+zoneA, +zoneE,
                'moment should equal moment.utcOffset(-1000)');
    });

    test('update offset after changing any values', function (assert) {
        var oldOffset = moment.updateOffset,
            m = moment.utc([2000, 6, 1]);

        moment.updateOffset = function (mom, keepTime) {
            if (mom.__doChange) {
                if (+mom > 962409600000) {
                    mom.utcOffset(-120, keepTime);
                } else {
                    mom.utcOffset(-60, keepTime);
                }
            }
        };

        assert.equal(m.format('ZZ'), '+0000', 'should be at +0000');
        assert.equal(m.format('HH:mm'), '00:00', 'should start 12AM at +0000 timezone');

        m.__doChange = true;
        m.add(1, 'h');

        assert.equal(m.format('ZZ'), '-0200', 'should be at -0200');
        assert.equal(m.format('HH:mm'), '23:00', '1AM at +0000 should be 11PM at -0200 timezone');

        m.subtract(1, 'h');

        assert.equal(m.format('ZZ'), '-0100', 'should be at -0100');
        assert.equal(m.format('HH:mm'), '23:00', '12AM at +0000 should be 11PM at -0100 timezone');

        moment.updateOffset = oldOffset;
    });

    //////////////////
    test('getters and setters', function (assert) {
        var a = moment([2011, 5, 20]);

        assert.equal(a.clone().utcOffset(-120).year(2012).year(), 2012, 'should get and set year correctly');
        assert.equal(a.clone().utcOffset(-120).month(1).month(), 1, 'should get and set month correctly');
        assert.equal(a.clone().utcOffset(-120).date(2).date(), 2, 'should get and set date correctly');
        assert.equal(a.clone().utcOffset(-120).day(1).day(), 1, 'should get and set day correctly');
        assert.equal(a.clone().utcOffset(-120).hour(1).hour(), 1, 'should get and set hour correctly');
        assert.equal(a.clone().utcOffset(-120).minute(1).minute(), 1, 'should get and set minute correctly');
    });

    test('getters', function (assert) {
        var a = moment.utc([2012, 0, 1, 0, 0, 0]);

        assert.equal(a.clone().utcOffset(-120).year(),  2011, 'should get year correctly');
        assert.equal(a.clone().utcOffset(-120).month(),   11, 'should get month correctly');
        assert.equal(a.clone().utcOffset(-120).date(),    31, 'should get date correctly');
        assert.equal(a.clone().utcOffset(-120).hour(),    22, 'should get hour correctly');
        assert.equal(a.clone().utcOffset(-120).minute(),   0, 'should get minute correctly');

        assert.equal(a.clone().utcOffset(120).year(),  2012, 'should get year correctly');
        assert.equal(a.clone().utcOffset(120).month(),    0, 'should get month correctly');
        assert.equal(a.clone().utcOffset(120).date(),     1, 'should get date correctly');
        assert.equal(a.clone().utcOffset(120).hour(),     2, 'should get hour correctly');
        assert.equal(a.clone().utcOffset(120).minute(),   0, 'should get minute correctly');

        assert.equal(a.clone().utcOffset(90).year(),  2012, 'should get year correctly');
        assert.equal(a.clone().utcOffset(90).month(),    0, 'should get month correctly');
        assert.equal(a.clone().utcOffset(90).date(),     1, 'should get date correctly');
        assert.equal(a.clone().utcOffset(90).hour(),     1, 'should get hour correctly');
        assert.equal(a.clone().utcOffset(90).minute(),  30, 'should get minute correctly');
    });

    test('from', function (assert) {
        var zoneA = moment(),
            zoneB = moment(zoneA).utcOffset(-720),
            zoneC = moment(zoneA).utcOffset(-360),
            zoneD = moment(zoneA).utcOffset(690),
            other = moment(zoneA).add(35, 'm');

        assert.equal(zoneA.from(other), zoneB.from(other), 'moment#from should be the same in all zones');
        assert.equal(zoneA.from(other), zoneC.from(other), 'moment#from should be the same in all zones');
        assert.equal(zoneA.from(other), zoneD.from(other), 'moment#from should be the same in all zones');
    });

    test('diff', function (assert) {
        var zoneA = moment(),
            zoneB = moment(zoneA).utcOffset(-720),
            zoneC = moment(zoneA).utcOffset(-360),
            zoneD = moment(zoneA).utcOffset(690),
            other = moment(zoneA).add(35, 'm');

        assert.equal(zoneA.diff(other), zoneB.diff(other), 'moment#diff should be the same in all zones');
        assert.equal(zoneA.diff(other), zoneC.diff(other), 'moment#diff should be the same in all zones');
        assert.equal(zoneA.diff(other), zoneD.diff(other), 'moment#diff should be the same in all zones');

        assert.equal(zoneA.diff(other, 'minute', true), zoneB.diff(other, 'minute', true), 'moment#diff should be the same in all zones');
        assert.equal(zoneA.diff(other, 'minute', true), zoneC.diff(other, 'minute', true), 'moment#diff should be the same in all zones');
        assert.equal(zoneA.diff(other, 'minute', true), zoneD.diff(other, 'minute', true), 'moment#diff should be the same in all zones');

        assert.equal(zoneA.diff(other, 'hour', true), zoneB.diff(other, 'hour', true), 'moment#diff should be the same in all zones');
        assert.equal(zoneA.diff(other, 'hour', true), zoneC.diff(other, 'hour', true), 'moment#diff should be the same in all zones');
        assert.equal(zoneA.diff(other, 'hour', true), zoneD.diff(other, 'hour', true), 'moment#diff should be the same in all zones');
    });

    test('unix offset and timestamp', function (assert) {
        var zoneA = moment(),
            zoneB = moment(zoneA).utcOffset(-720),
            zoneC = moment(zoneA).utcOffset(-360),
            zoneD = moment(zoneA).utcOffset(690);

        assert.equal(zoneA.unix(), zoneB.unix(), 'moment#unix should be the same in all zones');
        assert.equal(zoneA.unix(), zoneC.unix(), 'moment#unix should be the same in all zones');
        assert.equal(zoneA.unix(), zoneD.unix(), 'moment#unix should be the same in all zones');

        assert.equal(+zoneA, +zoneB, 'moment#valueOf should be the same in all zones');
        assert.equal(+zoneA, +zoneC, 'moment#valueOf should be the same in all zones');
        assert.equal(+zoneA, +zoneD, 'moment#valueOf should be the same in all zones');
    });

    test('cloning', function (assert) {
        assert.equal(moment().utcOffset(-120).clone().utcOffset(), -120,
                'explicit cloning should retain the offset');
        assert.equal(moment().utcOffset(120).clone().utcOffset(), 120,
                'explicit cloning should retain the offset');
        assert.equal(moment(moment().utcOffset(-120)).utcOffset(), -120,
                'implicit cloning should retain the offset');
        assert.equal(moment(moment().utcOffset(120)).utcOffset(), 120,
                'implicit cloning should retain the offset');
    });

    test('start of / end of', function (assert) {
        var a = moment.utc([2010, 1, 2, 0, 0, 0]).utcOffset(-450);

        assert.equal(a.clone().startOf('day').hour(), 0,
                'start of day should work on moments with utc offset');
        assert.equal(a.clone().startOf('day').minute(), 0,
                'start of day should work on moments with utc offset');
        assert.equal(a.clone().startOf('hour').minute(), 0,
                'start of hour should work on moments with utc offset');

        assert.equal(a.clone().endOf('day').hour(), 23,
                'end of day should work on moments with utc offset');
        assert.equal(a.clone().endOf('day').minute(), 59,
                'end of day should work on moments with utc offset');
        assert.equal(a.clone().endOf('hour').minute(), 59,
                'end of hour should work on moments with utc offset');
    });

    test('reset offset with moment#utc', function (assert) {
        var a = moment.utc([2012]).utcOffset(-480);

        assert.equal(a.clone().hour(),      16, 'different utc offset should have different hour');
        assert.equal(a.clone().utc().hour(), 0, 'calling moment#utc should reset the offset');
    });

    test('reset offset with moment#local', function (assert) {
        var a = moment([2012]).utcOffset(-480);

        assert.equal(a.clone().local().hour(), 0, 'calling moment#local should reset the offset');
    });

    test('toDate', function (assert) {
        var zoneA = new Date(),
            zoneB = moment(zoneA).utcOffset(-720).toDate(),
            zoneC = moment(zoneA).utcOffset(-360).toDate(),
            zoneD = moment(zoneA).utcOffset(690).toDate();

        assert.equal(+zoneA, +zoneB, 'moment#toDate should output a date with the right unix timestamp');
        assert.equal(+zoneA, +zoneC, 'moment#toDate should output a date with the right unix timestamp');
        assert.equal(+zoneA, +zoneD, 'moment#toDate should output a date with the right unix timestamp');
    });

    test('same / before / after', function (assert) {
        var zoneA = moment().utc(),
            zoneB = moment(zoneA).utcOffset(-120),
            zoneC = moment(zoneA).utcOffset(120);

        assert.ok(zoneA.isSame(zoneB), 'two moments with different offsets should be the same');
        assert.ok(zoneA.isSame(zoneC), 'two moments with different offsets should be the same');

        assert.ok(zoneA.isSame(zoneB, 'hour'), 'two moments with different offsets should be the same hour');
        assert.ok(zoneA.isSame(zoneC, 'hour'), 'two moments with different offsets should be the same hour');

        zoneA.add(1, 'hour');

        assert.ok(zoneA.isAfter(zoneB), 'isAfter should work with two moments with different offsets');
        assert.ok(zoneA.isAfter(zoneC), 'isAfter should work with two moments with different offsets');

        assert.ok(zoneA.isAfter(zoneB, 'hour'), 'isAfter:hour should work with two moments with different offsets');
        assert.ok(zoneA.isAfter(zoneC, 'hour'), 'isAfter:hour should work with two moments with different offsets');

        zoneA.subtract(2, 'hour');

        assert.ok(zoneA.isBefore(zoneB), 'isBefore should work with two moments with different offsets');
        assert.ok(zoneA.isBefore(zoneC), 'isBefore should work with two moments with different offsets');

        assert.ok(zoneA.isBefore(zoneB, 'hour'), 'isBefore:hour should work with two moments with different offsets');
        assert.ok(zoneA.isBefore(zoneC, 'hour'), 'isBefore:hour should work with two moments with different offsets');
    });

    test('add / subtract over dst', function (assert) {
        var oldOffset = moment.updateOffset,
            m = moment.utc([2000, 2, 31, 3]);

        moment.updateOffset = function (mom, keepTime) {
            if (mom.clone().utc().month() > 2) {
                mom.utcOffset(60, keepTime);
            } else {
                mom.utcOffset(0, keepTime);
            }
        };

        assert.equal(m.hour(), 3, 'should start at 00:00');

        m.add(24, 'hour');

        assert.equal(m.hour(), 4, 'adding 24 hours should disregard dst');

        m.subtract(24, 'hour');

        assert.equal(m.hour(), 3, 'subtracting 24 hours should disregard dst');

        m.add(1, 'day');

        assert.equal(m.hour(), 3, 'adding 1 day should have the same hour');

        m.subtract(1, 'day');

        assert.equal(m.hour(), 3, 'subtracting 1 day should have the same hour');

        m.add(1, 'month');

        assert.equal(m.hour(), 3, 'adding 1 month should have the same hour');

        m.subtract(1, 'month');

        assert.equal(m.hour(), 3, 'subtracting 1 month should have the same hour');

        moment.updateOffset = oldOffset;
    });

    test('isDST', function (assert) {
        var oldOffset = moment.updateOffset;

        moment.updateOffset = function (mom, keepTime) {
            if (mom.month() > 2 && mom.month() < 9) {
                mom.utcOffset(60, keepTime);
            } else {
                mom.utcOffset(0, keepTime);
            }
        };

        assert.ok(!moment().month(0).isDST(),  'Jan should not be summer dst');
        assert.ok(moment().month(6).isDST(),   'Jul should be summer dst');
        assert.ok(!moment().month(11).isDST(), 'Dec should not be summer dst');

        moment.updateOffset = function (mom) {
            if (mom.month() > 2 && mom.month() < 9) {
                mom.utcOffset(0);
            } else {
                mom.utcOffset(60);
            }
        };

        assert.ok(moment().month(0).isDST(),  'Jan should be winter dst');
        assert.ok(!moment().month(6).isDST(), 'Jul should not be winter dst');
        assert.ok(moment().month(11).isDST(), 'Dec should be winter dst');

        moment.updateOffset = oldOffset;
    });

    test('zone names', function (assert) {
        assert.equal(moment().zoneAbbr(),   '', 'Local zone abbr should be empty');
        assert.equal(moment().format('z'),  '', 'Local zone formatted abbr should be empty');
        assert.equal(moment().zoneName(),   '', 'Local zone name should be empty');
        assert.equal(moment().format('zz'), '', 'Local zone formatted name should be empty');

        assert.equal(moment.utc().zoneAbbr(),   'UTC', 'UTC zone abbr should be UTC');
        assert.equal(moment.utc().format('z'),  'UTC', 'UTC zone formatted abbr should be UTC');
        assert.equal(moment.utc().zoneName(),   'Coordinated Universal Time', 'UTC zone abbr should be Coordinated Universal Time');
        assert.equal(moment.utc().format('zz'), 'Coordinated Universal Time', 'UTC zone formatted abbr should be Coordinated Universal Time');
    });

    test('hours alignment with UTC', function (assert) {
        assert.equal(moment().utcOffset(-120).hasAlignedHourOffset(), true);
        assert.equal(moment().utcOffset(180).hasAlignedHourOffset(), true);
        assert.equal(moment().utcOffset(-90).hasAlignedHourOffset(), false);
        assert.equal(moment().utcOffset(90).hasAlignedHourOffset(), false);
    });

    test('hours alignment with other zone', function (assert) {
        var m = moment().utcOffset(-120);

        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(-180)), true);
        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(180)), true);
        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(-90)), false);
        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(90)), false);

        m = moment().utcOffset(-90);

        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(-180)), false);
        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(180)), false);
        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(-30)), true);
        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(30)), true);

        m = moment().utcOffset(60);

        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(-180)), true);
        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(180)), true);
        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(-90)), false);
        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(90)), false);

        m = moment().utcOffset(-25);

        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(35)), true);
        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(-85)), true);

        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(-35)), false);
        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(85)), false);
    });

    test('parse zone', function (assert) {
        var m = moment('2013-01-01T00:00:00-13:00').parseZone();
        assert.equal(m.utcOffset(), -13 * 60);
        assert.equal(m.hours(), 0);
    });

    test('parse zone static', function (assert) {
        var m = moment.parseZone('2013-01-01T00:00:00-13:00');
        assert.equal(m.utcOffset(), -13 * 60);
        assert.equal(m.hours(), 0);
    });

    test('parse zone with more arguments', function (assert) {
        var m;
        m = moment.parseZone('2013 01 01 05 -13:00', 'YYYY MM DD HH ZZ');
        assert.equal(m.format(), '2013-01-01T05:00:00-13:00', 'accept input and format');
        m = moment.parseZone('2013-01-01-13:00', 'YYYY MM DD ZZ', true);
        assert.equal(m.isValid(), false, 'accept input, format and strict flag');
        m = moment.parseZone('2013-01-01-13:00', ['DD MM YYYY ZZ', 'YYYY MM DD ZZ']);
        assert.equal(m.format(), '2013-01-01T00:00:00-13:00', 'accept input and array of formats');
    });

    test('parse zone with a timezone from the format string', function (assert) {
        var m = moment('11-12-2013 -0400 +1100', 'DD-MM-YYYY ZZ #####').parseZone();

        assert.equal(m.utcOffset(), -4 * 60);
    });

    test('parse zone without a timezone included in the format string', function (assert) {
        var m = moment('11-12-2013 -0400 +1100', 'DD-MM-YYYY').parseZone();

        assert.equal(m.utcOffset(), 11 * 60);
    });

    test('timezone format', function (assert) {
        assert.equal(moment().utcOffset(60).format('ZZ'), '+0100', '-60 -> +0100');
        assert.equal(moment().utcOffset(90).format('ZZ'), '+0130', '-90 -> +0130');
        assert.equal(moment().utcOffset(120).format('ZZ'), '+0200', '-120 -> +0200');

        assert.equal(moment().utcOffset(-60).format('ZZ'), '-0100', '+60 -> -0100');
        assert.equal(moment().utcOffset(-90).format('ZZ'), '-0130', '+90 -> -0130');
        assert.equal(moment().utcOffset(-120).format('ZZ'), '-0200', '+120 -> -0200');
    });

    test('local to utc, keepLocalTime = true', function (assert) {
        var m = moment(),
            fmt = 'YYYY-DD-MM HH:mm:ss';
        assert.equal(m.clone().utc(true).format(fmt), m.format(fmt), 'local to utc failed to keep local time');
    });

    test('local to utc, keepLocalTime = false', function (assert) {
        var m = moment();
        assert.equal(m.clone().utc().valueOf(), m.valueOf(), 'local to utc failed to keep utc time (implicit)');
        assert.equal(m.clone().utc(false).valueOf(), m.valueOf(), 'local to utc failed to keep utc time (explicit)');
    });

    test('local to zone, keepLocalTime = true', function (assert) {
        var m = moment(),
            fmt = 'YYYY-DD-MM HH:mm:ss',
            z;

        // Apparently there is -12:00 and +14:00
        // http://en.wikipedia.org/wiki/UTC+14:00
        // http://en.wikipedia.org/wiki/UTC-12:00
        for (z = -12; z <= 14; ++z) {
            assert.equal(m.clone().utcOffset(z * 60, true).format(fmt),
                    m.format(fmt),
                    'local to utcOffset(' + z + ':00) failed to keep local time');
        }
    });

    test('local to zone, keepLocalTime = false', function (assert) {
        var m = moment(),
            z;

        // Apparently there is -12:00 and +14:00
        // http://en.wikipedia.org/wiki/UTC+14:00
        // http://en.wikipedia.org/wiki/UTC-12:00
        for (z = -12; z <= 14; ++z) {
            assert.equal(m.clone().utcOffset(z * 60).valueOf(),
                    m.valueOf(),
                    'local to utcOffset(' + z + ':00) failed to keep utc time (implicit)');
            assert.equal(m.clone().utcOffset(z * 60, false).valueOf(),
                    m.valueOf(),
                    'local to utcOffset(' + z + ':00) failed to keep utc time (explicit)');
        }
    });

    test('utc to local, keepLocalTime = true', function (assert) {
        var um = moment.utc(),
            fmt = 'YYYY-DD-MM HH:mm:ss';

        assert.equal(um.clone().local(true).format(fmt), um.format(fmt), 'utc to local failed to keep local time');
    });

    test('utc to local, keepLocalTime = false', function (assert) {
        var um = moment.utc();
        assert.equal(um.clone().local().valueOf(), um.valueOf(), 'utc to local failed to keep utc time (implicit)');
        assert.equal(um.clone().local(false).valueOf(), um.valueOf(), 'utc to local failed to keep utc time (explicit)');
    });

    test('zone to local, keepLocalTime = true', function (assert) {
        var m = moment(),
            fmt = 'YYYY-DD-MM HH:mm:ss',
            z;

        // Apparently there is -12:00 and +14:00
        // http://en.wikipedia.org/wiki/UTC+14:00
        // http://en.wikipedia.org/wiki/UTC-12:00
        for (z = -12; z <= 14; ++z) {
            m.utcOffset(z * 60);

            assert.equal(m.clone().local(true).format(fmt),
                    m.format(fmt),
                    'utcOffset(' + z + ':00) to local failed to keep local time');
        }
    });

    test('zone to local, keepLocalTime = false', function (assert) {
        var m = moment(),
            z;

        // Apparently there is -12:00 and +14:00
        // http://en.wikipedia.org/wiki/UTC+14:00
        // http://en.wikipedia.org/wiki/UTC-12:00
        for (z = -12; z <= 14; ++z) {
            m.utcOffset(z * 60);

            assert.equal(m.clone().local(false).valueOf(), m.valueOf(),
                    'utcOffset(' + z + ':00) to local failed to keep utc time (explicit)');
            assert.equal(m.clone().local().valueOf(), m.valueOf(),
                    'utcOffset(' + z + ':00) to local failed to keep utc time (implicit)');
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('week year');

    test('iso week year', function (assert) {
        // Some examples taken from http://en.wikipedia.org/wiki/ISO_week
        assert.equal(moment([2005, 0, 1]).isoWeekYear(), 2004);
        assert.equal(moment([2005, 0, 2]).isoWeekYear(), 2004);
        assert.equal(moment([2005, 0, 3]).isoWeekYear(), 2005);
        assert.equal(moment([2005, 11, 31]).isoWeekYear(), 2005);
        assert.equal(moment([2006, 0, 1]).isoWeekYear(), 2005);
        assert.equal(moment([2006, 0, 2]).isoWeekYear(), 2006);
        assert.equal(moment([2007, 0, 1]).isoWeekYear(), 2007);
        assert.equal(moment([2007, 11, 30]).isoWeekYear(), 2007);
        assert.equal(moment([2007, 11, 31]).isoWeekYear(), 2008);
        assert.equal(moment([2008, 0, 1]).isoWeekYear(), 2008);
        assert.equal(moment([2008, 11, 28]).isoWeekYear(), 2008);
        assert.equal(moment([2008, 11, 29]).isoWeekYear(), 2009);
        assert.equal(moment([2008, 11, 30]).isoWeekYear(), 2009);
        assert.equal(moment([2008, 11, 31]).isoWeekYear(), 2009);
        assert.equal(moment([2009, 0, 1]).isoWeekYear(), 2009);
        assert.equal(moment([2010, 0, 1]).isoWeekYear(), 2009);
        assert.equal(moment([2010, 0, 2]).isoWeekYear(), 2009);
        assert.equal(moment([2010, 0, 3]).isoWeekYear(), 2009);
        assert.equal(moment([2010, 0, 4]).isoWeekYear(), 2010);
    });

    test('week year', function (assert) {
        // Some examples taken from http://en.wikipedia.org/wiki/ISO_week
        moment.locale('dow: 1,doy: 4', {week: {dow: 1, doy: 4}}); // like iso
        assert.equal(moment([2005, 0, 1]).weekYear(), 2004);
        assert.equal(moment([2005, 0, 2]).weekYear(), 2004);
        assert.equal(moment([2005, 0, 3]).weekYear(), 2005);
        assert.equal(moment([2005, 11, 31]).weekYear(), 2005);
        assert.equal(moment([2006, 0, 1]).weekYear(), 2005);
        assert.equal(moment([2006, 0, 2]).weekYear(), 2006);
        assert.equal(moment([2007, 0, 1]).weekYear(), 2007);
        assert.equal(moment([2007, 11, 30]).weekYear(), 2007);
        assert.equal(moment([2007, 11, 31]).weekYear(), 2008);
        assert.equal(moment([2008, 0, 1]).weekYear(), 2008);
        assert.equal(moment([2008, 11, 28]).weekYear(), 2008);
        assert.equal(moment([2008, 11, 29]).weekYear(), 2009);
        assert.equal(moment([2008, 11, 30]).weekYear(), 2009);
        assert.equal(moment([2008, 11, 31]).weekYear(), 2009);
        assert.equal(moment([2009, 0, 1]).weekYear(), 2009);
        assert.equal(moment([2010, 0, 1]).weekYear(), 2009);
        assert.equal(moment([2010, 0, 2]).weekYear(), 2009);
        assert.equal(moment([2010, 0, 3]).weekYear(), 2009);
        assert.equal(moment([2010, 0, 4]).weekYear(), 2010);

        moment.locale('dow: 1,doy: 7', {week: {dow: 1, doy: 7}});
        assert.equal(moment([2004, 11, 26]).weekYear(), 2004);
        assert.equal(moment([2004, 11, 27]).weekYear(), 2005);
        assert.equal(moment([2005, 11, 25]).weekYear(), 2005);
        assert.equal(moment([2005, 11, 26]).weekYear(), 2006);
        assert.equal(moment([2006, 11, 31]).weekYear(), 2006);
        assert.equal(moment([2007,  0,  1]).weekYear(), 2007);
        assert.equal(moment([2007, 11, 30]).weekYear(), 2007);
        assert.equal(moment([2007, 11, 31]).weekYear(), 2008);
        assert.equal(moment([2008, 11, 28]).weekYear(), 2008);
        assert.equal(moment([2008, 11, 29]).weekYear(), 2009);
        assert.equal(moment([2009, 11, 27]).weekYear(), 2009);
        assert.equal(moment([2009, 11, 28]).weekYear(), 2010);
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('week day');

    test('iso weekday', function (assert) {
        var i;

        for (i = 0; i < 7; ++i) {
            moment.locale('dow:' + i + ',doy: 6', {week: {dow: i, doy: 6}});
            assert.equal(moment([1985, 1,  4]).isoWeekday(), 1, 'Feb  4 1985 is Monday    -- 1st day');
            assert.equal(moment([2029, 8, 18]).isoWeekday(), 2, 'Sep 18 2029 is Tuesday   -- 2nd day');
            assert.equal(moment([2013, 3, 24]).isoWeekday(), 3, 'Apr 24 2013 is Wednesday -- 3rd day');
            assert.equal(moment([2015, 2,  5]).isoWeekday(), 4, 'Mar  5 2015 is Thursday  -- 4th day');
            assert.equal(moment([1970, 0,  2]).isoWeekday(), 5, 'Jan  2 1970 is Friday    -- 5th day');
            assert.equal(moment([2001, 4, 12]).isoWeekday(), 6, 'May 12 2001 is Saturday  -- 6th day');
            assert.equal(moment([2000, 0,  2]).isoWeekday(), 7, 'Jan  2 2000 is Sunday    -- 7th day');
        }
    });

    test('iso weekday setter', function (assert) {
        var a = moment([2011, 0, 10]);
        assert.equal(moment(a).isoWeekday(1).date(),  10, 'set from mon to mon');
        assert.equal(moment(a).isoWeekday(4).date(),  13, 'set from mon to thu');
        assert.equal(moment(a).isoWeekday(7).date(),  16, 'set from mon to sun');
        assert.equal(moment(a).isoWeekday(-6).date(),  3, 'set from mon to last mon');
        assert.equal(moment(a).isoWeekday(-3).date(),  6, 'set from mon to last thu');
        assert.equal(moment(a).isoWeekday(0).date(),   9, 'set from mon to last sun');
        assert.equal(moment(a).isoWeekday(8).date(),  17, 'set from mon to next mon');
        assert.equal(moment(a).isoWeekday(11).date(), 20, 'set from mon to next thu');
        assert.equal(moment(a).isoWeekday(14).date(), 23, 'set from mon to next sun');

        a = moment([2011, 0, 13]);
        assert.equal(moment(a).isoWeekday(1).date(), 10, 'set from thu to mon');
        assert.equal(moment(a).isoWeekday(4).date(), 13, 'set from thu to thu');
        assert.equal(moment(a).isoWeekday(7).date(), 16, 'set from thu to sun');
        assert.equal(moment(a).isoWeekday(-6).date(),  3, 'set from thu to last mon');
        assert.equal(moment(a).isoWeekday(-3).date(),  6, 'set from thu to last thu');
        assert.equal(moment(a).isoWeekday(0).date(),   9, 'set from thu to last sun');
        assert.equal(moment(a).isoWeekday(8).date(),  17, 'set from thu to next mon');
        assert.equal(moment(a).isoWeekday(11).date(), 20, 'set from thu to next thu');
        assert.equal(moment(a).isoWeekday(14).date(), 23, 'set from thu to next sun');

        a = moment([2011, 0, 16]);
        assert.equal(moment(a).isoWeekday(1).date(), 10, 'set from sun to mon');
        assert.equal(moment(a).isoWeekday(4).date(), 13, 'set from sun to thu');
        assert.equal(moment(a).isoWeekday(7).date(), 16, 'set from sun to sun');
        assert.equal(moment(a).isoWeekday(-6).date(),  3, 'set from sun to last mon');
        assert.equal(moment(a).isoWeekday(-3).date(),  6, 'set from sun to last thu');
        assert.equal(moment(a).isoWeekday(0).date(),   9, 'set from sun to last sun');
        assert.equal(moment(a).isoWeekday(8).date(),  17, 'set from sun to next mon');
        assert.equal(moment(a).isoWeekday(11).date(), 20, 'set from sun to next thu');
        assert.equal(moment(a).isoWeekday(14).date(), 23, 'set from sun to next sun');
    });

    test('weekday first day of week Sunday (dow 0)', function (assert) {
        moment.locale('dow: 0,doy: 6', {week: {dow: 0, doy: 6}});
        assert.equal(moment([1985, 1,  3]).weekday(), 0, 'Feb  3 1985 is Sunday    -- 0th day');
        assert.equal(moment([2029, 8, 17]).weekday(), 1, 'Sep 17 2029 is Monday    -- 1st day');
        assert.equal(moment([2013, 3, 23]).weekday(), 2, 'Apr 23 2013 is Tuesday   -- 2nd day');
        assert.equal(moment([2015, 2,  4]).weekday(), 3, 'Mar  4 2015 is Wednesday -- 3nd day');
        assert.equal(moment([1970, 0,  1]).weekday(), 4, 'Jan  1 1970 is Thursday  -- 4th day');
        assert.equal(moment([2001, 4, 11]).weekday(), 5, 'May 11 2001 is Friday    -- 5th day');
        assert.equal(moment([2000, 0,  1]).weekday(), 6, 'Jan  1 2000 is Saturday  -- 6th day');
    });

    test('weekday first day of week Monday (dow 1)', function (assert) {
        moment.locale('dow: 1,doy: 6', {week: {dow: 1, doy: 6}});
        assert.equal(moment([1985, 1,  4]).weekday(), 0, 'Feb  4 1985 is Monday    -- 0th day');
        assert.equal(moment([2029, 8, 18]).weekday(), 1, 'Sep 18 2029 is Tuesday   -- 1st day');
        assert.equal(moment([2013, 3, 24]).weekday(), 2, 'Apr 24 2013 is Wednesday -- 2nd day');
        assert.equal(moment([2015, 2,  5]).weekday(), 3, 'Mar  5 2015 is Thursday  -- 3nd day');
        assert.equal(moment([1970, 0,  2]).weekday(), 4, 'Jan  2 1970 is Friday    -- 4th day');
        assert.equal(moment([2001, 4, 12]).weekday(), 5, 'May 12 2001 is Saturday  -- 5th day');
        assert.equal(moment([2000, 0,  2]).weekday(), 6, 'Jan  2 2000 is Sunday    -- 6th day');
    });

    test('weekday first day of week Tuesday (dow 2)', function (assert) {
        moment.locale('dow: 2,doy: 6', {week: {dow: 2, doy: 6}});
        assert.equal(moment([1985, 1,  5]).weekday(), 0, 'Feb  5 1985 is Tuesday   -- 0th day');
        assert.equal(moment([2029, 8, 19]).weekday(), 1, 'Sep 19 2029 is Wednesday -- 1st day');
        assert.equal(moment([2013, 3, 25]).weekday(), 2, 'Apr 25 2013 is Thursday  -- 2nd day');
        assert.equal(moment([2015, 2,  6]).weekday(), 3, 'Mar  6 2015 is Friday    -- 3nd day');
        assert.equal(moment([1970, 0,  3]).weekday(), 4, 'Jan  3 1970 is Staturday -- 4th day');
        assert.equal(moment([2001, 4, 13]).weekday(), 5, 'May 13 2001 is Sunday    -- 5th day');
        assert.equal(moment([2000, 0,  3]).weekday(), 6, 'Jan  3 2000 is Monday    -- 6th day');
    });

    test('weekday first day of week Wednesday (dow 3)', function (assert) {
        moment.locale('dow: 3,doy: 6', {week: {dow: 3, doy: 6}});
        assert.equal(moment([1985, 1,  6]).weekday(), 0, 'Feb  6 1985 is Wednesday -- 0th day');
        assert.equal(moment([2029, 8, 20]).weekday(), 1, 'Sep 20 2029 is Thursday  -- 1st day');
        assert.equal(moment([2013, 3, 26]).weekday(), 2, 'Apr 26 2013 is Friday    -- 2nd day');
        assert.equal(moment([2015, 2,  7]).weekday(), 3, 'Mar  7 2015 is Saturday  -- 3nd day');
        assert.equal(moment([1970, 0,  4]).weekday(), 4, 'Jan  4 1970 is Sunday    -- 4th day');
        assert.equal(moment([2001, 4, 14]).weekday(), 5, 'May 14 2001 is Monday    -- 5th day');
        assert.equal(moment([2000, 0,  4]).weekday(), 6, 'Jan  4 2000 is Tuesday   -- 6th day');
        moment.locale('dow:3,doy:6', null);
    });

    test('weekday first day of week Thursday (dow 4)', function (assert) {
        moment.locale('dow: 4,doy: 6', {week: {dow: 4, doy: 6}});
        assert.equal(moment([1985, 1,  7]).weekday(), 0, 'Feb  7 1985 is Thursday  -- 0th day');
        assert.equal(moment([2029, 8, 21]).weekday(), 1, 'Sep 21 2029 is Friday    -- 1st day');
        assert.equal(moment([2013, 3, 27]).weekday(), 2, 'Apr 27 2013 is Saturday  -- 2nd day');
        assert.equal(moment([2015, 2,  8]).weekday(), 3, 'Mar  8 2015 is Sunday    -- 3nd day');
        assert.equal(moment([1970, 0,  5]).weekday(), 4, 'Jan  5 1970 is Monday    -- 4th day');
        assert.equal(moment([2001, 4, 15]).weekday(), 5, 'May 15 2001 is Tuesday   -- 5th day');
        assert.equal(moment([2000, 0,  5]).weekday(), 6, 'Jan  5 2000 is Wednesday -- 6th day');
    });

    test('weekday first day of week Friday (dow 5)', function (assert) {
        moment.locale('dow: 5,doy: 6', {week: {dow: 5, doy: 6}});
        assert.equal(moment([1985, 1,  8]).weekday(), 0, 'Feb  8 1985 is Friday    -- 0th day');
        assert.equal(moment([2029, 8, 22]).weekday(), 1, 'Sep 22 2029 is Staturday -- 1st day');
        assert.equal(moment([2013, 3, 28]).weekday(), 2, 'Apr 28 2013 is Sunday    -- 2nd day');
        assert.equal(moment([2015, 2,  9]).weekday(), 3, 'Mar  9 2015 is Monday    -- 3nd day');
        assert.equal(moment([1970, 0,  6]).weekday(), 4, 'Jan  6 1970 is Tuesday   -- 4th day');
        assert.equal(moment([2001, 4, 16]).weekday(), 5, 'May 16 2001 is Wednesday -- 5th day');
        assert.equal(moment([2000, 0,  6]).weekday(), 6, 'Jan  6 2000 is Thursday  -- 6th day');
    });

    test('weekday first day of week Saturday (dow 6)', function (assert) {
        moment.locale('dow: 6,doy: 6', {week: {dow: 6, doy: 6}});
        assert.equal(moment([1985, 1,  9]).weekday(), 0, 'Feb  9 1985 is Staturday -- 0th day');
        assert.equal(moment([2029, 8, 23]).weekday(), 1, 'Sep 23 2029 is Sunday    -- 1st day');
        assert.equal(moment([2013, 3, 29]).weekday(), 2, 'Apr 29 2013 is Monday    -- 2nd day');
        assert.equal(moment([2015, 2, 10]).weekday(), 3, 'Mar 10 2015 is Tuesday   -- 3nd day');
        assert.equal(moment([1970, 0,  7]).weekday(), 4, 'Jan  7 1970 is Wednesday -- 4th day');
        assert.equal(moment([2001, 4, 17]).weekday(), 5, 'May 17 2001 is Thursday  -- 5th day');
        assert.equal(moment([2000, 0,  7]).weekday(), 6, 'Jan  7 2000 is Friday    -- 6th day');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('weeks');

    test('day of year', function (assert) {
        assert.equal(moment([2000,  0,  1]).dayOfYear(),   1, 'Jan  1 2000 should be day 1 of the year');
        assert.equal(moment([2000,  1, 28]).dayOfYear(),  59, 'Feb 28 2000 should be day 59 of the year');
        assert.equal(moment([2000,  1, 29]).dayOfYear(),  60, 'Feb 28 2000 should be day 60 of the year');
        assert.equal(moment([2000, 11, 31]).dayOfYear(), 366, 'Dec 31 2000 should be day 366 of the year');
        assert.equal(moment([2001,  0,  1]).dayOfYear(),   1, 'Jan  1 2001 should be day 1 of the year');
        assert.equal(moment([2001,  1, 28]).dayOfYear(),  59, 'Feb 28 2001 should be day 59 of the year');
        assert.equal(moment([2001,  2,  1]).dayOfYear(),  60, 'Mar  1 2001 should be day 60 of the year');
        assert.equal(moment([2001, 11, 31]).dayOfYear(), 365, 'Dec 31 2001 should be day 365 of the year');
    });

    test('day of year setters', function (assert) {
        assert.equal(moment([2000,  0,  1]).dayOfYear(200).dayOfYear(), 200, 'Setting Jan  1 2000 day of the year to 200 should work');
        assert.equal(moment([2000,  1, 28]).dayOfYear(200).dayOfYear(), 200, 'Setting Feb 28 2000 day of the year to 200 should work');
        assert.equal(moment([2000,  1, 29]).dayOfYear(200).dayOfYear(), 200, 'Setting Feb 28 2000 day of the year to 200 should work');
        assert.equal(moment([2000, 11, 31]).dayOfYear(200).dayOfYear(), 200, 'Setting Dec 31 2000 day of the year to 200 should work');
        assert.equal(moment().dayOfYear(1).dayOfYear(),   1, 'Setting day of the year to 1 should work');
        assert.equal(moment().dayOfYear(59).dayOfYear(),  59, 'Setting day of the year to 59 should work');
        assert.equal(moment().dayOfYear(60).dayOfYear(),  60, 'Setting day of the year to 60 should work');
        assert.equal(moment().dayOfYear(365).dayOfYear(), 365, 'Setting day of the year to 365 should work');
    });

    test('iso weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).isoWeek(), 52, 'Jan  1 2012 should be iso week 52');
        assert.equal(moment([2012, 0, 2]).isoWeek(),  1, 'Jan  2 2012 should be iso week 1');
        assert.equal(moment([2012, 0, 8]).isoWeek(),  1, 'Jan  8 2012 should be iso week 1');
        assert.equal(moment([2012, 0, 9]).isoWeek(),  2, 'Jan  9 2012 should be iso week 2');
        assert.equal(moment([2012, 0, 15]).isoWeek(), 2, 'Jan 15 2012 should be iso week 2');
    });

    test('iso weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).isoWeek(),  1, 'Jan  1 2007 should be iso week 1');
        assert.equal(moment([2007, 0, 7]).isoWeek(),  1, 'Jan  7 2007 should be iso week 1');
        assert.equal(moment([2007, 0, 8]).isoWeek(),  2, 'Jan  8 2007 should be iso week 2');
        assert.equal(moment([2007, 0, 14]).isoWeek(), 2, 'Jan 14 2007 should be iso week 2');
        assert.equal(moment([2007, 0, 15]).isoWeek(), 3, 'Jan 15 2007 should be iso week 3');
    });

    test('iso weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).isoWeek(), 1, 'Dec 31 2007 should be iso week 1');
        assert.equal(moment([2008,  0,  1]).isoWeek(), 1, 'Jan  1 2008 should be iso week 1');
        assert.equal(moment([2008,  0,  6]).isoWeek(), 1, 'Jan  6 2008 should be iso week 1');
        assert.equal(moment([2008,  0,  7]).isoWeek(), 2, 'Jan  7 2008 should be iso week 2');
        assert.equal(moment([2008,  0, 13]).isoWeek(), 2, 'Jan 13 2008 should be iso week 2');
        assert.equal(moment([2008,  0, 14]).isoWeek(), 3, 'Jan 14 2008 should be iso week 3');
    });

    test('iso weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).isoWeek(), 1, 'Dec 30 2002 should be iso week 1');
        assert.equal(moment([2003,  0,  1]).isoWeek(), 1, 'Jan  1 2003 should be iso week 1');
        assert.equal(moment([2003,  0,  5]).isoWeek(), 1, 'Jan  5 2003 should be iso week 1');
        assert.equal(moment([2003,  0,  6]).isoWeek(), 2, 'Jan  6 2003 should be iso week 2');
        assert.equal(moment([2003,  0, 12]).isoWeek(), 2, 'Jan 12 2003 should be iso week 2');
        assert.equal(moment([2003,  0, 13]).isoWeek(), 3, 'Jan 13 2003 should be iso week 3');
    });

    test('iso weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).isoWeek(), 1, 'Dec 29 2008 should be iso week 1');
        assert.equal(moment([2009,  0,  1]).isoWeek(), 1, 'Jan  1 2009 should be iso week 1');
        assert.equal(moment([2009,  0,  4]).isoWeek(), 1, 'Jan  4 2009 should be iso week 1');
        assert.equal(moment([2009,  0,  5]).isoWeek(), 2, 'Jan  5 2009 should be iso week 2');
        assert.equal(moment([2009,  0, 11]).isoWeek(), 2, 'Jan 11 2009 should be iso week 2');
        assert.equal(moment([2009,  0, 13]).isoWeek(), 3, 'Jan 12 2009 should be iso week 3');
    });

    test('iso weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).isoWeek(), 53, 'Dec 28 2009 should be iso week 53');
        assert.equal(moment([2010,  0,  1]).isoWeek(), 53, 'Jan  1 2010 should be iso week 53');
        assert.equal(moment([2010,  0,  3]).isoWeek(), 53, 'Jan  3 2010 should be iso week 53');
        assert.equal(moment([2010,  0,  4]).isoWeek(),  1, 'Jan  4 2010 should be iso week 1');
        assert.equal(moment([2010,  0, 10]).isoWeek(),  1, 'Jan 10 2010 should be iso week 1');
        assert.equal(moment([2010,  0, 11]).isoWeek(),  2, 'Jan 11 2010 should be iso week 2');
    });

    test('iso weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).isoWeek(), 52, 'Dec 27 2010 should be iso week 52');
        assert.equal(moment([2011,  0,  1]).isoWeek(), 52, 'Jan  1 2011 should be iso week 52');
        assert.equal(moment([2011,  0,  2]).isoWeek(), 52, 'Jan  2 2011 should be iso week 52');
        assert.equal(moment([2011,  0,  3]).isoWeek(),  1, 'Jan  3 2011 should be iso week 1');
        assert.equal(moment([2011,  0,  9]).isoWeek(),  1, 'Jan  9 2011 should be iso week 1');
        assert.equal(moment([2011,  0, 10]).isoWeek(),  2, 'Jan 10 2011 should be iso week 2');
    });

    test('iso weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('W WW Wo'), '52 52 52nd', 'Jan  1 2012 should be iso week 52');
        assert.equal(moment([2012, 0,  2]).format('W WW Wo'),   '1 01 1st', 'Jan  2 2012 should be iso week 1');
        assert.equal(moment([2012, 0,  8]).format('W WW Wo'),   '1 01 1st', 'Jan  8 2012 should be iso week 1');
        assert.equal(moment([2012, 0,  9]).format('W WW Wo'),   '2 02 2nd', 'Jan  9 2012 should be iso week 2');
        assert.equal(moment([2012, 0, 15]).format('W WW Wo'),   '2 02 2nd', 'Jan 15 2012 should be iso week 2');
    });

    test('weeks plural year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).weeks(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).weeks(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).weeks(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).weeks(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).weeks(), 3, 'Jan 15 2012 should be week 3');
    });

    test('iso weeks plural year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).isoWeeks(), 52, 'Jan  1 2012 should be iso week 52');
        assert.equal(moment([2012, 0, 2]).isoWeeks(),  1, 'Jan  2 2012 should be iso week 1');
        assert.equal(moment([2012, 0, 8]).isoWeeks(),  1, 'Jan  8 2012 should be iso week 1');
        assert.equal(moment([2012, 0, 9]).isoWeeks(),  2, 'Jan  9 2012 should be iso week 2');
        assert.equal(moment([2012, 0, 15]).isoWeeks(), 2, 'Jan 15 2012 should be iso week 2');
    });

    test('weeks setter', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(30).week(), 30, 'Setting Jan 1 2012 to week 30 should work');
        assert.equal(moment([2012, 0,  7]).week(30).week(), 30, 'Setting Jan 7 2012 to week 30 should work');
        assert.equal(moment([2012, 0,  8]).week(30).week(), 30, 'Setting Jan 8 2012 to week 30 should work');
        assert.equal(moment([2012, 0, 14]).week(30).week(), 30, 'Setting Jan 14 2012 to week 30 should work');
        assert.equal(moment([2012, 0, 15]).week(30).week(), 30, 'Setting Jan 15 2012 to week 30 should work');
    });

    test('iso weeks setter', function (assert) {
        assert.equal(moment([2012, 0,  1]).isoWeeks(25).isoWeeks(), 25, 'Setting Jan  1 2012 to week 25 should work');
        assert.equal(moment([2012, 0,  2]).isoWeeks(24).isoWeeks(), 24, 'Setting Jan  2 2012 to week 24 should work');
        assert.equal(moment([2012, 0,  8]).isoWeeks(23).isoWeeks(), 23, 'Setting Jan  8 2012 to week 23 should work');
        assert.equal(moment([2012, 0,  9]).isoWeeks(22).isoWeeks(), 22, 'Setting Jan  9 2012 to week 22 should work');
        assert.equal(moment([2012, 0, 15]).isoWeeks(21).isoWeeks(), 21, 'Setting Jan 15 2012 to week 21 should work');
    });

    test('iso weeks setter day of year', function (assert) {
        assert.equal(moment([2012, 0,  1]).isoWeek(1).dayOfYear(), 9, 'Setting Jan  1 2012 to week 1 should be day of year 8');
        assert.equal(moment([2012, 0,  1]).isoWeek(1).year(),   2011, 'Setting Jan  1 2012 to week 1 should be year 2011');
        assert.equal(moment([2012, 0,  2]).isoWeek(1).dayOfYear(), 2, 'Setting Jan  2 2012 to week 1 should be day of year 2');
        assert.equal(moment([2012, 0,  8]).isoWeek(1).dayOfYear(), 8, 'Setting Jan  8 2012 to week 1 should be day of year 8');
        assert.equal(moment([2012, 0,  9]).isoWeek(1).dayOfYear(), 2, 'Setting Jan  9 2012 to week 1 should be day of year 2');
        assert.equal(moment([2012, 0, 15]).isoWeek(1).dayOfYear(), 8, 'Setting Jan 15 2012 to week 1 should be day of year 8');
    });

    test('years with iso week 53', function (assert) {
        // Based on a table taken from http://en.wikipedia.org/wiki/ISO_week_date
        // (as downloaded on 2014-01-06) listing the 71 years in a 400-year cycle
        // that have 53 weeks; in this case reflecting the 2000 based cycle
        assert.equal(moment([2004, 11, 31]).isoWeek(), 53, 'Dec 31 2004 should be iso week 53');
        assert.equal(moment([2009, 11, 31]).isoWeek(), 53, 'Dec 31 2009 should be iso week 53');
        assert.equal(moment([2015, 11, 31]).isoWeek(), 53, 'Dec 31 2015 should be iso week 53');
        assert.equal(moment([2020, 11, 31]).isoWeek(), 53, 'Dec 31 2020 should be iso week 53');
        assert.equal(moment([2026, 11, 31]).isoWeek(), 53, 'Dec 31 2026 should be iso week 53');
        assert.equal(moment([2032, 11, 31]).isoWeek(), 53, 'Dec 31 2032 should be iso week 53');
        assert.equal(moment([2037, 11, 31]).isoWeek(), 53, 'Dec 31 2037 should be iso week 53');
        assert.equal(moment([2043, 11, 31]).isoWeek(), 53, 'Dec 31 2043 should be iso week 53');
        assert.equal(moment([2048, 11, 31]).isoWeek(), 53, 'Dec 31 2048 should be iso week 53');
        assert.equal(moment([2054, 11, 31]).isoWeek(), 53, 'Dec 31 2054 should be iso week 53');
        assert.equal(moment([2060, 11, 31]).isoWeek(), 53, 'Dec 31 2060 should be iso week 53');
        assert.equal(moment([2065, 11, 31]).isoWeek(), 53, 'Dec 31 2065 should be iso week 53');
        assert.equal(moment([2071, 11, 31]).isoWeek(), 53, 'Dec 31 2071 should be iso week 53');
        assert.equal(moment([2076, 11, 31]).isoWeek(), 53, 'Dec 31 2076 should be iso week 53');
        assert.equal(moment([2082, 11, 31]).isoWeek(), 53, 'Dec 31 2082 should be iso week 53');
        assert.equal(moment([2088, 11, 31]).isoWeek(), 53, 'Dec 31 2088 should be iso week 53');
        assert.equal(moment([2093, 11, 31]).isoWeek(), 53, 'Dec 31 2093 should be iso week 53');
        assert.equal(moment([2099, 11, 31]).isoWeek(), 53, 'Dec 31 2099 should be iso week 53');
        assert.equal(moment([2105, 11, 31]).isoWeek(), 53, 'Dec 31 2105 should be iso week 53');
        assert.equal(moment([2111, 11, 31]).isoWeek(), 53, 'Dec 31 2111 should be iso week 53');
        assert.equal(moment([2116, 11, 31]).isoWeek(), 53, 'Dec 31 2116 should be iso week 53');
        assert.equal(moment([2122, 11, 31]).isoWeek(), 53, 'Dec 31 2122 should be iso week 53');
        assert.equal(moment([2128, 11, 31]).isoWeek(), 53, 'Dec 31 2128 should be iso week 53');
        assert.equal(moment([2133, 11, 31]).isoWeek(), 53, 'Dec 31 2133 should be iso week 53');
        assert.equal(moment([2139, 11, 31]).isoWeek(), 53, 'Dec 31 2139 should be iso week 53');
        assert.equal(moment([2144, 11, 31]).isoWeek(), 53, 'Dec 31 2144 should be iso week 53');
        assert.equal(moment([2150, 11, 31]).isoWeek(), 53, 'Dec 31 2150 should be iso week 53');
        assert.equal(moment([2156, 11, 31]).isoWeek(), 53, 'Dec 31 2156 should be iso week 53');
        assert.equal(moment([2161, 11, 31]).isoWeek(), 53, 'Dec 31 2161 should be iso week 53');
        assert.equal(moment([2167, 11, 31]).isoWeek(), 53, 'Dec 31 2167 should be iso week 53');
        assert.equal(moment([2172, 11, 31]).isoWeek(), 53, 'Dec 31 2172 should be iso week 53');
        assert.equal(moment([2178, 11, 31]).isoWeek(), 53, 'Dec 31 2178 should be iso week 53');
        assert.equal(moment([2184, 11, 31]).isoWeek(), 53, 'Dec 31 2184 should be iso week 53');
        assert.equal(moment([2189, 11, 31]).isoWeek(), 53, 'Dec 31 2189 should be iso week 53');
        assert.equal(moment([2195, 11, 31]).isoWeek(), 53, 'Dec 31 2195 should be iso week 53');
        assert.equal(moment([2201, 11, 31]).isoWeek(), 53, 'Dec 31 2201 should be iso week 53');
        assert.equal(moment([2207, 11, 31]).isoWeek(), 53, 'Dec 31 2207 should be iso week 53');
        assert.equal(moment([2212, 11, 31]).isoWeek(), 53, 'Dec 31 2212 should be iso week 53');
        assert.equal(moment([2218, 11, 31]).isoWeek(), 53, 'Dec 31 2218 should be iso week 53');
        assert.equal(moment([2224, 11, 31]).isoWeek(), 53, 'Dec 31 2224 should be iso week 53');
        assert.equal(moment([2229, 11, 31]).isoWeek(), 53, 'Dec 31 2229 should be iso week 53');
        assert.equal(moment([2235, 11, 31]).isoWeek(), 53, 'Dec 31 2235 should be iso week 53');
        assert.equal(moment([2240, 11, 31]).isoWeek(), 53, 'Dec 31 2240 should be iso week 53');
        assert.equal(moment([2246, 11, 31]).isoWeek(), 53, 'Dec 31 2246 should be iso week 53');
        assert.equal(moment([2252, 11, 31]).isoWeek(), 53, 'Dec 31 2252 should be iso week 53');
        assert.equal(moment([2257, 11, 31]).isoWeek(), 53, 'Dec 31 2257 should be iso week 53');
        assert.equal(moment([2263, 11, 31]).isoWeek(), 53, 'Dec 31 2263 should be iso week 53');
        assert.equal(moment([2268, 11, 31]).isoWeek(), 53, 'Dec 31 2268 should be iso week 53');
        assert.equal(moment([2274, 11, 31]).isoWeek(), 53, 'Dec 31 2274 should be iso week 53');
        assert.equal(moment([2280, 11, 31]).isoWeek(), 53, 'Dec 31 2280 should be iso week 53');
        assert.equal(moment([2285, 11, 31]).isoWeek(), 53, 'Dec 31 2285 should be iso week 53');
        assert.equal(moment([2291, 11, 31]).isoWeek(), 53, 'Dec 31 2291 should be iso week 53');
        assert.equal(moment([2296, 11, 31]).isoWeek(), 53, 'Dec 31 2296 should be iso week 53');
        assert.equal(moment([2303, 11, 31]).isoWeek(), 53, 'Dec 31 2303 should be iso week 53');
        assert.equal(moment([2308, 11, 31]).isoWeek(), 53, 'Dec 31 2308 should be iso week 53');
        assert.equal(moment([2314, 11, 31]).isoWeek(), 53, 'Dec 31 2314 should be iso week 53');
        assert.equal(moment([2320, 11, 31]).isoWeek(), 53, 'Dec 31 2320 should be iso week 53');
        assert.equal(moment([2325, 11, 31]).isoWeek(), 53, 'Dec 31 2325 should be iso week 53');
        assert.equal(moment([2331, 11, 31]).isoWeek(), 53, 'Dec 31 2331 should be iso week 53');
        assert.equal(moment([2336, 11, 31]).isoWeek(), 53, 'Dec 31 2336 should be iso week 53');
        assert.equal(moment([2342, 11, 31]).isoWeek(), 53, 'Dec 31 2342 should be iso week 53');
        assert.equal(moment([2348, 11, 31]).isoWeek(), 53, 'Dec 31 2348 should be iso week 53');
        assert.equal(moment([2353, 11, 31]).isoWeek(), 53, 'Dec 31 2353 should be iso week 53');
        assert.equal(moment([2359, 11, 31]).isoWeek(), 53, 'Dec 31 2359 should be iso week 53');
        assert.equal(moment([2364, 11, 31]).isoWeek(), 53, 'Dec 31 2364 should be iso week 53');
        assert.equal(moment([2370, 11, 31]).isoWeek(), 53, 'Dec 31 2370 should be iso week 53');
        assert.equal(moment([2376, 11, 31]).isoWeek(), 53, 'Dec 31 2376 should be iso week 53');
        assert.equal(moment([2381, 11, 31]).isoWeek(), 53, 'Dec 31 2381 should be iso week 53');
        assert.equal(moment([2387, 11, 31]).isoWeek(), 53, 'Dec 31 2387 should be iso week 53');
        assert.equal(moment([2392, 11, 31]).isoWeek(), 53, 'Dec 31 2392 should be iso week 53');
        assert.equal(moment([2398, 11, 31]).isoWeek(), 53, 'Dec 31 2398 should be iso week 53');
    });

    test('count years with iso week 53', function (assert) {
        // Based on http://en.wikipedia.org/wiki/ISO_week_date (as seen on 2014-01-06)
        // stating that there are 71 years in a 400-year cycle that have 53 weeks;
        // in this case reflecting the 2000 based cycle
        var count = 0, i;
        for (i = 0; i < 400; i++) {
            count += (moment([2000 + i, 11, 31]).isoWeek() === 53) ? 1 : 0;
        }
        assert.equal(count, 71, 'Should have 71 years in 400-year cycle with iso week 53');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('weeks in year');

    test('isoWeeksInYear', function (assert) {
        assert.equal(moment([2004]).isoWeeksInYear(), 53, '2004 has 53 iso weeks');
        assert.equal(moment([2005]).isoWeeksInYear(), 52, '2005 has 53 iso weeks');
        assert.equal(moment([2006]).isoWeeksInYear(), 52, '2006 has 53 iso weeks');
        assert.equal(moment([2007]).isoWeeksInYear(), 52, '2007 has 52 iso weeks');
        assert.equal(moment([2008]).isoWeeksInYear(), 52, '2008 has 53 iso weeks');
        assert.equal(moment([2009]).isoWeeksInYear(), 53, '2009 has 53 iso weeks');
        assert.equal(moment([2010]).isoWeeksInYear(), 52, '2010 has 52 iso weeks');
        assert.equal(moment([2011]).isoWeeksInYear(), 52, '2011 has 52 iso weeks');
        assert.equal(moment([2012]).isoWeeksInYear(), 52, '2012 has 52 iso weeks');
        assert.equal(moment([2013]).isoWeeksInYear(), 52, '2013 has 52 iso weeks');
        assert.equal(moment([2014]).isoWeeksInYear(), 52, '2014 has 52 iso weeks');
        assert.equal(moment([2015]).isoWeeksInYear(), 53, '2015 has 53 iso weeks');
    });

    test('weeksInYear doy/dow = 1/4', function (assert) {
        moment.locale('1/4', {week: {dow: 1, doy: 4}});

        assert.equal(moment([2004]).weeksInYear(), 53, '2004 has 53 weeks');
        assert.equal(moment([2005]).weeksInYear(), 52, '2005 has 53 weeks');
        assert.equal(moment([2006]).weeksInYear(), 52, '2006 has 53 weeks');
        assert.equal(moment([2007]).weeksInYear(), 52, '2007 has 52 weeks');
        assert.equal(moment([2008]).weeksInYear(), 52, '2008 has 53 weeks');
        assert.equal(moment([2009]).weeksInYear(), 53, '2009 has 53 weeks');
        assert.equal(moment([2010]).weeksInYear(), 52, '2010 has 52 weeks');
        assert.equal(moment([2011]).weeksInYear(), 52, '2011 has 52 weeks');
        assert.equal(moment([2012]).weeksInYear(), 52, '2012 has 52 weeks');
        assert.equal(moment([2013]).weeksInYear(), 52, '2013 has 52 weeks');
        assert.equal(moment([2014]).weeksInYear(), 52, '2014 has 52 weeks');
        assert.equal(moment([2015]).weeksInYear(), 53, '2015 has 53 weeks');
    });

    test('weeksInYear doy/dow = 6/12', function (assert) {
        moment.locale('6/12', {week: {dow: 6, doy: 12}});

        assert.equal(moment([2004]).weeksInYear(), 53, '2004 has 53 weeks');
        assert.equal(moment([2005]).weeksInYear(), 52, '2005 has 53 weeks');
        assert.equal(moment([2006]).weeksInYear(), 52, '2006 has 53 weeks');
        assert.equal(moment([2007]).weeksInYear(), 52, '2007 has 52 weeks');
        assert.equal(moment([2008]).weeksInYear(), 52, '2008 has 53 weeks');
        assert.equal(moment([2009]).weeksInYear(), 52, '2009 has 53 weeks');
        assert.equal(moment([2010]).weeksInYear(), 53, '2010 has 52 weeks');
        assert.equal(moment([2011]).weeksInYear(), 52, '2011 has 52 weeks');
        assert.equal(moment([2012]).weeksInYear(), 52, '2012 has 52 weeks');
        assert.equal(moment([2013]).weeksInYear(), 52, '2013 has 52 weeks');
        assert.equal(moment([2014]).weeksInYear(), 52, '2014 has 52 weeks');
        assert.equal(moment([2015]).weeksInYear(), 52, '2015 has 53 weeks');
    });

    test('weeksInYear doy/dow = 1/7', function (assert) {
        moment.locale('1/7', {week: {dow: 1, doy: 7}});

        assert.equal(moment([2004]).weeksInYear(), 52, '2004 has 53 weeks');
        assert.equal(moment([2005]).weeksInYear(), 52, '2005 has 53 weeks');
        assert.equal(moment([2006]).weeksInYear(), 53, '2006 has 53 weeks');
        assert.equal(moment([2007]).weeksInYear(), 52, '2007 has 52 weeks');
        assert.equal(moment([2008]).weeksInYear(), 52, '2008 has 53 weeks');
        assert.equal(moment([2009]).weeksInYear(), 52, '2009 has 53 weeks');
        assert.equal(moment([2010]).weeksInYear(), 52, '2010 has 52 weeks');
        assert.equal(moment([2011]).weeksInYear(), 52, '2011 has 52 weeks');
        assert.equal(moment([2012]).weeksInYear(), 53, '2012 has 52 weeks');
        assert.equal(moment([2013]).weeksInYear(), 52, '2013 has 52 weeks');
        assert.equal(moment([2014]).weeksInYear(), 52, '2014 has 52 weeks');
        assert.equal(moment([2015]).weeksInYear(), 52, '2015 has 53 weeks');
    });

    test('weeksInYear doy/dow = 0/6', function (assert) {
        moment.locale('0/6', {week: {dow: 0, doy: 6}});

        assert.equal(moment([2004]).weeksInYear(), 52, '2004 has 53 weeks');
        assert.equal(moment([2005]).weeksInYear(), 53, '2005 has 53 weeks');
        assert.equal(moment([2006]).weeksInYear(), 52, '2006 has 53 weeks');
        assert.equal(moment([2007]).weeksInYear(), 52, '2007 has 52 weeks');
        assert.equal(moment([2008]).weeksInYear(), 52, '2008 has 53 weeks');
        assert.equal(moment([2009]).weeksInYear(), 52, '2009 has 53 weeks');
        assert.equal(moment([2010]).weeksInYear(), 52, '2010 has 52 weeks');
        assert.equal(moment([2011]).weeksInYear(), 53, '2011 has 52 weeks');
        assert.equal(moment([2012]).weeksInYear(), 52, '2012 has 52 weeks');
        assert.equal(moment([2013]).weeksInYear(), 52, '2013 has 52 weeks');
        assert.equal(moment([2014]).weeksInYear(), 52, '2014 has 52 weeks');
        assert.equal(moment([2015]).weeksInYear(), 52, '2015 has 53 weeks');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('zone switching');

    test('local to utc, keepLocalTime = true', function (assert) {
        var m = moment(),
            fmt = 'YYYY-DD-MM HH:mm:ss';
        assert.equal(m.clone().utc(true).format(fmt), m.format(fmt), 'local to utc failed to keep local time');
    });

    test('local to utc, keepLocalTime = false', function (assert) {
        var m = moment();
        assert.equal(m.clone().utc().valueOf(), m.valueOf(), 'local to utc failed to keep utc time (implicit)');
        assert.equal(m.clone().utc(false).valueOf(), m.valueOf(), 'local to utc failed to keep utc time (explicit)');
    });

    test('local to zone, keepLocalTime = true', function (assert) {
        var m = moment(),
            fmt = 'YYYY-DD-MM HH:mm:ss',
            z;

        // Apparently there is -12:00 and +14:00
        // http://en.wikipedia.org/wiki/UTC+14:00
        // http://en.wikipedia.org/wiki/UTC-12:00
        for (z = -12; z <= 14; ++z) {
            assert.equal(m.clone().zone(z * 60, true).format(fmt), m.format(fmt),
                    'local to zone(' + z + ':00) failed to keep local time');
        }
    });

    test('local to zone, keepLocalTime = false', function (assert) {
        var m = moment(),
            z;

        // Apparently there is -12:00 and +14:00
        // http://en.wikipedia.org/wiki/UTC+14:00
        // http://en.wikipedia.org/wiki/UTC-12:00
        for (z = -12; z <= 14; ++z) {
            assert.equal(m.clone().zone(z * 60).valueOf(), m.valueOf(),
                    'local to zone(' + z + ':00) failed to keep utc time (implicit)');
            assert.equal(m.clone().zone(z * 60, false).valueOf(), m.valueOf(),
                    'local to zone(' + z + ':00) failed to keep utc time (explicit)');
        }
    });

    test('utc to local, keepLocalTime = true', function (assert) {
        var um = moment.utc(),
            fmt = 'YYYY-DD-MM HH:mm:ss';

        assert.equal(um.clone().local(true).format(fmt), um.format(fmt), 'utc to local failed to keep local time');
    });

    test('utc to local, keepLocalTime = false', function (assert) {
        var um = moment.utc();
        assert.equal(um.clone().local().valueOf(), um.valueOf(), 'utc to local failed to keep utc time (implicit)');
        assert.equal(um.clone().local(false).valueOf(), um.valueOf(), 'utc to local failed to keep utc time (explicit)');
    });

    test('zone to local, keepLocalTime = true', function (assert) {
        var m = moment(),
            fmt = 'YYYY-DD-MM HH:mm:ss',
            z;

        // Apparently there is -12:00 and +14:00
        // http://en.wikipedia.org/wiki/UTC+14:00
        // http://en.wikipedia.org/wiki/UTC-12:00
        for (z = -12; z <= 14; ++z) {
            m.zone(z * 60);

            assert.equal(m.clone().local(true).format(fmt), m.format(fmt),
                    'zone(' + z + ':00) to local failed to keep local time');
        }
    });

    test('zone to local, keepLocalTime = false', function (assert) {
        var m = moment(),
            z;

        // Apparently there is -12:00 and +14:00
        // http://en.wikipedia.org/wiki/UTC+14:00
        // http://en.wikipedia.org/wiki/UTC-12:00
        for (z = -12; z <= 14; ++z) {
            m.zone(z * 60);

            assert.equal(m.clone().local(false).valueOf(), m.valueOf(),
                    'zone(' + z + ':00) to local failed to keep utc time (explicit)');
            assert.equal(m.clone().local().valueOf(), m.valueOf(),
                    'zone(' + z + ':00) to local failed to keep utc time (implicit)');
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('zones');

    test('set zone', function (assert) {
        var zone = moment();

        zone.zone(0);
        assert.equal(zone.zone(), 0, 'should be able to set the zone to 0');

        zone.zone(60);
        assert.equal(zone.zone(), 60, 'should be able to set the zone to 60');

        zone.zone(-60);
        assert.equal(zone.zone(), -60, 'should be able to set the zone to -60');
    });

    test('set zone shorthand', function (assert) {
        var zone = moment();

        zone.zone(1);
        assert.equal(zone.zone(), 60, 'setting the zone to 1 should imply hours and convert to 60');

        zone.zone(-1);
        assert.equal(zone.zone(), -60, 'setting the zone to -1 should imply hours and convert to -60');

        zone.zone(15);
        assert.equal(zone.zone(), 900, 'setting the zone to 15 should imply hours and convert to 900');

        zone.zone(-15);
        assert.equal(zone.zone(), -900, 'setting the zone to -15 should imply hours and convert to -900');

        zone.zone(16);
        assert.equal(zone.zone(), 16, 'setting the zone to 16 should imply minutes');

        zone.zone(-16);
        assert.equal(zone.zone(), -16, 'setting the zone to -16 should imply minutes');
    });

    test('set zone with string', function (assert) {
        var zone = moment();

        zone.zone('+00:00');
        assert.equal(zone.zone(), 0, 'set the zone with a timezone string');

        zone.zone('2013-03-07T07:00:00-08:00');
        assert.equal(zone.zone(), 480, 'set the zone with a string that does not begin with the timezone');

        zone.zone('2013-03-07T07:00:00+0100');
        assert.equal(zone.zone(), -60, 'set the zone with a string that uses the +0000 syntax');

        zone.zone('03-07-2013T07:00:00-08:00');
        assert.equal(zone.zone(), 480, 'set the zone with a string with a non-ISO 8601 date');
    });

    test('change hours when changing the zone', function (assert) {
        var zone = moment.utc([2000, 0, 1, 6]);

        zone.zone(0);
        assert.equal(zone.hour(), 6, 'UTC 6AM should be 6AM at +0000');

        zone.zone(60);
        assert.equal(zone.hour(), 5, 'UTC 6AM should be 5AM at -0100');

        zone.zone(-60);
        assert.equal(zone.hour(), 7, 'UTC 6AM should be 7AM at +0100');
    });

    test('change minutes when changing the zone', function (assert) {
        var zone = moment.utc([2000, 0, 1, 6, 31]);

        zone.zone(0);
        assert.equal(zone.format('HH:mm'), '06:31', 'UTC 6:31AM should be 6:31AM at +0000');

        zone.zone(30);
        assert.equal(zone.format('HH:mm'), '06:01', 'UTC 6:31AM should be 6:01AM at -0030');

        zone.zone(-30);
        assert.equal(zone.format('HH:mm'), '07:01', 'UTC 6:31AM should be 7:01AM at +0030');

        zone.zone(1380);
        assert.equal(zone.format('HH:mm'), '07:31', 'UTC 6:31AM should be 7:31AM at +1380');
    });

    test('distance from the unix epoch', function (assert) {
        var zoneA = moment(),
            zoneB = moment(zoneA),
            zoneC = moment(zoneA),
            zoneD = moment(zoneA),
            zoneE = moment(zoneA);

        zoneB.utc();
        assert.equal(+zoneA, +zoneB, 'moment should equal moment.utc');

        zoneC.zone(-60);
        assert.equal(+zoneA, +zoneC, 'moment should equal moment.zone(-60)');

        zoneD.zone(480);
        assert.equal(+zoneA, +zoneD, 'moment should equal moment.zone(480)');

        zoneE.zone(1000);
        assert.equal(+zoneA, +zoneE, 'moment should equal moment.zone(1000)');
    });

    test('update offset after changing any values', function (assert) {
        var oldOffset = moment.updateOffset,
            m = moment.utc([2000, 6, 1]);

        moment.updateOffset = function (mom, keepTime) {
            if (mom.__doChange) {
                if (+mom > 962409600000) {
                    mom.zone(120, keepTime);
                } else {
                    mom.zone(60, keepTime);
                }
            }
        };

        assert.equal(m.format('ZZ'), '+0000', 'should be at +0000');
        assert.equal(m.format('HH:mm'), '00:00', 'should start 12AM at +0000 timezone');

        m.__doChange = true;
        m.add(1, 'h');

        assert.equal(m.format('ZZ'), '-0200', 'should be at -0200');
        assert.equal(m.format('HH:mm'), '23:00', '1AM at +0000 should be 11PM at -0200 timezone');

        m.subtract(1, 'h');

        assert.equal(m.format('ZZ'), '-0100', 'should be at -0100');
        assert.equal(m.format('HH:mm'), '23:00', '12AM at +0000 should be 11PM at -0100 timezone');

        moment.updateOffset = oldOffset;
    });

    test('getters and setters', function (assert) {
        var a = moment([2011, 5, 20]);

        assert.equal(a.clone().zone(120).year(2012).year(), 2012, 'should get and set year correctly');
        assert.equal(a.clone().zone(120).month(1).month(), 1, 'should get and set month correctly');
        assert.equal(a.clone().zone(120).date(2).date(), 2, 'should get and set date correctly');
        assert.equal(a.clone().zone(120).day(1).day(), 1, 'should get and set day correctly');
        assert.equal(a.clone().zone(120).hour(1).hour(), 1, 'should get and set hour correctly');
        assert.equal(a.clone().zone(120).minute(1).minute(), 1, 'should get and set minute correctly');
    });

    test('getters', function (assert) {
        var a = moment.utc([2012, 0, 1, 0, 0, 0]);

        assert.equal(a.clone().zone(120).year(),  2011, 'should get year correctly');
        assert.equal(a.clone().zone(120).month(),   11, 'should get month correctly');
        assert.equal(a.clone().zone(120).date(),    31, 'should get date correctly');
        assert.equal(a.clone().zone(120).hour(),    22, 'should get hour correctly');
        assert.equal(a.clone().zone(120).minute(),   0, 'should get minute correctly');

        assert.equal(a.clone().zone(-120).year(),  2012, 'should get year correctly');
        assert.equal(a.clone().zone(-120).month(),    0, 'should get month correctly');
        assert.equal(a.clone().zone(-120).date(),     1, 'should get date correctly');
        assert.equal(a.clone().zone(-120).hour(),     2, 'should get hour correctly');
        assert.equal(a.clone().zone(-120).minute(),   0, 'should get minute correctly');

        assert.equal(a.clone().zone(-90).year(),  2012, 'should get year correctly');
        assert.equal(a.clone().zone(-90).month(),    0, 'should get month correctly');
        assert.equal(a.clone().zone(-90).date(),     1, 'should get date correctly');
        assert.equal(a.clone().zone(-90).hour(),     1, 'should get hour correctly');
        assert.equal(a.clone().zone(-90).minute(),  30, 'should get minute correctly');
    });

    test('from', function (assert) {
        var zoneA = moment(),
            zoneB = moment(zoneA).zone(720),
            zoneC = moment(zoneA).zone(360),
            zoneD = moment(zoneA).zone(-690),
            other = moment(zoneA).add(35, 'm');

        assert.equal(zoneA.from(other), zoneB.from(other), 'moment#from should be the same in all zones');
        assert.equal(zoneA.from(other), zoneC.from(other), 'moment#from should be the same in all zones');
        assert.equal(zoneA.from(other), zoneD.from(other), 'moment#from should be the same in all zones');
    });

    test('diff', function (assert) {
        var zoneA = moment(),
            zoneB = moment(zoneA).zone(720),
            zoneC = moment(zoneA).zone(360),
            zoneD = moment(zoneA).zone(-690),
            other = moment(zoneA).add(35, 'm');

        assert.equal(zoneA.diff(other), zoneB.diff(other), 'moment#diff should be the same in all zones');
        assert.equal(zoneA.diff(other), zoneC.diff(other), 'moment#diff should be the same in all zones');
        assert.equal(zoneA.diff(other), zoneD.diff(other), 'moment#diff should be the same in all zones');

        assert.equal(zoneA.diff(other, 'minute', true), zoneB.diff(other, 'minute', true), 'moment#diff should be the same in all zones');
        assert.equal(zoneA.diff(other, 'minute', true), zoneC.diff(other, 'minute', true), 'moment#diff should be the same in all zones');
        assert.equal(zoneA.diff(other, 'minute', true), zoneD.diff(other, 'minute', true), 'moment#diff should be the same in all zones');

        assert.equal(zoneA.diff(other, 'hour', true), zoneB.diff(other, 'hour', true), 'moment#diff should be the same in all zones');
        assert.equal(zoneA.diff(other, 'hour', true), zoneC.diff(other, 'hour', true), 'moment#diff should be the same in all zones');
        assert.equal(zoneA.diff(other, 'hour', true), zoneD.diff(other, 'hour', true), 'moment#diff should be the same in all zones');
    });

    test('unix offset and timestamp', function (assert) {
        var zoneA = moment(),
            zoneB = moment(zoneA).zone(720),
            zoneC = moment(zoneA).zone(360),
            zoneD = moment(zoneA).zone(-690);

        assert.equal(zoneA.unix(), zoneB.unix(), 'moment#unix should be the same in all zones');
        assert.equal(zoneA.unix(), zoneC.unix(), 'moment#unix should be the same in all zones');
        assert.equal(zoneA.unix(), zoneD.unix(), 'moment#unix should be the same in all zones');

        assert.equal(+zoneA, +zoneB, 'moment#valueOf should be the same in all zones');
        assert.equal(+zoneA, +zoneC, 'moment#valueOf should be the same in all zones');
        assert.equal(+zoneA, +zoneD, 'moment#valueOf should be the same in all zones');
    });

    test('cloning', function (assert) {
        assert.equal(moment().zone(120).clone().zone(),   120, 'explicit cloning should retain the zone');
        assert.equal(moment().zone(-120).clone().zone(), -120, 'explicit cloning should retain the zone');
        assert.equal(moment(moment().zone(120)).zone(),   120, 'implicit cloning should retain the zone');
        assert.equal(moment(moment().zone(-120)).zone(), -120, 'implicit cloning should retain the zone');
    });

    test('start of / end of', function (assert) {
        var a = moment.utc([2010, 1, 2, 0, 0, 0]).zone(450);

        assert.equal(a.clone().startOf('day').hour(), 0, 'start of day should work on moments with a zone');
        assert.equal(a.clone().startOf('day').minute(), 0, 'start of day should work on moments with a zone');
        assert.equal(a.clone().startOf('hour').minute(), 0, 'start of hour should work on moments with a zone');

        assert.equal(a.clone().endOf('day').hour(), 23, 'end of day should work on moments with a zone');
        assert.equal(a.clone().endOf('day').minute(), 59, 'end of day should work on moments with a zone');
        assert.equal(a.clone().endOf('hour').minute(), 59, 'end of hour should work on moments with a zone');
    });

    test('reset zone with moment#utc', function (assert) {
        var a = moment.utc([2012]).zone(480);

        assert.equal(a.clone().hour(),      16, 'different zone should have different hour');
        assert.equal(a.clone().utc().hour(), 0, 'calling moment#utc should reset the offset');
    });

    test('reset zone with moment#local', function (assert) {
        var a = moment([2012]).zone(480);

        assert.equal(a.clone().local().hour(), 0, 'calling moment#local should reset the offset');
    });

    test('toDate', function (assert) {
        var zoneA = new Date(),
            zoneB = moment(zoneA).zone(720).toDate(),
            zoneC = moment(zoneA).zone(360).toDate(),
            zoneD = moment(zoneA).zone(-690).toDate();

        assert.equal(+zoneA, +zoneB, 'moment#toDate should output a date with the right unix timestamp');
        assert.equal(+zoneA, +zoneC, 'moment#toDate should output a date with the right unix timestamp');
        assert.equal(+zoneA, +zoneD, 'moment#toDate should output a date with the right unix timestamp');
    });

    test('same / before / after', function (assert) {
        var zoneA = moment().utc(),
            zoneB = moment(zoneA).zone(120),
            zoneC = moment(zoneA).zone(-120);

        assert.ok(zoneA.isSame(zoneB), 'two moments with different offsets should be the same');
        assert.ok(zoneA.isSame(zoneC), 'two moments with different offsets should be the same');

        assert.ok(zoneA.isSame(zoneB, 'hour'), 'two moments with different offsets should be the same hour');
        assert.ok(zoneA.isSame(zoneC, 'hour'), 'two moments with different offsets should be the same hour');

        zoneA.add(1, 'hour');

        assert.ok(zoneA.isAfter(zoneB), 'isAfter should work with two moments with different offsets');
        assert.ok(zoneA.isAfter(zoneC), 'isAfter should work with two moments with different offsets');

        assert.ok(zoneA.isAfter(zoneB, 'hour'), 'isAfter:hour should work with two moments with different offsets');
        assert.ok(zoneA.isAfter(zoneC, 'hour'), 'isAfter:hour should work with two moments with different offsets');

        zoneA.subtract(2, 'hour');

        assert.ok(zoneA.isBefore(zoneB), 'isBefore should work with two moments with different offsets');
        assert.ok(zoneA.isBefore(zoneC), 'isBefore should work with two moments with different offsets');

        assert.ok(zoneA.isBefore(zoneB, 'hour'), 'isBefore:hour should work with two moments with different offsets');
        assert.ok(zoneA.isBefore(zoneC, 'hour'), 'isBefore:hour should work with two moments with different offsets');
    });

    test('add / subtract over dst', function (assert) {
        var oldOffset = moment.updateOffset,
            m = moment.utc([2000, 2, 31, 3]);

        moment.updateOffset = function (mom, keepTime) {
            if (mom.clone().utc().month() > 2) {
                mom.zone(-60, keepTime);
            } else {
                mom.zone(0, keepTime);
            }
        };

        assert.equal(m.hour(), 3, 'should start at 00:00');

        m.add(24, 'hour');

        assert.equal(m.hour(), 4, 'adding 24 hours should disregard dst');

        m.subtract(24, 'hour');

        assert.equal(m.hour(), 3, 'subtracting 24 hours should disregard dst');

        m.add(1, 'day');

        assert.equal(m.hour(), 3, 'adding 1 day should have the same hour');

        m.subtract(1, 'day');

        assert.equal(m.hour(), 3, 'subtracting 1 day should have the same hour');

        m.add(1, 'month');

        assert.equal(m.hour(), 3, 'adding 1 month should have the same hour');

        m.subtract(1, 'month');

        assert.equal(m.hour(), 3, 'subtracting 1 month should have the same hour');

        moment.updateOffset = oldOffset;
    });

    test('isDST', function (assert) {
        var oldOffset = moment.updateOffset;

        moment.updateOffset = function (mom, keepTime) {
            if (mom.month() > 2 && mom.month() < 9) {
                mom.zone(-60, keepTime);
            } else {
                mom.zone(0, keepTime);
            }
        };

        assert.ok(!moment().month(0).isDST(),  'Jan should not be summer dst');
        assert.ok(moment().month(6).isDST(),   'Jul should be summer dst');
        assert.ok(!moment().month(11).isDST(), 'Dec should not be summer dst');

        moment.updateOffset = function (mom) {
            if (mom.month() > 2 && mom.month() < 9) {
                mom.zone(0);
            } else {
                mom.zone(-60);
            }
        };

        assert.ok(moment().month(0).isDST(),  'Jan should be winter dst');
        assert.ok(!moment().month(6).isDST(), 'Jul should not be winter dst');
        assert.ok(moment().month(11).isDST(), 'Dec should be winter dst');

        moment.updateOffset = oldOffset;
    });

    test('zone names', function (assert) {
        assert.equal(moment().zoneAbbr(),   '', 'Local zone abbr should be empty');
        assert.equal(moment().format('z'),  '', 'Local zone formatted abbr should be empty');
        assert.equal(moment().zoneName(),   '', 'Local zone name should be empty');
        assert.equal(moment().format('zz'), '', 'Local zone formatted name should be empty');

        assert.equal(moment.utc().zoneAbbr(),   'UTC', 'UTC zone abbr should be UTC');
        assert.equal(moment.utc().format('z'),  'UTC', 'UTC zone formatted abbr should be UTC');
        assert.equal(moment.utc().zoneName(),   'Coordinated Universal Time', 'UTC zone abbr should be Coordinated Universal Time');
        assert.equal(moment.utc().format('zz'), 'Coordinated Universal Time', 'UTC zone formatted abbr should be Coordinated Universal Time');
    });

    test('hours alignment with UTC', function (assert) {
        assert.equal(moment().zone(120).hasAlignedHourOffset(), true);
        assert.equal(moment().zone(-180).hasAlignedHourOffset(), true);
        assert.equal(moment().zone(90).hasAlignedHourOffset(), false);
        assert.equal(moment().zone(-90).hasAlignedHourOffset(), false);
    });

    test('hours alignment with other zone', function (assert) {
        var m = moment().zone(120);

        assert.equal(m.hasAlignedHourOffset(moment().zone(180)), true);
        assert.equal(m.hasAlignedHourOffset(moment().zone(-180)), true);
        assert.equal(m.hasAlignedHourOffset(moment().zone(90)), false);
        assert.equal(m.hasAlignedHourOffset(moment().zone(-90)), false);

        m = moment().zone(90);

        assert.equal(m.hasAlignedHourOffset(moment().zone(180)), false);
        assert.equal(m.hasAlignedHourOffset(moment().zone(-180)), false);
        assert.equal(m.hasAlignedHourOffset(moment().zone(30)), true);
        assert.equal(m.hasAlignedHourOffset(moment().zone(-30)), true);

        m = moment().zone(-60);

        assert.equal(m.hasAlignedHourOffset(moment().zone(180)), true);
        assert.equal(m.hasAlignedHourOffset(moment().zone(-180)), true);
        assert.equal(m.hasAlignedHourOffset(moment().zone(90)), false);
        assert.equal(m.hasAlignedHourOffset(moment().zone(-90)), false);

        m = moment().zone(25);

        assert.equal(m.hasAlignedHourOffset(moment().zone(-35)), true);
        assert.equal(m.hasAlignedHourOffset(moment().zone(85)), true);

        assert.equal(m.hasAlignedHourOffset(moment().zone(35)), false);
        assert.equal(m.hasAlignedHourOffset(moment().zone(-85)), false);
    });

    test('parse zone', function (assert) {
        var m = moment('2013-01-01T00:00:00-13:00').parseZone();
        assert.equal(m.zone(), 13 * 60);
        assert.equal(m.hours(), 0);
    });

    test('parse zone static', function (assert) {
        var m = moment.parseZone('2013-01-01T00:00:00-13:00');
        assert.equal(m.zone(), 13 * 60);
        assert.equal(m.hours(), 0);
    });

    test('parse zone with more arguments', function (assert) {
        var m;
        m = moment.parseZone('2013 01 01 05 -13:00', 'YYYY MM DD HH ZZ');
        assert.equal(m.format(), '2013-01-01T05:00:00-13:00', 'accept input and format');
        m = moment.parseZone('2013-01-01-13:00', 'YYYY MM DD ZZ', true);
        assert.equal(m.isValid(), false, 'accept input, format and strict flag');
        m = moment.parseZone('2013-01-01-13:00', ['DD MM YYYY ZZ', 'YYYY MM DD ZZ']);
        assert.equal(m.format(), '2013-01-01T00:00:00-13:00', 'accept input and array of formats');
    });

    test('parse zone with a timezone from the format string', function (assert) {
        var m = moment('11-12-2013 -0400 +1100', 'DD-MM-YYYY ZZ #####').parseZone();

        assert.equal(m.zone(), 4 * 60);
    });

    test('parse zone without a timezone included in the format string', function (assert) {
        var m = moment('11-12-2013 -0400 +1100', 'DD-MM-YYYY').parseZone();

        assert.equal(m.zone(), -11 * 60);
    });

    test('timezone format', function (assert) {
        assert.equal(moment().zone(-60).format('ZZ'), '+0100', '-60 -> +0100');
        assert.equal(moment().zone(-90).format('ZZ'), '+0130', '-90 -> +0130');
        assert.equal(moment().zone(-120).format('ZZ'), '+0200', '-120 -> +0200');

        assert.equal(moment().zone(+60).format('ZZ'), '-0100', '+60 -> -0100');
        assert.equal(moment().zone(+90).format('ZZ'), '-0130', '+90 -> -0130');
        assert.equal(moment().zone(+120).format('ZZ'), '-0200', '+120 -> -0200');
    });

}));
/*global moment:false*/

(function(){
	var banner = $('#nodeunit-banner');
	var tests = $('#nodeunit-tests');
	var headerRow = $("#header-row");

	var start = moment();
	var passed = 0;
	var failed = 0;
	var total = 0;
	var currentTestModule;
	var currentModuleEl;

	function updateTest(_passed, _failed) {
		passed += _passed;
		failed += _failed;
		updateTotals(passed, failed);
	}

	function updateTotals(_passed, _failed) {
		if (_failed) {
			banner.addClass('has-failed');
		}
		banner.html('<span class="test-num">' + _passed + '</span> tests passed<br/>' +
                        '<span class="fail-label"><span class="test-num">' + _failed + '</span> failed</span>');
	}

	(function() {
		var queryArgs = {}, query = window.location.search, pieces, i, key_val,
			filtered, suite, test;
		if (!query) { return; }
		if (query[query.length - 1] === '/') {
			query = query.slice(0, query.length - 1);
		}
		pieces = query.slice(1).split('&');
		for (i = 0; i < pieces.length; ++i) {
			key_val = pieces[i].split('=');
			queryArgs[decodeURIComponent(key_val[0])] = decodeURIComponent(key_val[1]);
		}
		if (queryArgs.suite !== undefined) {
			filtered = {};
			for (suite in exports) {
				if (suite.match(queryArgs.suite)) {
					filtered[suite] = exports[suite];
				}
			}
			exports = filtered;
		}
		if (queryArgs.test !== undefined) {
			for (suite in exports) {
				filtered = {};
				for (test in exports[suite]) {
					if (test === 'setUp' || test === 'tearDown' || test.match(queryArgs.test)) {
						filtered[test] = exports[suite][test];
					}
				}
				exports[suite] = filtered;
			}
		}
	}());

        QUnit.moduleStart(function (module) {
            var name = module.name;
            currentTestModule = name;
            currentModuleEl = $('<div>').addClass('tests-module');
            currentModuleEl.append('<h3 class="tests-module-title">' + name + '</h3>');
            tests.append(currentModuleEl);
        });

        var assertions;
        var failedAssertions = []
        QUnit.testStart(function (test) {
            assertions = [];
        });

        QUnit.log(function (assertion) {
            assertions.push(assertion);
        });

        QUnit.testDone(function (test) {
            var name = test.name;
            var testEl = $('<div>').addClass('tests-test'),
                    testHtml = '',
                    assertUl = $('<div>').addClass('tests-asserts'),
                    assertLi,
                    assertHtml = '',
                    assert;

            total++;

            // each test
            testHtml += '<div class="tests-test-title"><strong>' + name + '</strong> ';
            if (test.failed > 0) {
                    testEl.addClass('has-failed is-open');
                    testHtml += test.passed + ' passed : ';
                    testHtml += test.failed + ' failed</div>';
            } else {
                    testHtml += 'all ' + test.passed + ' passed</div>';
            }
            testEl.html(testHtml);

            // each assert
            for (var i = 0; i < assertions.length; i++) {
                    assert = assertions[i];
                    assert.uid = total + '.' + (i + 1);
                    assertLi = $('<div>').addClass('tests-assert');
                    assertHtml = '<strong>' + assert.uid + '</strong> ';
                    assertHtml += (assert.message || 'no message');
                    if (assert.result === false) {
                            assertHtml += ' (' + assert.expected + ' ' + '===' + ' ' + assert.actual + ')';
                            assertHtml += '<pre>' + (assert.source || assert.message) + '</pre>';
                            assertLi.addClass('has-failed');
                            failedAssertions.push(assert);
                    }
                    assertLi.html(assertHtml);
                    assertUl.append(assertLi);
            }

            testEl.append(assertUl);
            currentModuleEl.append(testEl);
            updateTest(test.passed, test.failed);
        });

        QUnit.done(function () {
            var duration = moment().diff(start),
                    failures = failedAssertions.length,
                    assert, i,
                    reportHTML = '',
                    header,
                    expression,
                    submitUrl = "https://github.com/moment/moment/issues/new",
                    searchUrl = "https://github.com/moment/moment/search",
                    titleText = "" + failures + " test" + (failures !== 1 ? "s" : "") + " failed. ",
                    bodyText = [
                            "### Client info",
                            '```',
                            "Date String   : " + (new Date()).toString(),
                            "Locale String : " + (new Date()).toLocaleString(),
                            "Offset        : " + (new Date(1000)).getTimezoneOffset(),
                            "User Agent    : " + navigator.userAgent,
                            '```'
                    ];

            for (i = 0; i < failedAssertions.length; ++i) {
                    assert = failedAssertions[i];

                    header = assert.module + ':' + assert.name + ' (' + assert.uid + ') ';
                    titleText += header;

                    bodyText.push('');
                    bodyText.push('====');
                    bodyText.push('');
                    bodyText.push('### ' + header);
                    bodyText.push('');
                    bodyText.push(assert.message);
                    bodyText.push('');
                    bodyText.push('```javascript');
                    bodyText.push('// Expected ' + assert.expected);
                    bodyText.push('// Actual   ' + assert.actual);

                    expression = typeof assert.actual === 'string' ?
                        '"' + assert.actual.replace('"', '\\"') + '"' : assert.actual;
                    expression += ' ' + '===' + ' ';
                    expression += typeof assert.expected === 'string' ?
                        '"' + assert.expected.replace('"', '\\"') + '"' : assert.expected;

                    bodyText.push(expression);
                    bodyText.push('```');
            }

            bodyText = bodyText.join('\n');

            submitUrl += '?title=' + encodeURIComponent(titleText);
            submitUrl += '&body=' + encodeURIComponent(bodyText);

            searchUrl += '?type=Issues&q=' + encodeURIComponent(titleText);

            if (failures) {
                    reportHTML += '<h2>Uh oh, looks like some tests failed.</h2>';
                    reportHTML += "<p>It's hard to catch bugs across all browsers and timezones. If you have a minute, please report the failing test.</p>";
                    reportHTML += "<a class='button' href='" + searchUrl + "' target='_blank'><b>STEP 1:</b> Search for an existing failure report</a>";
                    reportHTML += "<p>If it doesn't look like this failure has already been reported, proceed to step 2.</p>";
                    reportHTML += "<a class='button' href='" + submitUrl + "' target='_blank'><b>STEP 2:</b> Submit a failure report</a>";
                    reportHTML += '<h3>Issue title</h3>';
                    reportHTML += '<pre>' + titleText + '</pre>';
                    reportHTML += '<h3>Issue description</h3>';
                    reportHTML += '<pre>' + bodyText.replace(/\n/g, '<br/>') + '</pre>';
            } else {
                    reportHTML += "<p class='success'>Awesome, all the unit tests passed!</p>";
            }

            $('#report-wrapper').html('<div class="tests-reporting">' + reportHTML + '<div>');

            // updateTotals(assertions.passes(), failures);
	});

        // fire tests after callbacks are registered
        QUnit.start();

	tests.on('click', '.tests-test', function(){
		$(this).toggleClass('is-open');
	});
})();
